Document Number: N4296
Date:
Revises:
Reply to:

2014-11-19
N4140
Richard Smith
Google Inc
cxxeditor@gmail.com

Working Draft, Standard for Programming

Language C++

Note: this is an early draft. It’s known to be incomplet and incorrekt, and it has lots of bad
formatting.

c(cid:13) ISO/IEC

Contents

Contents

List of Tables

List of Figures

1 General

1.1
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Scope
1.2
Normative references . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.3
Terms and deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.4
Implementation compliance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.5
Structure of this International Standard . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.6
Syntax notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.7
The C++ memory model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.8
The C++ object model
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.9
Program execution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.10 Multi-threaded executions and data races
. . . . . . . . . . . . . . . . . . . . . . . . . . .
1.11 Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2 Lexical conventions

2.1
2.2
2.3
2.4
2.5
2.6
2.7
2.8
2.9
2.10
2.11 Keywords
2.12 Operators and punctuators
2.13 Literals

Separate translation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Phases of translation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Character sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Preprocessing tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Alternative tokens
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Header names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Preprocessing numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Identiﬁers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3 Basic concepts

Declarations and deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1
One deﬁnition rule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2
Scope
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3
Name lookup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4
Program and linkage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.5
Start and termination . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.6
Storage duration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.7
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Object lifetime
3.8
3.9
Types
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.10 Lvalues and rvalues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.11 Alignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Contents

N4296

ii

x

xiv

1
1
1
2
5
5
6
6
7
8
11
15

17
17
17
18
19
20
21
21
21
22
22
23
23
24

34
34
36
39
45
59
62
65
69
73
78
80

ii

c(cid:13) ISO/IEC

N4296

4 Standard conversions

4.1
Lvalue-to-rvalue conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2
Array-to-pointer conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.3
Function-to-pointer conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.4
Qualiﬁcation conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.5
Integral promotions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.6
Floating point promotion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.7
Integral conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.8
Floating point conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.9
Floating-integral conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.10 Pointer conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.11 Pointer to member conversions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.12 Boolean conversions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Integer conversion rank . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.13

5 Expressions

Additive operators
Shift operators
Relational operators

Primary expressions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.1
Postﬁx expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.2
Unary expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.3
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
Explicit type conversion (cast notation)
5.4
Pointer-to-member operators
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.5
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.6 Multiplicative operators
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.7
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.8
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.9
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.10 Equality operators
5.11 Bitwise AND operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.12 Bitwise exclusive OR operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.13 Bitwise inclusive OR operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.14 Logical AND operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.15 Logical OR operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.16 Conditional operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.17 Throwing an exception . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.18 Assignment and compound assignment operators . . . . . . . . . . . . . . . . . . . . . . .
5.19 Comma operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.20 Constant expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

6 Statements

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Labeled statement
Expression statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Compound statement or block . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Selection statements
Iteration statements
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Jump statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Declaration statement
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Ambiguity resolution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Speciﬁers
Enumeration declarations
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Namespaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

6.1
6.2
6.3
6.4
6.5
6.6
6.7
6.8

7.1
7.2
7.3

7 Declarations

Contents

82
83
83
83
84
84
85
85
85
86
86
86
87
87

88
91
102
113
122
123
124
124
126
126
127
128
128
128
128
129
129
130
131
132
132

137
137
137
137
138
139
142
143
145

147
149
166
169

iii

c(cid:13) ISO/IEC

N4296

7.4
7.5
7.6

The asm declaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Linkage speciﬁcations
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

8 Declarators

Type names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8.1
8.2
Ambiguity resolution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8.3 Meaning of declarators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Function deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8.4
8.5
Initializers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

9 Classes

9.1
Class names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.2
Class members
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.3 Member functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Static members . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.4
Unions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.5
9.6
Bit-ﬁelds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Nested class declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.7
Local class declarations
9.8
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.9
Nested type names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

10 Derived classes

10.1 Multiple base classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10.2 Member name lookup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10.3 Virtual functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10.4 Abstract classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

11 Member access control

11.1 Access speciﬁers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11.2 Accessibility of base classes and base class members . . . . . . . . . . . . . . . . . . . . . .
11.3 Friends . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11.4 Protected member access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11.5 Access to virtual functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11.6 Multiple access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11.7 Nested classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

12 Special member functions

12.1 Constructors
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12.2 Temporary objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12.3 Conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12.4 Destructors
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12.5 Free store . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12.6
Initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12.7 Construction and destruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12.8 Copying and moving class objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12.9
Inheriting constructors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

13 Overloading

13.1 Overloadable declarations
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13.2 Declaration matching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Contents

182
182
185

191
192
193
194
207
210

226
229
230
233
236
238
240
240
242
242

243
244
246
249
254

256
257
259
261
264
265
266
266

267
267
270
272
275
278
279
286
288
296

300
300
302

iv

c(cid:13) ISO/IEC

N4296

13.3 Overload resolution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13.4 Address of overloaded function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13.5 Overloaded operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13.6 Built-in operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

14 Templates

14.1 Template parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14.2 Names of template specializations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14.3 Template arguments
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14.4 Type equivalence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14.5 Template declarations
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14.6 Name resolution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14.7 Template instantiation and specialization . . . . . . . . . . . . . . . . . . . . . . . . . . .
14.8 Function template specializations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

15 Exception handling

15.1 Throwing an exception . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15.2 Constructors and destructors
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15.3 Handling an exception . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15.4 Exception speciﬁcations
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15.5

Special functions

16 Preprocessing directives

16.1 Conditional inclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16.2
Source ﬁle inclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16.3 Macro replacement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16.4 Line control
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16.5 Error directive
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16.6 Pragma directive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16.7 Null directive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16.8 Predeﬁned macro names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16.9 Pragma operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

17 Library introduction

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17.1 General
17.2 The C standard library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17.3 Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17.4 Additional deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17.5 Method of description (Informative)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17.6 Library-wide requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

18 Language support library

18.1 General
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18.2 Types
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18.3
Implementation properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18.4
Integer types
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18.5
Start and termination . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18.6 Dynamic memory management
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18.7 Type identiﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18.8 Exception handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18.9
Initializer lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Contents

303
323
325
329

333
334
337
339
344
345
364
379
392

414
415
417
417
419
424

426
427
429
430
435
435
435
436
436
437

438
438
439
439
442
442
448

468
468
468
469
478
479
481
487
489
494

v

c(cid:13) ISO/IEC

N4296

18.10 Other runtime support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

19 Diagnostics library

19.1 General
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19.2 Exception classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19.3 Assertions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19.4 Error numbers
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
System error support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19.5

20 General utilities library

20.1 General
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20.2 Utility components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20.3 Pairs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20.4 Tuples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20.5 Compile-time integer sequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20.6 Class template bitset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20.7 Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20.8
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20.9 Function objects
20.10 Metaprogramming and type traits
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20.11 Compile-time rational arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20.12 Time utilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20.13 Class template scoped_allocator_adaptor . . . . . . . . . . . . . . . . . . . . . . . . . .
20.14 Class type_index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Smart pointers

21 Strings library

21.1 General
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21.2 Character traits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21.3
String classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21.4 Class template basic_string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21.5 Numeric conversions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21.6 Hash support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21.7
Suﬃx for basic_string literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21.8 Null-terminated sequence utilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

22 Localization library

22.1 General
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22.2 Header <locale> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22.3 Locales . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Standard locale categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22.4
Standard code conversion facets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22.5
22.6 C library locales
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

23 Containers library

Sequence containers

23.1 General
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23.2 Container requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23.3
23.4 Associative containers
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23.5 Unordered associative containers
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23.6 Container adaptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Contents

495

498
498
498
502
502
502

514
514
514
519
523
533
534
541
556
582
602
622
625
640
646

648
648
648
654
658
684
686
686
686

690
690
690
691
703
742
743

745
745
745
774
805
823
842

vi

c(cid:13) ISO/IEC

N4296

24 Iterators library

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24.1 General
24.2
Iterator requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24.3 Header <iterator> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24.4
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Iterator primitives
Iterator adaptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24.5
Stream iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24.6
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24.7 Range access
24.8 Container access
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

25 Algorithms library

25.1 General
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
25.2 Non-modifying sequence operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
25.3 Mutating sequence operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Sorting and related operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
25.4
25.5 C library algorithms
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

852
852
852
857
860
864
877
883
884

886
886
897
902
910
922

26 Numerics library

924
924
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26.1 General
924
26.2 Numeric type requirements
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
925
26.3 The ﬂoating-point environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
926
26.4 Complex numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
936
26.5 Random number generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26.6 Numeric arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
980
26.7 Generalized numeric operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1001
26.8 C library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1004

27 Input/output library

1009
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1009
27.1 General
27.2
Iostreams requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1010
27.3 Forward declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1010
Standard iostream objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1012
27.4
Iostreams base classes
27.5
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1014
27.6
Stream buﬀers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1032
27.7 Formatting and manipulators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1041
String-based streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1069
27.8
27.9 File-based streams
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1079

28 Regular expressions library

1095
28.1 General
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1095
28.2 Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1095
28.3 Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1096
28.4 Header <regex> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1098
28.5 Namespace std::regex_constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1105
28.6 Class regex_error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1108
28.7 Class template regex_traits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1108
28.8 Class template basic_regex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1112
28.9 Class template sub_match . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1117
28.10 Class template match_results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1123
28.11 Regular expression algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1128
28.12 Regular expression iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1133

Contents

vii

c(cid:13) ISO/IEC

N4296

28.13 Modiﬁed ECMAScript regular expression grammar . . . . . . . . . . . . . . . . . . . . . . 1139

29 Atomic operations library

1142
29.1 General
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1142
29.2 Header <atomic> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1142
29.3 Order and consistency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1145
29.4 Lock-free property . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1147
29.5 Atomic types
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1147
29.6 Operations on atomic types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1151
29.7 Flag type and operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1156
29.8 Fences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1157

30 Thread support library

1159
30.1 General
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1159
30.2 Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1159
30.3 Threads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1162
30.4 Mutual exclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1167
30.5 Condition variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1186
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1194
30.6 Futures

A Grammar summary

1210
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1210
A.1 Keywords
Lexical conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1210
A.2
Basic concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1215
A.3
Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1215
A.4
A.5
Statements
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1218
A.6 Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1219
A.7 Declarators
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1223
Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1225
A.8
A.9 Derived classes
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1225
A.10 Special member functions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1226
A.11 Overloading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1226
A.12 Templates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1226
A.13 Exception handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1227
A.14 Preprocessing directives
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1228

B Implementation quantities

1230

C Compatibility

1232
C++ and ISO C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1232
C++ and ISO C++ 2003 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1241
C++ and ISO C++ 2011 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1248
C++ and ISO C++ 2014 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1249
C standard library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1249

C.1
C.2
C.3
C.4
C.5

D Compatibility features

1253
Increment operator with bool operand . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1253
D.1
register keyword . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1253
D.2
D.3
Implicit declaration of copy functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1253
D.4 Dynamic exception speciﬁcations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1253
D.5
C standard library headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1253

Contents

viii

c(cid:13) ISO/IEC

N4296

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1254
D.6 Old iostreams members
D.7
char* streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1255
D.8 Violating exception-speciﬁcations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1264
D.9
uncaught_exception . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1264

E Universal character names for identiﬁer characters

1265
Ranges of characters allowed . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1265
Ranges of characters disallowed initially . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1265

E.1
E.2

F Cross references

Index

Index of grammar productions

Index of library names

Index of implementation-deﬁned behavior

1266

1284

1313

1316

1352

Contents

ix

c(cid:13) ISO/IEC

N4296

List of Tables

1
2
3
4
5
6
7

8

9

Alternative tokens
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Identiﬁers with special meaning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Alternative representations
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Types of integer literals
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Escape sequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
String literal concatenations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Relations on const and volatile . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

simple-type-speciﬁers and the types they specify . . . . . . . . . . . . . . . . . . . . . . . . . .

10 Relationship between operator and function call notation . . . . . . . . . . . . . . . . . . . . .
11 Conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

12 Value of folding empty sequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Library categories

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
14 C++ library headers
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15 C++ headers for C library facilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16 C++ headers for freestanding implementations
. . . . . . . . . . . . . . . . . . . . . . . . . . .
EqualityComparable requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
LessThanComparable requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
DefaultConstructible requirements
19
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MoveConstructible requirements
20
21
CopyConstructible requirements (in addition to MoveConstructible)
. . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MoveAssignable requirements
22
CopyAssignable requirements (in addition to MoveAssignable)
23
. . . . . . . . . . . . . . . . .
Destructible requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24
25
NullablePointer requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Hash requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
27 Descriptive variable deﬁnitions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28 Allocator requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

29
Language support library summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
30 Header <cstddef> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31 Header <climits> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
32 Header <cfloat> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
33 Header <cstdlib> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
34 Header <csetjmp> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
35 Header <csignal> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
36 Header <cstdalign> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
37 Header <cstdarg> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
38 Header <cstdbool> synopsis
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
39 Header <cstdlib> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
40 Header <ctime> synopsis
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

List of Tables

20
22
23
23
25
27
30

78

160

308
316

353

438
448
449
450
451
451
451
451
451
452
452
452
454
454
455
455

468
468
478
478
479
496
496
496
496
496
496
497

x

c(cid:13) ISO/IEC

N4296

41 Diagnostics library summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
42 Header <cassert> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
43 Header <cerrno> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

44 General utilities library summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
45 Header <cstdlib> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
46 Header <cstring> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47 Primary type category predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
48 Composite type category predicates
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
49 Type property predicates
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
50 Type property queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51 Type relationship predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
52 Const-volatile modiﬁcations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
53 Reference modiﬁcations
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
54
Sign modiﬁcations
55 Array modiﬁcations
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
56 Pointer modiﬁcations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57 Other transformations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
58 Expressions used to perform ratio arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . .
59 Clock requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
60 Header <ctime> synopsis
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

498
502
503

514
555
555
607
608
608
615
616
617
618
618
619
619
620
624
628
640

61
Strings library summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
62 Character traits requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
63
basic_string(const Allocator&) eﬀects
basic_string(const basic_string&) eﬀects
64
. . . . . . . . . . . . . . . . . . . . . . . . . . .
65
basic_string(const basic_string&, size_type, size_type, const Allocator&) eﬀects
basic_string(const charT*, size_type, const Allocator&) eﬀects . . . . . . . . . . . . .
66
basic_string(const charT*, const Allocator&) eﬀects . . . . . . . . . . . . . . . . . . . .
67
basic_string(size_t, charT, const Allocator&) eﬀects
68
. . . . . . . . . . . . . . . . . . .
69
basic_string(const basic_string&, const Allocator&) and basic_string(basic_string&&,
const Allocator&) eﬀects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
70
operator=(const basic_string&) eﬀects
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
71
operator=(basic_string&&) eﬀects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
72
compare() results
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
73 Potential mbstate_t data races . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
74 Header <cctype> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
75 Header <cwctype> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
76 Header <cstring> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
77 Header <cwchar> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
78 Header <cstdlib> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
79 Header <cuchar> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

648
649
663
663
663
664
664
664

665
665
665
678
688
688
688
688
689
689
689

Localization library summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
80
81
Locale category facets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
82 Required specializations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
do_in/do_out result values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
83
84
do_unshift result values
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Integer conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
85
Length modiﬁer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
86
87
Integer conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

List of Tables

690
694
695
712
713
716
717
721

xi

c(cid:13) ISO/IEC

N4296

88 Floating-point conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
89
Length modiﬁer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
90 Numeric conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
91 Fill padding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
92
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
93 Header <clocale> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
94 Potential setlocale data races . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

do_get_date eﬀects

95 Containers library summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
96 Container requirements
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
97 Reversible container requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
98 Optional container operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
99 Allocator-aware container requirements
100 Sequence container requirements (in addition to container)
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
101 Optional sequence container operations
. . . . . . . . . . . . . . . . . . .
102 Associative container requirements (in addition to container)
103 Unordered associative container requirements (in addition to container)
. . . . . . . . . . . . .

104 Iterators library summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
105 Relations among iterator categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
106 Iterator requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
107 Input iterator requirements (in addition to Iterator)
. . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . .
108 Output iterator requirements (in addition to Iterator)
109 Forward iterator requirements (in addition to input iterator)
. . . . . . . . . . . . . . . . . . .
110 Bidirectional iterator requirements (in addition to forward iterator) . . . . . . . . . . . . . . . .
111 Random access iterator requirements (in addition to bidirectional iterator)
. . . . . . . . . . .

112 Algorithms library summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
113 Header <cstdlib> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

721
721
721
722
729
744
744

745
746
748
750
751
753
755
758
765

852
852
854
854
855
856
856
857

886
922

924
114 Numerics library summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
938
115 Seed sequence requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
939
116 Uniform random number generator requirements . . . . . . . . . . . . . . . . . . . . . . . . . .
940
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
117 Random number engine requirements
943
118 Random number distribution requirements
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
119 Header <cmath> synopsis
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1004
120 Header <cstdlib> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1005

121 Input/output library summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1009
122 fmtflags eﬀects
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1019
123 fmtflags constants
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1019
124 iostate eﬀects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1019
125 openmode eﬀects
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1019
126 seekdir eﬀects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1020
127 Position type requirements
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1024
128 basic_ios::init() eﬀects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1026
129 basic_ios::copyfmt() eﬀects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1028
130 seekoff positioning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1073
131 newoff values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1074
132 File open modes
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1083
133 seekoff eﬀects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1086

List of Tables

xii

c(cid:13) ISO/IEC

N4296

134 Header <cstdio> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1093
135 Header <cinttypes> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1093

136 Regular expressions library summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1095
137 Regular expression traits class requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1096
138 syntax_option_type eﬀects
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1106
139 regex_constants::match_flag_type eﬀects when obtaining a match against a character con-

tainer sequence [first,last).

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1106
140 error_type values in the C locale . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1108
141 Character class names and corresponding ctype masks . . . . . . . . . . . . . . . . . . . . . . . 1111
142 match_results assignment operator eﬀects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1125
143 Eﬀects of regex_match algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1128
144 Eﬀects of regex_search algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1130

145 Atomics library summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1142
146 atomic integral typedefs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1151
147 atomic <inttypes.h> typedefs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1152
148 Atomic arithmetic computations
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1155

149 Thread support library summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1159

150 Standard macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1249
151 Standard values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1250
152 Standard types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1250
153 Standard structs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1250
154 Standard functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1251

155 C headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1253
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1257
156 strstreambuf(streamsize) eﬀects
157 strstreambuf(void* (*)(size_t), void (*)(void*)) eﬀects
. . . . . . . . . . . . . . . . . 1257
158 strstreambuf(charT*, streamsize, charT*) eﬀects . . . . . . . . . . . . . . . . . . . . . . . 1257
159 seekoff positioning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1260
160 newoff values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1260

List of Tables

xiii

c(cid:13) ISO/IEC

N4296

List of Figures

1

2
3
4
5
6

7

Expression category taxonomy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Directed acyclic graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Non-virtual base . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Virtual base . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Virtual and non-virtual base
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Name lookup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

78

244
245
246
246
248

Stream position, oﬀset, and size types [non-normative]

. . . . . . . . . . . . . . . . . . . . . . . 1009

List of Figures

xiv

c(cid:13) ISO/IEC

N4296

1 General
1.1 Scope

[intro]
[intro.scope]
1 This International Standard speciﬁes requirements for implementations of the C++ programming language.
The ﬁrst such requirement is that they implement the language, and so this International Standard also
deﬁnes C++. Other requirements and relaxations of the ﬁrst requirement appear at various places within
this International Standard.

2 C++ is a general purpose programming language based on the C programming language as described in
ISO/IEC 9899:1999 Programming languages — C (hereinafter referred to as the C standard). In addition to
the facilities provided by C, C++ provides additional data types, classes, templates, exceptions, namespaces,
operator overloading, function name overloading, references, free store management operators, and additional
library facilities.
1.2 Normative references

[intro.refs]
1 The following referenced documents are indispensable for the application of this document. For dated refer-
ences, only the edition cited applies. For undated references, the latest edition of the referenced document
(including any amendments) applies.

(1.1)

(1.2)

(1.3)

(1.4)

(1.5)

(1.6)

(1.7)

(1.8)

(1.9)

—
—
—
—
—
—
—
—

—

Ecma International, ECMAScript Language Speciﬁcation, Standard Ecma-262, third edition, 1999.
ISO/IEC 2382 (all parts), Information technology — Vocabulary
ISO/IEC 9899:1999, Programming languages — C
ISO/IEC 9899:1999/Cor.1:2001(E), Programming languages — C, Technical Corrigendum 1
ISO/IEC 9899:1999/Cor.2:2004(E), Programming languages — C, Technical Corrigendum 2
ISO/IEC 9899:1999/Cor.3:2007(E), Programming languages — C, Technical Corrigendum 3
ISO/IEC 9945:2003, Information Technology — Portable Operating System Interface (POSIX)
ISO/IEC 10646-1:1993, Information technology — Universal Multiple-Octet Coded Character Set (UCS)
— Part 1: Architecture and Basic Multilingual Plane
ISO/IEC TR 19769:2004, Information technology — Programming languages, their environments and
system software interfaces — Extensions for the programming language C to support new character
data types

2 The library described in Clause 7 of ISO/IEC 9899:1999 and Clause 7 of ISO/IEC 9899:1999/Cor.1:2001

and Clause 7 of ISO/IEC 9899:1999/Cor.2:2003 is hereinafter called the C standard library.1

3 The library described in ISO/IEC TR 19769:2004 is hereinafter called the C Unicode TR.
4 The operating system interface described in ISO/IEC 9945:2003 is hereinafter called POSIX.
5 The ECMAScript Language Speciﬁcation described in Standard Ecma-262 is hereinafter called ECMA-262.

1) With the qualiﬁcations noted in Clauses 18 through 30 and in C.5, the C standard library is a subset of the C++ standard

library.

§ 1.2

1

c(cid:13) ISO/IEC

1.3 Terms and deﬁnitions

N4296

[intro.defs]

1 For the purposes of this document, the following deﬁnitions apply.
2 17.3 deﬁnes additional terms that are used only in Clauses 17 through 30 and Annex D.
3 Terms that are used only in a small portion of this International Standard are deﬁned where they are used

and italicized where they are deﬁned.

1.3.1
argument
<function call expression> expression in the comma-separated list bounded by the parentheses

[defns.argument]

1.3.2
argument
<function-like macro> sequence of preprocessing tokens in the comma-separated list bounded by the paren-
theses

[defns.argument.macro]

1.3.3
argument
<throw expression> the operand of throw

[defns.argument.throw]

1.3.4
argument
<template instantiation> expression, type-id or template-name in the comma-separated list bounded by the
angle brackets

[defns.argument.templ]

1.3.5
conditionally-supported
program construct that an implementation is not required to support
[ Note: Each implementation documents all conditionally-supported constructs that it does not support. —
end note ]

[defns.cond.supp]

1.3.6
diagnostic message
message belonging to an implementation-deﬁned subset of the implementation’s output messages

[defns.diagnostic]

1.3.7
dynamic type
<glvalue> type of the most derived object (1.8) to which the glvalue denoted by a glvalue expression refers
[ Example: if a pointer (8.3.1) p whose static type is “pointer to class B” is pointing to an object of class
D, derived from B (Clause 10), the dynamic type of the expression *p is “D.” References (8.3.2) are treated
similarly. — end example ]

[defns.dynamic.type]

1.3.8
dynamic type
<prvalue> static type of the prvalue expression

[defns.dynamic.type.prvalue]

1.3.9

§ 1.3

[defns.ill.formed]

2

c(cid:13) ISO/IEC

ill-formed program
program that is not well formed

N4296

1.3.10
implementation-deﬁned behavior
behavior, for a well-formed program construct and correct data, that depends on the implementation and
that each implementation documents

[defns.impl.deﬁned]

1.3.11
implementation limits
restrictions imposed upon programs by the implementation

[defns.impl.limits]

1.3.12
locale-speciﬁc behavior
behavior that depends on local conventions of nationality, culture, and language that each implementation
documents

[defns.locale.speciﬁc]

1.3.13
multibyte character
sequence of one or more bytes representing a member of the extended character set of either the source or
the execution environment
[ Note: The extended character set is a superset of the basic character set (2.3). — end note ]

[defns.multibyte]

1.3.14
parameter
<function or catch clause> object or reference declared as part of a function declaration or deﬁnition or in
the catch clause of an exception handler that acquires a value on entry to the function or handler

[defns.parameter]

1.3.15
parameter
<function-like macro> identiﬁer from the comma-separated list bounded by the parentheses immediately
following the macro name

[defns.parameter.macro]

1.3.16
parameter
<template> template-parameter

[defns.parameter.templ]

1.3.17
signature
<function> name, parameter type list (8.3.5), and enclosing namespace (if any)
[ Note: Signatures are used as a basis for name mangling and linking. — end note ]

[defns.signature]

1.3.18
signature
<function template> name, parameter type list (8.3.5), enclosing namespace (if any), return type, and
template parameter list

[defns.signature.templ]

§ 1.3

3

c(cid:13) ISO/IEC

N4296

1.3.19
signature
<function template specialization> signature of the template of which it is a specialization and its template
arguments (whether explicitly speciﬁed or deduced)

[defns.signature.spec]

1.3.20
signature
<class member function> name, parameter type list (8.3.5), class of which the function is a member, cv-
qualiﬁers (if any), and ref-qualiﬁer (if any)

[defns.signature.member]

1.3.21
signature
<class member function template> name, parameter type list (8.3.5), class of which the function is a member,
cv-qualiﬁers (if any), ref-qualiﬁer (if any), return type, and template parameter list

[defns.signature.member.templ]

1.3.22
signature
<class member function template specialization> signature of the member function template of which it is
a specialization and its template arguments (whether explicitly speciﬁed or deduced)

[defns.signature.member.spec]

1.3.23
static type
type of an expression (3.9) resulting from analysis of the program without considering execution semantics
[ Note: The static type of an expression depends only on the form of the program in which the expression
appears, and does not change while the program is executing. — end note ]

[defns.static.type]

1.3.24
undeﬁned behavior
behavior for which this International Standard imposes no requirements
[ Note: Undeﬁned behavior may be expected when this International Standard omits any explicit deﬁnition of
behavior or when a program uses an erroneous construct or erroneous data. Permissible undeﬁned behavior
ranges from ignoring the situation completely with unpredictable results, to behaving during translation or
program execution in a documented manner characteristic of the environment (with or without the issuance of
a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).
Many erroneous program constructs do not engender undeﬁned behavior; they are required to be diagnosed.
— end note ]

[defns.undeﬁned]

1.3.25
unspeciﬁed behavior
behavior, for a well-formed program construct and correct data, that depends on the implementation
[ Note: The implementation is not required to document which behavior occurs. The range of possible
behaviors is usually delineated by this International Standard. — end note ]

[defns.unspeciﬁed]

1.3.26
well-formed program
C++ program constructed according to the syntax rules, diagnosable semantic rules, and the One Deﬁnition
Rule (3.2).

[defns.well.formed]

§ 1.3

4

c(cid:13) ISO/IEC

N4296

1.4 Implementation compliance

[intro.compliance]
1 The set of diagnosable rules consists of all syntactic and semantic rules in this International Standard except
for those rules containing an explicit notation that “no diagnostic is required” or which are described as
resulting in “undeﬁned behavior.”

2 Although this International Standard states only requirements on C++ implementations, those requirements
are often easier to understand if they are phrased as requirements on programs, parts of programs, or
execution of programs. Such requirements have the following meaning:

(2.1)

(2.2)

(2.3)

—

—

—

If a program contains no violations of the rules in this International Standard, a conforming imple-
mentation shall, within its resource limits, accept and correctly execute2 that program.
If a program contains a violation of any diagnosable rule or an occurrence of a construct described in
this Standard as “conditionally-supported” when the implementation does not support that construct,
a conforming implementation shall issue at least one diagnostic message.
If a program contains a violation of a rule for which no diagnostic is required, this International
Standard places no requirement on implementations with respect to that program.

3 For classes and class templates, the library Clauses specify partial deﬁnitions. Private members (Clause 11)
are not speciﬁed, but each implementation shall supply them to complete the deﬁnitions according to the
description in the library Clauses.

4 For functions, function templates, objects, and values, the library Clauses specify declarations. Implemen-

tations shall supply deﬁnitions consistent with the descriptions in the library Clauses.

5 The names deﬁned in the library have namespace scope (7.3). A C++ translation unit (2.2) obtains access

to these names by including the appropriate standard library header (16.2).

6 The templates, classes, functions, and objects in the library have external linkage (3.5). The implementation
provides deﬁnitions for standard library entities, as necessary, while combining translation units to form a
complete C++ program (2.2).

7 Two kinds of implementations are deﬁned: a hosted implementation and a freestanding implementation. For
a hosted implementation, this International Standard deﬁnes the set of available libraries. A freestanding
implementation is one in which execution may take place without the beneﬁt of an operating system, and
has an implementation-deﬁned set of libraries that includes certain language-support libraries (17.6.1.3).

8 A conforming implementation may have extensions (including additional library functions), provided they do
not alter the behavior of any well-formed program. Implementations are required to diagnose programs that
use such extensions that are ill-formed according to this International Standard. Having done so, however,
they can compile and execute such programs.

9 Each implementation shall include documentation that identiﬁes all conditionally-supported constructs that

it does not support and deﬁnes all locale-speciﬁc characteristics.3
1.5 Structure of this International Standard

[intro.structure]
1 Clauses 2 through 16 describe the C++ programming language. That description includes detailed syntactic
speciﬁcations in a form described in 1.6. For convenience, Annex A repeats all such syntactic speciﬁcations.
2 Clauses 18 through 30 and Annex D (the library clauses) describe the Standard C++ library. That description
includes detailed descriptions of the templates, classes, functions, constants, and macros that constitute the
library, in a form described in Clause 17.

2) “Correct execution” can include undeﬁned behavior, depending on the data being processed; see 1.3 and 1.9.
3) This documentation also deﬁnes implementation-deﬁned behavior; see 1.9.

§ 1.5

5

c(cid:13) ISO/IEC

N4296

3 Annex B recommends lower bounds on the capacity of conforming implementations.
4 Annex C summarizes the evolution of C++ since its ﬁrst published description, and explains in detail the
diﬀerences between C++ and C. Certain features of C++ exist solely for compatibility purposes; Annex D
describes those features.

5 Throughout this International Standard, each example is introduced by “[ Example:” and terminated by
“ — end example ]”. Each note is introduced by “[ Note:” and terminated by “ — end note ]”. Examples and
notes may be nested.
1.6 Syntax notation
[syntax]
In the syntax notation used in this International Standard, syntactic categories are indicated by italic type,
and literal words and characters in constant width type. Alternatives are listed on separate lines except in
a few cases where a long set of alternatives is marked by the phrase “one of.” If the text of an alternative is
too long to ﬁt on a line, the text is continued on subsequent lines indented from the ﬁrst one. An optional
terminal or non-terminal symbol is indicated by the subscript “opt”, so

1

{ expressionopt}

indicates an optional expression enclosed in braces.

2 Names for syntactic categories have generally been chosen according to the following rules:

(2.1)

(2.2)

(2.3)

(2.4)

—

—
—

—

X-name is a use of an identiﬁer in a context that determines its meaning (e.g., class-name, typedef-
name).
X-id is an identiﬁer with no context-dependent meaning (e.g., qualiﬁed-id).
X-seq is one or more X’s without intervening delimiters (e.g., declaration-seq is a sequence of declara-
tions).
X-list is one or more X’s separated by intervening commas (e.g., expression-list is a sequence of
expressions separated by commas).

1.7 The C++ memory model

[intro.memory]
1 The fundamental storage unit in the C++ memory model is the byte. A byte is at least large enough to contain
any member of the basic execution character set (2.3) and the eight-bit code units of the Unicode UTF-8
encoding form and is composed of a contiguous sequence of bits, the number of which is implementation-
deﬁned. The least signiﬁcant bit is called the low-order bit; the most signiﬁcant bit is called the high-order
bit. The memory available to a C++ program consists of one or more sequences of contiguous bytes. Every
byte has a unique address.
[ Note: The representation of types is described in 3.9. — end note ]

2
3 A memory location is either an object of scalar type or a maximal sequence of adjacent bit-ﬁelds all having
non-zero width.
[ Note: Various features of the language, such as references and virtual functions, might
involve additional memory locations that are not accessible to programs but are managed by the imple-
mentation. — end note ] Two or more threads of execution (1.10) can update and access separate memory
locations without interfering with each other.
[ Note: Thus a bit-ﬁeld and an adjacent non-bit-ﬁeld are in separate memory locations, and therefore can be
concurrently updated by two threads of execution without interference. The same applies to two bit-ﬁelds,
if one is declared inside a nested struct declaration and the other is not, or if the two are separated by
a zero-length bit-ﬁeld declaration, or if they are separated by a non-bit-ﬁeld declaration. It is not safe to
concurrently update two bit-ﬁelds in the same struct if all ﬁelds between them are also bit-ﬁelds of non-zero
width. — end note ]

4

§ 1.7

6

c(cid:13) ISO/IEC

5

[ Example: A structure declared as

struct {
char a;
int b:5,
c:11,
:0,
d:8;
struct {int ee:8;} e;

}

N4296

contains four separate memory locations: The ﬁeld a and bit-ﬁelds d and e.ee are each separate memory
locations, and can be modiﬁed concurrently without interfering with each other. The bit-ﬁelds b and c
together constitute the fourth memory location. The bit-ﬁelds b and c cannot be concurrently modiﬁed, but
b and a, for example, can be. — end example ]
1.8 The C++ object model

[intro.object]
1 The constructs in a C++ program create, destroy, refer to, access, and manipulate objects. An object is a
region of storage. [ Note: A function is not an object, regardless of whether or not it occupies storage in the
way that objects do. — end note ] An object is created by a deﬁnition (3.1), by a new-expression (5.3.4)
or by the implementation (12.2) when needed. The properties of an object are determined when the object
is created. An object can have a name (Clause 3). An object has a storage duration (3.7) which inﬂuences
its lifetime (3.8). An object has a type (3.9). The term object type refers to the type with which the object
is created. Some objects are polymorphic (10.3); the implementation generates information associated with
each such object that makes it possible to determine that object’s type during program execution. For other
objects, the interpretation of the values found therein is determined by the type of the expressions (Clause 5)
used to access them.

2 Objects can contain other objects, called subobjects. A subobject can be a member subobject (9.2), a base
class subobject (Clause 10), or an array element. An object that is not a subobject of any other object is
called a complete object.

3 For every object x, there is some object called the complete object of x, determined as follows:

(3.1)

(3.2)

4

—
—

If x is a complete object, then x is the complete object of x.
Otherwise, the complete object of x is the complete object of the (unique) object that contains x.

If a complete object, a data member (9.2), or an array element is of class type, its type is considered the
most derived class, to distinguish it from the class type of any base class subobject; an object of a most
derived class type or of a non-class type is called a most derived object.

5 Unless it is a bit-ﬁeld (9.6), a most derived object shall have a non-zero size and shall occupy one or more
bytes of storage. Base class subobjects may have zero size. An object of trivially copyable or standard-layout
type (3.9) shall occupy contiguous bytes of storage.

6 Unless an object is a bit-ﬁeld or a base class subobject of zero size, the address of that object is the address of
the ﬁrst byte it occupies. Two objects that are not bit-ﬁelds may have the same address if one is a subobject
of the other, or if at least one is a base class subobject of zero size and they are of diﬀerent types; otherwise,
they shall have distinct addresses.4
[ Example:

static const char test1 = ’x’;
static const char test2 = ’x’;
const bool b = &test1 != &test2;
4) Under the “as-if” rule an implementation is allowed to store two objects at the same machine address or not store an

// always true

object at all if the program cannot observe the diﬀerence (1.9).

§ 1.8

7

c(cid:13) ISO/IEC

N4296

7

— end example ]
[ Note: C++ provides a variety of fundamental types and several ways of composing new types from existing
types (3.9). — end note ]
1.9 Program execution

[intro.execution]
1 The semantic descriptions in this International Standard deﬁne a parameterized nondeterministic abstract
machine. This International Standard places no requirement on the structure of conforming implementations.
In particular, they need not copy or emulate the structure of the abstract machine. Rather, conforming
implementations are required to emulate (only) the observable behavior of the abstract machine as explained
below.5

2 Certain aspects and operations of the abstract machine are described in this International Standard as
implementation-deﬁned (for example, sizeof(int)). These constitute the parameters of the abstract ma-
chine. Each implementation shall include documentation describing its characteristics and behavior in these
respects.6 Such documentation shall deﬁne the instance of the abstract machine that corresponds to that
implementation (referred to as the “corresponding instance” below).

3 Certain other aspects and operations of the abstract machine are described in this International Standard
as unspeciﬁed (for example, evaluation of expressions in a new-initializer if the allocation function fails to
allocate memory (5.3.4)). Where possible, this International Standard deﬁnes a set of allowable behaviors.
These deﬁne the nondeterministic aspects of the abstract machine. An instance of the abstract machine can
thus have more than one possible execution for a given program and a given input.

4 Certain other operations are described in this International Standard as undeﬁned (for example, the eﬀect
of attempting to modify a const object). [ Note: This International Standard imposes no requirements on
the behavior of programs that contain undeﬁned behavior. — end note ]

5 A conforming implementation executing a well-formed program shall produce the same observable behavior
as one of the possible executions of the corresponding instance of the abstract machine with the same program
and the same input. However, if any such execution contains an undeﬁned operation, this International
Standard places no requirement on the implementation executing that program with that input (not even
with regard to operations preceding the ﬁrst undeﬁned operation).
If a signal handler is executed as a result of a call to the raise function, then the execution of the handler is
sequenced after the invocation of the raise function and before its return. [ Note: When a signal is received
for another reason, the execution of the signal handler is usually unsequenced with respect to the rest of the
program. — end note ]

6

7 An instance of each object with automatic storage duration (3.7.3) is associated with each entry into its
block. Such an object exists and retains its last-stored value during the execution of the block and while the
block is suspended (by a call of a function or receipt of a signal).

8 The least requirements on a conforming implementation are:

(8.1)

(8.2)

(8.3)

—
—

—

Access to volatile objects are evaluated strictly according to the rules of the abstract machine.
At program termination, all data written into ﬁles shall be identical to one of the possible results that
execution of the program according to the abstract semantics would have produced.
The input and output dynamics of interactive devices shall take place in such a fashion that prompting
output is actually delivered before a program waits for input. What constitutes an interactive device
is implementation-deﬁned.

5) This provision is sometimes called the “as-if” rule, because an implementation is free to disregard any requirement of this
International Standard as long as the result is as if the requirement had been obeyed, as far as can be determined from the
observable behavior of the program. For instance, an actual implementation need not evaluate part of an expression if it can
deduce that its value is not used and that no side eﬀects aﬀecting the observable behavior of the program are produced.

6) This documentation also includes conditionally-supported constructs and locale-speciﬁc behavior. See 1.4.

§ 1.9

8

c(cid:13) ISO/IEC

N4296

These collectively are referred to as the observable behavior of the program.
spondences between abstract and actual semantics may be deﬁned by each implementation. — end note ]
[ Note: Operators can be regrouped according to the usual mathematical rules only where the operators
really are associative or commutative.7 For example, in the following fragment

[ Note: More stringent corre-

9

int a, b;
/∗ ... ∗/
a = a + 32760 + b + 5;

the expression statement behaves exactly the same as

a = (((a + 32760) + b) + 5);

due to the associativity and precedence of these operators. Thus, the result of the sum (a + 32760) is next
added to b, and that result is then added to 5 which results in the value assigned to a. On a machine in which
overﬂows produce an exception and in which the range of values representable by an int is [-32768,+32767],
the implementation cannot rewrite this expression as

a = ((a + b) + 32765);

since if the values for a and b were, respectively, -32754 and -15, the sum a + b would produce an exception
while the original expression would not; nor can the expression be rewritten either as

a = ((a + 32765) + b);

or

a = (a + (b + 32765));

since the values for a and b might have been, respectively, 4 and -8 or -17 and 12. However on a machine in
which overﬂows do not produce an exception and in which the results of overﬂows are reversible, the above
expression statement can be rewritten by the implementation in any of the above ways because the same
result will occur. — end note ]

10 A full-expression is an expression that is not a subexpression of another expression. [ Note: in some contexts,
such as unevaluated operands, a syntactic subexpression is considered a full-expression (Clause 5). — end
note ] If a language construct is deﬁned to produce an implicit call of a function, a use of the language
construct is considered to be an expression for the purposes of this deﬁnition. A call to a destructor
generated at the end of the lifetime of an object other than a temporary object is an implicit full-expression.
Conversions applied to the result of an expression in order to satisfy the requirements of the language
construct in which the expression appears are also considered to be part of the full-expression.
[ Example:

struct S {

S(int i): I(i) { }
int& v() { return I; }

private:
int I;

};

S s1(1);
S s2 = 2;

void f() {

// full-expression is call of S::S(int)
// full-expression is call of S::S(int)

7) Overloaded operators are never assumed to be associative or commutative.

§ 1.9

9

c(cid:13) ISO/IEC

if (S(3).v())

{ }

}

// full-expression includes lvalue-to-rvalue and
// int to bool conversions, performed before
// temporary is deleted at end of full-expression

N4296

11

— end example ]
[ Note: The evaluation of a full-expression can include the evaluation of subexpressions that are not lexically
part of the full-expression. For example, subexpressions involved in evaluating default arguments (8.3.6) are
considered to be created in the expression that calls the function, not the expression that deﬁnes the default
argument. — end note ]

12 Accessing an object designated by a volatile glvalue (3.10), modifying an object, calling a library I/O
function, or calling a function that does any of those operations are all side eﬀects, which are changes in the
state of the execution environment. Evaluation of an expression (or a sub-expression) in general includes
both value computations (including determining the identity of an object for glvalue evaluation and fetching
a value previously assigned to an object for prvalue evaluation) and initiation of side eﬀects. When a call
to a library I/O function returns or an access to a volatile object is evaluated the side eﬀect is considered
complete, even though some external actions implied by the call (such as the I/O itself) or by the volatile
access may not have completed yet.

13 Sequenced before is an asymmetric, transitive, pair-wise relation between evaluations executed by a single
thread (1.10), which induces a partial order among those evaluations. Given any two evaluations A and B, if
A is sequenced before B, then the execution of A shall precede the execution of B. If A is not sequenced before
B and B is not sequenced before A, then A and B are unsequenced. [ Note: The execution of unsequenced
evaluations can overlap. — end note ] Evaluations A and B are indeterminately sequenced when either A
is sequenced before B or B is sequenced before A, but it is unspeciﬁed which.
[ Note: Indeterminately
sequenced evaluations cannot overlap, but either could be executed ﬁrst. — end note ]

14 Every value computation and side eﬀect associated with a full-expression is sequenced before every value

computation and side eﬀect associated with the next full-expression to be evaluated.8

15 Except where noted, evaluations of operands of individual operators and of subexpressions of individual
expressions are unsequenced. [ Note: In an expression that is evaluated more than once during the execution
of a program, unsequenced and indeterminately sequenced evaluations of its subexpressions need not be
performed consistently in diﬀerent evaluations. — end note ] The value computations of the operands of an
operator are sequenced before the value computation of the result of the operator. If a side eﬀect on a scalar
object is unsequenced relative to either another side eﬀect on the same scalar object or a value computation
using the value of the same scalar object, and they are not potentially concurrent (1.10), the behavior is
undeﬁned. [ Note: The next section imposes similar, but more complex restrictions on potentially concurrent
computations. — end note ]
[ Example:

void f(int, int);
void g(int i, int* v) {

i = v[i++];
i = 7, i++, i++;

// the behavior is undeﬁned
// i becomes 9

i = i++ + 1;
i = i + 1;

// the behavior is undeﬁned
// the value of i is incremented

f(i = -1, i = -1); // the behavior is undeﬁned

8) As speciﬁed in 12.2, after a full-expression is evaluated, a sequence of zero or more invocations of destructor functions for

temporary objects takes place, usually in reverse order of the construction of each temporary object.

§ 1.9

10

c(cid:13) ISO/IEC

}

N4296

— end example ]
When calling a function (whether or not the function is inline), every value computation and side eﬀect
associated with any argument expression, or with the postﬁx expression designating the called function, is
sequenced before execution of every expression or statement in the body of the called function. [ Note: Value
computations and side eﬀects associated with diﬀerent argument expressions are unsequenced. — end note ]
Every evaluation in the calling function (including other function calls) that is not otherwise speciﬁcally
sequenced before or after the execution of the body of the called function is indeterminately sequenced with
respect to the execution of the called function.9 Several contexts in C++ cause evaluation of a function call,
even though no corresponding function call syntax appears in the translation unit. [ Example: Evaluation of
a new-expression invokes one or more allocation and constructor functions; see 5.3.4. For another example,
invocation of a conversion function (12.3.2) can arise in contexts in which no function call syntax appears.
— end example ] The sequencing constraints on the execution of the called function (as described above)
are features of the function calls as evaluated, whatever the syntax of the expression that calls the function
might be.
1.10 Multi-threaded executions and data races

[intro.multithread]
1 A thread of execution (also known as a thread) is a single ﬂow of control within a program, including the initial
invocation of a speciﬁc top-level function, and recursively including every function invocation subsequently
executed by the thread. [ Note: When one thread creates another, the initial call to the top-level function of
the new thread is executed by the new thread, not by the creating thread. — end note ] Every thread in a
program can potentially access every object and function in a program.10 Under a hosted implementation, a
C++ program can have more than one thread running concurrently. The execution of each thread proceeds
as deﬁned by the remainder of this standard. The execution of the entire program consists of an execution of
all of its threads. [ Note: Usually the execution can be viewed as an interleaving of all its threads. However,
some kinds of atomic operations, for example, allow executions inconsistent with a simple interleaving, as
described below. — end note ] Under a freestanding implementation, it is implementation-deﬁned whether
a program can have more than one thread of execution.

2 A signal handler that is executed as a result of a call to the raise function belongs to the same thread of
execution as the call to the raise function. Otherwise it is unspeciﬁed which thread of execution contains
a signal handler invocation.
Implementations should ensure that all unblocked threads eventually make progress.
[ Note: Standard
library functions may silently block on I/O or locks. Factors in the execution environment, including
externally-imposed thread priorities, may prevent an implementation from making certain guarantees of
forward progress. — end note ]

3

4 Executions of atomic functions that are either deﬁned to be lock-free (29.7) or indicated as lock-free (29.4)

are lock-free executions.

(4.1)

—

(4.2)

—

If there is only one unblocked thread, a lock-free execution in that thread shall complete.
[ Note:
Concurrently executing threads may prevent progress of a lock-free execution. For example, this
situation can occur with load-locked store-conditional implementations. This property is sometimes
termed obstruction-free. — end note ]
When one or more lock-free executions run concurrently, at least one should complete.
[ Note: It
is diﬃcult for some implementations to provide absolute guarantees to this eﬀect, since repeated and

9) In other words, function executions do not interleave with each other.
10) An object with automatic or thread storage duration (3.7) is associated with one speciﬁc thread, and can be accessed by
a diﬀerent thread only indirectly through a pointer or reference (3.9.2).

§ 1.10

11

c(cid:13) ISO/IEC

N4296

particularly inopportune interference from other threads may prevent forward progress, e.g., by repeat-
edly stealing a cache line for unrelated purposes between load-locked and store-conditional instructions.
Implementations should ensure that such eﬀects cannot indeﬁnitely delay progress under expected op-
erating conditions, and that such anomalies can therefore safely be ignored by programmers. Outside
this International Standard, this property is sometimes termed lock-free. — end note ]

5 The value of an object visible to a thread T at a particular point is the initial value of the object, a value
assigned to the object by T, or a value assigned to the object by another thread, according to the rules
below. [ Note: In some cases, there may instead be undeﬁned behavior. Much of this section is motivated
by the desire to support atomic operations with explicit and detailed visibility constraints. However, it also
implicitly supports a simpler view for more restricted programs. — end note ]

6 Two expression evaluations conﬂict if one of them modiﬁes a memory location (1.7) and the other one

accesses or modiﬁes the same memory location.

7 The library deﬁnes a number of atomic operations (Clause 29) and operations on mutexes (Clause 30)
that are specially identiﬁed as synchronization operations. These operations play a special role in making
assignments in one thread visible to another. A synchronization operation on one or more memory locations
is either a consume operation, an acquire operation, a release operation, or both an acquire and release
operation. A synchronization operation without an associated memory location is a fence and can be either
an acquire fence, a release fence, or both an acquire and release fence. In addition, there are relaxed atomic
operations, which are not synchronization operations, and atomic read-modify-write operations, which have
special characteristics. [ Note: For example, a call that acquires a mutex will perform an acquire operation
on the locations comprising the mutex. Correspondingly, a call that releases the same mutex will perform a
release operation on those same locations. Informally, performing a release operation on A forces prior side
eﬀects on other memory locations to become visible to other threads that later perform a consume or an
acquire operation on A. “Relaxed” atomic operations are not synchronization operations even though, like
synchronization operations, they cannot contribute to data races. — end note ]

8 All modiﬁcations to a particular atomic object M occur in some particular total order, called the modiﬁcation
order of M. If A and B are modiﬁcations of an atomic object M and A happens before (as deﬁned below) B,
then A shall precede B in the modiﬁcation order of M, which is deﬁned below. [ Note: This states that the
modiﬁcation orders must respect the “happens before” relationship. — end note ] [ Note: There is a separate
order for each atomic object. There is no requirement that these can be combined into a single total order for
all objects. In general this will be impossible since diﬀerent threads may observe modiﬁcations to diﬀerent
objects in inconsistent orders. — end note ]

9 A release sequence headed by a release operation A on an atomic object M is a maximal contiguous sub-
sequence of side eﬀects in the modiﬁcation order of M, where the ﬁrst operation is A, and every subsequent
operation

(9.1)

(9.2)

—
—

is performed by the same thread that performed A, or
is an atomic read-modify-write operation.

10 Certain library calls synchronize with other library calls performed by another thread. For example, an
atomic store-release synchronizes with a load-acquire that takes its value from the store (29.3).
[ Note:
Except in the speciﬁed cases, reading a later value does not necessarily ensure visibility as described below.
Such a requirement would sometimes interfere with eﬃcient implementation. — end note ] [ Note: The
speciﬁcations of the synchronization operations deﬁne when one reads the value written by another. For
atomic objects, the deﬁnition is clear. All operations on a given mutex occur in a single total order. Each
mutex acquisition “reads the value written” by the last mutex release. — end note ]

11 An evaluation A carries a dependency to an evaluation B if

(11.1)

—

the value of A is used as an operand of B, unless:

§ 1.10

12

c(cid:13) ISO/IEC

N4296

(11.1.1)

(11.1.2)

(11.1.3)

(11.1.4)

(11.2)

(11.3)

—

—

—
—

B is an invocation of any specialization of std::kill_dependency (29.3), or
A is the left operand of a built-in logical AND (&&, see 5.14) or logical OR (||, see 5.15) operator,
or
A is the left operand of a conditional (?:, see 5.16) operator, or
A is the left operand of the built-in comma (,) operator (5.19);

—
—
or
A writes a scalar object or bit-ﬁeld M, B reads the value written by A from M, and A is sequenced
before B, or
for some evaluation X, A carries a dependency to X, and X carries a dependency to B.

[ Note: “Carries a dependency to” is a subset of “is sequenced before”, and is similarly strictly intra-thread.
— end note ]

12 An evaluation A is dependency-ordered before an evaluation B if

(12.1)

(12.2)

—

—

A performs a release operation on an atomic object M, and, in another thread, B performs a consume
operation on M and reads a value written by any side eﬀect in the release sequence headed by A, or
for some evaluation X, A is dependency-ordered before X and X carries a dependency to B.

[ Note: The relation “is dependency-ordered before” is analogous to “synchronizes with”, but uses release/-
consume in place of release/acquire. — end note ]

13 An evaluation A inter-thread happens before an evaluation B if

—
—
—

(13.1)

(13.2)

(13.3)
(13.3.1)

(13.3.2)

(13.3.3)

A synchronizes with B, or
A is dependency-ordered before B, or
for some evaluation X
—
—
—

A synchronizes with X and X is sequenced before B, or
A is sequenced before X and X inter-thread happens before B, or
A inter-thread happens before X and X inter-thread happens before B.

[ Note: The “inter-thread happens before” relation describes arbitrary concatenations of “sequenced before”,
“synchronizes with” and “dependency-ordered before” relationships, with two exceptions. The ﬁrst exception
is that a concatenation is not permitted to end with “dependency-ordered before” followed by “sequenced
before”. The reason for this limitation is that a consume operation participating in a “dependency-ordered
before” relationship provides ordering only with respect to operations to which this consume operation
actually carries a dependency. The reason that this limitation applies only to the end of such a concatenation
is that any subsequent release operation will provide the required ordering for a prior consume operation.
The second exception is that a concatenation is not permitted to consist entirely of “sequenced before”. The
reasons for this limitation are (1) to permit “inter-thread happens before” to be transitively closed and (2)
the “happens before” relation, deﬁned below, provides for relationships consisting entirely of “sequenced
before”. — end note ]

14 An evaluation A happens before an evaluation B if:

(14.1)

(14.2)

—
—

A is sequenced before B, or
A inter-thread happens before B.

§ 1.10

13

c(cid:13) ISO/IEC

N4296

The implementation shall ensure that no program execution demonstrates a cycle in the “happens before”
relation. [ Note: This cycle would otherwise be possible only through the use of consume operations. — end
note ]

15 A visible side eﬀect A on a scalar object or bit-ﬁeld M with respect to a value computation B of M satisﬁes

the conditions:

(15.1)

(15.2)

—
—

A happens before B and
there is no other side eﬀect X to M such that A happens before X and X happens before B.

The value of a non-atomic scalar object or bit-ﬁeld M, as determined by evaluation B, shall be the value
stored by the visible side eﬀect A. [ Note: If there is ambiguity about which side eﬀect to a non-atomic object
or bit-ﬁeld is visible, then the behavior is either unspeciﬁed or undeﬁned. — end note ] [ Note: This states
that operations on ordinary objects are not visibly reordered. This is not actually detectable without data
races, but it is necessary to ensure that data races, as deﬁned below, and with suitable restrictions on the
use of atomics, correspond to data races in a simple interleaved (sequentially consistent) execution. — end
note ]

19

18

17

16 The value of an atomic object M, as determined by evaluation B, shall be the value stored by some side
eﬀect A that modiﬁes M, where B does not happen before A. [ Note: The set of such side eﬀects is also
restricted by the rest of the rules described here, and in particular, by the coherence requirements below.
— end note ]
If an operation A that modiﬁes an atomic object M happens before an operation B that modiﬁes M, then
A shall be earlier than B in the modiﬁcation order of M. [ Note: This requirement is known as write-write
coherence. — end note ]
If a value computation A of an atomic object M happens before a value computation B of M, and A takes
its value from a side eﬀect X on M, then the value computed by B shall either be the value stored by X or
the value stored by a side eﬀect Y on M, where Y follows X in the modiﬁcation order of M. [ Note: This
requirement is known as read-read coherence. — end note ]
If a value computation A of an atomic object M happens before an operation B that modiﬁes M, then A
shall take its value from a side eﬀect X on M, where X precedes B in the modiﬁcation order of M. [ Note:
This requirement is known as read-write coherence. — end note ]
If a side eﬀect X on an atomic object M happens before a value computation B of M, then the evaluation
B shall take its value from X or from a side eﬀect Y that follows X in the modiﬁcation order of M. [ Note:
This requirement is known as write-read coherence. — end note ]
[ Note: The four preceding coherence requirements eﬀectively disallow compiler reordering of atomic opera-
tions to a single object, even if both operations are relaxed loads. This eﬀectively makes the cache coherence
guarantee provided by most hardware available to C++ atomic operations. — end note ]
[ Note: The value observed by a load of an atomic depends on the “happens before” relation, which depends
on the values observed by loads of atomics. The intended reading is that there must exist an association of
atomic loads with modiﬁcations they observe that, together with suitably chosen modiﬁcation orders and
the “happens before” relation derived as described above, satisfy the resulting constraints as imposed here.
— end note ]

20

21

22

23 Two actions are potentially concurrent if

(23.1)

(23.2)

—
—

they are performed by diﬀerent threads, or
they are unsequenced, and at least one is performed by a signal handler.

The execution of a program contains a data race if it contains two potentially concurrent conﬂicting actions,
at least one of which is not atomic, and neither happens before the other, except for the special case for signal

§ 1.10

14

c(cid:13) ISO/IEC

N4296

handlers described below. Any such data race results in undeﬁned behavior. [ Note: It can be shown that
programs that correctly use mutexes and memory_order_seq_cst operations to prevent all data races and
use no other synchronization operations behave as if the operations executed by their constituent threads
were simply interleaved, with each value computation of an object being taken from the last side eﬀect on that
object in that interleaving. This is normally referred to as “sequential consistency”. However, this applies only
to data-race-free programs, and data-race-free programs cannot observe most program transformations that
do not change single-threaded program semantics. In fact, most single-threaded program transformations
continue to be allowed, since any program that behaves diﬀerently as a result must perform an undeﬁned
operation. — end note ]

25

24 Two accesses to the same object of type volatile sig_atomic_t do not result in a data race if both occur
in the same thread, even if one or more occurs in a signal handler. For each signal handler invocation,
evaluations performed by the thread invoking a signal handler can be divided into two groups A and B,
such that no evaluations in B happen before evaluations in A, and the evaluations of such volatile sig_-
atomic_t objects take values as though all evaluations in A happened before the execution of the signal
handler and the execution of the signal handler happened before all evaluations in B.
[ Note: Compiler transformations that introduce assignments to a potentially shared memory location that
would not be modiﬁed by the abstract machine are generally precluded by this standard, since such an
assignment might overwrite another assignment by a diﬀerent thread in cases in which an abstract machine
execution would not have encountered a data race. This includes implementations of data member assign-
ment that overwrite adjacent members in separate memory locations. Reordering of atomic loads in cases
in which the atomics in question may alias is also generally precluded, since this may violate the coherence
rules. — end note ]
[ Note: Transformations that introduce a speculative read of a potentially shared memory location may not
preserve the semantics of the C++ program as deﬁned in this standard, since they potentially introduce a
data race. However, they are typically valid in the context of an optimizing compiler that targets a speciﬁc
machine with well-deﬁned semantics for data races. They would be invalid for a hypothetical machine that
is not tolerant of races or provides hardware race detection. — end note ]

26

27 The implementation may assume that any thread will eventually do one of the following:

(27.1)

(27.2)

(27.3)

(27.4)

—
—
—
—

terminate,
make a call to a library I/O function,
access or modify a volatile object, or
perform a synchronization operation or an atomic operation.

[ Note: This is intended to allow compiler transformations such as removal of empty loops, even when
termination cannot be proven. — end note ]

28 An implementation should ensure that the last value (in modiﬁcation order) assigned by an atomic or

synchronization operation will become visible to all other threads in a ﬁnite period of time.
1.11 Acknowledgments

[intro.ack]
1 The C++ programming language as described in this International Standard is based on the language as
described in Chapter R (Reference Manual) of Stroustrup: The C++ Programming Language (second edition,
Addison-Wesley Publishing Company, ISBN 0-201-53992-6, copyright c(cid:13)1991 AT&T). That, in turn, is based
on the C programming language as described in Appendix A of Kernighan and Ritchie: The C Programming
Language (Prentice-Hall, 1978, ISBN 0-13-110163-3, copyright c(cid:13)1978 AT&T).

2 Portions of the library Clauses of this International Standard are based on work by P.J. Plauger, which was
published as The Draft Standard C++ Library (Prentice-Hall, ISBN 0-13-117003-1, copyright c(cid:13)1995 P.J.
Plauger).

§ 1.11

15

c(cid:13) ISO/IEC

N4296

3 POSIX R(cid:13) is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
4 All rights in these originals are reserved.

§ 1.11

16

c(cid:13) ISO/IEC

N4296

2 Lexical conventions
2.1 Separate translation

[lex]
[lex.separate]
1 The text of the program is kept in units called source ﬁles in this International Standard. A source ﬁle
together with all the headers (17.6.1.2) and source ﬁles included (16.2) via the preprocessing directive
#include, less any source lines skipped by any of the conditional inclusion (16.1) preprocessing directives, is
called a translation unit. [ Note: A C++ program need not all be translated at the same time. — end note ]
[ Note: Previously translated translation units and instantiation units can be preserved individually or in
libraries. The separate translation units of a program communicate (3.5) by (for example) calls to functions
whose identiﬁers have external linkage, manipulation of objects whose identiﬁers have external linkage, or
manipulation of data ﬁles. Translation units can be separately translated and then later linked to produce
an executable program (3.5). — end note ]
2.2 Phases of translation

2

[lex.phases]

1 The precedence among the syntax rules of translation is speciﬁed by the following phases.11

1. Physical source ﬁle characters are mapped, in an implementation-deﬁned manner, to the basic source
character set (introducing new-line characters for end-of-line indicators) if necessary. The set of phys-
ical source ﬁle characters accepted is implementation-deﬁned. Any source ﬁle character not in the
basic source character set (2.3) is replaced by the universal-character-name that designates that char-
acter. (An implementation may use any internal encoding, so long as an actual extended character
encountered in the source ﬁle, and the same extended character expressed in the source ﬁle as a
universal-character-name (i.e., using the \uXXXX notation), are handled equivalently except where this
replacement is reverted in a raw string literal.)

2. Each instance of a backslash character (\) immediately followed by a new-line character is deleted,
splicing physical source lines to form logical source lines. Only the last backslash on any physical source
line shall be eligible for being part of such a splice. Except for splices reverted in a raw string literal,
if a splice results in a character sequence that matches the syntax of a universal-character-name, the
behavior is undeﬁned. A source ﬁle that is not empty and that does not end in a new-line character,
or that ends in a new-line character immediately preceded by a backslash character before any such
splicing takes place, shall be processed as if an additional new-line character were appended to the ﬁle.
3. The source ﬁle is decomposed into preprocessing tokens (2.4) and sequences of white-space characters
(including comments). A source ﬁle shall not end in a partial preprocessing token or in a partial com-
ment.12 Each comment is replaced by one space character. New-line characters are retained. Whether
each nonempty sequence of white-space characters other than new-line is retained or replaced by one
space character is unspeciﬁed. The process of dividing a source ﬁle’s characters into preprocessing to-
kens is context-dependent. [ Example: see the handling of < within a #include preprocessing directive.
— end example ]

4. Preprocessing directives are executed, macro invocations are expanded, and _Pragma unary operator
expressions are executed. If a character sequence that matches the syntax of a universal-character-name
11) Implementations must behave as if these separate phases occur, although in practice diﬀerent phases might be folded
together.
12) A partial preprocessing token would arise from a source ﬁle ending in the ﬁrst portion of a multi-character token that
requires a terminating sequence of characters, such as a header-name that is missing the closing " or >. A partial comment
would arise from a source ﬁle ending with an unclosed /* comment.

§ 2.2

17

c(cid:13) ISO/IEC

N4296

is produced by token concatenation (16.3.3), the behavior is undeﬁned. A #include preprocessing di-
rective causes the named header or source ﬁle to be processed from phase 1 through phase 4, recursively.
All preprocessing directives are then deleted.

5. Each source character set member in a character literal or a string literal, as well as each escape
sequence and universal-character-name in a character literal or a non-raw string literal, is converted to
the corresponding member of the execution character set (2.13.3, 2.13.5); if there is no corresponding
member, it is converted to an implementation-deﬁned member other than the null (wide) character.13

6. Adjacent string literal tokens are concatenated.
7. White-space characters separating tokens are no longer signiﬁcant. Each preprocessing token is con-
verted into a token. (2.6). The resulting tokens are syntactically and semantically analyzed and trans-
lated as a translation unit. [ Note: The process of analyzing and translating the tokens may occasionally
result in one token being replaced by a sequence of other tokens (14.2). — end note ] [ Note: Source
ﬁles, translation units and translated translation units need not necessarily be stored as ﬁles, nor need
there be any one-to-one correspondence between these entities and any external representation. The
description is conceptual only, and does not specify any particular implementation. — end note ]

8. Translated translation units and instantiation units are combined as follows:

[ Note: Some or all of
these may be supplied from a library. — end note ] Each translated translation unit is examined to
produce a list of required instantiations.
[ Note: This may include instantiations which have been
explicitly requested (14.7.2). — end note ] The deﬁnitions of the required templates are located.
It is implementation-deﬁned whether the source of the translation units containing these deﬁnitions
is required to be available.
[ Note: An implementation could encode suﬃcient information into the
translated translation unit so as to ensure the source is not required here. — end note ] All the required
instantiations are performed to produce instantiation units.
[ Note: These are similar to translated
translation units, but contain no references to uninstantiated templates and no template deﬁnitions.
— end note ] The program is ill-formed if any instantiation fails.

9. All external entity references are resolved. Library components are linked to satisfy external references
to entities not deﬁned in the current translation. All such translator output is collected into a program
image which contains information needed for execution in its execution environment.

2.3 Character sets

[lex.charset]
1 The basic source character set consists of 96 characters: the space character, the control characters repre-

senting horizontal tab, vertical tab, form feed, and new-line, plus the following 91 graphical characters:14

a b c d e f g h i j k l m n o p q r s t u v w x y z

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

0 1 2 3 4 5 6 7 8 9

_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ " ’

2 The universal-character-name construct provides a way to name other characters.

hex-quad:

hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit

13) An implementation need not convert all non-corresponding source characters to the same execution character.
14) The glyphs for the members of the basic source character set are intended to identify characters from the subset of
ISO/IEC 10646 which corresponds to the ASCII character set. However, because the mapping from source ﬁle characters to the
source character set (described in translation phase 1) is speciﬁed as implementation-deﬁned, an implementation is required to
document how the basic source characters are represented in source ﬁles.

§ 2.3

18

c(cid:13) ISO/IEC

N4296

universal-character-name:

\u hex-quad
\U hex-quad hex-quad

The character designated by the universal-character-name \UNNNNNNNN is that character whose character
short name in ISO/IEC 10646 is NNNNNNNN; the character designated by the universal-character-name \uNNNN
is that character whose character short name in ISO/IEC 10646 is 0000NNNN. If the hexadecimal value for a
universal-character-name corresponds to a surrogate code point (in the range 0xD800–0xDFFF, inclusive),
the program is ill-formed. Additionally, if the hexadecimal value for a universal-character-name outside the
c-char-sequence, s-char-sequence, or r-char-sequence of a character or string literal corresponds to a control
character (in either of the ranges 0x00–0x1F or 0x7F–0x9F, both inclusive) or to a character in the basic
source character set, the program is ill-formed.15

3 The basic execution character set and the basic execution wide-character set shall each contain all the
members of the basic source character set, plus control characters representing alert, backspace, and carriage
return, plus a null character (respectively, null wide character), whose value is 0. For each basic execution
character set, the values of the members shall be non-negative and distinct from one another. In both the
source and execution basic character sets, the value of each character after 0 in the above list of decimal
digits shall be one greater than the value of the previous. The execution character set and the execution
wide-character set are implementation-deﬁned supersets of the basic execution character set and the basic
execution wide-character set, respectively. The values of the members of the execution character sets and
the sets of additional members are locale-speciﬁc.
2.4 Preprocessing tokens

[lex.pptoken]

preprocessing-token:
header-name
identiﬁer
pp-number
character-literal
user-deﬁned-character-literal
string-literal
user-deﬁned-string-literal
preprocessing-op-or-punc
each non-white-space character that cannot be one of the above

1 Each preprocessing token that is converted to a token (2.6) shall have the lexical form of a keyword, an

identiﬁer, a literal, an operator, or a punctuator.

2 A preprocessing token is the minimal lexical element of the language in translation phases 3 through 6. The
categories of preprocessing token are: header names, identiﬁers, preprocessing numbers, character literals
(including user-deﬁned character literals), string literals (including user-deﬁned string literals), preprocessing
operators and punctuators, and single non-white-space characters that do not lexically match the other
preprocessing token categories. If a ’ or a " character matches the last category, the behavior is undeﬁned.
Preprocessing tokens can be separated by white space; this consists of comments (2.7), or white-space
characters (space, horizontal tab, new-line, vertical tab, and form-feed), or both. As described in Clause 16,
in certain circumstances during translation phase 4, white space (or the absence thereof) serves as more
than preprocessing token separation. White space can appear within a preprocessing token only as part of
a header name or between the quotation characters in a character literal or string literal.
If the input stream has been parsed into preprocessing tokens up to a given character:

3

(3.1)

—

If the next character begins a sequence of characters that could be the preﬁx and initial double quote
of a raw string literal, such as R", the next preprocessing token shall be a raw string literal. Between
15) A sequence of characters resembling a universal-character-name in an r-char-sequence (2.13.5) does not form a universal-
character-name.

§ 2.4

19

c(cid:13) ISO/IEC

N4296

the initial and ﬁnal double quote characters of the raw string, any transformations performed in phases
1 and 2 (universal-character-names and line splicing) are reverted; this reversion shall apply before any
d-char, r-char, or delimiting parenthesis is identiﬁed. The raw string literal is deﬁned as the shortest
sequence of characters that matches the raw-string pattern

encoding-preﬁxoptR raw-string

(3.2)

(3.3)

—

—

Otherwise, if the next three characters are <:: and the subsequent character is neither : nor >, the <
is treated as a preprocessor token by itself and not as the ﬁrst character of the alternative token <:.
Otherwise, the next preprocessing token is the longest sequence of characters that could constitute a
preprocessing token, even if that would cause further lexical analysis to fail.

[ Example:

#define R "x"
const char* s = R"y";

// ill-formed raw string, not "x" "y"

4

5

— end example ]
[ Example: The program fragment 0xe+foo is parsed as a preprocessing number token (one that is not a
valid ﬂoating or integer literal token), even though a parse as three preprocessing tokens 0xe, +, and foo
might produce a valid expression (for example, if foo were a macro deﬁned as 1). Similarly, the program
fragment 1E1 is parsed as a preprocessing number (one that is a valid ﬂoating literal token), whether or not
E is a macro name. — end example ]
[ Example: The program fragment x+++++y is parsed as x ++ ++ + y, which, if x and y have integral types,
violates a constraint on increment operators, even though the parse x ++ + ++ y might yield a correct
expression. — end example ]
2.5 Alternative tokens

[lex.digraph]

1 Alternative token representations are provided for some operators and punctuators.16
2

In all respects of the language, each alternative token behaves the same, respectively, as its primary token,
except for its spelling.17 The set of alternative tokens is deﬁned in Table 1.

Table 1 — Alternative tokens

Alternative Primary Alternative Primary Alternative Primary

<%
%>
<:
:>
%:
%:%:

{
}
[
]
#
##

and
bitor

or
xor
compl
bitand

&&
|
||
ˆ
~
&

and_eq
or_eq
xor_eq

not

not_eq

&=
|=
ˆ=
!
!=

16) These include “digraphs” and additional reserved words. The term “digraph” (token consisting of two characters) is not
perfectly descriptive, since one of the alternative preprocessing-tokens is %:%: and of course several primary tokens contain two
characters. Nonetheless, those alternative tokens that aren’t lexical keywords are colloquially known as “digraphs”.
17) Thus the “stringized” values (16.3.2) of [ and <: will be diﬀerent, maintaining the source spelling, but the tokens can
otherwise be freely interchanged.

§ 2.5

20

c(cid:13) ISO/IEC

2.6 Tokens

token:

identiﬁer
keyword
literal
operator
punctuator

N4296

[lex.token]

1 There are ﬁve kinds of tokens:

identiﬁers, keywords, literals,18 operators, and other separators. Blanks,
horizontal and vertical tabs, newlines, formfeeds, and comments (collectively, “white space”), as described
below, are ignored except as they serve to separate tokens.
[ Note: Some white space is required to sepa-
rate otherwise adjacent identiﬁers, keywords, numeric literals, and alternative tokens containing alphabetic
characters. — end note ]
2.7 Comments

[lex.comment]
1 The characters /* start a comment, which terminates with the characters */. These comments do not nest.
The characters // start a comment, which terminates immediately before the next new-line character. If
there is a form-feed or a vertical-tab character in such a comment, only white-space characters shall appear
between it and the new-line that terminates the comment; no diagnostic is required. [ Note: The comment
characters //, /*, and */ have no special meaning within a // comment and are treated just like other
characters. Similarly, the comment characters // and /* have no special meaning within a /* comment.
— end note ]
2.8 Header names

[lex.header]

header-name:

< h-char-sequence >
" q-char-sequence "

h-char-sequence:

h-char
h-char-sequence h-char

h-char:

any member of the source character set except new-line and >

q-char-sequence:

q-char
q-char-sequence q-char

q-char:

any member of the source character set except new-line and "

1 Header name preprocessing tokens shall only appear within a #include preprocessing directive (16.2). The
sequences in both forms of header-names are mapped in an implementation-deﬁned manner to headers or
to external source ﬁle names as speciﬁed in 16.2.

2 The appearance of either of the characters ’ or \ or of either of the character sequences /* or // in a
q-char-sequence or an h-char-sequence is conditionally-supported with implementation-deﬁned semantics, as
is the appearance of the character " in an h-char-sequence.19
18) Literals include strings and character and numeric literals.
19) Thus, a sequence of characters that resembles an escape sequence might result in an error, be interpreted as the character
corresponding to the escape sequence, or have a completely diﬀerent meaning, depending on the implementation.

§ 2.8

21

integer literal token or a ﬂoating literal token.
2.10 Identiﬁers

identiﬁer:

identiﬁer-nondigit
identiﬁer identiﬁer-nondigit
identiﬁer digit

identiﬁer-nondigit:

nondigit
universal-character-name
other implementation-deﬁned characters

nondigit: one of

a b c d e f g h i j k l m
n o p q r s t u v w x y z
A B C D E F G H I J K L M
N O P Q R S T U V W X Y Z _

digit: one of

0 1 2 3 4 5 6 7 8 9

c(cid:13) ISO/IEC

2.9 Preprocessing numbers

pp-number:
digit
. digit
pp-number digit
pp-number identiﬁer-nondigit
pp-number ’ digit
pp-number ’ nondigit
pp-number e sign
pp-number E sign
pp-number .

N4296

[lex.ppnumber]

1 Preprocessing number tokens lexically include all integer literal tokens (2.13.2) and all ﬂoating literal to-

kens (2.13.4).

2 A preprocessing number does not have a type or a value; it acquires both after a successful conversion to an

[lex.name]

1 An identiﬁer is an arbitrarily long sequence of letters and digits. Each universal-character-name in an
identiﬁer shall designate a character whose encoding in ISO 10646 falls into one of the ranges speciﬁed
in E.1. The initial element shall not be a universal-character-name designating a character whose encoding
falls into one of the ranges speciﬁed in E.2. Upper- and lower-case letters are diﬀerent. All characters are
signiﬁcant.20

2 The identiﬁers in Table 2 have a special meaning when appearing in a certain context. When referred to
in the grammar, these identiﬁers are used explicitly rather than using the identiﬁer grammar production.
Unless otherwise speciﬁed, any ambiguity as to whether a given identiﬁer has a special meaning is resolved
to interpret the token as a regular identiﬁer.

Table 2 — Identiﬁers with special meaning

override

final

20) On systems in which linkers cannot accept extended characters, an encoding of the universal-character-name may be used
in forming valid external identiﬁers. For example, some otherwise unused character or sequence of characters may be used to
encode the \u in a universal-character-name. Extended characters may produce a long external identiﬁer, but C++ does not
place a translation limit on signiﬁcant characters for external identiﬁers. In C++, upper- and lower-case letters are considered
diﬀerent for all identiﬁers, including external identiﬁers.

§ 2.10

22

c(cid:13) ISO/IEC

N4296

3

In addition, some identiﬁers are reserved for use by C++ implementations and shall not be used otherwise;
no diagnostic is required.

(3.1)

(3.2)

—

—

Each identiﬁer that contains a double underscore __ or begins with an underscore followed by an
uppercase letter is reserved to the implementation for any use.
Each identiﬁer that begins with an underscore is reserved to the implementation for use as a name in
the global namespace.

2.11 Keywords

[lex.key]
1 The identiﬁers shown in Table 3 are reserved for use as keywords (that is, they are unconditionally treated
as keywords in phase 7) except in an attribute-token (7.6.1) [ Note: The export keyword is unused but is
reserved for future use. — end note ]:

Table 3 — Keywords

alignas
alignof
asm
auto
bool
break
case
catch
char
char16_t
char32_t
class
const
constexpr
const_cast

continue
decltype
default
delete
do
double
dynamic_cast
else
enum
explicit
export
extern
false
float
for

friend
goto
if
inline
int
long
mutable
namespace
new
noexcept
nullptr
operator
private
protected
public

register
reinterpret_cast
return
short
signed
sizeof
static
static_assert
static_cast
struct
switch
template
this
thread_local
throw

true
try
typedef
typeid
typename
union
unsigned
using
virtual
void
volatile
wchar_t
while

2 Furthermore, the alternative representations shown in Table 4 for certain operators and punctuators (2.5)

are reserved and shall not be used otherwise:

Table 4 — Alternative representations
compl
xor_eq

bitand
or_eq

bitor
xor

and
not_eq

and_eq
or

not

2.12 Operators and punctuators

[lex.operators]
1 The lexical representation of C++ programs includes a number of preprocessing tokens which are used in

the syntax of the preprocessor or are converted into tokens for operators and punctuators:

preprocessing-op-or-punc: one of

§ 2.12

{
<:
new
+
!
ˆ=
<=
and
or

}
:>
delete
-
=
&=
>=
and_eq
or_eq

[
<%
?
*
<
|=
&&
bitand
xor

]
%>
::
/
>
<<
||
bitor
xor_eq

#
%:
.
%
+=
>>
++
compl

##
%:%:
.*
ˆ
-=
>>=
--
not

(
;

&
*=
<<=
,
not_eq

)
:

|
/=
==
->*

...

~
%=
!=
->

23

c(cid:13) ISO/IEC

N4296

Each preprocessing-op-or-punc is converted to a single token in translation phase 7 (2.2).
2.13 Literals
2.13.1 Kinds of literals

[lex.literal]
[lex.literal.kinds]

1 There are several kinds of literals.21

literal:

integer-literal
character-literal
ﬂoating-literal
string-literal
boolean-literal
pointer-literal
user-deﬁned-literal
2.13.2 Integer literals

integer-literal:

binary-literal integer-suﬃxopt
octal-literal integer-suﬃxopt
decimal-literal integer-suﬃxopt
hexadecimal-literal integer-suﬃxopt

binary-literal:

0b binary-digit
0B binary-digit
binary-literal ’opt binary-digit

octal-literal:

0
octal-literal ’opt octal-digit

decimal-literal:

nonzero-digit
decimal-literal ’opt digit

hexadecimal-literal:

0x hexadecimal-digit
0X hexadecimal-digit
hexadecimal-literal ’opt hexadecimal-digit

[lex.icon]

binary-digit:

0
1

octal-digit: one of

0 1 2 3 4 5 6 7

nonzero-digit: one of

1 2 3 4 5 6 7 8 9
hexadecimal-digit: one of

0 1 2 3 4 5 6 7 8 9
a b c d e f
A B C D E F

integer-suﬃx:

unsigned-suﬃx long-suﬃxopt
unsigned-suﬃx long-long-suﬃxopt
long-suﬃx unsigned-suﬃxopt
long-long-suﬃx unsigned-suﬃxopt

21) The term “literal” generally designates, in this International Standard, those tokens that are called “constants” in ISO C.

§ 2.13.2

24

c(cid:13) ISO/IEC

N4296

long-suﬃx: one of

u U

l L

unsigned-suﬃx: one of

long-long-suﬃx: one of

ll LL

1 An integer literal is a sequence of digits that has no period or exponent part, with optional separating single
quotes that are ignored when determining its value. An integer literal may have a preﬁx that speciﬁes its base
and a suﬃx that speciﬁes its type. The lexically ﬁrst digit of the sequence of digits is the most signiﬁcant.
A binary integer literal (base two) begins with 0b or 0B and consists of a sequence of binary digits. An octal
integer literal (base eight) begins with the digit 0 and consists of a sequence of octal digits.22 A decimal
integer literal (base ten) begins with a digit other than 0 and consists of a sequence of decimal digits. A
hexadecimal integer literal (base sixteen) begins with 0x or 0X and consists of a sequence of hexadecimal
digits, which include the decimal digits and the letters a through f and A through F with decimal values
ten through ﬁfteen.
[ Example: The number twelve can be written 12, 014, 0XC, or 0b1100. The literals
1048576, 1’048’576, 0X100000, 0x10’0000, and 0’004’000’000 all have the same value. — end example ]
2 The type of an integer literal is the ﬁrst of the corresponding list in Table 5 in which its value can be

represented.

Table 5 — Types of integer literals

Suﬃx

none

Decimal literal

int
long int
long long int

u or U

l or L

unsigned int
unsigned long int
unsigned long long int
long int
long long int

Both u or U
and l or L
ll or LL

Both u or U
and ll or LL

unsigned long int
unsigned long long int
long long int

unsigned long long int

Binary, octal, or hexadecimal literal
int
unsigned int
long int
unsigned long int
long long int
unsigned long long int
unsigned int
unsigned long int
unsigned long long int
long int
unsigned long int
long long int
unsigned long long int
unsigned long int
unsigned long long int
long long int
unsigned long long int
unsigned long long int

3

If an integer literal cannot be represented by any type in its list and an extended integer type (3.9.1) can
represent its value, it may have that extended integer type. If all of the types in the list for the literal are
signed, the extended integer type shall be signed. If all of the types in the list for the literal are unsigned, the
extended integer type shall be unsigned. If the list contains both signed and unsigned types, the extended
integer type may be signed or unsigned. A program is ill-formed if one of its translation units contains an
integer literal that cannot be represented by any of the allowed types.
22) The digits 8 and 9 are not octal digits.

§ 2.13.2

25

c(cid:13) ISO/IEC

2.13.3 Character literals

character-literal:

encoding-preﬁxopt’ c-char-sequence ’

N4296

[lex.ccon]

encoding-preﬁx: one of
L

U
c-char-sequence:

u8

u

c-char
c-char-sequence c-char

c-char:

any member of the source character set except

the single-quote ’, backslash \, or new-line character

escape-sequence
universal-character-name

escape-sequence:

simple-escape-sequence
octal-escape-sequence
hexadecimal-escape-sequence

simple-escape-sequence: one of

\’
\a

\"
\b

\?
\f

\\
\n

octal-escape-sequence:

\r

\t

\v

\ octal-digit
\ octal-digit octal-digit
\ octal-digit octal-digit octal-digit

hexadecimal-escape-sequence:

\x hexadecimal-digit
hexadecimal-escape-sequence hexadecimal-digit

1 A character literal is one or more characters enclosed in single quotes, as in ’x’, optionally preceded by u8,

u, U, or L, as in u8’w’, u’x’, U’y’, or L’z’, respectively.

2 A character literal that does not begin with u8, u, U, or L is an ordinary character literal. An ordinary
character literal that contains a single c-char representable in the execution character set has type char,
with value equal to the numerical value of the encoding of the c-char in the execution character set. An
ordinary character literal that contains more than one c-char is a multicharacter literal. A multicharacter
literal, or an ordinary character literal containing a single c-char not representable in the execution character
set, is conditionally-supported, has type int, and has an implementation-deﬁned value.

3 A character literal that begins with u8, such as u8’w’, is a character literal of type char, known as a UTF-8
character literal. The value of a UTF-8 character literal is equal to its ISO 10646 code point value, provided
that the code point value is representable with a single UTF-8 code unit (that is, provided it is in the C0
Controls and Basic Latin Unicode block). If the value is not representable with a single UTF-8 code unit,
the program is ill-formed. A UTF-8 character literal containing multiple c-chars is ill-formed.

4 A character literal that begins with the letter u, such as u’x’, is a character literal of type char16_t. The
value of a char16_t literal containing a single c-char is equal to its ISO 10646 code point value, provided that
the code point is representable with a single 16-bit code unit. (That is, provided it is a basic multi-lingual
plane code point.) If the value is not representable within 16 bits, the program is ill-formed. A char16_t
literal containing multiple c-chars is ill-formed.

5 A character literal that begins with the letter U, such as U’y’, is a character literal of type char32_t. The
value of a char32_t literal containing a single c-char is equal to its ISO 10646 code point value. A char32_t
literal containing multiple c-chars is ill-formed.

6 A character literal that begins with the letter L, such as L’z’, is a wide-character literal. A wide-character

§ 2.13.3

26

c(cid:13) ISO/IEC

N4296

literal has type wchar_t.23 The value of a wide-character literal containing a single c-char has value equal
to the numerical value of the encoding of the c-char in the execution wide-character set, unless the c-char
has no representation in the execution wide-character set, in which case the value is implementation-deﬁned.
[ Note: The type wchar_t is able to represent all members of the execution wide-character set (see 3.9.1).
— end note ]. The value of a wide-character literal containing multiple c-chars is implementation-deﬁned.
7 Certain nongraphic characters, the single quote ’, the double quote ", the question mark ?,24 and the
backslash \, can be represented according to Table 6. The double quote " and the question mark ?, can
be represented as themselves or by the escape sequences \" and \? respectively, but the single quote ’
and the backslash \ shall be represented by the escape sequences \’ and \\ respectively. Escape sequences
in which the character following the backslash is not listed in Table 6 are conditionally-supported, with
implementation-deﬁned semantics. An escape sequence speciﬁes a single character.

Table 6 — Escape sequences
\n
\t
\v
\b
\r
\f
\a
\\
\?
\’
\"
\ooo
\xhhh

new-line
NL(LF)
horizontal tab
HT
vertical tab
VT
backspace
BS
carriage return CR
FF
form feed
BEL
alert
backslash
\
?
question mark
single quote
’
double quote
"
octal number
ooo
hhh
hex number

8 The escape \ooo consists of the backslash followed by one, two, or three octal digits that are taken to specify
the value of the desired character. The escape \xhhh consists of the backslash followed by x followed by one
or more hexadecimal digits that are taken to specify the value of the desired character. There is no limit to
the number of digits in a hexadecimal sequence. A sequence of octal or hexadecimal digits is terminated by
the ﬁrst character that is not an octal digit or a hexadecimal digit, respectively. The value of a character
literal is implementation-deﬁned if it falls outside of the implementation-deﬁned range deﬁned for char (for
literals with no preﬁx) or wchar_t (for literals preﬁxed by L). [ Note: If the value of a character literal
preﬁxed by u, u8, or U is outside the range deﬁned for its type, the program is ill-formed. — end note ]

9 A universal-character-name is translated to the encoding, in the appropriate execution character set, of the

character named. If there is no such encoding, the universal-character-name is translated to an implementation-
deﬁned encoding. [ Note: In translation phase 1, a universal-character-name is introduced whenever an actual
extended character is encountered in the source text. Therefore, all extended characters are described in
terms of universal-character-names. However, the actual compiler implementation may use its own native
character set, so long as the same results are obtained. — end note ]
2.13.4 Floating literals

[lex.fcon]

ﬂoating-literal:

fractional-constant exponent-partopt ﬂoating-suﬃxopt
digit-sequence exponent-part ﬂoating-suﬃxopt

23) They are intended for character sets where a character does not ﬁt into a single byte.
24) Using an escape sequence for a question mark is supported for compatibility with ISO C++14 and ISO C.

§ 2.13.4

27

c(cid:13) ISO/IEC

N4296

fractional-constant:

digit-sequenceopt. digit-sequence
digit-sequence .

exponent-part:

e signopt digit-sequence
E signopt digit-sequence

sign: one of

+ -

digit-sequence:

digit
digit-sequence ’opt digit

ﬂoating-suﬃx: one of

f l F L

1 A ﬂoating literal consists of an integer part, a decimal point, a fraction part, an e or E, an optionally signed
integer exponent, and an optional type suﬃx. The integer and fraction parts both consist of a sequence of
decimal (base ten) digits. Optional separating single quotes in a digit-sequence are ignored when determining
its value. [ Example: The literals 1.602’176’565e-19 and 1.602176565e-19 have the same value. — end
example ] Either the integer part or the fraction part (not both) can be omitted; either the decimal point
or the letter e (or E ) and the exponent (not both) can be omitted. The integer part, the optional decimal
point and the optional fraction part form the signiﬁcant part of the ﬂoating literal. The exponent, if present,
indicates the power of 10 by which the signiﬁcant part is to be scaled. If the scaled value is in the range
of representable values for its type, the result is the scaled value if representable, else the larger or smaller
representable value nearest the scaled value, chosen in an implementation-deﬁned manner. The type of a
ﬂoating literal is double unless explicitly speciﬁed by a suﬃx. The suﬃxes f and F specify float, the suﬃxes
l and L specify long double. If the scaled value is not in the range of representable values for its type, the
program is ill-formed.
2.13.5 String literals

[lex.string]

string-literal:

encoding-preﬁxopt" s-char-sequenceopt"
encoding-preﬁxoptR raw-string

s-char-sequence:

s-char
s-char-sequence s-char

s-char:

any member of the source character set except

the double-quote ", backslash \, or new-line character

escape-sequence
universal-character-name

raw-string:

" d-char-sequenceopt( r-char-sequenceopt) d-char-sequenceopt"

r-char-sequence:

r-char
r-char-sequence r-char

r-char:

any member of the source character set, except

a right parenthesis ) followed by the initial d-char-sequence
(which may be empty) followed by a double quote ".

d-char-sequence:

d-char
d-char-sequence d-char

§ 2.13.5

28

c(cid:13) ISO/IEC

N4296

d-char:

any member of the basic source character set except:

space, the left parenthesis (, the right parenthesis ), the backslash \,
and the control characters representing horizontal tab,
vertical tab, form feed, and newline.

1 A string-literal is a sequence of characters (as deﬁned in 2.13.3) surrounded by double quotes, optionally
preﬁxed by R, u8, u8R, u, uR, U, UR, L, or LR, as in "...", R"(...)", u8"...", u8R"**(...)**", u"...",
uR"*~(...)*~", U"...", UR"zzz(...)zzz", L"...", or LR"(...)", respectively.

3

2 A string-literal that has an R in the preﬁx is a raw string literal. The d-char-sequence serves as a delimiter.
The terminating d-char-sequence of a raw-string is the same sequence of characters as the initial d-char-
sequence. A d-char-sequence shall consist of at most 16 characters.
[ Note: The characters ’(’ and ’)’ are permitted in a raw-string. Thus, R"delimiter((a|b))delimiter"
is equivalent to "(a|b)". — end note ]
[ Note: A source-ﬁle new-line in a raw string literal results in a new-line in the resulting execution string-
literal. Assuming no whitespace at the beginning of lines in the following example, the assert will succeed:

4

const char* p = R"(a\
b
c)";
assert(std::strcmp(p, "a\\\nb\nc") == 0);

— end note ]
[ Example: The raw string

5

R"a(
)\
a"
)a"

is equivalent to "\n)\\\na\"\n". The raw string

R"(??)"

is equivalent to "\?\?". The raw string

R"#(
)??="
)#"

is equivalent to "\n)\?\?=\"\n". — end example ]

6 After translation phase 6, a string-literal that does not begin with an encoding-preﬁx is an ordinary string

literal, and is initialized with the given characters.

7 A string-literal that begins with u8, such as u8"asdf", is a UTF-8 string literal.
8 Ordinary string literals and UTF-8 string literals are also referred to as narrow string literals. A narrow
string literal has type “array of n const char”, where n is the size of the string as deﬁned below, and has
static storage duration (3.7).

9 For a UTF-8 string literal, each successive element of the object representation (3.9) has the value of the

corresponding code unit of the UTF-8 encoding of the string.

10 A string-literal that begins with u, such as u"asdf", is a char16_t string literal. A char16_t string literal
has type “array of n const char16_t”, where n is the size of the string as deﬁned below; it is initialized
with the given characters. A single c-char may produce more than one char16_t character in the form of
surrogate pairs.

§ 2.13.5

29

c(cid:13) ISO/IEC

N4296

11 A string-literal that begins with U, such as U"asdf", is a char32_t string literal. A char32_t string literal
has type “array of n const char32_t”, where n is the size of the string as deﬁned below; it is initialized
with the given characters.

13

12 A string-literal that begins with L, such as L"asdf", is a wide string literal. A wide string literal has type
“array of n const wchar_t”, where n is the size of the string as deﬁned below; it is initialized with the given
characters.
In translation phase 6 (2.2), adjacent string-literal s are concatenated. If both string-literal s have the same
encoding-preﬁx, the resulting concatenated string literal has that encoding-preﬁx. If one string-literal has no
encoding-preﬁx, it is treated as a string-literal of the same encoding-preﬁx as the other operand. If a UTF-8
string literal token is adjacent to a wide string literal token, the program is ill-formed. Any other concate-
nations are conditionally-supported with implementation-deﬁned behavior.
[ Note: This concatenation is
an interpretation, not a conversion. Because the interpretation happens in translation phase 6 (after each
character from a literal has been translated into a value from the appropriate character set), a string-literal’s
initial rawness has no eﬀect on the interpretation or well-formedness of the concatenation. — end note ]
Table 7 has some examples of valid concatenations.

Source

u"a"
u"a"
"a"

u"b"
"b"
u"b"

Table 7 — String literal concatenations
Means
u"ab"
u"ab"
u"ab"

Means
U"ab"
U"ab"
U"ab"

L"a"
L"a"
"a"

Source

U"a"
U"a"
"a"

U"b"
"b"
U"b"

Source

Means
L"ab"
L"ab"
L"ab"

L"b"
"b"
L"b"

Characters in concatenated strings are kept distinct.
[ Example:

"\xA" "B"

contains the two characters ’\xA’ and ’B’ after concatenation (and not the single hexadecimal character
’\xAB’). — end example ]

14 After any necessary concatenation, in translation phase 7 (2.2), ’\0’ is appended to every string literal so

that programs that scan a string can ﬁnd its end.

15 Escape sequences and universal-character-names in non-raw string literals have the same meaning as in
character literals (2.13.3), except that the single quote ’ is representable either by itself or by the escape
sequence \’, and the double quote " shall be preceded by a \, and except that a universal-character-name
in a char16_t string literal may yield a surrogate pair. In a narrow string literal, a universal-character-
name may map to more than one char element due to multibyte encoding. The size of a char32_t or
wide string literal is the total number of escape sequences, universal-character-names, and other characters,
plus one for the terminating U’\0’ or L’\0’. The size of a char16_t string literal is the total number
of escape sequences, universal-character-names, and other characters, plus one for each character requiring
a surrogate pair, plus one for the terminating u’\0’.
[ Note: The size of a char16_t string literal is the
number of code units, not the number of characters. — end note ] Within char32_t and char16_t literals,
any universal-character-names shall be within the range 0x0 to 0x10FFFF. The size of a narrow string literal
is the total number of escape sequences and other characters, plus at least one for the multibyte encoding
of each universal-character-name, plus one for the terminating ’\0’.

16 Evaluating a string-literal results in a string literal object with static storage duration, initialized from
the given characters as speciﬁed above. Whether all string literals are distinct (that is, are stored in
nonoverlapping objects) and whether successive evaluations of a string-literal yield the same or a diﬀerent
object is unspeciﬁed. [ Note: The eﬀect of attempting to modify a string literal is undeﬁned. — end note ]

§ 2.13.5

30

c(cid:13) ISO/IEC

2.13.6 Boolean literals

N4296

[lex.bool]

boolean-literal:

false
true

1 The Boolean literals are the keywords false and true. Such literals are prvalues and have type bool.

2.13.7 Pointer literals

pointer-literal:
nullptr

[lex.nullptr]

1 The pointer literal is the keyword nullptr. It is a prvalue of type std::nullptr_t. [ Note: std::nullptr_t
is a distinct type that is neither a pointer type nor a pointer to member type; rather, a prvalue of this type is
a null pointer constant and can be converted to a null pointer value or null member pointer value. See 4.10
and 4.11. — end note ]
2.13.8 User-deﬁned literals

[lex.ext]

user-deﬁned-literal:

user-deﬁned-integer-literal
user-deﬁned-ﬂoating-literal
user-deﬁned-string-literal
user-deﬁned-character-literal

user-deﬁned-integer-literal:

decimal-literal ud-suﬃx
octal-literal ud-suﬃx
hexadecimal-literal ud-suﬃx
binary-literal ud-suﬃx
user-deﬁned-ﬂoating-literal:

fractional-constant exponent-partopt ud-suﬃx
digit-sequence exponent-part ud-suﬃx

user-deﬁned-string-literal:

string-literal ud-suﬃx
user-deﬁned-character-literal:

character-literal ud-suﬃx

ud-suﬃx:

identiﬁer

1

If a token matches both user-deﬁned-literal and another literal kind, it is treated as the latter. [ Example:
123_km is a user-deﬁned-literal, but 12LL is an integer-literal. — end example ] The syntactic non-terminal
preceding the ud-suﬃx in a user-deﬁned-literal is taken to be the longest sequence of characters that could
match that non-terminal.

2 A user-deﬁned-literal is treated as a call to a literal operator or literal operator template (13.5.8). To
determine the form of this call for a given user-deﬁned-literal L with ud-suﬃx X, the literal-operator-id
whose literal suﬃx identiﬁer is X is looked up in the context of L using the rules for unqualiﬁed name
lookup (3.4.1). Let S be the set of declarations found by this lookup. S shall not be empty.
If L is a user-deﬁned-integer-literal, let n be the literal without its ud-suﬃx. If S contains a literal operator
with parameter type unsigned long long, the literal L is treated as a call of the form

3

operator "" X (n ULL)

Otherwise, S shall contain a raw literal operator or a literal operator template (13.5.8) but not both. If S
contains a raw literal operator, the literal L is treated as a call of the form

operator "" X ("n ")

§ 2.13.8

31

c(cid:13) ISO/IEC

N4296

Otherwise (S contains a literal operator template), L is treated as a call of the form

operator "" X <’c1’, ’c2’, ... ’ck’>()

where n is the source character sequence c1c2...ck. [ Note: The sequence c1c2...ck can only contain characters
from the basic source character set. — end note ]
If L is a user-deﬁned-ﬂoating-literal, let f be the literal without its ud-suﬃx. If S contains a literal operator
with parameter type long double, the literal L is treated as a call of the form

4

operator "" X (f L)

Otherwise, S shall contain a raw literal operator or a literal operator template (13.5.8) but not both. If S
contains a raw literal operator, the literal L is treated as a call of the form

operator "" X ("f ")

Otherwise (S contains a literal operator template), L is treated as a call of the form

operator "" X <’c1’, ’c2’, ... ’ck’>()

where f is the source character sequence c1c2...ck. [ Note: The sequence c1c2...ck can only contain characters
from the basic source character set. — end note ]
If L is a user-deﬁned-string-literal, let str be the literal without its ud-suﬃx and let len be the number of
code units in str (i.e., its length excluding the terminating null character). The literal L is treated as a call
of the form

operator "" X (str , len )

If L is a user-deﬁned-character-literal, let ch be the literal without its ud-suﬃx. S shall contain a literal
operator (13.5.8) whose only parameter has the type of ch and the literal L is treated as a call of the form

5

6

operator "" X (ch )

7

[ Example:

long double operator "" _w(long double);
std::string operator "" _w(const char16_t*, std::size_t);
unsigned operator "" _w(const char*);
int main() {

1.2_w;
u"one"_w;
12_w;
"two"_w;

// calls operator "" _w(1.2L)
// calls operator "" _w(u"one", 3)
// calls operator "" _w("12")
// error: no applicable literal operator

}

}

— end example ]
In translation phase 6 (2.2), adjacent string literals are concatenated and user-deﬁned-string-literals are
considered string literals for that purpose. During concatenation, ud-suﬃxes are removed and ignored and
the concatenation process occurs as described in 2.13.5. At the end of phase 6, if a string literal is the result
of a concatenation involving at least one user-deﬁned-string-literal, all the participating user-deﬁned-string-
literals shall have the same ud-suﬃx and that suﬃx is applied to the result of the concatenation.
[ Example:

8

9

int main() {

L"A" "B" "C"_x; // OK: same as L"ABC"_x
"P"_x "Q" "R"_y;// error: two diﬀerent ud-suﬃxes

§ 2.13.8

32

c(cid:13) ISO/IEC

— end example ]

N4296

§ 2.13.8

33

c(cid:13) ISO/IEC

3 Basic concepts

N4296

[basic]

1

2

[ Note: This Clause presents the basic concepts of the C++ language. It explains the diﬀerence between an
object and a name and how they relate to the value categories for expressions. It introduces the concepts
of a declaration and a deﬁnition and presents C++’s notion of type, scope, linkage, and storage duration.
The mechanisms for starting and terminating a program are discussed. Finally, this Clause presents the
fundamental types of the language and lists the ways of constructing compound types from these. — end
note ]
[ Note: This Clause does not cover concepts that aﬀect only a single part of the language. Such concepts
are discussed in the relevant Clauses. — end note ]

3 An entity is a value, object, reference, function, enumerator, type, class member, bit-ﬁeld, template, template

specialization, namespace, parameter pack, or this.

4 A name is a use of an identiﬁer (2.10), operator-function-id (13.5), literal-operator-id (13.5.8), conversion-

function-id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1).

5 Every name that denotes an entity is introduced by a declaration. Every name that denotes a label is

introduced either by a goto statement (6.6.4) or a labeled-statement (6.1).

6 A variable is introduced by the declaration of a reference other than a non-static data member or of an

object. The variable’s name, if any, denotes the reference or object.

7 Some names denote types or templates.

In general, whenever a name is encountered it is necessary to
determine whether that name denotes one of these entities before continuing to parse the program that
contains it. The process that determines this is called name lookup (3.4).

8 Two names are the same if

(8.1)

(8.2)

(8.3)

(8.4)

(8.5)

—
—
—
—
—

they are identiﬁers composed of the same character sequence, or
they are operator-function-ids formed with the same operator, or
they are conversion-function-ids formed with the same type, or
they are template-ids that refer to the same class, function, or variable (14.4), or
they are the names of literal operators (13.5.8) formed with the same literal suﬃx identiﬁer.

9 A name used in more than one translation unit can potentially refer to the same entity in these translation

units depending on the linkage (3.5) of the name speciﬁed in each translation unit.
3.1 Declarations and deﬁnitions

[basic.def]
1 A declaration (Clause 7) may introduce one or more names into a translation unit or redeclare names
introduced by previous declarations. If so, the declaration speciﬁes the interpretation and attributes of these
names. A declaration may also have eﬀects including:

(1.1)

(1.2)

(1.3)

(1.4)

—
—
—
—

a static assertion (Clause 7),
controlling template instantiation (14.7.2),
use of attributes (Clause 7), and
nothing (in the case of an empty-declaration).

§ 3.1

34

c(cid:13) ISO/IEC

N4296

2 A declaration is a deﬁnition unless it declares a function without specifying the function’s body (8.4), it
contains the extern speciﬁer (7.1.1) or a linkage-speciﬁcation25 (7.5) and neither an initializer nor a function-
body, it declares a static data member in a class deﬁnition (9.2, 9.4), it is a class name declaration (9.1), it is
an opaque-enum-declaration (7.2), it is a template-parameter (14.1), it is a parameter-declaration (8.3.5) in a
function declarator that is not the declarator of a function-deﬁnition, or it is a typedef declaration (7.1.3),
an alias-declaration (7.1.3), a using-declaration (7.3.3), a static_assert-declaration (Clause 7), an attribute-
declaration (Clause 7), an empty-declaration (Clause 7), a using-directive (7.3.4), an explicit instantiation
declaration (14.7.2), or an explicit specialization (14.7.3) whose declaration is not a deﬁnition.
[ Example: all but one of the following are deﬁnitions:

int a;
extern const int c = 1;
int f(int x) { return x+a; }
struct S { int a; int b; };
struct X {

int x;
static int y;
X(): x(0) { }

};
int X::y = 1;
enum { up, down };
namespace N { int d; }
namespace N1 = N;
X anX;

whereas these are just declarations:

extern int a;
extern const int c;
int f(int);
struct S;
typedef int Int;
extern X anotherX;
using N::d;

// deﬁnes a
// deﬁnes c
// deﬁnes f and deﬁnes x
// deﬁnes S, S::a, and S::b
// deﬁnes X
// deﬁnes non-static data member x
// declares static data member y
// deﬁnes a constructor of X

// deﬁnes X::y
// deﬁnes up and down
// deﬁnes N and N::d
// deﬁnes N1
// deﬁnes anX

// declares a
// declares c
// declares f
// declares S
// declares Int
// declares anotherX
// declares d

3

— end example ]
[ Note: In some circumstances, C++ implementations implicitly deﬁne the default constructor (12.1), copy
constructor (12.8), move constructor (12.8), copy assignment operator (12.8), move assignment opera-
tor (12.8), or destructor (12.4) member functions. — end note ] [ Example: given

#include <string>

struct C {

std::string s;

};

// std::string is the standard library class (Clause 21)

int main() {

C a;
C b = a;
b = a;

}

the implementation will implicitly deﬁne functions to make the deﬁnition of C equivalent to
25) Appearing inside the braced-enclosed declaration-seq in a linkage-speciﬁcation does not aﬀect whether a declaration is a
deﬁnition.

§ 3.1

35

c(cid:13) ISO/IEC

N4296

struct C {

std::string s;
C() : s() { }
C(const C& x): s(x.s) { }
C(C&& x): s(static_cast<std::string&&>(x.s)) { }

// : s(std::move(x.s)) { }

C& operator=(const C& x) { s = x.s; return *this; }
C& operator=(C&& x) { s = static_cast<std::string&&>(x.s); return *this; }

// { s = std::move(x.s); return *this; }

~C() { }

};

— end example ]
[ Note: A class name can also be implicitly declared by an elaborated-type-speciﬁer (7.1.6.3). — end note ]

4
5 A program is ill-formed if the deﬁnition of any object gives the object an incomplete type (3.9).

3.2 One deﬁnition rule

[basic.def.odr]
1 No translation unit shall contain more than one deﬁnition of any variable, function, class type, enumeration

type, or template.

2 An expression is potentially evaluated unless it is an unevaluated operand (Clause 5) or a subexpression

thereof. The set of potential results of an expression e is deﬁned as follows:

(2.1)

(2.2)

(2.3)

(2.4)

(2.5)

(2.6)

(2.7)

—
—

—

—
—

—
—

If e is an id-expression (5.1.1), the set contains only e.
If e is a class member access expression (5.2.5), the set contains the potential results of the object
expression.
If e is a pointer-to-member expression (5.5) whose second operand is a constant expression, the set
contains the potential results of the object expression.
If e has the form (e1), the set contains the potential results of e1.
If e is a glvalue conditional expression (5.16), the set is the union of the sets of potential results of the
second and third operands.
If e is a comma expression (5.19), the set contains the potential results of the right operand.
Otherwise, the set is empty.

[ Note: This set is a (possibly-empty) set of id-expressions, each of which is either e or a subexpression of e.
[ Example: In the following example, the set of potential results of the initializer of n contains the ﬁrst S::x
subexpression, but not the second S::x subexpression.

struct S { static const int x = 0; };
const int &f(const int &r);
int n = b ? (1, S::x) // S::x is not odr-used here
// S::x is odr-used here, so
// a deﬁnition is required

: f(S::x);

— end example ] — end note ]

3 A variable x whose name appears as a potentially-evaluated expression ex is odr-used by ex unless applying
the lvalue-to-rvalue conversion (4.1) to x yields a constant expression (5.20) that does not invoke any non-
trivial functions and, if x is an object, ex is an element of the set of potential results of an expression e,
where either the lvalue-to-rvalue conversion (4.1) is applied to e, or e is a discarded-value expression (Clause

§ 3.2

36

c(cid:13) ISO/IEC

N4296

5). this is odr-used if it appears as a potentially-evaluated expression (including as the result of the implicit
transformation in the body of a non-static member function (9.3.1)). A virtual member function is odr-
used if it is not pure. A function whose name appears as a potentially-evaluated expression is odr-used
if it is the unique lookup result or the selected member of a set of overloaded functions (3.4, 13.3, 13.4),
unless it is a pure virtual function and either its name is not explicitly qualiﬁed or the expression forms
a pointer to member (5.3.1).
[ Note: This covers calls to named functions (5.2.2), operator overloading
(Clause 13), user-deﬁned conversions (12.3.2), allocation function for placement new (5.3.4), as well as non-
default initialization (8.5). A constructor selected to copy or move an object of class type is odr-used even if
the call is actually elided by the implementation (12.8). — end note ] An allocation or deallocation function
for a class is odr-used by a new-expression appearing in a potentially-evaluated expression as speciﬁed in 5.3.4
and 12.5. A deallocation function for a class is odr-used by a delete expression appearing in a potentially-
evaluated expression as speciﬁed in 5.3.5 and 12.5. A non-placement allocation or deallocation function for
a class is odr-used by the deﬁnition of a constructor of that class. A non-placement deallocation function for
a class is odr-used by the deﬁnition of the destructor of that class, or by being selected by the lookup at the
point of deﬁnition of a virtual destructor (12.4).26 An assignment operator function in a class is odr-used by
an implicitly-deﬁned copy-assignment or move-assignment function for another class as speciﬁed in 12.8. A
constructor for a class is odr-used as speciﬁed in 8.5. A destructor for a class is odr-used if it is potentially
invoked (12.4).

4 Every program shall contain exactly one deﬁnition of every non-inline function or variable that is odr-used
in that program; no diagnostic required. The deﬁnition can appear explicitly in the program, it can be found
in the standard or a user-deﬁned library, or (when appropriate) it is implicitly deﬁned (see 12.1, 12.4 and
12.8). An inline function shall be deﬁned in every translation unit in which it is odr-used.

5 Exactly one deﬁnition of a class is required in a translation unit if the class is used in a way that requires the
class type to be complete. [ Example: the following complete translation unit is well-formed, even though it
never deﬁnes X:

struct X;
struct X* x1;
X* x2;

// declare X as a struct type
// use X in pointer formation
// use X in pointer formation

— end example ] [ Note: The rules for declarations and expressions describe in which contexts complete class
types are required. A class type T must be complete if:

(5.1)

(5.2)

(5.3)

(5.4)

(5.5)

(5.6)

(5.7)

(5.8)

—
—
—
—
—

—

an object of type T is deﬁned (3.1), or
a non-static class data member of type T is declared (9.2), or
T is used as the object type or array element type in a new-expression (5.3.4), or
an lvalue-to-rvalue conversion is applied to a glvalue referring to an object of type T (4.1), or
an expression is converted (either implicitly or explicitly) to type T (Clause 4, 5.2.3, 5.2.7, 5.2.9, 5.4),
or
an expression that is not a null pointer constant, and has type other than cv void*, is converted to
the type pointer to T or reference to T using a standard conversion (Clause 4), a dynamic_cast (5.2.7)
or a static_cast (5.2.9), or
a class member access operator is applied to an expression of type T (5.2.5), or
the typeid operator (5.2.8) or the sizeof operator (5.3.3) is applied to an operand of type T, or

—
—
26) An implementation is not required to call allocation and deallocation functions from constructors or destructors; however,
this is a permissible implementation technique.

§ 3.2

37

c(cid:13) ISO/IEC

N4296

(5.9)

(5.10)

(5.11)

(5.12)

(5.13)

—
—
—
—
—

a function with a return type or argument type of type T is deﬁned (3.1) or called (5.2.2), or
a class with a base class of type T is deﬁned (Clause 10), or
an lvalue of type T is assigned to (5.18), or
the type T is the subject of an alignof expression (5.3.6), or
an exception-declaration has type T, reference to T, or pointer to T (15.3).

— end note ]

6 There can be more than one deﬁnition of a class type (Clause 9), enumeration type (7.2), inline function with
external linkage (7.1.2), class template (Clause 14), non-static function template (14.5.6), static data member
of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template specialization for
which some template parameters are not speciﬁed (14.7, 14.5.5) in a program provided that each deﬁnition
appears in a diﬀerent translation unit, and provided the deﬁnitions satisfy the following requirements. Given
such an entity named D deﬁned in more than one translation unit, then

(6.1)

(6.2)

(6.3)

(6.4)

(6.5)

—
—

—
—

—

(6.6)

—

each deﬁnition of D shall consist of the same sequence of tokens; and
in each deﬁnition of D, corresponding names, looked up according to 3.4, shall refer to an entity deﬁned
within the deﬁnition of D, or shall refer to the same entity, after overload resolution (13.3) and after
matching of partial template specialization (14.8.3), except that a name can refer to a non-volatile
const object with internal or no linkage if the object has the same literal type in all deﬁnitions of D,
and the object is initialized with a constant expression (5.20), and the object is not odr-used, and the
object has the same value in all deﬁnitions of D; and
in each deﬁnition of D, corresponding entities shall have the same language linkage; and
in each deﬁnition of D, the overloaded operators referred to, the implicit calls to conversion functions,
constructors, operator new functions and operator delete functions, shall refer to the same function,
or to a function deﬁned within the deﬁnition of D; and
in each deﬁnition of D, a default argument used by an (implicit or explicit) function call is treated as
if its token sequence were present in the deﬁnition of D; that is, the default argument is subject to
the three requirements described above (and, if the default argument has sub-expressions with default
arguments, this requirement applies recursively).27
if D is a class with an implicitly-declared constructor (12.1), it is as if the constructor was implicitly
deﬁned in every translation unit where it is odr-used, and the implicit deﬁnition in every translation
unit shall call the same constructor for a base class or a class member of D. [ Example:

//translation unit 1:
struct X {
X(int);
X(int, int);

};
X::X(int = 0) { }
class D: public X { };
D d2;

//translation unit 2:
struct X {
X(int);

// X(int) called by D()

27) 8.3.6 describes how default argument names are looked up.

§ 3.2

38

c(cid:13) ISO/IEC

N4296

X(int, int);

};
X::X(int = 0, int = 0) { }
class D: public X { };

— end example ]

// X(int, int) called by D();
// D()’s implicit deﬁnition
// violates the ODR

If D is a template and is deﬁned in more than one translation unit, then the preceding requirements shall
apply both to names from the template’s enclosing scope used in the template deﬁnition (14.6.3), and also to
dependent names at the point of instantiation (14.6.2). If the deﬁnitions of D satisfy all these requirements,
then the behavior is as if there were a single deﬁnition of D. If the deﬁnitions of D do not satisfy these
requirements, then the behavior is undeﬁned.
3.3 Scope
3.3.1 Declarative regions and scopes

[basic.scope]
[basic.scope.declarative]
1 Every name is introduced in some portion of program text called a declarative region, which is the largest part
of the program in which that name is valid, that is, in which that name may be used as an unqualiﬁed name
to refer to the same entity. In general, each particular name is valid only within some possibly discontiguous
portion of program text called its scope. To determine the scope of a declaration, it is sometimes convenient
to refer to the potential scope of a declaration. The scope of a declaration is the same as its potential scope
unless the potential scope contains another declaration of the same name. In that case, the potential scope
of the declaration in the inner (contained) declarative region is excluded from the scope of the declaration
in the outer (containing) declarative region.
[ Example: in
int j = 24;
int main() {

2

int i = j, j;
j = 42;

}

the identiﬁer j is declared twice as a name (and used twice). The declarative region of the ﬁrst j includes
the entire example. The potential scope of the ﬁrst j begins immediately after that j and extends to the
end of the program, but its (actual) scope excludes the text between the , and the }. The declarative region
of the second declaration of j (the j immediately before the semicolon) includes all the text between { and
}, but its potential scope excludes the declaration of i. The scope of the second declaration of j is the same
as its potential scope. — end example ]

3 The names declared by a declaration are introduced into the scope in which the declaration occurs, except
that the presence of a friend speciﬁer (11.3), certain uses of the elaborated-type-speciﬁer (7.1.6.3), and
using-directives (7.3.4) alter this general behavior.

4 Given a set of declarations in a single declarative region, each of which speciﬁes the same unqualiﬁed name,

(4.1)

(4.2)

—
—

they shall all refer to the same entity, or all refer to functions and function templates; or
exactly one declaration shall declare a class name or enumeration name that is not a typedef name
and the other declarations shall all refer to the same variable or enumerator, or all refer to functions
and function templates; in this case the class name or enumeration name is hidden (3.3.10). [ Note: A
namespace name or a class template name must be unique in its declarative region (7.3.2, Clause 14).
— end note ]

§ 3.3.1

39

c(cid:13) ISO/IEC

N4296

[ Note: These restrictions apply to the declarative region into which a name is introduced, which is not neces-
sarily the same as the region in which the declaration occurs. In particular, elaborated-type-speciﬁers (7.1.6.3)
and friend declarations (11.3) may introduce a (possibly not visible) name into an enclosing namespace; these
restrictions apply to that region. Local extern declarations (3.5) may introduce a name into the declarative
region where the declaration appears and also introduce a (possibly not visible) name into an enclosing
namespace; these restrictions apply to both regions. — end note ]
[ Note: The name lookup rules are summarized in 3.4. — end note ]
3.3.2 Point of declaration

[basic.scope.pdecl]
1 The point of declaration for a name is immediately after its complete declarator (Clause 8) and before its

5

initializer (if any), except as noted below. [ Example:

unsigned char x = 12;
{ unsigned char x = x; }

2

Here the second x is initialized with its own (indeterminate) value. — end example ]
[ Note: a name from an outer scope remains visible up to the point of declaration of the name that hides
it.[ Example:
const int
{ int

i[i]; }

i = 2;

declares a block-scope array of two integers. — end example ] — end note ]

3 The point of declaration for a class or class template ﬁrst declared by a class-speciﬁer is immediately
after the identiﬁer or simple-template-id (if any) in its class-head (Clause 9). The point of declaration
for an enumeration is immediately after the identiﬁer (if any) in either its enum-speciﬁer (7.2) or its ﬁrst
opaque-enum-declaration (7.2), whichever comes ﬁrst. The point of declaration of an alias or alias template
immediately follows the type-id to which the alias refers.

4 The point of declaration of a using-declaration that does not name a constructor is immediately after the

using-declaration (7.3.3).

5 The point of declaration for an enumerator is immediately after its enumerator-deﬁnition.[ Example:

const int x = 12;
{ enum { x = x }; }

Here, the enumerator x is initialized with the value of the constant x, namely 12. — end example ]

6 After the point of declaration of a class member, the member name can be looked up in the scope of its

class. [ Note: this is true even if the class is an incomplete class. For example,

struct X {

};

enum E { z = 16 };
int b[X::z];

// OK

— end note ]

7 The point of declaration of a class ﬁrst declared in an elaborated-type-speciﬁer is as follows:

(7.1)

—

for a declaration of the form

class-key attribute-speciﬁer-seqopt identiﬁer ;

the identiﬁer is declared to be a class-name in the scope that contains the declaration, otherwise

§ 3.3.2

40

c(cid:13) ISO/IEC

N4296

(7.2)

—

for an elaborated-type-speciﬁer of the form

class-key identiﬁer

if the elaborated-type-speciﬁer is used in the decl-speciﬁer-seq or parameter-declaration-clause of a
function deﬁned in namespace scope, the identiﬁer is declared as a class-name in the namespace that
contains the declaration; otherwise, except as a friend declaration, the identiﬁer is declared in the
smallest namespace or block scope that contains the declaration. [ Note: These rules also apply within
templates. — end note ] [ Note: Other forms of elaborated-type-speciﬁer do not declare a new name,
and therefore must refer to an existing type-name. See 3.4.4 and 7.1.6.3. — end note ]

8 The point of declaration for an injected-class-name (Clause 9) is immediately following the opening brace of

the class deﬁnition.

9 The point of declaration for a function-local predeﬁned variable (8.4) is immediately before the function-body

of a function deﬁnition.

10 The point of declaration for a template parameter is immediately after its complete template-parameter.

[ Example:

typedef unsigned char T;
template<class T

N = 0> struct A { };

= T
, T

// lookup ﬁnds the typedef name of unsigned char
// lookup ﬁnds the template parameter

11

12

— end example ]
[ Note: Friend declarations refer to functions or classes that are members of the nearest enclosing namespace,
but they do not introduce new names into that namespace (7.3.1.2). Function declarations at block scope
and variable declarations with the extern speciﬁer at block scope refer to declarations that are members of
an enclosing namespace, but they do not introduce new names into that scope. — end note ]
[ Note: For point of instantiation of a template, see 14.6.4.1. — end note ]
3.3.3 Block scope

[basic.scope.block]
1 A name declared in a block (6.3) is local to that block; it has block scope. Its potential scope begins at its
point of declaration (3.3.2) and ends at the end of its block. A variable declared at block scope is a local
variable.

2 The potential scope of a function parameter name (including one appearing in a lambda-declarator) or of
a function-local predeﬁned variable in a function deﬁnition (8.4) begins at its point of declaration. If the
function has a function-try-block the potential scope of a parameter or of a function-local predeﬁned variable
ends at the end of the last associated handler, otherwise it ends at the end of the outermost block of
the function deﬁnition. A parameter name shall not be redeclared in the outermost block of the function
deﬁnition nor in the outermost block of any handler associated with a function-try-block.

3 The name declared in an exception-declaration is local to the handler and shall not be redeclared in the

outermost block of the handler.

4 Names declared in the for-init-statement, the for-range-declaration, and in the condition of if, while, for,
and switch statements are local to the if, while, for, or switch statement (including the controlled
statement), and shall not be redeclared in a subsequent condition of that statement nor in the outermost
block (or, for the if statement, any of the outermost blocks) of the controlled statement; see 6.4.
3.3.4 Function prototype scope
[basic.scope.proto]
In a function declaration, or in any function declarator except the declarator of a function deﬁnition (8.4),
names of parameters (if supplied) have function prototype scope, which terminates at the end of the nearest

1

§ 3.3.4

41

c(cid:13) ISO/IEC

N4296

[basic.funscope]
1 Labels (6.1) have function scope and may be used anywhere in the function in which they are declared. Only

enclosing function declarator.
3.3.5 Function scope

labels have function scope.
3.3.6 Namespace scope

[basic.scope.namespace]
1 The declarative region of a namespace-deﬁnition is its namespace-body. Entities declared in a namespace-body
are said to be members of the namespace, and names introduced by these declarations into the declarative
region of the namespace are said to be member names of the namespace. A namespace member name has
namespace scope. Its potential scope includes its namespace from the name’s point of declaration (3.3.2)
onwards; and for each using-directive (7.3.4) that nominates the member’s namespace, the member’s potential
scope includes that portion of the potential scope of the using-directive that follows the member’s point of
declaration. [ Example:

namespace N {

int i;
int g(int a) { return a; }
int j();
void q();

}
namespace { int l=1; }
// the potential scope of l is from its point of declaration
// to the end of the translation unit

namespace N {

int g(char a) {

return l+a;

}

// overloads N::g(int)
// l is from unnamed namespace

int i;
int j();

// error: duplicate deﬁnition
// OK: duplicate function declaration

int j() {

return g(i);

}
int q();

// OK: deﬁnition of N::j()
// calls N::g(int)

// error: diﬀerent return type

}

— end example ]

2 A namespace member can also be referred to after the :: scope resolution operator (5.1) applied to the name
of its namespace or the name of a namespace which nominates the member’s namespace in a using-directive;
see 3.4.3.2.

3 The outermost declarative region of a translation unit is also a namespace, called the global namespace. A
name declared in the global namespace has global namespace scope (also called global scope). The potential
scope of such a name begins at its point of declaration (3.3.2) and ends at the end of the translation unit
that is its declarative region. A name with global namespace scope is said to be a global name.
3.3.7 Class scope

[basic.scope.class]

1 The following rules describe the scope of names declared in classes.

1) The potential scope of a name declared in a class consists not only of the declarative region following the
name’s point of declaration, but also of all function bodies, default arguments, exception-speciﬁcations,

§ 3.3.7

42

c(cid:13) ISO/IEC

N4296

and brace-or-equal-initializers of non-static data members in that class (including such things in nested
classes).

2) A name N used in a class S shall refer to the same declaration in its context and when re-evaluated in

the completed scope of S. No diagnostic is required for a violation of this rule.

3) If reordering member declarations in a class yields an alternate valid program under (1) and (2), the

program is ill-formed, no diagnostic is required.

4) A name declared within a member function hides a declaration of the same name whose scope extends

to or past the end of the member function’s class.

5) The potential scope of a declaration that extends to or past the end of a class deﬁnition also extends
to the regions deﬁned by its member deﬁnitions, even if the members are deﬁned lexically outside
the class (this includes static data member deﬁnitions, nested class deﬁnitions, and member func-
tion deﬁnitions, including the member function body and any portion of the declarator part of such
deﬁnitions which follows the declarator-id, including a parameter-declaration-clause and any default
arguments (8.3.6)).[ Example:

typedef int
c;
enum { i = 1 };

class X {

char

v[i];

int f() { return sizeof(c); }
char
enum { i = 2 };

c;

};

typedef char*
struct Y {

T

a;

T;

typedef long
T

b;

T;

};

typedef int I;
class D {

typedef I I;

};

// error: i refers to ::i
// but when reevaluated is X::i
// OK: X::c

// error: T refers to ::T
// but when reevaluated is Y::T

// error, even though no reordering involved

— end example ]

2 The name of a class member shall only be used as follows:

(2.1)

(2.2)

(2.3)

(2.4)

—
—

—

—

in the scope of its class (as described above) or a class derived (Clause 10) from its class,
after the . operator applied to an expression of the type of its class (5.2.5) or a class derived from its
class,
after the -> operator applied to a pointer to an object of its class (5.2.5) or a class derived from its
class,
after the :: scope resolution operator (5.1) applied to the name of its class or a class derived from its
class.

§ 3.3.7

43

c(cid:13) ISO/IEC

N4296

3.3.8 Enumeration scope

[basic.scope.enum]
1 The name of a scoped enumerator (7.2) has enumeration scope. Its potential scope begins at its point of

declaration and terminates at the end of the enum-speciﬁer.
3.3.9 Template parameter scope

[basic.scope.temp]
1 The declarative region of the name of a template parameter of a template template-parameter is the smallest

template-parameter-list in which the name was introduced.

2 The declarative region of the name of a template parameter of a template is the smallest template-declaration
in which the name was introduced. Only template parameter names belong to this declarative region; any
other kind of name introduced by the declaration of a template-declaration is instead introduced into the
same declarative region where it would be introduced as a result of a non-template declaration of the same
name. [ Example:
namespace N {

template<class T> struct A { };
template<class U> void f(U) { }
struct B {

template<class V> friend int g(struct C*); // #3

// #1
// #2

};

}

The declarative regions of T, U and V are the template-declarations on lines #1, #2 and #3, respectively.
But the names A, f, g and C all belong to the same declarative region — namely, the namespace-body of
N. (g is still considered to belong to this declarative region in spite of its being hidden during qualiﬁed and
unqualiﬁed name lookup.) — end example ]

3 The potential scope of a template parameter name begins at its point of declaration (3.3.2) and ends at the
end of its declarative region. [ Note: This implies that a template-parameter can be used in the declaration
of subsequent template-parameters and their default arguments but cannot be used in preceding template-
parameters or their default arguments. For example,

template<class T, T* p, class U = T> class X { /∗ ... ∗/ };
template<class T> void f(T* p = new T);

This also implies that a template-parameter can be used in the speciﬁcation of base classes. For example,

template<class T> class X : public Array<T> { /∗ ... ∗/ };
template<class T> class Y : public T { /∗ ... ∗/ };

The use of a template parameter as a base class implies that a class used as a template argument must be
deﬁned and not just declared when the class template is instantiated. — end note ]

4 The declarative region of the name of a template parameter is nested within the immediately-enclosing
[ Note: As a result, a template-parameter hides any entity with the same name in an

declarative region.
enclosing scope (3.3.10). [ Example:

typedef int N;
template<N X, typename N, template<N Y> class T> struct A;

5

Here, X is a non-type template parameter of type int and Y is a non-type template parameter of the same
type as the second template parameter of A. — end example ] — end note ]
[ Note: Because the name of a template parameter cannot be redeclared within its potential scope (14.6.1), a
template parameter’s scope is often its potential scope. However, it is still possible for a template parameter
name to be hidden; see 14.6.1. — end note ]

§ 3.3.9

44

c(cid:13) ISO/IEC

N4296

3.3.10 Name hiding

[basic.scope.hiding]
1 A name can be hidden by an explicit declaration of that same name in a nested declarative region or derived

class (10.2).

2 A class name (9.1) or enumeration name (7.2) can be hidden by the name of a variable, data member,
function, or enumerator declared in the same scope. If a class or enumeration name and a variable, data
member, function, or enumerator are declared in the same scope (in any order) with the same name, the
class or enumeration name is hidden wherever the variable, data member, function, or enumerator name is
visible.
In a member function deﬁnition, the declaration of a name at block scope hides the declaration of a member
of the class with the same name; see 3.3.7. The declaration of a member in a derived class (Clause 10) hides
the declaration of a member of a base class of the same name; see 10.2.

3

5

4 During the lookup of a name qualiﬁed by a namespace name, declarations that would otherwise be made
visible by a using-directive can be hidden by declarations with the same name in the namespace containing
the using-directive; see (3.4.3.2).
If a name is in scope and is not hidden it is said to be visible.
3.4 Name lookup

[basic.lookup]
1 The name lookup rules apply uniformly to all names (including typedef-names (7.1.3), namespace-names (7.3),
and class-names (9.1)) wherever the grammar allows such names in the context discussed by a particular
rule. Name lookup associates the use of a name with a declaration (3.1) of that name. Name lookup shall
ﬁnd an unambiguous declaration for the name (see 10.2). Name lookup may associate more than one dec-
laration with a name if it ﬁnds the name to be a function name; the declarations are said to form a set
of overloaded functions (13.1). Overload resolution (13.3) takes place after name lookup has succeeded.
The access rules (Clause 11) are considered only once name lookup and function overload resolution (if
applicable) have succeeded. Only after name lookup, function overload resolution (if applicable) and access
checking have succeeded are the attributes introduced by the name’s declaration used further in expression
processing (Clause 5).

2 A name “looked up in the context of an expression” is looked up as an unqualiﬁed name in the scope where

the expression is found.

3 The injected-class-name of a class (Clause 9) is also considered to be a member of that class for the purposes

of name hiding and lookup.
[ Note: 3.5 discusses linkage issues. The notions of scope, point of declaration and name hiding are discussed
in 3.3. — end note ]
3.4.1 Unqualiﬁed name lookup
[basic.lookup.unqual]
In all the cases listed in 3.4.1, the scopes are searched for a declaration in the order listed in each of the
respective categories; name lookup ends as soon as a declaration is found for the name. If no declaration is
found, the program is ill-formed.

4

1

2 The declarations from the namespace nominated by a using-directive become visible in a namespace enclosing
the using-directive; see 7.3.4. For the purpose of the unqualiﬁed name lookup rules described in 3.4.1, the
declarations from the namespace nominated by the using-directive are considered members of that enclosing
namespace.

3 The lookup for an unqualiﬁed name used as the postﬁx-expression of a function call is described in 3.4.2.
[ Note: For purposes of determining (during parsing) whether an expression is a postﬁx-expression for a func-
tion call, the usual name lookup rules apply. The rules in 3.4.2 have no eﬀect on the syntactic interpretation
of an expression. For example,

typedef int f;

§ 3.4.1

45

c(cid:13) ISO/IEC

N4296

namespace N {
struct A {

friend void f(A &);
operator int();
void g(A a) {

int i = f(a);

}

};

}

// f is the typedef, not the friend
// function: equivalent to int(a)

Because the expression is not a function call, the argument-dependent name lookup (3.4.2) does not apply
and the friend function f is not found. — end note ]

4 A name used in global scope, outside of any function, class or user-declared namespace, shall be declared

before its use in global scope.

5 A name used in a user-declared namespace outside of the deﬁnition of any function or class shall be declared

before its use in that namespace or before its use in a namespace enclosing its namespace.

6 A name used in the deﬁnition of a function following the function’s declarator-id28 that is a member of
namespace N (where, only for the purpose of exposition, N could represent the global scope) shall be declared
before its use in the block in which it is used or in one of its enclosing blocks (6.3) or, shall be declared
before its use in namespace N or, if N is a nested namespace, shall be declared before its use in one of N’s
enclosing namespaces. [ Example:

namespace A {

namespace N {

void f();

}

}
void A::N::f() {

i = 5;
// The following scopes are searched for a declaration of i:
// 1) outermost block scope of A::N::f, before the use of i
// 2) scope of namespace N
// 3) scope of namespace A
// 4) global scope, before the deﬁnition of A::N::f

}

— end example ]

7 A name used in the deﬁnition of a class X outside of a member function body, default argument, exception-
speciﬁcation, brace-or-equal-initializer of a non-static data member, or nested class deﬁnition29 shall be
declared in one of the following ways:

(7.1)

(7.2)

—
—

before its use in class X or be a member of a base class of X (10.2), or
if X is a nested class of class Y (9.7), before the deﬁnition of X in Y, or shall be a member of a base
class of Y (this lookup applies in turn to Y ’s enclosing classes, starting with the innermost enclosing
class),30 or

28) This refers to unqualiﬁed names that occur, for instance, in a type or default argument in the parameter-declaration-clause
or used in the function body.
29) This refers to unqualiﬁed names following the class name; such a name may be used in the base-clause or may be used in
the class deﬁnition.
30) This lookup applies whether the deﬁnition of X is nested within Y’s deﬁnition or whether X’s deﬁnition appears in a
namespace scope enclosing Y ’s deﬁnition (9.7).

§ 3.4.1

46

c(cid:13) ISO/IEC

N4296

(7.3)

(7.4)

—

—

if X is a local class (9.8) or is a nested class of a local class, before the deﬁnition of class X in a block
enclosing the deﬁnition of class X, or
if X is a member of namespace N, or is a nested class of a class that is a member of N, or is a local class
or a nested class within a local class of a function that is a member of N, before the deﬁnition of class
X in namespace N or in one of N ’s enclosing namespaces.

[ Example:

namespace M {
class B { };

}

namespace N {

class Y : public M::B {

class X {

int a[i];

};

};

}

// The following scopes are searched for a declaration of i:
// 1) scope of class N::Y::X, before the use of i
// 2) scope of class N::Y, before the deﬁnition of N::Y::X
// 3) scope of N::Y’s base class M::B
// 4) scope of namespace N, before the deﬁnition of N::Y
// 5) global scope, before the deﬁnition of N

— end example ] [ Note: When looking for a prior declaration of a class or function introduced by a friend
declaration, scopes outside of the innermost enclosing namespace scope are not considered; see 7.3.1.2. —
end note ] [ Note: 3.3.7 further describes the restrictions on the use of names in a class deﬁnition. 9.7 further
describes the restrictions on the use of names in nested class deﬁnitions. 9.8 further describes the restrictions
on the use of names in local class deﬁnitions. — end note ]

8 For the members of a class X, a name used in a member function body, in a default argument, in an exception-
speciﬁcation, in the brace-or-equal-initializer of a non-static data member (9.2), or in the deﬁnition of a class
member outside of the deﬁnition of X, following the member’s declarator-id31, shall be declared in one of the
following ways:

(8.1)

(8.2)

(8.3)

(8.4)

(8.5)

—
—
—

—

—

before its use in the block in which it is used or in an enclosing block (6.3), or
shall be a member of class X or be a member of a base class of X (10.2), or
if X is a nested class of class Y (9.7), shall be a member of Y, or shall be a member of a base class of Y
(this lookup applies in turn to Y’s enclosing classes, starting with the innermost enclosing class),32 or
if X is a local class (9.8) or is a nested class of a local class, before the deﬁnition of class X in a block
enclosing the deﬁnition of class X, or
if X is a member of namespace N, or is a nested class of a class that is a member of N, or is a local class
or a nested class within a local class of a function that is a member of N, before the use of the name,
in namespace N or in one of N ’s enclosing namespaces.

31) That is, an unqualiﬁed name that occurs, for instance, in a type in the parameter-declaration-clause or in the exception-
speciﬁcation.
32) This lookup applies whether the member function is deﬁned within the deﬁnition of class X or whether the member function
is deﬁned in a namespace scope enclosing X’s deﬁnition.

§ 3.4.1

47

c(cid:13) ISO/IEC

[ Example:

N4296

class B { };
namespace M {

namespace N {

class X : public B {

void f();

};

}

}
void M::N::X::f() {

i = 16;

}

// The following scopes are searched for a declaration of i:
// 1) outermost block scope of M::N::X::f, before the use of i
// 2) scope of class M::N::X
// 3) scope of M::N::X’s base class B
// 4) scope of namespace M::N
// 5) scope of namespace M
// 6) global scope, before the deﬁnition of M::N::X::f

— end example ] [ Note: 9.3 and 9.4 further describe the restrictions on the use of names in member function
deﬁnitions. 9.7 further describes the restrictions on the use of names in the scope of nested classes. 9.8
further describes the restrictions on the use of names in local class deﬁnitions. — end note ]

9 Name lookup for a name used in the deﬁnition of a friend function (11.3) deﬁned inline in the class granting
friendship shall proceed as described for lookup in member function deﬁnitions. If the friend function is
not deﬁned in the class granting friendship, name lookup in the friend function deﬁnition shall proceed as
described for lookup in namespace member function deﬁnitions.
In a friend declaration naming a member function, a name used in the function declarator and not part of a
template-argument in the declarator-id is ﬁrst looked up in the scope of the member function’s class (10.2). If
it is not found, or if the name is part of a template-argument in the declarator-id, the look up is as described
for unqualiﬁed names in the deﬁnition of the class granting friendship. [ Example:

10

struct A {

typedef int AT;
void f1(AT);
void f2(float);
template <class T> void f3();

};
struct B {

typedef char AT;
typedef float BT;
friend void A::f1(AT);
friend void A::f2(BT);
friend void A::f3<AT>();

};

// parameter type is A::AT
// parameter type is B::BT
// template argument is B::AT

— end example ]

11 During the lookup for a name used as a default argument (8.3.6) in a function parameter-declaration-clause
or used in the expression of a mem-initializer for a constructor (12.6.2), the function parameter names are
visible and hide the names of entities declared in the block, class or namespace scopes containing the function
declaration. [ Note: 8.3.6 further describes the restrictions on the use of names in default arguments. 12.6.2
further describes the restrictions on the use of names in a ctor-initializer. — end note ]

§ 3.4.1

48

c(cid:13) ISO/IEC

N4296

12 During the lookup of a name used in the constant-expression of an enumerator-deﬁnition, previously declared
enumerators of the enumeration are visible and hide the names of entities declared in the block, class, or
namespace scopes containing the enum-speciﬁer.

13 A name used in the deﬁnition of a static data member of class X (9.4.2) (after the qualiﬁed-id of the static
member) is looked up as if the name was used in a member function of X. [ Note: 9.4.2 further describes the
restrictions on the use of names in the deﬁnition of a static data member. — end note ]
If a variable member of a namespace is deﬁned outside of the scope of its namespace then any name that
appears in the deﬁnition of the member (after the declarator-id) is looked up as if the deﬁnition of the
member occurred in its namespace. [ Example:

14

namespace N {
int i = 4;
extern int j;

}

int i = 2;

int N::j = i;

— end example ]

// N::j == 4

16

15 A name used in the handler for a function-try-block (Clause 15) is looked up as if the name was used in
the outermost block of the function deﬁnition. In particular, the function parameter names shall not be
redeclared in the exception-declaration nor in the outermost block of a handler for the function-try-block.
Names declared in the outermost block of the function deﬁnition are not found when looked up in the scope
of a handler for the function-try-block. [ Note: But function parameter names are found. — end note ]
[ Note: The rules for name lookup in template deﬁnitions are described in 14.6. — end note ]
3.4.2 Argument-dependent name lookup

[basic.lookup.argdep]
1 When the postﬁx-expression in a function call (5.2.2) is an unqualiﬁed-id, other namespaces not considered
during the usual unqualiﬁed lookup (3.4.1) may be searched, and in those namespaces, namespace-scope
friend function or function template declarations (11.3) not otherwise visible may be found. These mod-
iﬁcations to the search depend on the types of the arguments (and for template template arguments, the
namespace of the template argument). [ Example:

namespace N {

struct S { };
void f(S);

}

void g() {
N::S s;
f(s);
(f)(s);

}

— end example ]

// OK: calls N::f
// error: N::f not considered; parentheses
// prevent argument-dependent lookup

2 For each argument type T in the function call, there is a set of zero or more associated namespaces and a
set of zero or more associated classes to be considered. The sets of namespaces and classes is determined
entirely by the types of the function arguments (and the namespace of any template template argument).
Typedef names and using-declarations used to specify the types do not contribute to this set. The sets of
namespaces and classes are determined in the following way:

§ 3.4.2

49

c(cid:13) ISO/IEC

N4296

(2.1)

(2.2)

—
—

(2.3)

(2.4)

(2.5)

(2.6)

(2.7)

—

—

—

—

—

If T is a fundamental type, its associated sets of namespaces and classes are both empty.
If T is a class type (including unions), its associated classes are: the class itself; the class of which it is
a member, if any; and its direct and indirect base classes. Its associated namespaces are the innermost
enclosing namespaces of its associated classes. Furthermore, if T is a class template specialization,
its associated namespaces and classes also include: the namespaces and classes associated with the
types of the template arguments provided for template type parameters (excluding template template
parameters); the namespaces of which any template template arguments are members; and the classes
of which any member templates used as template template arguments are members. [ Note: Non-type
template arguments do not contribute to the set of associated namespaces. — end note ]
If T is an enumeration type, its associated namespace is the innermost enclosing namespace of its
declaration. If it is a class member, its associated class is the member’s class; else it has no associated
class.
If T is a pointer to U or an array of U, its associated namespaces and classes are those associated with
U.
If T is a function type, its associated namespaces and classes are those associated with the function
parameter types and those associated with the return type.
If T is a pointer to a member function of a class X, its associated namespaces and classes are those
associated with the function parameter types and return type, together with those associated with X.
If T is a pointer to a data member of class X, its associated namespaces and classes are those associated
with the member type together with those associated with X.

If an associated namespace is an inline namespace (7.3.1), its enclosing namespace is also included in the set.
If an associated namespace directly contains inline namespaces, those inline namespaces are also included in
the set. In addition, if the argument is the name or address of a set of overloaded functions and/or function
templates, its associated classes and namespaces are the union of those associated with each of the members of
the set, i.e., the classes and namespaces associated with its parameter types and return type. Additionally,
if the aforementioned set of overloaded functions is named with a template-id, its associated classes and
namespaces also include those of its type template-arguments and its template template-arguments.

3 Let X be the lookup set produced by unqualiﬁed lookup (3.4.1) and let Y be the lookup set produced by

argument dependent lookup (deﬁned as follows). If X contains

(3.1)

(3.2)

(3.3)

—
—
—

a declaration of a class member, or
a block-scope function declaration that is not a using-declaration, or
a declaration that is neither a function or a function template

then Y is empty. Otherwise Y is the set of declarations found in the namespaces associated with the
argument types as described below. The set of declarations found by the lookup of the name is the union of
X and Y . [ Note: The namespaces and classes associated with the argument types can include namespaces
and classes already considered by the ordinary unqualiﬁed lookup. — end note ] [ Example:

namespace NS {
class T { };
void f(T);
void g(T, int);

}
NS::T parm;
void g(NS::T, float);

§ 3.4.2

50

c(cid:13) ISO/IEC

N4296

int main() {

f(parm);
extern void g(NS::T, float);
g(parm, 1);

// OK: calls NS::f

// OK: calls g(NS::T, float)

}

— end example ]

4 When considering an associated namespace, the lookup is the same as the lookup performed when the

associated namespace is used as a qualiﬁer (3.4.3.2) except that:

(4.1)

(4.2)

(4.3)

—
—

—

Any using-directives in the associated namespace are ignored.
Any namespace-scope friend functions or friend function templates declared in associated classes are
visible within their respective namespaces even if they are not visible during an ordinary lookup (11.3).
All names except those of (possibly overloaded) functions and function templates are ignored.

3.4.3 Qualiﬁed name lookup

[basic.lookup.qual]
1 The name of a class or namespace member or enumerator can be referred to after the :: scope resolution
operator (5.1) applied to a nested-name-speciﬁer that denotes its class, namespace, or enumeration. If a ::
scope resolution operator in a nested-name-speciﬁer is not preceded by a decltype-speciﬁer, lookup of the
name preceding that :: considers only namespaces, types, and templates whose specializations are types.
If the name found does not designate a namespace or a class, enumeration, or dependent type, the program
is ill-formed.[ Example:

class A {
public:

static int n;

};
int main() {

int A;
A::n = 42;
A b;

}

// OK
// ill-formed: A does not name a type

2

3

— end example ]
[ Note: Multiply qualiﬁed names, such as N1::N2::N3::n, can be used to refer to members of nested
classes (9.7) or members of nested namespaces. — end note ]
In a declaration in which the declarator-id is a qualiﬁed-id, names used before the qualiﬁed-id being declared
are looked up in the deﬁning namespace scope; names following the qualiﬁed-id are looked up in the scope
of the member’s class or namespace. [ Example:

class X { };
class C {

class X { };
static const int number = 50;
static X arr[number];

};
X C::arr[number];

// ill-formed:
// equivalent to: ::X C::arr[C::number];
// not to: C::X C::arr[C::number];

— end example ]

§ 3.4.3

51

c(cid:13) ISO/IEC

N4296

4 A name preﬁxed by the unary scope operator :: (5.1) is looked up in global scope, in the translation unit
where it is used. The name shall be declared in global namespace scope or shall be a name whose declaration
is visible in global scope because of a using-directive (3.4.3.2). The use of :: allows a global name to be
referred to even if its identiﬁer has been hidden (3.3.10).

5 A name preﬁxed by a nested-name-speciﬁer that nominates an enumeration type shall represent an enumer-

ator of that enumeration.
If a pseudo-destructor-name (5.2.4) contains a nested-name-speciﬁer, the type-names are looked up as types
in the scope designated by the nested-name-speciﬁer. Similarly, in a qualiﬁed-id of the form:

6

nested-name-speciﬁeropt class-name :: ~ class-name

the second class-name is looked up in the same scope as the ﬁrst. [ Example:

struct C {

typedef int I;

};
typedef int I1, I2;
extern int* p;
extern int* q;
p->C::I::~I();
q->I1::~I2();

struct A {

~A();

};
typedef A AB;
int main() {

AB* p;
p->AB::~AB();

}

// I is looked up in the scope of C
// I2 is looked up in the scope of
// the postﬁx-expression

// explicitly calls the destructor for A

— end example ] [ Note: 3.4.5 describes how name lookup proceeds after the . and -> operators. — end
note ]
3.4.3.1 Class members
[class.qual]
If the nested-name-speciﬁer of a qualiﬁed-id nominates a class, the name speciﬁed after the nested-name-
speciﬁer is looked up in the scope of the class (10.2), except for the cases listed below. The name shall
represent one or more members of that class or of one of its base classes (Clause 10). [ Note: A class member
can be referred to using a qualiﬁed-id at any point in its potential scope (3.3.7). — end note ] The exceptions
to the name lookup rule above are the following:

—
—

—

—

a destructor name is looked up as speciﬁed in 3.4.3;
a conversion-type-id of a conversion-function-id is looked up in the same manner as a conversion-type-id
in a class member access (see 3.4.5);
the names in a template-argument of a template-id are looked up in the context in which the entire
postﬁx-expression occurs.
the lookup for a name speciﬁed in a using-declaration (7.3.3) also ﬁnds class or enumeration names
hidden within the same scope (3.3.10).

In a lookup in which function names are not ignored33 and the nested-name-speciﬁer nominates a class C:
33) Lookups in which function names are ignored include names appearing in a nested-name-speciﬁer, an elaborated-type-
speciﬁer, or a base-speciﬁer.

1

(1.1)

(1.2)

(1.3)

(1.4)

2

§ 3.4.3.1

52

c(cid:13) ISO/IEC

N4296

(2.1)

(2.2)

—

—

if the name speciﬁed after the nested-name-speciﬁer, when looked up in C, is the injected-class-name
of C (Clause 9), or
in a using-declaration (7.3.3) that is a member-declaration, if the name speciﬁed after the nested-name-
speciﬁer is the same as the identiﬁer or the simple-template-id’s template-name in the last component
of the nested-name-speciﬁer,

the name is instead considered to name the constructor of class C. [ Note: For example, the constructor is
not an acceptable lookup result in an elaborated-type-speciﬁer so the constructor would not be used in place
of the injected-class-name. — end note ] Such a constructor name shall be used only in the declarator-id of
a declaration that names a constructor or in a using-declaration. [ Example:

struct A { A(); };
struct B: public A { B(); };

A::A() { }
B::B() { }

B::A ba;
A::A a;
struct A::A a2;

// object of type A
// error, A::A is not a type name
// object of type A

— end example ]

3 A class member name hidden by a name in a nested declarative region or by the name of a derived class

member can still be found if qualiﬁed by the name of its class followed by the :: operator.
3.4.3.2 Namespace members
[namespace.qual]
If the nested-name-speciﬁer of a qualiﬁed-id nominates a namespace (including the case where the nested-
name-speciﬁer is ::, i.e., nominating the global namespace), the name speciﬁed after the nested-name-
speciﬁer is looked up in the scope of the namespace. The names in a template-argument of a template-id are
looked up in the context in which the entire postﬁx-expression occurs.

1

2 For a namespace X and name m, the namespace-qualiﬁed lookup set S(X, m) is deﬁned as follows: Let
S0(X, m) be the set of all declarations of m in X and the inline namespace set of X (7.3.1). If S0(X, m) is not
empty, S(X, m) is S0(X, m); otherwise, S(X, m) is the union of S(Ni, m) for all namespaces Ni nominated
by using-directives in X and its inline namespace set.

3 Given X::m (where X is a user-declared namespace), or given ::m (where X is the global namespace), if
S(X, m) is the empty set, the program is ill-formed. Otherwise, if S(X, m) has exactly one member, or if
the context of the reference is a using-declaration (7.3.3), S(X, m) is the required set of declarations of m.
Otherwise if the use of m is not one that allows a unique declaration to be chosen from S(X, m), the program
is ill-formed. [ Example:

int x;
namespace Y {

void f(float);
void h(int);

}

}

namespace Z {

void h(double);

namespace A {

using namespace Y;
void f(int);

§ 3.4.3.2

53

c(cid:13) ISO/IEC

void g(int);
int i;

}

N4296

namespace B {

using namespace Z;
void f(char);
int i;

namespace AB {

using namespace A;
using namespace B;
void g();

}

}

}

}

void h()
{

AB::g();

AB::f(1);

AB::f(’c’);

AB::x++;

AB::i++;

AB::h(16.8);

}

// g is declared directly in AB,
// therefore S is { AB::g() } and AB::g() is chosen
// f is not declared directly in AB so the rules are
// applied recursively to A and B;
// namespace Y is not searched and Y::f(float)
// is not considered;
// S is { A::f(int), B::f(char) } and overload
// resolution chooses A::f(int)
// as above but resolution chooses B::f(char)

// x is not declared directly in AB, and
// is not declared in A or B , so the rules are
// applied recursively to Y and Z,
// S is { } so the program is ill-formed
// i is not declared directly in AB so the rules are
// applied recursively to A and B,
// S is { A::i , B::i } so the use is ambiguous
// and the program is ill-formed
// h is not declared directly in AB and
// not declared directly in A or B so the rules are
// applied recursively to Y and Z,
// S is { Y::h(int), Z::h(double) } and overload
// resolution chooses Z::h(double)

4 The same declaration found more than once is not an ambiguity (because it is still a unique declaration).

For example:

namespace A {

int a;

namespace B {

using namespace A;

namespace C {

using namespace A;

§ 3.4.3.2

54

c(cid:13) ISO/IEC

}

N4296

// OK: S is { A::a, A::a }

namespace BC {

using namespace B;
using namespace C;

void f()
{

BC::a++;

namespace D {
using A::a;

}

namespace BD {

using namespace B;
using namespace D;

void g()
{

BD::a++;

namespace B {

int b;

namespace A {

using namespace B;
int a;

namespace B {

using namespace A;

void f()
{

A::a++;
B::a++;
A::b++;
B::b++;

}

}

}

}

}

}

}

}

// OK: S is { A::a, A::a }

5 Because each referenced namespace is searched at most once, the following is well-deﬁned:

// OK: a declared directly in A, S is { A::a}
// OK: both A and B searched (once), S is { A::a}
// OK: both A and B searched (once), S is { B::b}
// OK: b declared directly in B, S is { B::b}

— end example ]

6 During the lookup of a qualiﬁed namespace member name, if the lookup ﬁnds more than one declaration of
the member, and if one declaration introduces a class name or enumeration name and the other declarations
either introduce the same variable, the same enumerator or a set of functions, the non-type name hides
the class or enumeration name if and only if the declarations are from the same namespace; otherwise (the
declarations are from diﬀerent namespaces), the program is ill-formed. [ Example:

§ 3.4.3.2

55

c(cid:13) ISO/IEC

N4296

namespace A {

struct x { };
int x;
int y;

namespace B {

struct y { };

}

}

}

namespace C {

using namespace A;
using namespace B;
int i = C::x;
int j = C::y;

// OK, A::x (of type int )
// ambiguous, A::y or B::y

7

— end example ]
In a declaration for a namespace member in which the declarator-id is a qualiﬁed-id, given that the qualiﬁed-id
for the namespace member has the form

nested-name-speciﬁer unqualiﬁed-id

the unqualiﬁed-id shall name a member of the namespace designated by the nested-name-speciﬁer or of an
element of the inline namespace set (7.3.1) of that namespace. [ Example:

namespace A {

namespace B {

void f1(int);

}
using namespace B;

}
void A::f1(int){ } // ill-formed, f1 is not a member of A

— end example ] However, in such namespace member declarations, the nested-name-speciﬁer may rely on
using-directives to implicitly provide the initial part of the nested-name-speciﬁer. [ Example:

namespace A {

namespace B {

void f1(int);

}

}

namespace C {

namespace D {

void f1(int);

}

}

using namespace A;
using namespace C::D;
void B::f1(int){ } // OK, deﬁnes A::B::f1(int)

— end example ]

§ 3.4.3.2

56

c(cid:13) ISO/IEC

N4296

3.4.4 Elaborated type speciﬁers

[basic.lookup.elab]
1 An elaborated-type-speciﬁer (7.1.6.3) may be used to refer to a previously declared class-name or enum-name

even though the name has been hidden by a non-type declaration (3.3.10).
If the elaborated-type-speciﬁer has no nested-name-speciﬁer, and unless the elaborated-type-speciﬁer appears
in a declaration with the following form:

2

3

class-key attribute-speciﬁer-seqopt identiﬁer ;

the identiﬁer is looked up according to 3.4.1 but ignoring any non-type names that have been declared. If
the elaborated-type-speciﬁer is introduced by the enum keyword and this lookup does not ﬁnd a previously
declared type-name, the elaborated-type-speciﬁer is ill-formed. If the elaborated-type-speciﬁer is introduced by
the class-key and this lookup does not ﬁnd a previously declared type-name, or if the elaborated-type-speciﬁer
appears in a declaration with the form:

class-key attribute-speciﬁer-seqopt identiﬁer ;

the elaborated-type-speciﬁer is a declaration that introduces the class-name as described in 3.3.2.
If the elaborated-type-speciﬁer has a nested-name-speciﬁer, qualiﬁed name lookup is performed, as described
in 3.4.3, but ignoring any non-type names that have been declared. If the name lookup does not ﬁnd a
previously declared type-name, the elaborated-type-speciﬁer is ill-formed. [ Example:

struct Node {

struct Node* Next;
struct Data* Data;

};

struct Data {

struct Node* Node;
friend struct ::Glob;

friend struct Glob;
/∗ ... ∗/

};

// OK: Refers to Node at global scope
// OK: Declares type Data
// at global scope and member Data

// OK: Refers to Node at global scope
// error: Glob is not declared
// cannot introduce a qualiﬁed type (7.1.6.3)
// OK: Refers to (as yet) undeclared Glob
// at global scope.

struct Base {
struct Data;
struct ::Data*
struct Base::Data* thisData; // OK: Refers to nested Data
// OK: global Data is a friend
friend class ::Data;
// OK: nested Data is a friend
friend class Data;
// Deﬁnes nested Data
struct Data { /* ...

thatData; // OK: Refers to ::Data

// OK: Declares nested Data

};

*/ };

struct Data;
struct ::Data;
struct Base::Data;
struct Base::Datum;
struct Base::Data* pBase;

// OK: Redeclares Data at global scope
// error: cannot introduce a qualiﬁed type (7.1.6.3)
// error: cannot introduce a qualiﬁed type (7.1.6.3)
// error: Datum undeﬁned
// OK: refers to nested Data

— end example ]

§ 3.4.4

57

1

2

3

4

5

6

7

c(cid:13) ISO/IEC

N4296

[basic.lookup.classref]
3.4.5 Class member access
In a class member access expression (5.2.5), if the . or -> token is immediately followed by an identiﬁer
followed by a <, the identiﬁer must be looked up to determine whether the < is the beginning of a template
argument list (14.2) or a less-than operator. The identiﬁer is ﬁrst looked up in the class of the object
expression. If the identiﬁer is not found, it is then looked up in the context of the entire postﬁx-expression
and shall name a class template.
If the id-expression in a class member access (5.2.5) is an unqualiﬁed-id, and the type of the object expression
is of a class type C, the unqualiﬁed-id is looked up in the scope of class C. For a pseudo-destructor call (5.2.4),
the unqualiﬁed-id is looked up in the context of the complete postﬁx-expression.
If the unqualiﬁed-id is ~type-name, the type-name is looked up in the context of the entire postﬁx-expression.
If the type T of the object expression is of a class type C, the type-name is also looked up in the scope of
class C. At least one of the lookups shall ﬁnd a name that refers to (possibly cv-qualiﬁed) T. [ Example:

struct A { };

struct B {

struct A { };
void f(::A* a);

void B::f(::A* a) {

a->~A();

};

}

// OK: lookup in *a ﬁnds the injected-class-name

— end example ]
If the id-expression in a class member access is a qualiﬁed-id of the form

class-name-or-namespace-name::...

the class-name-or-namespace-name following the . or -> operator is ﬁrst looked up in the class of the
object expression and the name, if found, is used. Otherwise it is looked up in the context of the entire
postﬁx-expression. [ Note: See 3.4.3, which describes the lookup of a name before ::, which will only ﬁnd a
type or namespace name. — end note ]
If the qualiﬁed-id has the form

::class-name-or-namespace-name::...

the class-name-or-namespace-name is looked up in global scope as a class-name or namespace-name.
If the nested-name-speciﬁer contains a simple-template-id (14.2), the names in its template-arguments are
looked up in the context in which the entire postﬁx-expression occurs.
If the id-expression is a conversion-function-id, its conversion-type-id is ﬁrst looked up in the class of the
object expression and the name, if found, is used. Otherwise it is looked up in the context of the entire
postﬁx-expression. In each of these lookups, only names that denote types or templates whose specializations
are types are considered. [ Example:

struct A { };
namespace N {
struct A {

};

}

void g() { }
template <class T> operator T();

§ 3.4.5

58

c(cid:13) ISO/IEC

N4296

int main() {

N::A a;
a.operator A();

}

// calls N::A::operator N::A

1

— end example ]
3.4.6 Using-directives and namespace aliases
[basic.lookup.udir]
In a using-directive or namespace-alias-deﬁnition, during the lookup for a namespace-name or for a name in
a nested-name-speciﬁer only namespace names are considered.
3.5 Program and linkage

[basic.link]
1 A program consists of one or more translation units (Clause 2) linked together. A translation unit consists

of a sequence of declarations.

translation-unit:

declaration-seqopt

2 A name is said to have linkage when it might denote the same object, reference, function, type, template,

namespace or value as a name introduced by a declaration in another scope:

(2.1)

(2.2)

(2.3)

—

—

—

When a name has external linkage , the entity it denotes can be referred to by names from scopes of
other translation units or from other scopes of the same translation unit.
When a name has internal linkage , the entity it denotes can be referred to by names from other scopes
in the same translation unit.
When a name has no linkage , the entity it denotes cannot be referred to by names from other scopes.

3 A name having namespace scope (3.3.6) has internal linkage if it is the name of

(3.1)

(3.2)

(3.3)

—
—

—

a variable, function or function template that is explicitly declared static; or,
a variable of non-volatile const-qualiﬁed type that is neither explicitly declared extern nor previously
declared to have external linkage; or
a data member of an anonymous union.

4 An unnamed namespace or a namespace declared directly or indirectly within an unnamed namespace has
internal linkage. All other namespaces have external linkage. A name having namespace scope that has not
been given internal linkage above has the same linkage as the enclosing namespace if it is the name of

(4.1)

(4.2)

(4.3)

(4.4)

(4.5)

(4.6)

—
—
—

—

—
—

a variable; or
a function; or
a named class (Clause 9), or an unnamed class deﬁned in a typedef declaration in which the class has
the typedef name for linkage purposes (7.1.3); or
a named enumeration (7.2), or an unnamed enumeration deﬁned in a typedef declaration in which the
enumeration has the typedef name for linkage purposes (7.1.3); or
an enumerator belonging to an enumeration with linkage; or
a template.

§ 3.5

59

c(cid:13) ISO/IEC

N4296

5

In addition, a member function, static data member, a named class or enumeration of class scope, or an
unnamed class or enumeration deﬁned in a class-scope typedef declaration such that the class or enumeration
has the typedef name for linkage purposes (7.1.3), has the same linkage, if any, as the name of the class of
which it is a member.

6 The name of a function declared in block scope and the name of a variable declared by a block scope extern
declaration have linkage. If there is a visible declaration of an entity with linkage having the same name and
type, ignoring entities declared outside the innermost enclosing namespace scope, the block scope declaration
declares that same entity and receives the linkage of the previous declaration. If there is more than one such
matching entity, the program is ill-formed. Otherwise, if no matching entity is found, the block scope entity
receives external linkage.[ Example:

static void f();
static int i = 0;
void g() {

extern void f();
int i;
{

extern void f();
extern int i;

}

}

// #1

// internal linkage
// #2 i has no linkage

// internal linkage
// #3 external linkage

There are three objects named i in this program. The object with internal linkage introduced by the
declaration in global scope (line #1 ), the object with automatic storage duration and no linkage introduced
by the declaration on line #2, and the object with static storage duration and external linkage introduced
by the declaration on line #3. — end example ]

7 When a block scope declaration of an entity with linkage is not found to refer to some other declaration,
then that entity is a member of the innermost enclosing namespace. However such a declaration does not
introduce the member name in its namespace scope. [ Example:

namespace X {
void p() {

q();
extern void q();

}

}

void middle() {

q();

// error: q not yet declared
// q is a member of namespace X

// error: q not yet declared

void q() { /* ...

*/ }

// deﬁnition of X::q

}

void q() { /* ...

*/ }

// some other, unrelated q

— end example ]

8 Names not covered by these rules have no linkage. Moreover, except as noted, a name declared at block

scope (3.3.3) has no linkage. A type is said to have linkage if and only if:

(8.1)

(8.2)

—

—

it is a class or enumeration type that is named (or has a name for linkage purposes (7.1.3)) and the
name has linkage; or
it is an unnamed class or enumeration member of a class with linkage; or

§ 3.5

60

c(cid:13) ISO/IEC

N4296

—
—
—

—

it is a specialization of a class template (Clause 14)34; or
it is a fundamental type (3.9.1); or
it is a compound type (3.9.2) other than a class or enumeration, compounded exclusively from types
that have linkage; or
it is a cv-qualiﬁed (3.9.3) version of a type that has linkage.

A type without linkage shall not be used as the type of a variable or function with external linkage unless

—
—
—

the entity has C language linkage (7.5), or
the entity is declared within an unnamed namespace (7.3.1), or
the entity is not odr-used (3.2) or is deﬁned in the same translation unit.

(8.3)

(8.4)

(8.5)

(8.6)

(8.7)

(8.8)

(8.9)

[ Note: In other words, a type without linkage contains a class or enumeration that cannot be named outside
its translation unit. An entity with external linkage declared using such a type could not correspond to any
other entity in another translation unit of the program and thus must be deﬁned in the translation unit if
it is odr-used. Also note that classes with linkage may contain members whose types do not have linkage,
and that typedef names are ignored in the determination of whether a type has linkage. — end note ]
[ Example:

template <class T> struct B {

void g(T) { }
void h(T);
friend void i(B, T) { }

};

void f() {

}

struct A { int x; };
A a = { 1 };
B<A> ba;
ba.g(a);
ba.h(a);
i(ba, a);

// no linkage

// declares B<A>::g(A) and B<A>::h(A)
// OK
// error: B<A>::h(A) not defined in the translation unit
// OK

— end example ]

9 Two names that are the same (Clause 3) and that are declared in diﬀerent scopes shall denote the same

variable, function, type, enumerator, template or namespace if

(9.1)

(9.2)

(9.3)

(9.4)

—

—

both names have external linkage or else both names have internal linkage and are declared in the
same translation unit; and
both names refer to members of the same namespace or to members, not by inheritance, of the same
class; and
—
when both names denote functions, the parameter-type-lists of the functions (8.3.5) are identical; and
—
when both names denote function templates, the signatures (14.5.6.1) are the same.
34) A class template has the linkage of the innermost enclosing class or namespace in which it is declared.

§ 3.5

61

c(cid:13) ISO/IEC

N4296

11

10 After all adjustments of types (during which typedefs (7.1.3) are replaced by their deﬁnitions), the types
speciﬁed by all declarations referring to a given variable or function shall be identical, except that decla-
rations for an array object can specify array types that diﬀer by the presence or absence of a major array
bound (8.3.4). A violation of this rule on type identity does not require a diagnostic.
[ Note: Linkage to non-C++ declarations can be achieved using a linkage-speciﬁcation (7.5). — end note ]
3.6 Start and termination
3.6.1 Main function

[basic.start]
[basic.start.main]
1 A program shall contain a global function called main, which is the designated start of the program. It
is implementation-deﬁned whether a program in a freestanding environment is required to deﬁne a main
function. [ Note: In a freestanding environment, start-up and termination is implementation-deﬁned; start-
up contains the execution of constructors for objects of namespace scope with static storage duration;
termination contains the execution of destructors for objects with static storage duration. — end note ]

2 An implementation shall not predeﬁne the main function. This function shall not be overloaded. It shall have
a declared return type of type int, but otherwise its type is implementation-deﬁned. An implementation
shall allow both

(2.1)

(2.2)

—
—

a function of () returning int and
a function of (int, pointer to pointer to char) returning int

as the type of main (8.3.5). In the latter form, for purposes of exposition, the ﬁrst function parameter is
called argc and the second function parameter is called argv, where argc shall be the number of arguments
passed to the program from the environment in which the program is run. If argc is nonzero these arguments
shall be supplied in argv[0] through argv[argc-1] as pointers to the initial characters of null-terminated
multibyte strings (ntmbs s) (17.5.2.1.4.2) and argv[0] shall be the pointer to the initial character of a
ntmbs that represents the name used to invoke the program or "". The value of argc shall be non-negative.
The value of argv[argc] shall be 0. [ Note: It is recommended that any further (optional) parameters be
added after argv. — end note ]

3 The function main shall not be used within a program. The linkage (3.5) of main is implementation-deﬁned.
A program that deﬁnes main as deleted or that declares main to be inline, static, or constexpr is ill-
formed. The name main is not otherwise reserved. [ Example: member functions, classes, and enumerations
can be called main, as can entities in other namespaces. — end example ]

4 Terminating the program without leaving the current block (e.g., by calling the function std::exit(int)
(18.5)) does not destroy any objects with automatic storage duration (12.4).
If std::exit is called to
end a program during the destruction of an object with static or thread storage duration, the program has
undeﬁned behavior.

5 A return statement in main has the eﬀect of leaving the main function (destroying any objects with automatic
storage duration) and calling std::exit with the return value as the argument. If control reaches the end
of main without encountering a return statement, the eﬀect is that of executing

return 0;

3.6.2 Initialization of non-local variables

[basic.start.init]
1 There are two broad classes of named non-local variables: those with static storage duration (3.7.1) and
those with thread storage duration (3.7.2). Non-local variables with static storage duration are initialized
as a consequence of program initiation. Non-local variables with thread storage duration are initialized as a
consequence of thread execution. Within each of these phases of initiation, initialization occurs as follows.
2 Variables with static storage duration (3.7.1) or thread storage duration (3.7.2) shall be zero-initialized (8.5)
before any other initialization takes place. A constant initializer for an object o is an expression that is a

§ 3.6.2

62

(2.1)

(2.2)

(2.3)

c(cid:13) ISO/IEC

N4296

constant expression, except that it may also invoke constexpr constructors for o and its subobjects even
if those objects are of non-literal class types [ Note: such a class may have a non-trivial destructor — end
note ]. Constant initialization is performed:

—

—

—

if each full-expression (including implicit conversions) that appears in the initializer of a reference
with static or thread storage duration is a constant expression (5.20) and the reference is bound to a
glvalue designating an object with static storage duration, to a temporary object (see 12.2) or subobject
thereof, or to a function;
if an object with static or thread storage duration is initialized by a constructor call, and if the
initialization full-expression is a constant initializer for the object;
if an object with static or thread storage duration is not initialized by a constructor call and if either the
object is value-initialized or every full-expression that appears in its initializer is a constant expression.
Together, zero-initialization and constant initialization are called static initialization; all other initialization is
dynamic initialization. Static initialization shall be performed before any dynamic initialization takes place.
Dynamic initialization of a non-local variable with static storage duration is unordered if the variable is an
implicitly or explicitly instantiated specialization, and otherwise is ordered [ Note: an explicitly specialized
static data member or variable template specialization has ordered initialization. — end note ] Variables
with ordered initialization deﬁned within a single translation unit shall be initialized in the order of their
deﬁnitions in the translation unit. If a program starts a thread (30.3), the subsequent initialization of a
variable is unsequenced with respect to the initialization of a variable deﬁned in a diﬀerent translation unit.
Otherwise, the initialization of a variable is indeterminately sequenced with respect to the initialization of
a variable deﬁned in a diﬀerent translation unit. If a program starts a thread, the subsequent unordered
initialization of a variable is unsequenced with respect to every other dynamic initialization. Otherwise,
the unordered initialization of a variable is indeterminately sequenced with respect to every other dynamic
initialization.
[ Note: This deﬁnition permits initialization of a sequence of ordered variables concurrently
with another sequence. — end note ] [ Note: The initialization of local static variables is described in 6.7.
— end note ]

(3.1)

3 An implementation is permitted to perform the initialization of a non-local variable with static storage
duration as a static initialization even if such initialization is not required to be done statically, provided
that
—

the dynamic version of the initialization does not change the value of any other object of namespace
scope prior to its initialization, and
the static version of the initialization produces the same value in the initialized variable as would be
produced by the dynamic initialization if all variables not required to be initialized statically were
initialized dynamically.

(3.2)

—

[ Note: As a consequence, if the initialization of an object obj1 refers to an object obj2 of namespace scope
potentially requiring dynamic initialization and deﬁned later in the same translation unit, it is unspeciﬁed
whether the value of obj2 used will be the value of the fully initialized obj2 (because obj2 was statically
initialized) or will be the value of obj2 merely zero-initialized. For example,

inline double fd() { return 1.0; }
extern double d1;
double d2 = d1;

// unspeciﬁed:
// may be statically initialized to 0.0 or
// dynamically initialized to 0.0 if d1 is
// dynamically initialized, or 1.0 otherwise
// may be initialized statically or dynamically to 1.0

double d1 = fd();

§ 3.6.2

63

c(cid:13) ISO/IEC

N4296

4

— end note ]
It is implementation-deﬁned whether the dynamic initialization of a non-local variable with static storage
duration is done before the ﬁrst statement of main. If the initialization is deferred to some point in time
after the ﬁrst statement of main, it shall occur before the ﬁrst odr-use (3.2) of any function or variable
deﬁned in the same translation unit as the variable to be initialized.35 [ Example:

// - File 1 -
#include "a.h"
#include "b.h"
B b;
A::A(){

b.Use();

}

// - File 2 -
#include "a.h"
A a;

// - File 3 -
#include "a.h"
#include "b.h"
extern A a;
extern B b;

int main() {

a.Use();
b.Use();

}

5

6

It is implementation-deﬁned whether either a or b is initialized before main is entered or whether the
initializations are delayed until a is ﬁrst odr-used in main. In particular, if a is initialized before main is
entered, it is not guaranteed that b will be initialized before it is odr-used by the initialization of a, that is,
before A::A is called. If, however, a is initialized at some point after the ﬁrst statement of main, b will be
initialized prior to its use in A::A. — end example ]
It is implementation-deﬁned whether the dynamic initialization of a non-local variable with static or thread
storage duration is done before the ﬁrst statement of the initial function of the thread. If the initialization
is deferred to some point in time after the ﬁrst statement of the initial function of the thread, it shall occur
before the ﬁrst odr-use (3.2) of any variable with thread storage duration deﬁned in the same translation
unit as the variable to be initialized.
If the initialization of a non-local variable with static or thread storage duration exits via an exception,
std::terminate is called (15.5.1).
3.6.3 Termination

[basic.start.term]
1 Destructors (12.4) for initialized objects (that is, objects whose lifetime (3.8) has begun) with static storage
duration are called as a result of returning from main and as a result of calling std::exit (18.5). Destructors
for initialized objects with thread storage duration within a given thread are called as a result of returning
from the initial function of that thread and as a result of that thread calling std::exit. The completions
of the destructors for all initialized objects with thread storage duration within that thread are sequenced
before the initiation of the destructors of any object with static storage duration. If the completion of the
constructor or dynamic initialization of an object with thread storage duration is sequenced before that of
35) A non-local variable with static storage duration having initialization with side-eﬀects must be initialized even if it is not
odr-used (3.2, 3.7.1).

§ 3.6.3

64

c(cid:13) ISO/IEC

N4296

another, the completion of the destructor of the second is sequenced before the initiation of the destructor
of the ﬁrst. If the completion of the constructor or dynamic initialization of an object with static storage
duration is sequenced before that of another, the completion of the destructor of the second is sequenced
before the initiation of the destructor of the ﬁrst.
[ Note: This deﬁnition permits concurrent destruction.
— end note ] If an object is initialized statically, the object is destroyed in the same order as if the object was
dynamically initialized. For an object of array or class type, all subobjects of that object are destroyed before
any block-scope object with static storage duration initialized during the construction of the subobjects is
destroyed.
If the destruction of an object with static or thread storage duration exits via an exception,
std::terminate is called (15.5.1).
If a function contains a block-scope object of static or thread storage duration that has been destroyed and
the function is called during the destruction of an object with static or thread storage duration, the program
has undeﬁned behavior if the ﬂow of control passes through the deﬁnition of the previously destroyed block-
scope object. Likewise, the behavior is undeﬁned if the block-scope object is used indirectly (i.e., through a
pointer) after its destruction.
If the completion of the initialization of an object with static storage duration is sequenced before a call
to std::atexit (see <cstdlib>, 18.5), the call to the function passed to std::atexit is sequenced before
the call to the destructor for the object. If a call to std::atexit is sequenced before the completion of the
initialization of an object with static storage duration, the call to the destructor for the object is sequenced
before the call to the function passed to std::atexit. If a call to std::atexit is sequenced before another
call to std::atexit, the call to the function passed to the second std::atexit call is sequenced before the
call to the function passed to the ﬁrst std::atexit call.
If there is a use of a standard library object or function not permitted within signal handlers (18.10) that
does not happen before (1.10) completion of destruction of objects with static storage duration and execution
of std::atexit registered functions (18.5), the program has undeﬁned behavior.
[ Note: If there is a use
of an object with static storage duration that does not happen before the object’s destruction, the program
has undeﬁned behavior. Terminating every thread before a call to std::exit or the exit from main is
suﬃcient, but not necessary, to satisfy these requirements. These requirements permit thread managers as
static-storage-duration objects. — end note ]

2

3

4

5 Calling the function std::abort() declared in <cstdlib> terminates the program without executing any

destructors and without calling the functions passed to std::atexit() or std::at_quick_exit().
3.7 Storage duration

[basic.stc]
1 Storage duration is the property of an object that deﬁnes the minimum potential lifetime of the storage
containing the object. The storage duration is determined by the construct used to create the object and is
one of the following:

(1.1)

(1.2)

(1.3)

(1.4)

—
—
—
—

static storage duration
thread storage duration
automatic storage duration
dynamic storage duration

2 Static, thread, and automatic storage durations are associated with objects introduced by declarations (3.1)
and implicitly created by the implementation (12.2). The dynamic storage duration is associated with objects
created with operator new (5.3.4).

3 The storage duration categories apply to references as well. The lifetime of a reference is its storage duration.

§ 3.7

65

c(cid:13) ISO/IEC

N4296

3.7.1 Static storage duration

[basic.stc.static]
1 All variables which do not have dynamic storage duration, do not have thread storage duration, and are
not local have static storage duration. The storage for these entities shall last for the duration of the
program (3.6.2, 3.6.3).
If a variable with static storage duration has initialization or a destructor with side eﬀects, it shall not be
eliminated even if it appears to be unused, except that a class object or its copy/move may be eliminated
as speciﬁed in 12.8.

2

3 The keyword static can be used to declare a local variable with static storage duration. [ Note: 6.7 describes
the initialization of local static variables; 3.6.3 describes the destruction of local static variables. — end
note ]

4 The keyword static applied to a class data member in a class deﬁnition gives the data member static

storage duration.
3.7.2 Thread storage duration

[basic.stc.thread]
1 All variables declared with the thread_local keyword have thread storage duration. The storage for these
entities shall last for the duration of the thread in which they are created. There is a distinct object or
reference per thread, and use of the declared name refers to the entity associated with the current thread.
2 A variable with thread storage duration shall be initialized before its ﬁrst odr-use (3.2) and, if constructed,

shall be destroyed on thread exit.
3.7.3 Automatic storage duration

3

2

[basic.stc.auto]
1 Block-scope variables explicitly declared register or not explicitly declared static or extern have au-
tomatic storage duration. The storage for these entities lasts until the block in which they are created
exits.
[ Note: These variables are initialized and destroyed as described in 6.7. — end note ]
If a variable with automatic storage duration has initialization or a destructor with side eﬀects, it shall not
be destroyed before the end of its block, nor shall it be eliminated as an optimization even if it appears to
be unused, except that a class object or its copy/move may be eliminated as speciﬁed in 12.8.
3.7.4 Dynamic storage duration

[basic.stc.dynamic]
1 Objects can be created dynamically during program execution (1.9), using new-expressions (5.3.4), and
destroyed using delete-expressions (5.3.5). A C++ implementation provides access to, and management
of, dynamic storage via the global allocation functions operator new and operator new[] and the global
deallocation functions operator delete and operator delete[].

2 The library provides default deﬁnitions for the global allocation and deallocation functions. Some global
allocation and deallocation functions are replaceable (18.6.1). A C++ program shall provide at most one
deﬁnition of a replaceable allocation or deallocation function. Any such function deﬁnition replaces the
default version provided in the library (17.6.4.6). The following allocation and deallocation functions (18.6)
are implicitly declared in global scope in each translation unit of a program.

void* operator new(std::size_t);
void* operator new[](std::size_t);
void operator delete(void*) noexcept;
void operator delete[](void*) noexcept;
void operator delete(void*, std::size_t) noexcept;
void operator delete[](void*, std::size_t) noexcept;

These implicit declarations introduce only the function names operator new, operator new[], opera-
tor delete, and operator delete[].
[ Note: The implicit declarations do not introduce the names std,

§ 3.7.4

66

c(cid:13) ISO/IEC

N4296

std::size_t, or any other names that the library uses to declare these names. Thus, a new-expression,
delete-expression or function call that refers to one of these functions without including the header <new>
is well-formed. However, referring to std or std::size_t is ill-formed unless the name has been declared
by including the appropriate header. — end note ] Allocation and/or deallocation functions can also be
declared and deﬁned for any class (12.5).

3 Any allocation and/or deallocation functions deﬁned in a C++ program, including the default versions in

the library, shall conform to the semantics speciﬁed in 3.7.4.1 and 3.7.4.2.
3.7.4.1 Allocation functions

[basic.stc.dynamic.allocation]
1 An allocation function shall be a class member function or a global function; a program is ill-formed if an
allocation function is declared in a namespace scope other than global scope or declared static in global
scope. The return type shall be void*. The ﬁrst parameter shall have type std::size_t (18.2). The ﬁrst
parameter shall not have an associated default argument (8.3.6). The value of the ﬁrst parameter shall be
interpreted as the requested size of the allocation. An allocation function can be a function template. Such
a template shall declare its return type and ﬁrst parameter as speciﬁed above (that is, template parameter
types shall not be used in the return type and ﬁrst parameter type). Template allocation functions shall
have two or more parameters.

2 The allocation function attempts to allocate the requested amount of storage. If it is successful, it shall
return the address of the start of a block of storage whose length in bytes shall be at least as large as
the requested size. There are no constraints on the contents of the allocated storage on return from the
allocation function. The order, contiguity, and initial value of storage allocated by successive calls to an
allocation function are unspeciﬁed. The pointer returned shall be suitably aligned so that it can be converted
to a pointer of any complete object type with a fundamental alignment requirement (3.11) and then used
to access the object or array in the storage allocated (until the storage is explicitly deallocated by a call
to a corresponding deallocation function). Even if the size of the space requested is zero, the request can
fail. If the request succeeds, the value returned shall be a non-null pointer value (4.10) p0 diﬀerent from
any previously returned value p1, unless that value p1 was subsequently passed to an operator delete.
Furthermore, for the library allocation functions in 18.6.1.1 and 18.6.1.2, p0 shall point to a block of storage
disjoint from the storage for any other object accessible to the caller. The eﬀect of indirecting through a
pointer returned as a request for zero size is undeﬁned.36

3 An allocation function that fails to allocate storage can invoke the currently installed new-handler func-
tion (18.6.2.3), if any. [ Note: A program-supplied allocation function can obtain the address of the currently
installed new_handler using the std::get_new_handler function (18.6.2.4). — end note ] If an allocation
function that has a non-throwing exception speciﬁcation (15.4) fails to allocate storage, it shall return a null
pointer. Any other allocation function that fails to allocate storage shall indicate failure only by throwing
an exception (15.1) of a type that would match a handler (15.3) of type std::bad_alloc (18.6.2.1).

4 A global allocation function is only called as the result of a new expression (5.3.4), or called directly using the
function call syntax (5.2.2), or called indirectly through calls to the functions in the C++ standard library.
[ Note: In particular, a global allocation function is not called to allocate storage for objects with static
storage duration (3.7.1), for objects or references with thread storage duration (3.7.2), for objects of type
std::type_info (5.2.8), or for an exception object (15.1). — end note ]
3.7.4.2 Deallocation functions

[basic.stc.dynamic.deallocation]
1 Deallocation functions shall be class member functions or global functions; a program is ill-formed if deal-
location functions are declared in a namespace scope other than global scope or declared static in global
scope.
36) The intent is to have operator new() implementable by calling std::malloc() or std::calloc(), so the rules are sub-
stantially the same. C++ diﬀers from C in requiring a zero request to return a non-null pointer.

§ 3.7.4.2

67

c(cid:13) ISO/IEC

N4296

2 Each deallocation function shall return void and its ﬁrst parameter shall be void*. A deallocation function
can have more than one parameter. The global operator delete with exactly one parameter is a usual (non-
placement) deallocation function. The global operator delete with exactly two parameters, the second
of which has type std::size_t, is a usual deallocation function. Similarly, the global operator delete[]
with exactly one parameter is a usual deallocation function. The global operator delete[] with exactly
two parameters, the second of which has type std::size_t, is a usual deallocation function.37 If a class T
has a member deallocation function named operator delete with exactly one parameter, then that function
is a usual deallocation function. If class T does not declare such an operator delete but does declare a
member deallocation function named operator delete with exactly two parameters, the second of which has
type std::size_t, then this function is a usual deallocation function. Similarly, if a class T has a member
deallocation function named operator delete[] with exactly one parameter, then that function is a usual
(non-placement) deallocation function. If class T does not declare such an operator delete[] but does
declare a member deallocation function named operator delete[] with exactly two parameters, the second
of which has type std::size_t, then this function is a usual deallocation function. A deallocation function
can be an instance of a function template. Neither the ﬁrst parameter nor the return type shall depend on
a template parameter. [ Note: That is, a deallocation function template shall have a ﬁrst parameter of type
void* and a return type of void (as speciﬁed above). — end note ] A deallocation function template shall
have two or more function parameters. A template instance is never a usual deallocation function, regardless
of its signature.
If a deallocation function terminates by throwing an exception, the behavior is undeﬁned. The value of the
ﬁrst argument supplied to a deallocation function may be a null pointer value; if so, and if the deallocation
function is one supplied in the standard library, the call has no eﬀect. Otherwise, the behavior is undeﬁned
if the value supplied to operator delete(void*) in the standard library is not one of the values returned
by a previous invocation of either operator new(std::size_t) or operator new(std::size_t, const
std::nothrow_t&) in the standard library, and the behavior is undeﬁned if the value supplied to operator
delete[](void*) in the standard library is not one of the values returned by a previous invocation of
either operator new[](std::size_t) or operator new[](std::size_t, const std::nothrow_t&) in the
standard library.
If the argument given to a deallocation function in the standard library is a pointer that is not the null pointer
value (4.10), the deallocation function shall deallocate the storage referenced by the pointer, rendering invalid
all pointers referring to any part of the deallocated storage. Indirection through an invalid pointer value
and passing an invalid pointer value to a deallocation function have undeﬁned behavior. Any other use of
an invalid pointer value has implementation-deﬁned behavior.38
3.7.4.3 Safely-derived pointers

[basic.stc.dynamic.safety]

3

4

1 A traceable pointer object is

(1.1)

(1.2)

(1.3)

—
—
—

an object of an object pointer type (3.9.2), or
an object of an integral type that is at least as large as std::intptr_t, or
a sequence of elements in an array of narrow character type (3.9.1), where the size and alignment of
the sequence match those of some object pointer type.

2 A pointer value is a safely-derived pointer to a dynamic object only if it has an object pointer type and it

is one of the following:
37) This deallocation function precludes use of an allocation function void operator new(std::size_t, std::size_t) as a
placement allocation function (C.3.2).
38) Some implementations might deﬁne that copying an invalid pointer value causes a system-generated runtime fault.

§ 3.7.4.3

68

c(cid:13) ISO/IEC

N4296

(2.1)

(2.2)

(2.3)

(2.4)

(2.5)

(2.6)

(2.7)

—

—

—
—
—
—
—

the value returned by a call to the C++ standard library implementation of ::operator new(std::
size_t);39
the result of taking the address of an object (or one of its subobjects) designated by an lvalue resulting
from indirection through a safely-derived pointer value;
the result of well-deﬁned pointer arithmetic (5.7) using a safely-derived pointer value;
the result of a well-deﬁned pointer conversion (4.10, 5.4) of a safely-derived pointer value;
the result of a reinterpret_cast of a safely-derived pointer value;
the result of a reinterpret_cast of an integer representation of a safely-derived pointer value;
the value of an object whose value was copied from a traceable pointer object, where at the time of
the copy the source object contained a copy of a safely-derived pointer value.

3 An integer value is an integer representation of a safely-derived pointer only if its type is at least as large as

std::intptr_t and it is one of the following:

(3.1)

(3.2)

(3.3)

(3.4)

—
—
—

—

the result of a reinterpret_cast of a safely-derived pointer value;
the result of a valid conversion of an integer representation of a safely-derived pointer value;
the value of an object whose value was copied from a traceable pointer object, where at the time of
the copy the source object contained an integer representation of a safely-derived pointer value;
the result of an additive or bitwise operation, one of whose operands is an integer representation of a
safely-derived pointer value P, if that result converted by reinterpret_cast<void*> would compare
equal to a safely-derived pointer computable from reinterpret_cast<void*>(P).

4 An implementation may have relaxed pointer safety, in which case the validity of a pointer value does not
depend on whether it is a safely-derived pointer value. Alternatively, an implementation may have strict
pointer safety, in which case a pointer value referring to an object with dynamic storage duration that is not
a safely-derived pointer value is an invalid pointer value unless the referenced complete object has previously
been declared reachable (20.7.4). [ Note: the eﬀect of using an invalid pointer value (including passing it to a
deallocation function) is undeﬁned, see 3.7.4.2. This is true even if the unsafely-derived pointer value might
compare equal to some safely-derived pointer value. — end note ] It is implementation deﬁned whether an
implementation has relaxed or strict pointer safety.
3.7.5 Duration of subobjects

[basic.stc.inherit]
1 The storage duration of member subobjects, base class subobjects and array elements is that of their complete

object (1.8).
3.8 Object lifetime

[basic.life]
1 The lifetime of an object is a runtime property of the object. An object is said to have non-vacuous
initialization if it is of a class or aggregate type and it or one of its members is initialized by a constructor
other than a trivial default constructor.
initialization by a trivial copy/move constructor is non-
vacuous initialization. — end note ] The lifetime of an object of type T begins when:

[ Note:

(1.1)

storage with the proper alignment and size for type T is obtained, and

—
39) This section does not impose restrictions on indirection through pointers to memory not allocated by ::operator new.
This maintains the ability of many C++ implementations to use binary libraries and components written in other languages.
In particular, this applies to C binaries, because indirection through pointers to memory allocated by std::malloc is not
restricted.

§ 3.8

69

c(cid:13) ISO/IEC

N4296

(1.2)

—

if the object has non-vacuous initialization, its initialization is complete.

The lifetime of an object of type T ends when:

(1.3)

(1.4)

2

—
—

if T is a class type with a non-trivial destructor (12.4), the destructor call starts, or
the storage which the object occupies is reused or released.

[ Note: The lifetime of an array object starts as soon as storage with proper size and alignment is obtained,
and its lifetime ends when the storage which the array occupies is reused or released. 12.6.2 describes the
lifetime of base and member subobjects. — end note ]

3 The properties ascribed to objects throughout this International Standard apply for a given object only
during its lifetime.
[ Note: In particular, before the lifetime of an object starts and after its lifetime ends
there are signiﬁcant restrictions on the use of the object, as described below, in 12.6.2 and in 12.7. Also,
the behavior of an object under construction and destruction might not be the same as the behavior of an
object whose lifetime has started and not ended. 12.6.2 and 12.7 describe the behavior of objects during the
construction and destruction phases. — end note ]

4 A program may end the lifetime of any object by reusing the storage which the object occupies or by explicitly
calling the destructor for an object of a class type with a non-trivial destructor. For an object of a class type
with a non-trivial destructor, the program is not required to call the destructor explicitly before the storage
which the object occupies is reused or released; however, if there is no explicit call to the destructor or if a
delete-expression (5.3.5) is not used to release the storage, the destructor shall not be implicitly called and
any program that depends on the side eﬀects produced by the destructor has undeﬁned behavior.

5 Before the lifetime of an object has started but after the storage which the object will occupy has been
allocated40 or, after the lifetime of an object has ended and before the storage which the object occupied is
reused or released, any pointer that refers to the storage location where the object will be or was located
may be used but only in limited ways. For an object under construction or destruction, see 12.7. Otherwise,
such a pointer refers to allocated storage (3.7.4.2), and using the pointer as if the pointer were of type void*,
is well-deﬁned. Indirection through such a pointer is permitted but the resulting lvalue may only be used in
limited ways, as described below. The program has undeﬁned behavior if:

(5.1)

(5.2)

(5.3)

(5.4)

(5.5)

—

—

—
—

—

the object will be or was of a class type with a non-trivial destructor and the pointer is used as the
operand of a delete-expression,
the pointer is used to access a non-static data member or call a non-static member function of the
object, or
the pointer is implicitly converted (4.10) to a pointer to a virtual base class, or
the pointer is used as the operand of a static_cast (5.2.9), except when the conversion is to pointer
to cv void, or to pointer to cv void and subsequently to pointer to either cv char or cv unsigned
char, or
the pointer is used as the operand of a dynamic_cast (5.2.7). [ Example:

#include <cstdlib>

struct B {

virtual void f();
void mutate();
virtual ~B();

};

40) For example, before the construction of a global object of non-POD class type (12.7).

§ 3.8

70

c(cid:13) ISO/IEC

N4296

struct D1 : B { void f(); };
struct D2 : B { void f(); };

void B::mutate() {

new (this) D2;
f();
... = this;

// reuses storage — ends the lifetime of *this
// undeﬁned behavior
// OK, this points to valid memory

}

}

void g() {

void* p = std::malloc(sizeof(D1) + sizeof(D2));
B* pb = new (p) D1;
pb->mutate();
&pb;
void* q = pb;
pb->f();

// OK: pb points to valid memory
// OK: pb points to valid memory
// undeﬁned behavior, lifetime of *pb has ended

— end example ]

6 Similarly, before the lifetime of an object has started but after the storage which the object will occupy
has been allocated or, after the lifetime of an object has ended and before the storage which the object
occupied is reused or released, any glvalue that refers to the original object may be used but only in limited
ways. For an object under construction or destruction, see 12.7. Otherwise, such a glvalue refers to allocated
storage (3.7.4.2), and using the properties of the glvalue that do not depend on its value is well-deﬁned. The
program has undeﬁned behavior if:

(6.1)

(6.2)

(6.3)

(6.4)

7

(7.1)

(7.2)

(7.3)

(7.4)

—
—

—
—

an lvalue-to-rvalue conversion (4.1) is applied to such a glvalue,
the glvalue is used to access a non-static data member or call a non-static member function of the
object, or
the glvalue is bound to a reference to a virtual base class (8.5.3), or
the glvalue is used as the operand of a dynamic_cast (5.2.7) or as the operand of typeid.

If, after the lifetime of an object has ended and before the storage which the object occupied is reused or
released, a new object is created at the storage location which the original object occupied, a pointer that
pointed to the original object, a reference that referred to the original object, or the name of the original
object will automatically refer to the new object and, once the lifetime of the new object has started, can
be used to manipulate the new object, if:

—

—
—

—

the storage for the new object exactly overlays the storage location which the original object occupied,
and
the new object is of the same type as the original object (ignoring the top-level cv-qualiﬁers), and
the type of the original object is not const-qualiﬁed, and, if a class type, does not contain any non-static
data member whose type is const-qualiﬁed or a reference type, and
the original object was a most derived object (1.8) of type T and the new object is a most derived
object of type T (that is, they are not base class subobjects). [ Example:

struct C {

int i;
void f();
const C& operator=( const C& );

§ 3.8

71

c(cid:13) ISO/IEC

};

N4296

const C& C::operator=( const C& other) {

if ( this != &other ) {

this->~C();
new (this) C(other);
f();

// lifetime of *this ends
// new object of type C created
// well-deﬁned

}
return *this;

}

C c1;
C c2;
c1 = c2;
c1.f();

— end example ]

// well-deﬁned
// well-deﬁned; c1 refers to a new object of type C

8

If a program ends the lifetime of an object of type T with static (3.7.1), thread (3.7.2), or automatic (3.7.3)
storage duration and if T has a non-trivial destructor,41 the program must ensure that an object of the
original type occupies that same storage location when the implicit destructor call takes place; otherwise the
behavior of the program is undeﬁned. This is true even if the block is exited with an exception. [ Example:

class T { };
struct B {

~B();

};

void h() {

B b;
new (&b) T;

}

// undeﬁned behavior at block exit

— end example ]

9 Creating a new object at the storage location that a const object with static, thread, or automatic storage
duration occupies or, at the storage location that such a const object used to occupy before its lifetime
ended results in undeﬁned behavior. [ Example:

struct B {

B();
~B();

};

const B b;

void h() {
b.~B();
new (const_cast<B*>(&b)) const B;

}

// undeﬁned behavior

— end example ]
41) That is, an object for which a destructor will be called implicitly—upon exit from the block for an object with automatic
storage duration, upon exit from the thread for an object with thread storage duration, or upon exit from the program for an
object with static storage duration.

§ 3.8

72

c(cid:13) ISO/IEC

N4296

10

1

In this section, “before” and “after” refer to the “happens before” relation (1.10). [ Note: Therefore, undeﬁned
behavior results if an object that is being constructed in one thread is referenced from another thread without
adequate synchronization. — end note ]
[basic.types]
3.9 Types
[ Note: 3.9 and the subclauses thereof impose requirements on implementations regarding the representation
of types. There are two kinds of types: fundamental types and compound types. Types describe objects
(1.8), references (8.3.2), or functions (8.3.5). — end note ]

2 For any object (other than a base-class subobject) of trivially copyable type T, whether or not the object
holds a valid value of type T, the underlying bytes (1.7) making up the object can be copied into an array
of char or unsigned char.42 If the content of the array of char or unsigned char is copied back into the
object, the object shall subsequently hold its original value. [ Example:

#define N sizeof(T)
char buf[N];
T obj;
std::memcpy(buf, &obj, N);

std::memcpy(&obj, buf, N);

— end example ]

// obj initialized to its original value
// between these two calls to std::memcpy,
// obj might be modiﬁed
// at this point, each subobject of obj of scalar type
// holds its original value

3 For any trivially copyable type T, if two pointers to T point to distinct T objects obj1 and obj2, where
neither obj1 nor obj2 is a base-class subobject, if the underlying bytes (1.7) making up obj1 are copied
into obj2,43 obj2 shall subsequently hold the same value as obj1. [ Example:

T* t1p;
T* t2p;

// provided that t2p points to an initialized object ...

std::memcpy(t1p, t2p, sizeof(T));

// at this point, every subobject of trivially copyable type in *t1p contains
// the same value as the corresponding subobject in *t2p

— end example ]

4 The object representation of an object of type T is the sequence of N unsigned char objects taken up by
the object of type T, where N equals sizeof(T). The value representation of an object is the set of bits that
hold the value of type T. For trivially copyable types, the value representation is a set of bits in the object
representation that determines a value, which is one discrete element of an implementation-deﬁned set of
values.44

5 A class that has been declared but not deﬁned, an enumeration type in certain contexts (7.2), or an array of
unknown size or of incomplete element type, is an incompletely-deﬁned object type.45 Incompletely-deﬁned
object types and the void types are incomplete types (3.9.1). Objects shall not be deﬁned to have an
incomplete type.

6 A class type (such as “class X”) might be incomplete at one point in a translation unit and complete later
on; the type “class X” is the same type at both points. The declared type of an array object might be
an array of incomplete class type and therefore incomplete; if the class type is completed later on in the
translation unit, the array type becomes complete; the array type at those two points is the same type. The
42) By using, for example, the library functions (17.6.1.2) std::memcpy or std::memmove.
43) By using, for example, the library functions (17.6.1.2) std::memcpy or std::memmove.
44) The intent is that the memory model of C++ is compatible with that of ISO/IEC 9899 Programming Language C.
45) The size and layout of an instance of an incompletely-deﬁned object type is unknown.

§ 3.9

73

c(cid:13) ISO/IEC

N4296

declared type of an array object might be an array of unknown bound and therefore be incomplete at one
point in a translation unit and complete later on; the array types at those two points (“array of unknown
bound of T” and “array of N T”) are diﬀerent types. The type of a pointer to array of unknown size, or of a
type deﬁned by a typedef declaration to be an array of unknown size, cannot be completed. [ Example:

class X;
extern X* xp;
extern int arr[];
typedef int UNKA[];
UNKA* arrp;
UNKA** arrpp;

// X is an incomplete type
// xp is a pointer to an incomplete type
// the type of arr is incomplete
// UNKA is an incomplete type
// arrp is a pointer to an incomplete type

void foo() {

xp++;
arrp++;
arrpp++;

// ill-formed: X is incomplete
// ill-formed: incomplete type
// OK: sizeof UNKA* is known

}

}

X x;
void bar() {

xp = &x;
arrp = &arr;
xp++;
arrp++;

struct X { int i; };
int

arr[10];

// now X is a complete type
// now the type of arr is complete

// OK; type is “pointer to X”
// ill-formed: diﬀerent types
// OK: X is complete
// ill-formed: UNKA can’t be completed

7

— end example ]
[ Note: The rules for declarations and expressions describe in which contexts incomplete types are prohibited.
— end note ]

8 An object type is a (possibly cv-qualiﬁed) type that is not a function type, not a reference type, and not a

void type.

9 Arithmetic types (3.9.1), enumeration types, pointer types, pointer to member types (3.9.2), std::nullptr_-
t, and cv-qualiﬁed versions of these types (3.9.3) are collectively called scalar types. Scalar types, POD classes
(Clause 9), arrays of such types and cv-qualiﬁed versions of these types (3.9.3) are collectively called POD
types. Cv-unqualiﬁed scalar types, trivially copyable class types (Clause 9), arrays of such types, and non-
volatile const-qualiﬁed versions of these types (3.9.3) are collectively called trivially copyable types. Scalar
types, trivial class types (Clause 9), arrays of such types and cv-qualiﬁed versions of these types (3.9.3) are
collectively called trivial types. Scalar types, standard-layout class types (Clause 9), arrays of such types
and cv-qualiﬁed versions of these types (3.9.3) are collectively called standard-layout types.

10 A type is a literal type if it is:

(10.1)

(10.2)

(10.3)

(10.4)

(10.5)

—
—
—
—
—

void; or
a scalar type; or
a reference type; or
an array of literal type; or
a class type (Clause 9) that has all of the following properties:

§ 3.9

74

c(cid:13) ISO/IEC

N4296

(10.5.1)

(10.5.2)

(10.5.3)

—
—

—

it has a trivial destructor,
it is an aggregate type (8.5.1) or has at least one constexpr constructor or constructor template
that is not a copy or move constructor, and
all of its non-static data members and base classes are of non-volatile literal types.

11 Two types cv1 T1 and cv2 T2 are layout-compatible types if T1 and T2 are the same type, layout-compatible

enumerations (7.2), or layout-compatible standard-layout class types (9.2).
3.9.1 Fundamental types

[basic.fundamental]
1 Objects declared as characters (char) shall be large enough to store any member of the implementation’s basic
character set. If a character from this set is stored in a character object, the integral value of that character
object is equal to the value of the single character literal form of that character.
It is implementation-
deﬁned whether a char object can hold negative values. Characters can be explicitly declared unsigned or
signed. Plain char, signed char, and unsigned char are three distinct types, collectively called narrow
character types. A char, a signed char, and an unsigned char occupy the same amount of storage and
have the same alignment requirements (3.11); that is, they have the same object representation. For narrow
character types, all bits of the object representation participate in the value representation. For unsigned
narrow character types, each possible bit pattern of the value representation represents a distinct number.
These requirements do not hold for other types. In any particular implementation, a plain char object can
take on either the same values as a signed char or an unsigned char; which one is implementation-deﬁned.
For each value i of type unsigned char in the range 0 to 255 inclusive, there exists a value j of type char
such that the result of an integral conversion (4.7) from i to char is j, and the result of an integral conversion
from j to unsigned char is i.

2 There are ﬁve standard signed integer types : “signed char”, “short int”, “int”, “long int”, and “long
In this list, each type provides at least as much storage as those preceding it in the list.
long int”.
There may also be implementation-deﬁned extended signed integer types. The standard and extended signed
integer types are collectively called signed integer types. Plain ints have the natural size suggested by the
architecture of the execution environment46; the other signed integer types are provided to meet special
needs.

3 For each of the standard signed integer types, there exists a corresponding (but diﬀerent) standard un-
signed integer type: “unsigned char”, “unsigned short int”, “unsigned int”, “unsigned long int”,
and “unsigned long long int”, each of which occupies the same amount of storage and has the same
alignment requirements (3.11) as the corresponding signed integer type47; that is, each signed integer type
has the same object representation as its corresponding unsigned integer type. Likewise, for each of the
extended signed integer types there exists a corresponding extended unsigned integer type with the same
amount of storage and alignment requirements. The standard and extended unsigned integer types are
collectively called unsigned integer types. The range of non-negative values of a signed integer type is a
subrange of the corresponding unsigned integer type, and the value representation of each corresponding
signed/unsigned type shall be the same. The standard signed integer types and standard unsigned integer
types are collectively called the standard integer types, and the extended signed integer types and extended
unsigned integer types are collectively called the extended integer types. The signed and unsigned integer
types shall satisfy the constraints given in the C standard, section 5.2.4.2.1.

4 Unsigned integers shall obey the laws of arithmetic modulo 2n where n is the number of bits in the value

representation of that particular size of integer.48
46) that is, large enough to contain any value in the range of INT_MIN and INT_MAX, as deﬁned in the header <climits>.
47) See 7.1.6.2 regarding the correspondence between types and the sequences of type-speciﬁers that designate them.
48) This implies that unsigned arithmetic does not overﬂow because a result that cannot be represented by the resulting
unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the
resulting unsigned integer type.

§ 3.9.1

75

c(cid:13) ISO/IEC

N4296

5 Type wchar_t is a distinct type whose values can represent distinct codes for all members of the largest
extended character set speciﬁed among the supported locales (22.3.1). Type wchar_t shall have the same
size, signedness, and alignment requirements (3.11) as one of the other integral types, called its underlying
type. Types char16_t and char32_t denote distinct types with the same size, signedness, and alignment as
uint_least16_t and uint_least32_t, respectively, in <cstdint>, called the underlying types.

6 Values of type bool are either true or false.49 [ Note: There are no signed, unsigned, short, or long

bool types or values. — end note ] Values of type bool participate in integral promotions (4.5).

7 Types bool, char, char16_t, char32_t, wchar_t, and the signed and unsigned integer types are collectively
called integral types.50 A synonym for integral type is integer type. The representations of integral types
shall deﬁne values by use of a pure binary numeration system.51 [ Example: this International Standard
permits 2’s complement, 1’s complement and signed magnitude representations for integral types. — end
example ]

8 There are three ﬂoating point types: float, double, and long double. The type double provides at least
as much precision as float, and the type long double provides at least as much precision as double.
The set of values of the type float is a subset of the set of values of the type double; the set of values
of the type double is a subset of the set of values of the type long double. The value representation of
ﬂoating-point types is implementation-deﬁned. Integral and ﬂoating types are collectively called arithmetic
types. Specializations of the standard template std::numeric_limits (18.3) shall specify the maximum
and minimum values of each arithmetic type for an implementation.

9 The void type has an empty set of values. The void type is an incomplete type that cannot be completed. It
is used as the return type for functions that do not return a value. Any expression can be explicitly converted
to type cv void (5.4). An expression of type void shall be used only as an expression statement (6.2), as an
operand of a comma expression (5.19), as a second or third operand of ?: (5.16), as the operand of typeid,
noexcept, or decltype, as the expression in a return statement (6.6.3) for a function with the return type
void, or as the operand of an explicit conversion to type cv void.

11

10 A value of type std::nullptr_t is a null pointer constant (4.10). Such values participate in the pointer and
the pointer to member conversions (4.10, 4.11). sizeof(std::nullptr_t) shall be equal to sizeof(void*).
[ Note: Even if the implementation deﬁnes two or more basic types to have the same value representation,
they are nevertheless diﬀerent types. — end note ]
3.9.2 Compound types

[basic.compound]

1 Compound types can be constructed in the following ways:

(1.1)

(1.2)

(1.3)

(1.4)

(1.4.1)

(1.4.2)

—
—

—
—

arrays of objects of a given type, 8.3.4;
functions, which have parameters of given types and return void or references or objects of a given
type, 8.3.5;
pointers to void or objects or functions (including static members of classes) of a given type, 8.3.1;
references to objects or functions of a given type, 8.3.2. There are two types of references:
—
—

lvalue reference
rvalue reference

49) Using a bool value in ways described by this International Standard as “undeﬁned,” such as by examining the value of an
uninitialized automatic object, might cause it to behave as if it is neither true nor false.
50) Therefore, enumerations (7.2) are not integral; however, enumerations can be promoted to integral types as speciﬁed in 4.5.
51) A positional representation for integers that uses the binary digits 0 and 1, in which the values represented by successive
bits are additive, begin with 1, and are multiplied by successive integral power of 2, except perhaps for the bit with the highest
position. (Adapted from the American National Dictionary for Information Processing Systems.)

§ 3.9.2

76

c(cid:13) ISO/IEC

N4296

(1.5)

(1.6)

(1.7)

(1.8)

—

—
—

—

classes containing a sequence of objects of various types (Clause 9), a set of types, enumerations and
functions for manipulating these objects (9.3), and a set of restrictions on the access to these entities
(Clause 11);
unions, which are classes capable of containing objects of diﬀerent types at diﬀerent times, 9.5;
enumerations, which comprise a set of named constant values. Each distinct enumeration constitutes
a diﬀerent enumerated type, 7.2;
pointers to non-static 52 class members, which identify members of a given type within objects of a
given class, 8.3.3.

2 These methods of constructing types can be applied recursively; restrictions are mentioned in 8.3.1, 8.3.4,
8.3.5, and 8.3.2. Constructing a type such that the number of bytes in its object representation exceeds the
maximum value representable in the type std::size_t (18.2) is ill-formed.

3 The type of a pointer to void or a pointer to an object type is called an object pointer type. [ Note: A pointer
to void does not have a pointer-to-object type, however, because void is not an object type. — end note ]
The type of a pointer that can designate a function is called a function pointer type. A pointer to objects
of type T is referred to as a “pointer to T.” [ Example: a pointer to an object of type int is referred to as
“pointer to int ” and a pointer to an object of class X is called a “pointer to X.” — end example ] Except
for pointers to static members, text referring to “pointers” does not apply to pointers to members. Pointers
to incomplete types are allowed although there are restrictions on what can be done with them (3.11).
A valid value of an object pointer type represents either the address of a byte in memory (1.7) or a null
pointer (4.10). If an object of type T is located at an address A, a pointer of type cv T* whose value is the
address A is said to point to that object, regardless of how the value was obtained.
[ Note: For instance,
the address one past the end of an array (5.7) would be considered to point to an unrelated object of the
array’s element type that might be located at that address. There are further restrictions on pointers to
objects with dynamic storage duration; see 3.7.4.3. — end note ] The value representation of pointer types
is implementation-deﬁned. Pointers to layout-compatible types shall have the same value representation and
alignment requirements (3.11). [ Note: Pointers to over-aligned types (3.11) have no special representation,
but their range of valid values is restricted by the extended alignment requirement. This International
Standard speciﬁes only two ways of obtaining such a pointer: taking the address of a valid object with
an over-aligned type, and using one of the runtime pointer alignment functions. An implementation may
provide other means of obtaining a valid pointer value for an over-aligned type. — end note ]

4 A pointer to cv-qualiﬁed (3.9.3) or cv-unqualiﬁed void can be used to point to objects of unknown type.
Such a pointer shall be able to hold any object pointer. An object of type cv void* shall have the same
representation and alignment requirements as cv char*.
3.9.3 CV-qualiﬁers

[basic.type.qualiﬁer]
1 A type mentioned in 3.9.1 and 3.9.2 is a cv-unqualiﬁed type. Each type which is a cv-unqualiﬁed complete
or incomplete object type or is void (3.9) has three corresponding cv-qualiﬁed versions of its type: a const-
qualiﬁed version, a volatile-qualiﬁed version, and a const-volatile-qualiﬁed version. The term object type (1.8)
includes the cv-qualiﬁers speciﬁed in the decl-speciﬁer-seq (7.1), declarator (Clause 8), type-id (8.1), or new-
type-id (5.3.4) when the object is created.

(1.1)

(1.2)

(1.3)

—
—

—

A const object is an object of type const T or a non-mutable subobject of such an object.
A volatile object is an object of type volatile T, a subobject of such an object, or a mutable subobject
of a const volatile object.
A const volatile object is an object of type const volatile T, a non-mutable subobject of such an
object, a const subobject of a volatile object, or a non-mutable volatile subobject of a const object.

52) Static class members are objects or functions, and pointers to them are ordinary pointers to objects or functions.

§ 3.9.3

77

c(cid:13) ISO/IEC

N4296

The cv-qualiﬁed or cv-unqualiﬁed versions of a type are distinct types; however, they shall have the same
representation and alignment requirements (3.11).53

2 A compound type (3.9.2) is not cv-qualiﬁed by the cv-qualiﬁers (if any) of the types from which it is com-
pounded. Any cv-qualiﬁers applied to an array type aﬀect the array element type, not the array type (8.3.4).

3 See 8.3.5 and 9.3.2 regarding function types that have cv-qualiﬁers.
4 There is a partial ordering on cv-qualiﬁers, so that a type can be said to be more cv-qualiﬁed than another.

Table 8 shows the relations that constitute this ordering.

Table 8 — Relations on const and volatile

no cv-qualiﬁer <
no cv-qualiﬁer <
no cv-qualiﬁer < const volatile
< const volatile
< const volatile

volatile

const

const

volatile

5

In this International Standard, the notation cv (or cv1, cv2, etc.), used in the description of types, represents
an arbitrary set of cv-qualiﬁers, i.e., one of {const}, {volatile}, {const, volatile}, or the empty set.
For a type cv T, the top-level cv-qualiﬁers of that type are those denoted by cv.
[ Example: The type
corresponding to the type-id const int& has no top-level cv-qualiﬁers. The type corresponding to the type-
id volatile int * const has the top-level cv-qualiﬁer const. For a class type C, the type corresponding to
the type-id void (C::* volatile)(int) const has the top-level cv-qualiﬁer volatile. — end example ]
6 Cv-qualiﬁers applied to an array type attach to the underlying element type, so the notation “cv T,” where
T is an array type, refers to an array whose elements are so-qualiﬁed. An array type whose elements are
cv-qualiﬁed is also considered to have the same cv-qualiﬁcations as its elements. [ Example:

typedef char CA[5];
typedef const char CC;
CC arr1[5] = { 0 };
const CA arr2 = { 0 };

The type of both arr1 and arr2 is “array of 5 const char,” and the array type is considered to be const-
qualiﬁed. — end example ]
3.10 Lvalues and rvalues

[basic.lval]

1 Expressions are categorized according to the taxonomy in Figure 1.

Figure 1 — Expression category taxonomy

53) The same representation and alignment requirements are meant to imply interchangeability as arguments to functions,
return values from functions, and non-static data members of unions.

§ 3.10

78

expressionglvaluervaluelvaluexvalueprvaluec(cid:13) ISO/IEC

N4296

(1.1)

—

(1.2)

—

(1.3)

(1.4)

(1.5)

—
—

—

An lvalue (so called, historically, because lvalues could appear on the left-hand side of an assignment
expression) designates a function or an object. [ Example: If E is an expression of pointer type, then
*E is an lvalue expression referring to the object or function to which E points. As another example,
the result of calling a function whose return type is an lvalue reference is an lvalue. — end example ]
An xvalue (an “eXpiring” value) also refers to an object, usually near the end of its lifetime (so that its
resources may be moved, for example). Certain kinds of expressions involving rvalue references (8.3.2)
yield xvalues. [ Example: The result of calling a function whose return type is an rvalue reference to
an object type is an xvalue (5.2.2). — end example ]
A glvalue (“generalized” lvalue) is an lvalue or an xvalue.
An rvalue (so called, historically, because rvalues could appear on the right-hand side of an assignment
expression) is an xvalue, a temporary object (12.2) or subobject thereof, or a value that is not associated
with an object.
A prvalue (“pure” rvalue) is an rvalue that is not an xvalue. [ Example: The result of calling a function
whose return type is not a reference is a prvalue. The value of a literal such as 12, 7.3e5, or true is
also a prvalue. — end example ]

Every expression belongs to exactly one of the fundamental classiﬁcations in this taxonomy: lvalue, xvalue,
or prvalue. This property of an expression is called its value category. [ Note: The discussion of each built-in
operator in Clause 5 indicates the category of the value it yields and the value categories of the operands it
expects. For example, the built-in assignment operators expect that the left operand is an lvalue and that
the right operand is a prvalue and yield an lvalue as the result. User-deﬁned operators are functions, and
the categories of values they expect and yield are determined by their parameter and return types. — end
note ]

2 Whenever a glvalue appears in a context where a prvalue is expected, the glvalue is converted to a prvalue;
[ Note: An attempt to bind an rvalue reference to an lvalue is not such a context;

see 4.1, 4.2, and 4.3.
see 8.5.3. — end note ]

3 The discussion of reference initialization in 8.5.3 and of temporaries in 12.2 indicates the behavior of lvalues

and rvalues in other signiﬁcant contexts.

4 Unless otherwise indicated (5.2.2), prvalues shall always have complete types or the void type; in addition to
these types, glvalues can also have incomplete types. [ Note: class and array prvalues can have cv-qualiﬁed
types; other prvalues always have cv-unqualiﬁed types. See Clause 5. — end note ]

5 An lvalue for an object is necessary in order to modify the object except that an rvalue of class type can
also be used to modify its referent under certain circumstances. [ Example: a member function called for an
object (9.3) can modify the object. — end example ]

6 Functions cannot be modiﬁed, but pointers to functions can be modiﬁable.
7 A pointer to an incomplete type can be modiﬁable. At some point in the program when the pointed to type

is complete, the object at which the pointer points can also be modiﬁed.

9

10

8 The referent of a const-qualiﬁed expression shall not be modiﬁed (through that expression), except that if

it is of class type and has a mutable component, that component can be modiﬁed (7.1.6.1).
If an expression can be used to modify the object to which it refers, the expression is called modiﬁable. A
program that attempts to modify an object through a nonmodiﬁable lvalue or rvalue expression is ill-formed.
If a program attempts to access the stored value of an object through a glvalue of other than one of the
following types the behavior is undeﬁned:54
54) The intent of this list is to specify those circumstances in which an object may or may not be aliased.

§ 3.10

79

c(cid:13) ISO/IEC

N4296

(10.1)

(10.2)

(10.3)

(10.4)

(10.5)

(10.6)

(10.7)

(10.8)

—
—
—
—
—

—

—
—

the dynamic type of the object,
a cv-qualiﬁed version of the dynamic type of the object,
a type similar (as deﬁned in 4.4) to the dynamic type of the object,
a type that is the signed or unsigned type corresponding to the dynamic type of the object,
a type that is the signed or unsigned type corresponding to a cv-qualiﬁed version of the dynamic type
of the object,
an aggregate or union type that includes one of the aforementioned types among its elements or non-
static data members (including, recursively, an element or non-static data member of a subaggregate
or contained union),
a type that is a (possibly cv-qualiﬁed) base class type of the dynamic type of the object,
a char or unsigned char type.

3.11 Alignment

[basic.align]
1 Object types have alignment requirements (3.9.1, 3.9.2) which place restrictions on the addresses at which an
object of that type may be allocated. An alignment is an implementation-deﬁned integer value representing
the number of bytes between successive addresses at which a given object can be allocated. An object type
imposes an alignment requirement on every object of that type; stricter alignment can be requested using
the alignment speciﬁer (7.6.2).

2 A fundamental alignment is represented by an alignment less than or equal to the greatest alignment sup-
ported by the implementation in all contexts, which is equal to alignof(std::max_align_t) (18.2). The
alignment required for a type might be diﬀerent when it is used as the type of a complete object and when
it is used as the type of a subobject. [ Example:

struct B { long double d; };
struct D : virtual B { char c; }

When D is the type of a complete object, it will have a subobject of type B, so it must be aligned appropriately
for a long double. If D appears as a subobject of another object that also has B as a virtual base class, the
B subobject might be part of a diﬀerent subobject, reducing the alignment requirements on the D subobject.
— end example ] The result of the alignof operator reﬂects the alignment requirement of the type in the
complete-object case.

3 An extended alignment is represented by an alignment greater than alignof(std::max_align_t).

It is
implementation-deﬁned whether any extended alignments are supported and the contexts in which they
are supported (7.6.2). A type having an extended alignment requirement is an over-aligned type.
[ Note:
every over-aligned type is or contains a class type to which extended alignment applies (possibly through a
non-static data member). — end note ]

4 Alignments are represented as values of the type std::size_t. Valid alignments include only those values
returned by an alignof expression for the fundamental types plus an additional implementation-deﬁned set
of values, which may be empty. Every alignment value shall be a non-negative integral power of two.

5 Alignments have an order from weaker to stronger or stricter alignments. Stricter alignments have larger
alignment values. An address that satisﬁes an alignment requirement also satisﬁes any weaker valid alignment
requirement.

6 The alignment requirement of a complete type can be queried using an alignof expression (5.3.6). Further-
more, the narrow character types (3.9.1) shall have the weakest alignment requirement. [ Note: This enables

§ 3.11

80

c(cid:13) ISO/IEC

N4296

the narrow character types to be used as the underlying type for an aligned memory area (7.6.2). — end
note ]

(7.1)

(7.2)

7 Comparing alignments is meaningful and provides the obvious results:
Two alignments are equal when their numeric values are equal.
Two alignments are diﬀerent when their numeric values are not equal.
When an alignment is larger than another it represents a stricter alignment.

—
—
—

(7.3)

8

9

[ Note: The runtime pointer alignment function (20.7.5) can be used to obtain an aligned pointer within a
buﬀer; the aligned-storage templates in the library (20.10.7.6) can be used to obtain aligned storage. — end
note ]
If a request for a speciﬁc extended alignment in a speciﬁc context is not supported by an implementation,
the program is ill-formed. Additionally, a request for runtime allocation of dynamic storage for which the
requested alignment cannot be honored shall be treated as an allocation failure.

§ 3.11

81

c(cid:13) ISO/IEC

4 Standard conversions

N4296

[conv]

1 Standard conversions are implicit conversions with built-in meaning. Clause 4 enumerates the full set of such

conversions. A standard conversion sequence is a sequence of standard conversions in the following order:

(1.1)

(1.2)

(1.3)

2

(2.1)

(2.2)

(2.3)

(2.4)

—

—

—

Zero or one conversion from the following set: lvalue-to-rvalue conversion, array-to-pointer conversion,
and function-to-pointer conversion.
Zero or one conversion from the following set: integral promotions, ﬂoating point promotion, integral
conversions, ﬂoating point conversions, ﬂoating-integral conversions, pointer conversions, pointer to
member conversions, and boolean conversions.
Zero or one qualiﬁcation conversion.

[ Note: A standard conversion sequence can be empty, i.e., it can consist of no conversions. — end note ]
A standard conversion sequence will be applied to an expression if necessary to convert it to a required
destination type.
[ Note: expressions with a given type will be implicitly converted to other types in several contexts:

—

—

—
—

When used as operands of operators. The operator’s requirements for its operands dictate the desti-
nation type (Clause 5).
When used in the condition of an if statement or iteration statement (6.4, 6.5). The destination type
is bool.
When used in the expression of a switch statement. The destination type is integral (6.4).
When used as the source expression for an initialization (which includes use as an argument in a
function call and use as the expression in a return statement). The type of the entity being initialized
is (generally) the destination type. See 8.5, 8.5.3.

— end note ]

3 An expression e can be implicitly converted to a type T if and only if the declaration T t=e; is well-formed,

for some invented temporary variable t (8.5).

4 Certain language constructs require that an expression be converted to a Boolean value. An expression e
appearing in such a context is said to be contextually converted to bool and is well-formed if and only if the
declaration bool t(e); is well-formed, for some invented temporary variable t (8.5).

5 Certain language constructs require conversion to a value having one of a speciﬁed set of types appropriate
to the construct. An expression e of class type E appearing in such a context is said to be contextually
implicitly converted to a speciﬁed type T and is well-formed if and only if e can be implicitly converted to
a type T that is determined as follows: E is searched for conversion functions whose return type is cv T or
reference to cv T such that T is allowed by the context. There shall be exactly one such T.

6 The eﬀect of any implicit conversion is the same as performing the corresponding declaration and initializa-
tion and then using the temporary variable as the result of the conversion. The result is an lvalue if T is an
lvalue reference type or an rvalue reference to function type (8.3.2), an xvalue if T is an rvalue reference to
object type, and a prvalue otherwise. The expression e is used as a glvalue if and only if the initialization
uses it as a glvalue.
[ Note: For class types, user-deﬁned conversions are considered as well; see 12.3. In general, an implicit con-
version sequence (13.3.3.1) consists of a standard conversion sequence followed by a user-deﬁned conversion
followed by another standard conversion sequence. — end note ]

7

Standard conversions

82

c(cid:13) ISO/IEC

N4296

8

[ Note: There are some contexts where certain conversions are suppressed. For example, the lvalue-to-
rvalue conversion is not done on the operand of the unary & operator. Speciﬁc exceptions are given in the
descriptions of those operators and contexts. — end note ]
4.1 Lvalue-to-rvalue conversion

[conv.lval]
1 A glvalue (3.10) of a non-function, non-array type T can be converted to a prvalue.55 If T is an incomplete
If T is a non-class type, the type of the

type, a program that necessitates this conversion is ill-formed.
prvalue is the cv-unqualiﬁed version of T. Otherwise, the type of the prvalue is T.56

2 When an lvalue-to-rvalue conversion is applied to an expression e, and either

(2.1)

(2.2)

—
—

e is not potentially evaluated, or
the evaluation of e results in the evaluation of a member ex of the set of potential results of e, and
ex names a variable x that is not odr-used by ex (3.2),

the value contained in the referenced object is not accessed. [ Example:

struct S { int n; };
auto f() {

S x { 1 };
constexpr S y { 2 };
return [&](bool b) { return (b ? y : x).n; };

}
auto g = f();
int m = g(false); // undeﬁned behavior due to access of x.n outside its lifetime
int n = g(true); // OK, does not access y.n

— end example ] In all other cases, the result of the conversion is determined according to the following
rules:
—
—

If T is (possibly cv-qualiﬁed) std::nullptr_t, the result is a null pointer constant (4.10).
Otherwise, if T has a class type, the conversion copy-initializes a temporary of type T from the glvalue
and the result of the conversion is a prvalue for the temporary.
Otherwise, if the object to which the glvalue refers contains an invalid pointer value (3.7.4.2, 3.7.4.3),
the behavior is implementation-deﬁned.
Otherwise, the value contained in the object indicated by the glvalue is the prvalue result.

—

—

(2.3)

(2.4)

(2.5)

(2.6)

3

[ Note: See also 3.10. — end note ]
4.2 Array-to-pointer conversion

[conv.array]
1 An lvalue or rvalue of type “array of N T” or “array of unknown bound of T” can be converted to a prvalue

of type “pointer to T”. The result is a pointer to the ﬁrst element of the array.
4.3 Function-to-pointer conversion

[conv.func]
1 An lvalue of function type T can be converted to a prvalue of type “pointer to T.” The result is a pointer to

2

the function.57
[ Note: See 13.4 for additional rules for the case where the function is overloaded. — end note ]
55) For historical reasons, this conversion is called the “lvalue-to-rvalue” conversion, even though that name does not accurately
reﬂect the taxonomy of expressions described in 3.10.
56) In C++ class prvalues can have cv-qualiﬁed types (because they are objects). This diﬀers from ISO C, in which non-lvalues
never have cv-qualiﬁed types.
57) This conversion never applies to non-static member functions because an lvalue that refers to a non-static member function
cannot be obtained.

§ 4.3

83

c(cid:13) ISO/IEC

4.4 Qualiﬁcation conversions

1 A cv-decomposition of a type T is a sequence of cvi and Pi such that

T is “cv0 P0 cv1 P1 ··· cvn−1 Pn−1 cvn U” for n > 0,

N4296

[conv.qual]

where each cvi is a set of cv-qualiﬁers (3.9.3), and each Pi is “pointer to” (8.3.1), “pointer to member of class
Ci of type” (8.3.3), “array of Ni”, or “array of unknown bound of” (8.3.4). If Pi designates an array, the
cv-qualiﬁers cvi+1 on the element type are also taken as the cv-qualiﬁers cvi of the array.
[ Example: The
type denoted by the type-id const int ** has two cv-decompositions, taking U as “int” and as “pointer to
const int”. — end example ] The n-tuple of cv-qualiﬁers after the ﬁrst one in the longest cv-decomposition
of T, that is, cv1, cv2, ··· , cvn, is called the cv-qualiﬁcation signature of T.

2 Two types T1 and T2 are similar if they have cv-decompositions with the same n such that corresponding

Pi components are the same and the types denoted by U are the same.

3 A prvalue expression of type T1 can be converted to type T2 if the following conditions are satisﬁed, where cvj

i

denotes the cv-qualiﬁers in the cv-qualiﬁcation signature of Tj

58:

(3.1)

(3.2)

(3.3)

—
—
—

T1 and T2 are similar.
For every i > 0, if const is in cv1
If the cv1

i and cv2

i then const is in cv2

i , and similarly for volatile.

i are diﬀerent, then const is in every cv2

k for 0 < k < i.

[ Note: if a program could assign a pointer of type T** to a pointer of type const T** (that is, if line #1
below were allowed), a program could inadvertently modify a const object (as it is done on line #2). For
example,

int main() {

const char c = ’c’;
char* pc;
const char** pcc = &pc;
*pcc = &c;
*pc = ’C’;

}

// #1: not allowed

// #2: modiﬁes a const object

4

5

6

— end note ]
[ Note: A prvalue of type “pointer to cv1 T” can be converted to a prvalue of type “pointer to cv2 T” if “cv2
T” is more cv-qualiﬁed than “cv1 T”. — end note ]
[ Note: A prvalue of type “pointer to member of X of type cv1 T” can be converted to a prvalue of type
“pointer to member of X of type cv2 T” if “cv2 T” is more cv-qualiﬁed than “cv1 T”. — end note ]
[ Note: Function types (including those used in pointer to member function types) are never cv-qualiﬁed (8.3.5).
— end note ]
4.5

[conv.prom]
1 A prvalue of an integer type other than bool, char16_t, char32_t, or wchar_t whose integer conversion
rank (4.13) is less than the rank of int can be converted to a prvalue of type int if int can represent all
the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type unsigned
int.

Integral promotions

2 A prvalue of type char16_t, char32_t, or wchar_t (3.9.1) can be converted to a prvalue of the ﬁrst of
the following types that can represent all the values of its underlying type: int, unsigned int, long int,
unsigned long int, long long int, or unsigned long long int. If none of the types in that list can
58) These rules ensure that const-safety is preserved by the conversion.

§ 4.5

84

c(cid:13) ISO/IEC

N4296

represent all the values of its underlying type, a prvalue of type char16_t, char32_t, or wchar_t can be
converted to a prvalue of its underlying type.

3 A prvalue of an unscoped enumeration type whose underlying type is not ﬁxed (7.2) can be converted to a
prvalue of the ﬁrst of the following types that can represent all the values of the enumeration (i.e., the values
in the range bmin to bmax as described in 7.2): int, unsigned int, long int, unsigned long int, long
long int, or unsigned long long int. If none of the types in that list can represent all the values of
the enumeration, a prvalue of an unscoped enumeration type can be converted to a prvalue of the extended
integer type with lowest integer conversion rank (4.13) greater than the rank of long long in which all the
values of the enumeration can be represented. If there are two such extended types, the signed one is chosen.
4 A prvalue of an unscoped enumeration type whose underlying type is ﬁxed (7.2) can be converted to a
prvalue of its underlying type. Moreover, if integral promotion can be applied to its underlying type, a
prvalue of an unscoped enumeration type whose underlying type is ﬁxed can also be converted to a prvalue
of the promoted underlying type.

5 A prvalue for an integral bit-ﬁeld (9.6) can be converted to a prvalue of type int if int can represent all
the values of the bit-ﬁeld; otherwise, it can be converted to unsigned int if unsigned int can represent
all the values of the bit-ﬁeld. If the bit-ﬁeld is larger yet, no integral promotion applies to it. If the bit-ﬁeld
has an enumerated type, it is treated as any other value of that type for promotion purposes.

6 A prvalue of type bool can be converted to a prvalue of type int, with false becoming zero and true

becoming one.

7 These conversions are called integral promotions.

4.6 Floating point promotion

[conv.fpprom]

1 A prvalue of type float can be converted to a prvalue of type double. The value is unchanged.
2 This conversion is called ﬂoating point promotion.

4.7 Integral conversions

[conv.integral]
1 A prvalue of an integer type can be converted to a prvalue of another integer type. A prvalue of an unscoped

2

3

4

enumeration type can be converted to a prvalue of an integer type.
If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source
integer (modulo 2n where n is the number of bits used to represent the unsigned type). [ Note: In a two’s
complement representation, this conversion is conceptual and there is no change in the bit pattern (if there
is no truncation). — end note ]
If the destination type is signed, the value is unchanged if it can be represented in the destination type;
otherwise, the value is implementation-deﬁned.
If the destination type is bool, see 4.12. If the source type is bool, the value false is converted to zero and
the value true is converted to one.

5 The conversions allowed as integral promotions are excluded from the set of integral conversions.

4.8 Floating point conversions

1 A prvalue of ﬂoating point type can be converted to a prvalue of another ﬂoating point type.

[conv.double]
If the
source value can be exactly represented in the destination type, the result of the conversion is that exact
representation. If the source value is between two adjacent destination values, the result of the conversion
is an implementation-deﬁned choice of either of those values. Otherwise, the behavior is undeﬁned.

2 The conversions allowed as ﬂoating point promotions are excluded from the set of ﬂoating point conversions.

§ 4.8

85

c(cid:13) ISO/IEC

N4296

4.9 Floating-integral conversions

[conv.fpint]
1 A prvalue of a ﬂoating point type can be converted to a prvalue of an integer type. The conversion trun-
cates; that is, the fractional part is discarded. The behavior is undeﬁned if the truncated value cannot be
represented in the destination type. [ Note: If the destination type is bool, see 4.12. — end note ]

2 A prvalue of an integer type or of an unscoped enumeration type can be converted to a prvalue of a ﬂoating
point type. The result is exact if possible. If the value being converted is in the range of values that can
be represented but the value cannot be represented exactly, it is an implementation-deﬁned choice of either
the next lower or higher representable value.
[ Note: Loss of precision occurs if the integral value cannot
be represented exactly as a value of the ﬂoating type. — end note ] If the value being converted is outside
the range of values that can be represented, the behavior is undeﬁned. If the source type is bool, the value
false is converted to zero and the value true is converted to one.
4.10 Pointer conversions

[conv.ptr]
1 A null pointer constant is an integer literal (2.13.2) with value zero or a prvalue of type std::nullptr_t.
A null pointer constant can be converted to a pointer type; the result is the null pointer value of that type
and is distinguishable from every other value of object pointer or function pointer type. Such a conversion
is called a null pointer conversion. Two null pointer values of the same type shall compare equal. The
conversion of a null pointer constant to a pointer to cv-qualiﬁed type is a single conversion, and not the
sequence of a pointer conversion followed by a qualiﬁcation conversion (4.4). A null pointer constant of
integral type can be converted to a prvalue of type std::nullptr_t. [ Note: The resulting prvalue is not a
null pointer value. — end note ]

2 A prvalue of type “pointer to cv T,” where T is an object type, can be converted to a prvalue of type “pointer
to cv void”. The result of converting a non-null pointer value of a pointer to object type to a “pointer to
cv void” represents the address of the same byte in memory as the original pointer value. The null pointer
value is converted to the null pointer value of the destination type.

3 A prvalue of type “pointer to cv D”, where D is a class type, can be converted to a prvalue of type “pointer
to cv B”, where B is a base class (Clause 10) of D. If B is an inaccessible (Clause 11) or ambiguous (10.2)
base class of D, a program that necessitates this conversion is ill-formed. The result of the conversion is a
pointer to the base class subobject of the derived class object. The null pointer value is converted to the
null pointer value of the destination type.
4.11 Pointer to member conversions

[conv.mem]
1 A null pointer constant (4.10) can be converted to a pointer to member type; the result is the null member
pointer value of that type and is distinguishable from any pointer to member not created from a null pointer
constant. Such a conversion is called a null member pointer conversion. Two null member pointer values
of the same type shall compare equal. The conversion of a null pointer constant to a pointer to member of
cv-qualiﬁed type is a single conversion, and not the sequence of a pointer to member conversion followed by
a qualiﬁcation conversion (4.4).

2 A prvalue of type “pointer to member of B of type cv T”, where B is a class type, can be converted to a
prvalue of type “pointer to member of D of type cv T”, where D is a derived class (Clause 10) of B. If B is an
inaccessible (Clause 11), ambiguous (10.2), or virtual (10.1) base class of D, or a base class of a virtual base
class of D, a program that necessitates this conversion is ill-formed. The result of the conversion refers to
the same member as the pointer to member before the conversion took place, but it refers to the base class
member as if it were a member of the derived class. The result refers to the member in D’s instance of B.
Since the result has type “pointer to member of D of type cv T”, indirection through it with a D object is
valid. The result is the same as if indirecting through the pointer to member of B with the B subobject of
D. The null member pointer value is converted to the null member pointer value of the destination type.59
59) The rule for conversion of pointers to members (from pointer to member of base to pointer to member of derived) appears

§ 4.11

86

c(cid:13) ISO/IEC

N4296

4.12 Boolean conversions

[conv.bool]
1 A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a
prvalue of type bool. A zero value, null pointer value, or null member pointer value is converted to false;
any other value is converted to true. For direct-initialization (8.5), a prvalue of type std::nullptr_t can
be converted to a prvalue of type bool; the resulting value is false.
4.13 Integer conversion rank

[conv.rank]

1 Every integer type has an integer conversion rank deﬁned as follows:

(1.1)

(1.2)

(1.3)

(1.4)

(1.5)

(1.6)

(1.7)

(1.8)

(1.9)

(1.10)

—

—

—

—
—

—
—
—
—

—

No two signed integer types other than char and signed char (if char is signed) shall have the same
rank, even if they have the same representation.
The rank of a signed integer type shall be greater than the rank of any signed integer type with a
smaller size.
The rank of long long int shall be greater than the rank of long int, which shall be greater than
the rank of int, which shall be greater than the rank of short int, which shall be greater than the
rank of signed char.
The rank of any unsigned integer type shall equal the rank of the corresponding signed integer type.
The rank of any standard integer type shall be greater than the rank of any extended integer type
with the same size.
The rank of char shall equal the rank of signed char and unsigned char.
The rank of bool shall be less than the rank of all other standard integer types.
The ranks of char16_t, char32_t, and wchar_t shall equal the ranks of their underlying types (3.9.1).
The rank of any extended signed integer type relative to another extended signed integer type with
the same size is implementation-deﬁned, but still subject to the other rules for determining the integer
conversion rank.
For all integer types T1, T2, and T3, if T1 has greater rank than T2 and T2 has greater rank than T3,
then T1 shall have greater rank than T3.

[ Note: The integer conversion rank is used in the deﬁnition of the integral promotions (4.5) and the usual
arithmetic conversions (Clause 5). — end note ]

inverted compared to the rule for pointers to objects (from pointer to derived to pointer to base) (4.10, Clause 10). This
inversion is necessary to ensure type safety. Note that a pointer to member is not an object pointer or a function pointer and
the rules for conversions of such pointers do not apply to pointers to members. In particular, a pointer to member cannot be
converted to a void*.

§ 4.13

87

c(cid:13) ISO/IEC

5 Expressions

N4296

[expr]

1

2

[ Note: Clause 5 deﬁnes the syntax, order of evaluation, and meaning of expressions.60 An expression is a
sequence of operators and operands that speciﬁes a computation. An expression can result in a value and
can cause side eﬀects. — end note ]
[ Note: Operators can be overloaded, that is, given meaning when applied to expressions of class type (Clause
9) or enumeration type (7.2). Uses of overloaded operators are transformed into function calls as described
in 13.5. Overloaded operators obey the rules for syntax speciﬁed in Clause 5, but the requirements of
operand type, value category, and evaluation order are replaced by the rules for function call. Relations
between operators, such as ++a meaning a+=1, are not guaranteed for overloaded operators (13.5), and are
not guaranteed for operands of type bool. — end note ]

3 Clause 5 deﬁnes the eﬀects of operators when applied to types for which they have not been overloaded.
Operator overloading shall not modify the rules for the built-in operators, that is, for operators applied to
types for which they are deﬁned by this Standard. However, these built-in operators participate in overload
resolution, and as part of that process user-deﬁned conversions will be considered where necessary to convert
the operands to types appropriate for the built-in operator. If a built-in operator is selected, such conversions
will be applied to the operands before the operation is considered further according to the rules in Clause 5;
see 13.3.1.2, 13.6.
If during the evaluation of an expression, the result is not mathematically deﬁned or not in the range of
representable values for its type, the behavior is undeﬁned. [ Note: most existing implementations of C++
ignore integer overﬂows. Treatment of division by zero, forming a remainder using a zero divisor, and all
ﬂoating point exceptions vary among machines, and is usually adjustable by a library function. — end note ]
If an expression initially has the type “reference to T” (8.3.2, 8.5.3), the type is adjusted to T prior to
any further analysis. The expression designates the object or function denoted by the reference, and the
expression is an lvalue or an xvalue, depending on the expression.
If a prvalue initially has the type “cv T,” where T is a cv-unqualiﬁed non-class, non-array type, the type of
the expression is adjusted to T prior to any further analysis.
[ Note: An expression is an xvalue if it is:

6

7

4

5

(7.1)

(7.2)

(7.3)

(7.4)

—

—
—

—

the result of calling a function, whether implicitly or explicitly, whose return type is an rvalue reference
to object type,
a cast to an rvalue reference to object type,
a class member access expression designating a non-static data member of non-reference type in which
the object expression is an xvalue, or
a .* pointer-to-member expression in which the ﬁrst operand is an xvalue and the second operand is
a pointer to data member.

In general, the eﬀect of this rule is that named rvalue references are treated as lvalues and unnamed rvalue
references to objects are treated as xvalues; rvalue references to functions are treated as lvalues whether
named or not. — end note ]
[ Example:
60) The precedence of operators is not directly speciﬁed, but it can be derived from the syntax.

Expressions

88

c(cid:13) ISO/IEC

N4296

struct A {

int m;

};
A&& operator+(A, A);
A&& f();

A a;
A&& ar = static_cast<A&&>(a);

8

The expressions f(), f().m, static_cast<A&&>(a), and a + a are xvalues. The expression ar is an lvalue.
— end example ]
In some contexts, unevaluated operands appear (5.2.8, 5.3.3, 5.3.7, 7.1.6.2). An unevaluated operand is not
evaluated. An unevaluated operand is considered a full-expression.
[ Note: In an unevaluated operand, a
non-static class member may be named (5.1) and naming of objects or functions does not, by itself, require
that a deﬁnition be provided (3.2). — end note ]

9 Whenever a glvalue expression appears as an operand of an operator that expects a prvalue for that operand,
the lvalue-to-rvalue (4.1), array-to-pointer (4.2), or function-to-pointer (4.3) standard conversions are applied
to convert the expression to a prvalue.
[ Note: because cv-qualiﬁers are removed from the type of an
expression of non-class type when the expression is converted to a prvalue, an lvalue expression of type
const int can, for example, be used where a prvalue expression of type int is required. — end note ]

10 Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield
result types in a similar way. The purpose is to yield a common type, which is also the type of the result.
This pattern is called the usual arithmetic conversions, which are deﬁned as follows:

—

—
—
—
—

(10.1)

(10.2)

(10.3)

(10.4)

(10.5)

(10.5.1)

(10.5.2)

(10.5.3)

(10.5.4)

(10.5.5)

If either operand is of scoped enumeration type (7.2), no conversions are performed; if the other
operand does not have the same type, the expression is ill-formed.
If either operand is of type long double, the other shall be converted to long double.
Otherwise, if either operand is double, the other shall be converted to double.
Otherwise, if either operand is float, the other shall be converted to float.
Otherwise, the integral promotions (4.5) shall be performed on both operands.61 Then the following
rules shall be applied to the promoted operands:
—
—

If both operands have the same type, no further conversion is needed.
Otherwise, if both operands have signed integer types or both have unsigned integer types, the
operand with the type of lesser integer conversion rank shall be converted to the type of the
operand with greater rank.
Otherwise, if the operand that has unsigned integer type has rank greater than or equal to the
rank of the type of the other operand, the operand with signed integer type shall be converted to
the type of the operand with unsigned integer type.
Otherwise, if the type of the operand with signed integer type can represent all of the values of
the type of the operand with unsigned integer type, the operand with unsigned integer type shall
be converted to the type of the operand with signed integer type.
Otherwise, both operands shall be converted to the unsigned integer type corresponding to the
type of the operand with signed integer type.

—

—

—

61) As a consequence, operands of type bool, char16_t, char32_t, wchar_t, or an enumerated type are converted to some
integral type.

Expressions

89

c(cid:13) ISO/IEC

N4296

11

In some contexts, an expression only appears for its side eﬀects. Such an expression is called a discarded-value
expression. The expression is evaluated and its value is discarded. The array-to-pointer (4.2) and function-
to-pointer (4.3) standard conversions are not applied. The lvalue-to-rvalue conversion (4.1) is applied if and
only if the expression is a glvalue of volatile-qualiﬁed type and it is one of the following:

(11.1)

(11.2)

(11.3)

(11.4)

(11.5)

(11.6)

(11.7)

(11.8)

—
—
—
—
—
—
—

—

( expression ), where expression is one of these expressions,
id-expression (5.1.1),
subscripting (5.2.1),
class member access (5.2.5),
indirection (5.3.1),
pointer-to-member operation (5.5),
conditional expression (5.16) where both the second and the third operands are one of these expressions,
or
comma expression (5.19) where the right operand is one of these expressions.

[ Note: Using an overloaded operator causes a function call; the above covers only operators with built-in
meaning. If the lvalue is of class type, it must have a volatile copy constructor to initialize the temporary
that is the result of the lvalue-to-rvalue conversion. — end note ]

12 The values of the ﬂoating operands and the results of ﬂoating expressions may be represented in greater

precision and range than that required by the type; the types are not changed thereby.62

13 The cv-combined type of two types T1 and T2 is a type T3 similar to T1 whose cv-qualiﬁcation signature (4.4)

is:

(13.1)

(13.2)

—
—

for every j > 0, cv3,j is the union of cv1,j and cv2,j;
if the resulting cv3,j is diﬀerent from cv1,j or cv2,j, then const is added to every cv3,k for 0 < k < j.

[ Note: Given similar types T1 and T2, this construction ensures that both can be converted to T3. — end
note ] The composite pointer type of two operands p1 and p2 having types T1 and T2, respectively, where at
least one is a pointer or pointer to member type or std::nullptr_t, is:

(13.3)

(13.4)

(13.5)

(13.6)

(13.7)

(13.8)

—
—
—

—

—

if both p1 and p2 are null pointer constants, std::nullptr_t;
if either p1 or p2 is a null pointer constant, T2 or T1, respectively;
if T1 or T2 is “pointer to cv1 void” and the other type is “pointer to cv2 T”, “pointer to cv12 void”,
where cv12 is the union of cv1 and cv2;
if T1 is “pointer to cv1 C1” and T2 is “pointer to cv2 C2”, where C1 is reference-related to C2 or C2 is
reference-related to C1 (8.5.3), the cv-combined type of T1 and T2 or the cv-combined type of T2 and
T1, respectively;
if T1 is “pointer to member of C1 of type cv1 U1” and T2 is “pointer to member of C2 of type cv2 U2”
where C1 is reference-related to C2 or C2 is reference-related to C1 (8.5.3), the cv-combined type of T2
and T1 or the cv-combined type of T1 and T2, respectively;
if T1 and T2 are similar types (4.4), the cv-combined type of T1 and T2;

—
62) The cast and assignment operators must still perform their speciﬁc conversions as described in 5.4, 5.2.9 and 5.18.

Expressions

90

c(cid:13) ISO/IEC

N4296

(13.9)

—

otherwise, a program that necessitates the determination of a composite pointer type is ill-formed.

[ Example:

typedef void *p;
typedef const int *q;
typedef int **pi;
typedef const int **pci;

The composite pointer type of p and q is “pointer to const void”; the composite pointer type of pi and
pci is “pointer to const pointer to const int”. — end example ]
5.1 Primary expressions
5.1.1 General

[expr.prim]
[expr.prim.general]

primary-expression:

literal
this
( expression )
id-expression
lambda-expression
fold-expression

id-expression:

unqualiﬁed-id
qualiﬁed-id

unqualiﬁed-id:
identiﬁer
operator-function-id
conversion-function-id
literal-operator-id
~ class-name
~ decltype-speciﬁer
template-id

1 A literal is a primary expression. Its type depends on its form (2.13). A string literal is an lvalue; all other

literals are prvalues.

3

2 The keyword this names a pointer to the object for which a non-static member function (9.3.2) is invoked

or a non-static data member’s initializer (9.2) is evaluated.
If a declaration declares a member function or member function template of a class X, the expression this
is a prvalue of type “pointer to cv-qualiﬁer-seq X” between the optional cv-qualifer-seq and the end of the
function-deﬁnition, member-declarator, or declarator. It shall not appear before the optional cv-qualiﬁer-seq
and it shall not appear within the declaration of a static member function (although its type and value
category are deﬁned within a static member function as they are within a non-static member function).
[ Note: this is because declaration matching does not occur until the complete declarator is known. — end
note ] Unlike the object expression in other contexts, *this is not required to be of complete type for purposes
of class member access (5.2.5) outside the member function body. [ Note: only class members declared prior
to the declaration are visible. — end note ] [ Example:

struct A {
char g();
template<class T> auto f(T t) -> decltype(t + g())

{ return t + g(); }

};
template auto A::f(int t) -> decltype(t + g());

§ 5.1.1

91

c(cid:13) ISO/IEC

— end example ]

N4296

4 Otherwise, if a member-declarator declares a non-static data member (9.2) of a class X, the expression this
is a prvalue of type “pointer to X” within the optional brace-or-equal-initializer. It shall not appear elsewhere
in the member-declarator.

5 The expression this shall not appear in any other context. [ Example:

class Outer {

int a[sizeof(*this)];
unsigned int sz = sizeof(*this);

// error: not inside a member function
// OK: in brace-or-equal-initializer

void f() {

int b[sizeof(*this)];

// OK

struct Inner {

int c[sizeof(*this)];

};

}
};

// error: not inside a member function of Inner

— end example ]

6 A parenthesized expression is a primary expression whose type and value are identical to those of the
enclosed expression. The presence of parentheses does not aﬀect whether the expression is an lvalue. The
parenthesized expression can be used in exactly the same contexts as those where the enclosed expression
can be used, and with the same meaning, except as otherwise indicated.

7 An id-expression is a restricted form of a primary-expression.

and -> operators (5.2.5). — end note ]

[ Note: an id-expression can appear after .

8 An identiﬁer is an id-expression provided it has been suitably declared (Clause 7).

for operator-
function-ids, see 13.5; for conversion-function-ids, see 12.3.2; for literal-operator-ids, see 13.5.8; for template-
ids, see 14.2. A class-name or decltype-speciﬁer preﬁxed by ~ denotes a destructor; see 12.4. Within the
deﬁnition of a non-static member function, an identiﬁer that names a non-static member is transformed to a
class member access expression (9.3.1). — end note ] The type of the expression is the type of the identiﬁer.
The result is the entity denoted by the identiﬁer. The result is an lvalue if the entity is a function, variable,
or data member and a prvalue otherwise.

[ Note:

§ 5.1.1

92

c(cid:13) ISO/IEC

N4296

qualiﬁed-id:

nested-name-speciﬁer templateopt unqualiﬁed-id

nested-name-speciﬁer:

::
type-name ::
namespace-name ::
decltype-speciﬁer ::
nested-name-speciﬁer identiﬁer ::
nested-name-speciﬁer templateopt simple-template-id ::

The type denoted by a decltype-speciﬁer in a nested-name-speciﬁer shall be a class or enumeration type.

9 A nested-name-speciﬁer that denotes a class, optionally followed by the keyword template (14.2), and then
followed by the name of a member of either that class (9.2) or one of its base classes (Clause 10), is a
qualiﬁed-id; 3.4.3.1 describes name lookup for class members that appear in qualiﬁed-ids. The result is the
member. The type of the result is the type of the member. The result is an lvalue if the member is a static
member function or a data member and a prvalue otherwise. [ Note: a class member can be referred to using
a qualiﬁed-id at any point in its potential scope (3.3.7). — end note ] Where class-name ::~ class-name is
used, the two class-names shall refer to the same class; this notation names the destructor (12.4). The form
~ decltype-speciﬁer also denotes the destructor, but it shall not be used as the unqualiﬁed-id in a qualiﬁed-id.
[ Note: a typedef-name that names a class is a class-name (9.1). — end note ]

10 The nested-name-speciﬁer :: names the global namespace. A nested-name-speciﬁer that names a name-
space (7.3), followed by the name of a member of that namespace (or the name of a member of a namespace
made visible by a using-directive), is a qualiﬁed-id; 3.4.3.2 describes name lookup for namespace members
that appear in qualiﬁed-ids. The result is the member. The type of the result is the type of the member.
The result is an lvalue if the member is a function or a variable and a prvalue otherwise.

11 A nested-name-speciﬁer that denotes an enumeration (7.2), followed by the name of an enumerator of that
enumeration, is a qualiﬁed-id that refers to the enumerator. The result is the enumerator. The type of the
result is the type of the enumeration. The result is a prvalue.
In a qualiﬁed-id, if the unqualiﬁed-id is a conversion-function-id, its conversion-type-id shall denote the same
type in both the context in which the entire qualiﬁed-id occurs and in the context of the class denoted by
the nested-name-speciﬁer.

12

13 An id-expression that denotes a non-static data member or non-static member function of a class can only

be used:

(13.1)

(13.2)

(13.3)

—

—
—

as part of a class member access (5.2.5) in which the object expression refers to the member’s class63
or a class derived from that class, or
to form a pointer to member (5.3.1), or
if that id-expression denotes a non-static data member and it appears in an unevaluated operand.
[ Example:

struct S {

int m;

};
int i = sizeof(S::m);
int j = sizeof(S::m + 42);

// OK
// OK

— end example ]

63) This also applies when the object expression is an implicit (*this) (9.3.1).

§ 5.1.1

93

c(cid:13) ISO/IEC

N4296

5.1.2 Lambda expressions

[expr.prim.lambda]

1 Lambda expressions provide a concise way to create simple function objects. [ Example:

#include <algorithm>
#include <cmath>
void abssort(float* x, unsigned N) {

std::sort(x, x + N,

[](float a, float b) {

return std::abs(a) < std::abs(b);

});

}

— end example ]

lambda-expression:

lambda-introducer lambda-declaratoropt compound-statement

lambda-introducer:

[ lambda-captureopt]

lambda-capture:

capture-default
capture-list
capture-default , capture-list

capture-default:

&
=

capture-list:

capture ...opt
capture-list , capture ...opt

capture:

simple-capture
init-capture

simple-capture:
identiﬁer
& identiﬁer
this
init-capture:

identiﬁer initializer
& identiﬁer initializer

lambda-declarator:

( parameter-declaration-clause ) mutableopt

exception-speciﬁcationopt attribute-speciﬁer-seqopt trailing-return-typeopt

2 The evaluation of a lambda-expression results in a prvalue temporary (12.2). This temporary is called the
closure object. A lambda-expression shall not appear in an unevaluated operand (Clause 5), in a template-
argument, in an alias-declaration, in a typedef declaration, or in the declaration of a function or function
template outside its function body and default arguments. [ Note: The intention is to prevent lambdas from
appearing in a signature. — end note ] [ Note: A closure object behaves like a function object (20.9). — end
note ]

3 The type of the lambda-expression (which is also the type of the closure object) is a unique, unnamed non-
union class type — called the closure type — whose properties are described below. This class type is neither
an aggregate (8.5.1) nor a literal type (3.9). The closure type is declared in the smallest block scope, class
scope, or namespace scope that contains the corresponding lambda-expression. [ Note: This determines the
set of namespaces and classes associated with the closure type (3.4.2). The parameter types of a lambda-
declarator do not aﬀect these associated namespaces and classes. — end note ] An implementation may

§ 5.1.2

94

(3.1)

(3.2)

(3.3)

(3.4)

4

c(cid:13) ISO/IEC

N4296

deﬁne the closure type diﬀerently from what is described below provided this does not alter the observable
behavior of the program other than by changing:

—
—
—
—

the size and/or alignment of the closure type,
whether the closure type is trivially copyable (Clause 9),
whether the closure type is a standard-layout class (Clause 9), or
whether the closure type is a POD class (Clause 9).

An implementation shall not add members of rvalue reference type to the closure type.
If a lambda-expression does not include a lambda-declarator, it is as if the lambda-declarator were (). The
lambda return type is auto, which is replaced by the trailing-return-type if provided and/or deduced from
return statements as described in 7.1.6.4. [ Example:

auto x1 = [](int i){ return i; };
auto x2 = []{ return { 1, 2 }; };
int j;
auto x3 = []()->auto&& { return j; }; // OK: return type is int&

// OK: return type is int
// error: deducing return type from braced-init-list

— end example ]

5 The closure type for a non-generic lambda-expression has a public inline function call operator (13.5.4)
whose parameters and return type are described by the lambda-expression’s parameter-declaration-clause
and trailing-return-type respectively. For a generic lambda, the closure type has a public inline function call
operator member template (14.5.2) whose template-parameter-list consists of one invented type template-
parameter for each occurrence of auto in the lambda’s parameter-declaration-clause, in order of appearance.
The invented type template-parameter is a parameter pack if the corresponding parameter-declaration de-
clares a function parameter pack (8.3.5). The return type and function parameters of the function call
operator template are derived from the lambda-expression’s trailing-return-type and parameter-declaration-
clause by replacing each occurrence of auto in the decl-speciﬁers of the parameter-declaration-clause with
the name of the corresponding invented template-parameter. [ Example:

auto glambda = [](auto a, auto&& b) { return a < b; };
bool b = glambda(3, 3.14);
auto vglambda = [](auto printer) {

return [=](auto&& ... ts) {

printer(std::forward<decltype(ts)>(ts)...);

return [=]() {

printer(ts ...);

};

};

auto q = p(1, ’a’, 3.14);
q();

};
auto p = vglambda( [](auto v1, auto v2, auto v3)

{ std::cout << v1 << v2 << v3; } );

// OK

// OK: ts is a function parameter pack

// OK: outputs 1a3.14
// OK: outputs 1a3.14

— end example ] This function call operator or operator template is declared const (9.3.1) if and only if
the lambda-expression’s parameter-declaration-clause is not followed by mutable. It is neither virtual nor
declared volatile. Any exception-speciﬁcation speciﬁed on a lambda-expression applies to the corresponding
function call operator or operator template. An attribute-speciﬁer-seq in a lambda-declarator appertains to
the type of the corresponding function call operator or operator template. [ Note: Names referenced in the
lambda-declarator are looked up in the context in which the lambda-expression appears. — end note ]

§ 5.1.2

95

c(cid:13) ISO/IEC

N4296

6 The closure type for a non-generic lambda-expression with no lambda-capture has a public non-virtual non-
explicit const conversion function to pointer to function with C++ language linkage (7.5) having the same
parameter and return types as the closure type’s function call operator. The value returned by this conversion
function shall be the address of a function that, when invoked, has the same eﬀect as invoking the closure
type’s function call operator. For a generic lambda with no lambda-capture, the closure type has a public
non-virtual non-explicit const conversion function template to pointer to function. The conversion function
template has the same invented template-parameter-list, and the pointer to function has the same parameter
types, as the function call operator template. The return type of the pointer to function shall behave as
if it were a decltype-speciﬁer denoting the return type of the corresponding function call operator template
specialization. [ Note: If the generic lambda has no trailing-return-type or the trailing-return-type contains a
placeholder type, return type deduction of the corresponding function call operator template specialization
has to be done. The corresponding specialization is that instantiation of the function call operator template
with the same template arguments as those deduced for the conversion function template. Consider the
following:

auto glambda = [](auto a) { return a; };
int (*fp)(int) = glambda;

The behavior of the conversion function of glambda above is like that of the following conversion func-
tion:

struct Closure {

template<class T> auto operator()(T t) const { ... }
template<class T> static auto lambda_call_operator_invoker(T a) {

// forwards execution to operator()(a) and therefore has
// the same return type deduced
...

}
template<class T> using fptr_t =

decltype(lambda_call_operator_invoker(declval<T>())) (*)(T);

template<class T> operator fptr_t<T>() const
{ return &lambda_call_operator_invoker; }

};

— end note ] [ Example:
void f1(int (*)(int))
void f2(char (*)(int))

{ }
{ }

void g(int (*)(int))
void g(char (*)(char))

{ } // #1
{ } // #2

void h(int (*)(int))
void h(char (*)(int))

{ } // #3
{ } // #4

auto glambda = [](auto a) { return a; };
f1(glambda); // OK
f2(glambda); // error: ID is not convertible
g(glambda);
h(glambda);
int& (*fpi)(int*) = [](auto* a) -> auto& { return *a; }; // OK

// error: ambiguous
// OK: calls #3 since it is convertible from ID

— end example ] The value returned by any given specialization of this conversion function template shall
be the address of a function that, when invoked, has the same eﬀect as invoking the generic lambda’s corre-
sponding function call operator template specialization. [ Note: This will result in the implicit instantiation

§ 5.1.2

96

c(cid:13) ISO/IEC

N4296

of the generic lambda’s body. The instantiated generic lambda’s return type and parameter types shall
match the return type and parameter types of the pointer to function. — end note ] [ Example:

auto GL = [](auto a) { std::cout << a; return a; };
int (*GL_int)(int) = GL; // OK: through conversion function template
GL_int(3);

// OK: same as GL(3)

— end example ]

7 The lambda-expression’s compound-statement yields the function-body (8.4) of the function call operator,
but for purposes of name lookup (3.4), determining the type and value of this (9.3.2) and transforming id-
expressions referring to non-static class members into class member access expressions using (*this) (9.3.1),
the compound-statement is considered in the context of the lambda-expression. [ Example:

struct S1 {
int x, y;
int operator()(int);
void f() {

[=]()->int {

};

}
};

return operator()(this->x + y); // equivalent to S1::operator()(this->x + (*this).y)

// this has type S1*

8

— end example ] Further, a variable __func__ is implicitly deﬁned at the beginning of the compound-
statement of the lambda-expression, with semantics as described in 8.4.1.
If a lambda-capture includes a capture-default that is &, no identiﬁer in a simple-capture of that lambda-
capture shall be preceded by &. If a lambda-capture includes a capture-default that is =, each simple-capture
of that lambda-capture shall be of the form “& identiﬁer”. Ignoring appearances in initializers of init-captures,
an identiﬁer or this shall not appear more than once in a lambda-capture. [ Example:

struct S2 { void f(int i); };
void S2::f(int i) {

// OK
// error: i preceded by & when & is the default

[&, i]{ };
[&, &i]{ };
[=, this]{ }; // error: this when = is the default
[i, i]{ };

// error: i repeated

}

— end example ]

9 A lambda-expression whose smallest enclosing scope is a block scope (3.3.3) is a local lambda expression;
any other lambda-expression shall not have a capture-default or simple-capture in its lambda-introducer.
The reaching scope of a local lambda expression is the set of enclosing scopes up to and including the
innermost enclosing function and its parameters.
[ Note: This reaching scope includes any intervening
lambda-expressions. — end note ]

10 The identiﬁer in a simple-capture is looked up using the usual rules for unqualiﬁed name lookup (3.4.1);
each such lookup shall ﬁnd an entity. An entity that is designated by a simple-capture is said to be explicitly
captured, and shall be this or a variable with automatic storage duration declared in the reaching scope of
the local lambda expression.

11 An init-capture behaves as if it declares and explicitly captures a variable of the form “auto init-capture ;”

whose declarative region is the lambda-expression’s compound-statement, except that:

§ 5.1.2

97

c(cid:13) ISO/IEC

N4296

(11.1)

(11.2)

—

—

if the capture is by copy (see below), the non-static data member declared for the capture and the
variable are treated as two diﬀerent ways of referring to the same object, which has the lifetime of the
non-static data member, and no additional copy and destruction is performed, and
if the capture is by reference, the variable’s lifetime ends when the closure object’s lifetime ends.

[ Note: This enables an init-capture like “x = std::move(x)”; the second “x” must bind to a declaration in
the surrounding context. — end note ] [ Example:

int x = 4;
auto y = [&r = x, x = x+1]()->int {

r += 2;
return x+2;

}(); // Updates ::x to 6, and initializes y to 7.

— end example ]

12 A lambda-expression with an associated capture-default that does not explicitly capture this or a variable
with automatic storage duration (this excludes any id-expression that has been found to refer to an init-
capture’s associated non-static data member), is said to implicitly capture the entity (i.e., this or a variable)
if the compound-statement:

(12.1)

(12.2)

—
—

odr-uses (3.2) the entity, or
names the entity in a potentially-evaluated expression (3.2) where the enclosing full-expression depends
on a generic lambda parameter declared within the reaching scope of the lambda-expression.

[ Example:

void f(int, const int (&)[2] = {})
{ }
void f(const int&, const int (&)[1]) { }
void test() {

// #1
// #2

const int x = 17;
auto g = [](auto a) {

f(x); // OK: calls #1, does not capture x

auto g2 = [=](auto a) {

int selector[sizeof(a) == 1 ? 1 : 2]{};
f(x, selector); // OK: is a dependent expression, so captures x

};

};

}

— end example ] All such implicitly captured entities shall be declared within the reaching scope of the
lambda expression.
[ Note: The implicit capture of an entity by a nested lambda-expression can cause its
implicit capture by the containing lambda-expression (see below). Implicit odr-uses of this can result in
implicit capture. — end note ]

13 An entity is captured if it is captured explicitly or implicitly. An entity captured by a lambda-expression
If this is captured by a local lambda
is odr-used (3.2) in the scope containing the lambda-expression.
expression, its nearest enclosing function shall be a non-static member function.
If a lambda-expression
or an instantiation of the function call operator template of a generic lambda odr-uses (3.2) this or a
variable with automatic storage duration from its reaching scope, that entity shall be captured by the
lambda-expression. If a lambda-expression captures an entity and that entity is not deﬁned or captured in
the immediately enclosing lambda expression or function, the program is ill-formed. [ Example:

§ 5.1.2

98

c(cid:13) ISO/IEC

N4296

void f1(int i) {

int const N = 20;
auto m1 = [=]{

int const M = 30;
auto m2 = [i]{
int x[N][M];
x[0][0] = i;

};

};
struct s1 {

int f;
void work(int n) {

int m = n*n;
int j = 40;
auto m3 = [this,m] {
auto m4 = [&,j] {

int x = n;

x += m;

x += i;
x += f;

};

};

}

};

}

— end example ]

// OK: N and M are not odr-used
// OK: i is explicitly captured by m2
// and implicitly captured by m1

// error: j not captured by m3
// error: n implicitly captured by m4
// but not captured by m3
// OK: m implicitly captured by m4
// and explicitly captured by m3
// error: i is outside of the reaching scope
// OK: this captured implicitly by m4
// and explicitly by m3

14 A lambda-expression appearing in a default argument shall not implicitly or explicitly capture any entity.

[ Example:

void f2() {
int i = 1;
// ill-formed
void g1(int = ([i]{ return i; })());
// ill-formed
void g2(int = ([i]{ return 0; })());
// ill-formed
void g3(int = ([=]{ return i; })());
// OK
void g4(int = ([=]{ return 0; })());
void g5(int = ([]{ return sizeof i; })()); // OK

}

— end example ]

15 An entity is captured by copy if it is implicitly captured and the capture-default is = or if it is explicitly
captured with a capture that is not of the form & identiﬁer or & identiﬁer initializer. For each entity
captured by copy, an unnamed non-static data member is declared in the closure type. The declaration
order of these members is unspeciﬁed. The type of such a data member is the type of the corresponding
captured entity if the entity is not a reference to an object, or the referenced type otherwise. [ Note: If the
captured entity is a reference to a function, the corresponding data member is also a reference to a function.
— end note ] A member of an anonymous union shall not be captured by copy.

16 An entity is captured by reference if it is implicitly or explicitly captured but not captured by copy. It is
unspeciﬁed whether additional unnamed non-static data members are declared in the closure type for entities
captured by reference. A member of an anonymous union shall not be captured by reference.

§ 5.1.2

99

c(cid:13) ISO/IEC

N4296

17

If a lambda-expression m2 captures an entity and that entity is captured by an immediately enclosing lambda-
expression m1, then m2’s capture is transformed as follows:

(17.1)

(17.2)

—

—

if m1 captures the entity by copy, m2 captures the corresponding non-static data member of m1’s closure
type;
if m1 captures the entity by reference, m2 captures the same entity captured by m1.

[ Example: the nested lambda expressions and invocations below will output 123234.

int a = 1, b = 1, c = 1;
auto m1 = [a, &b, &c]() mutable {
auto m2 = [a, b, &c]() mutable {

std::cout << a << b << c;
a = 4; b = 4; c = 4;

};
a = 3; b = 3; c = 3;
m2();

};
a = 2; b = 2; c = 2;
m1();
std::cout << a << b << c;

— end example ]

18 Every id-expression within the compound-statement of a lambda-expression that is an odr-use (3.2) of an
entity captured by copy is transformed into an access to the corresponding unnamed data member of the
closure type. [ Note: An id-expression that is not an odr-use refers to the original entity, never to a member
of the closure type. Furthermore, such an id-expression does not cause the implicit capture of the entity.
— end note ] If this is captured, each odr-use of this is transformed into an access to the corresponding
unnamed data member of the closure type, cast (5.4) to the type of this. [ Note: The cast ensures that the
transformed expression is a prvalue. — end note ] [ Example:

void f(const int*);
void g() {

const int N = 10;
[=] {

int arr[N];
f(&N);

};

}

— end example ]

// OK: not an odr-use, refers to automatic variable
// OK: causes N to be captured; &N points to the
// corresponding member of the closure type

19 Every occurrence of decltype((x)) where x is a possibly parenthesized id-expression that names an entity
of automatic storage duration is treated as if x were transformed into an access to a corresponding data
member of the closure type that would have been declared if x were an odr-use of the denoted entity.
[ Example:

void f3() {

float x, &r = x;
[=] {

decltype(x) y1;
decltype((x)) y2 = y1; // y2 has type float const& because this lambda

// x and r are not captured (appearance in a decltype operand is not an odr-use)
// y1 has type float

decltype(r) r1 = y1;
decltype((r)) r2 = y2; // r2 has type float const&

// is not mutable and x is an lvalue
// r1 has type float& (transformation not considered)

§ 5.1.2

100

c(cid:13) ISO/IEC

};

}

— end example ]

N4296

20 The closure type associated with a lambda-expression has no default constructor and a deleted copy assign-
ment operator. It has a defaulted copy constructor and a defaulted move constructor (12.8). [ Note: These
special member functions are implicitly deﬁned as usual, and might therefore be deﬁned as deleted. — end
note ]

21 The closure type associated with a lambda-expression has an implicitly-declared destructor (12.4).
22 A member of a closure type shall not be explicitly instantiated (14.7.1), explicitly specialized (14.7.2), or

named in a friend declaration (11.3).

23 When the lambda-expression is evaluated, the entities that are captured by copy are used to direct-initialize
each corresponding non-static data member of the resulting closure object, and the non-static data members
corresponding to the init-captures are initialized as indicated by the corresponding initializer (which may
be copy- or direct-initialization). (For array members, the array elements are direct-initialized in increasing
subscript order.) These initializations are performed in the (unspeciﬁed) order in which the non-static data
members are declared.
[ Note: This ensures that the destructions will occur in the reverse order of the
constructions. — end note ]
[ Note: If an entity is implicitly or explicitly captured by reference, invoking the function call operator of
the corresponding lambda-expression after the lifetime of the entity has ended is likely to result in undeﬁned
behavior. — end note ]

24

25 A simple-capture followed by an ellipsis is a pack expansion (14.5.3). An init-capture followed by an ellipsis

is ill-formed. [ Example:

template<class... Args>
void f(Args... args) {

auto lm = [&, args...] { return g(args...); };
lm();

}

— end example ]
5.1.3 Fold expressions

[expr.prim.fold]

1 A fold expression performs a fold of a template parameter pack (14.5.3) over a binary operator.

fold-expression:

( cast-expression fold-operator ... )
( ... fold-operator cast-expression )
( cast-expression fold-operator ... fold-operator cast-expression )

fold-operator: one of

+
+=
==

-
-=
!=

*
*=
<

/
/=
>

%
%=
<=

ˆ
ˆ=
>=

&
&=
&&

|
|=
||

<<
<<=
,

>>
>>=
.*

=
->*

2 An expression of the form (... op e) where op is a fold-operator is called a unary left fold. An expression of
the form (e op ...) where op is a fold-operator is called a unary right fold. Unary left folds and unary right
folds are collectively called unary folds. In a unary fold, the cast-expression shall contain an unexpanded
parameter pack (14.5.3).

3 An expression of the form (e1 op1 ... op2 e2) where op1 and op2 are fold-operators is called a binary
fold. In a binary fold, op1 and op2 shall be the same fold-operator, and either e1 shall contain an unex-
panded parameter pack or e2 shall contain an unexpanded parameter pack, but not both. If e2 contains

§ 5.1.3

101

c(cid:13) ISO/IEC

N4296

an unexpanded parameter pack, the expression is called a binary left fold. If e1 contains an unexpanded
parameter pack, the expression is called a binary right fold. [ Example:

template<typename ...Args>
bool f(Args ...args) {

return (true && ... && args); // OK

template<typename ...Args>
bool f(Args ...args) {

}

}

return (args + ... + args); // error: both operands contain unexpanded parameter packs

[expr.post]

— end example ]
5.2 Postﬁx expressions

1 Postﬁx expressions group left-to-right.

postﬁx-expression:

primary-expression
postﬁx-expression [ expression ]
postﬁx-expression [ braced-init-list ]
postﬁx-expression ( expression-listopt)
simple-type-speciﬁer ( expression-listopt)
typename-speciﬁer ( expression-listopt)
simple-type-speciﬁer braced-init-list
typename-speciﬁer braced-init-list
postﬁx-expression . templateopt id-expression
postﬁx-expression -> templateopt id-expression
postﬁx-expression . pseudo-destructor-name
postﬁx-expression -> pseudo-destructor-name
postﬁx-expression ++
postﬁx-expression --
dynamic_cast < type-id > ( expression )
static_cast < type-id > ( expression )
reinterpret_cast < type-id > ( expression )
const_cast < type-id > ( expression )
typeid ( expression )
typeid ( type-id )

expression-list:

initializer-list

pseudo-destructor-name:

nested-name-speciﬁeropt type-name :: ~ type-name
nested-name-speciﬁer template simple-template-id :: ~ type-name
~ type-name
~ decltype-speciﬁer

2

[ Note: The > token following the type-id in a dynamic_cast, static_cast, reinterpret_cast, or const_-
cast may be the product of replacing a >> token by two consecutive > tokens (14.2). — end note ]
5.2.1 Subscripting

[expr.sub]
1 A postﬁx expression followed by an expression in square brackets is a postﬁx expression. One of the ex-
pressions shall have the type “array of T” or “pointer to T” and the other shall have unscoped enumeration
or integral type. The result is of type “T.” The type “T” shall be a completely-deﬁned object type.64 The
64) This is true even if the subscript operator is used in the following common idiom: &x[0].

§ 5.2.1

102

c(cid:13) ISO/IEC

N4296

expression E1[E2] is identical (by deﬁnition) to *((E1)+(E2)) [ Note: see 5.3 and 5.7 for details of * and
+ and 8.3.4 for details of arrays. — end note ], except that in the case of an array operand, the result is an
lvalue if that operand is an lvalue and an xvalue otherwise.

2 A braced-init-list shall not be used with the built-in subscript operator.

5.2.2 Function call

[expr.call]
1 A function call is a postﬁx expression followed by parentheses containing a possibly empty, comma-separated
list of initializer-clauses which constitute the arguments to the function. The postﬁx expression shall have
function type or pointer to function type. For a call to a non-member function or to a static member function,
the postﬁx expression shall be either an lvalue that refers to a function (in which case the function-to-pointer
standard conversion (4.3) is suppressed on the postﬁx expression), or it shall have pointer to function type.
Calling a function through an expression whose function type has a language linkage that is diﬀerent from
the language linkage of the function type of the called function’s deﬁnition is undeﬁned (7.5). For a call to a
non-static member function, the postﬁx expression shall be an implicit (9.3.1, 9.4) or explicit class member
access (5.2.5) whose id-expression is a function member name, or a pointer-to-member expression (5.5)
selecting a function member; the call is as a member of the class object referred to by the object expression.
In the case of an implicit class member access, the implied object is the one pointed to by this. [ Note: a
member function call of the form f() is interpreted as (*this).f() (see 9.3.1). — end note ] If a function
or member function name is used, the name can be overloaded (Clause 13), in which case the appropriate
function shall be selected according to the rules in 13.3. If the selected function is non-virtual, or if the
id-expression in the class member access expression is a qualiﬁed-id, that function is called. Otherwise, its
ﬁnal overrider (10.3) in the dynamic type of the object expression is called; such a call is referred to as a
virtual function call. [ Note: the dynamic type is the type of the object referred to by the current value of
the object expression. 12.7 describes the behavior of virtual function calls when the object expression refers
to an object under construction or destruction. — end note ]
[ Note: If a function or member function name is used, and name lookup (3.4) does not ﬁnd a declaration of
that name, the program is ill-formed. No function is implicitly declared by such a call. — end note ]
If the postﬁx-expression designates a destructor (12.4), the type of the function call expression is void;
otherwise, the type of the function call expression is the return type of the statically chosen function (i.e.,
ignoring the virtual keyword), even if the type of the function actually called is diﬀerent. This return type
shall be an object type, a reference type or cv void.

2

3

4 When a function is called, each parameter (8.3.5) shall be initialized (8.5, 12.8, 12.1) with its corresponding
argument.
[ Note: Such initializations are indeterminately sequenced with respect to each other (1.9) —
end note ] If the function is a non-static member function, the this parameter of the function (9.3.2) shall
be initialized with a pointer to the object of the call, converted as if by an explicit type conversion (5.4).
[ Note: There is no access or ambiguity checking on this conversion; the access checking and disambiguation
are done as part of the (possibly implicit) class member access operator. See 10.2, 11.2, and 5.2.5. —
end note ] When a function is called, the parameters that have object type shall have completely-deﬁned
object type.
[ Note: this still allows a parameter to be a pointer or reference to an incomplete class type.
However, it prevents a passed-by-value parameter to have an incomplete class type. — end note ] During
the initialization of a parameter, an implementation may avoid the construction of extra temporaries by
combining the conversions on the associated argument and/or the construction of temporaries with the
initialization of the parameter (see 12.2). The lifetime of a parameter ends when the function in which it
is deﬁned returns. The initialization and destruction of each parameter occurs within the context of the
calling function.
[ Example: the access of the constructor, conversion functions or destructor is checked at
the point of call in the calling function. If a constructor or destructor for a function parameter throws an
exception, the search for a handler starts in the scope of the calling function; in particular, if the function
called has a function-try-block (Clause 15) with a handler that could handle the exception, this handler is
not considered. — end example ] The value of a function call is the value returned by the called function

§ 5.2.2

103

c(cid:13) ISO/IEC

N4296

5

except in a virtual function call if the return type of the ﬁnal overrider is diﬀerent from the return type of
the statically chosen function, the value returned from the ﬁnal overrider is converted to the return type of
the statically chosen function.
[ Note: a function can change the values of its non-const parameters, but these changes cannot aﬀect the
values of the arguments except where a parameter is of a reference type (8.3.2); if the reference is to a
const-qualiﬁed type, const_cast is required to be used to cast away the constness in order to modify
the argument’s value. Where a parameter is of const reference type a temporary object is introduced if
needed (7.1.6, 2.13, 2.13.5, 8.3.4, 12.2). In addition, it is possible to modify the values of nonconstant objects
through pointer parameters. — end note ]

6 A function can be declared to accept fewer arguments (by declaring default arguments (8.3.6)) or more
arguments (by using the ellipsis, ..., or a function parameter pack (8.3.5)) than the number of parameters
in the function deﬁnition (8.4).
[ Note: this implies that, except where the ellipsis (...) or a function
parameter pack is used, a parameter is available for each argument. — end note ]

7 When there is no parameter for a given argument, the argument is passed in such a way that the receiving
function can obtain the value of the argument by invoking va_arg (18.10). [ Note: This paragraph does not
apply to arguments passed to a function parameter pack. Function parameter packs are expanded during
template instantiation (14.5.3), thus each such argument has a corresponding parameter when a function
template specialization is actually called. — end note ] The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and
function-to-pointer (4.3) standard conversions are performed on the argument expression. An argument that
has (possibly cv-qualiﬁed) type std::nullptr_t is converted to type void* (4.10). After these conversions,
if the argument does not have arithmetic, enumeration, pointer, pointer to member, or class type, the
program is ill-formed. Passing a potentially-evaluated argument of class type (Clause 9) having a non-
trivial copy constructor, a non-trivial move constructor, or a non-trivial destructor, with no corresponding
parameter, is conditionally-supported with implementation-deﬁned semantics. If the argument has integral
or enumeration type that is subject to the integral promotions (4.5), or a ﬂoating point type that is subject
to the ﬂoating point promotion (4.6), the value of the argument is converted to the promoted type before
the call. These promotions are referred to as the default argument promotions.
[ Note: The evaluations of the postﬁx expression and of the arguments are all unsequenced relative to one
another. All side eﬀects of argument evaluations are sequenced before the function is entered (see 1.9).
— end note ]

8

9 Recursive calls are permitted, except to the main function (3.6.1).
10 A function call is an lvalue if the result type is an lvalue reference type or an rvalue reference to function

type, an xvalue if the result type is an rvalue reference to object type, and a prvalue otherwise.
If a function call is a prvalue of object type:

the operand of a decltype-speciﬁer or
the right operand of a comma operator that is the operand of a decltype-speciﬁer,

if the function call is either
—
—
a temporary object is not introduced for the prvalue. The type of the prvalue may be incomplete.
[ Note: as a result, storage is not allocated for the prvalue and it is not destroyed; thus, a class type is
not instantiated as a result of being the type of a function call in this context. This is true regardless of
whether the expression uses function call notation or operator notation (13.3.1.2). — end note ] [ Note:
unlike the rule for a decltype-speciﬁer that considers whether an id-expression is parenthesized (7.1.6.2),
parentheses have no special meaning in this context. — end note ]
otherwise, the type of the prvalue shall be complete.

—

11

(11.1)

(11.1.1)

(11.1.2)

(11.2)

—

§ 5.2.2

104

c(cid:13) ISO/IEC

N4296

5.2.3 Explicit type conversion (functional notation)

[expr.type.conv]
1 A simple-type-speciﬁer (7.1.6.2) or typename-speciﬁer (14.6) followed by a parenthesized expression-list
constructs a value of the speciﬁed type given the expression list. If the expression list is a single expression,
the type conversion expression is equivalent (in deﬁnedness, and if deﬁned in meaning) to the corresponding
cast expression (5.4). If the type speciﬁed is a class type, the class type shall be complete. If the expression
list speciﬁes more than a single value, the type shall be a class with a suitably declared constructor (8.5, 12.1),
and the expression T(x1, x2, ...) is equivalent in eﬀect to the declaration T t(x1, x2, ...); for some
invented temporary variable t, with the result being the value of t as a prvalue.

2 The expression T(), where T is a simple-type-speciﬁer or typename-speciﬁer for a non-array complete object
type or the (possibly cv-qualiﬁed) void type, creates a prvalue of the speciﬁed type, whose value is that
produced by value-initializing (8.5) an object of type T; no initialization is done for the void() case. [ Note:
if T is a non-class type that is cv-qualiﬁed, the cv-qualiﬁers are discarded when determining the type of the
resulting prvalue (Clause 5). — end note ]

3 Similarly, a simple-type-speciﬁer or typename-speciﬁer followed by a braced-init-list creates a temporary
object of the speciﬁed type direct-list-initialized (8.5.4) with the speciﬁed braced-init-list, and its value is
that temporary object as a prvalue.
5.2.4 Pseudo destructor call

[expr.pseudo]
1 The use of a pseudo-destructor-name after a dot . or arrow -> operator represents the destructor for the
non-class type denoted by type-name or decltype-speciﬁer. The result shall only be used as the operand for
the function call operator (), and the result of such a call has type void. The only eﬀect is the evaluation
of the postﬁx-expression before the dot or arrow.

2 The left-hand side of the dot operator shall be of scalar type. The left-hand side of the arrow operator shall
be of pointer to scalar type. This scalar type is the object type. The cv-unqualiﬁed versions of the object
type and of the type designated by the pseudo-destructor-name shall be the same type. Furthermore, the
two type-names in a pseudo-destructor-name of the form

nested-name-speciﬁeropt type-name :: ~ type-name

shall designate the same scalar type.
5.2.5 Class member access

[expr.ref]
1 A postﬁx expression followed by a dot . or an arrow ->, optionally followed by the keyword template (14.2),
and then followed by an id-expression, is a postﬁx expression. The postﬁx expression before the dot or arrow
is evaluated;65 the result of that evaluation, together with the id-expression, determines the result of the
entire postﬁx expression.

2 For the ﬁrst option (dot) the ﬁrst expression shall have complete class type. For the second option (arrow)
the ﬁrst expression shall have pointer to complete class type. The expression E1->E2 is converted to the
equivalent form (*(E1)).E2; the remainder of 5.2.5 will address only the ﬁrst option (dot).66 In either case,
the id-expression shall name a member of the class or of one of its base classes. [ Note: because the name
of a class is inserted in its class scope (Clause 9), the name of a class is also considered a nested member
of that class. — end note ] [ Note: 3.4.5 describes how names are looked up after the . and -> operators.
— end note ]

3 Abbreviating postﬁx-expression.id-expression as E1.E2, E1 is called the object expression. The type and
value category of E1.E2 are determined as follows. In the remainder of 5.2.5, cq represents either const
or the absence of const and vq represents either volatile or the absence of volatile. cv represents an
arbitrary set of cv-qualiﬁers, as deﬁned in 3.9.3.
65) If the class member access expression is evaluated, the subexpression evaluation happens even if the result is unnecessary
to determine the value of the entire postﬁx expression, for example if the id-expression denotes a static member.
66) Note that (*(E1)) is an lvalue.

§ 5.2.5

105

c(cid:13) ISO/IEC

N4296

4

If E2 is declared to have type “reference to T,” then E1.E2 is an lvalue; the type of E1.E2 is T. Otherwise,
one of the following rules applies.

(4.1)

(4.2)

—

—

(4.3)

—

(4.3.1)

(4.3.2)

—

If E2 is a static data member and the type of E2 is T, then E1.E2 is an lvalue; the expression designates
the named member of the class. The type of E1.E2 is T.
If E2 is a non-static data member and the type of E1 is “cq1 vq1 X”, and the type of E2 is “cq2 vq2
T”, the expression designates the named member of the object designated by the ﬁrst expression. If
E1 is an lvalue, then E1.E2 is an lvalue; otherwise E1.E2 is an xvalue. Let the notation vq12 stand
for the “union” of vq1 and vq2; that is, if vq1 or vq2 is volatile, then vq12 is volatile. Similarly,
let the notation cq12 stand for the “union” of cq1 and cq2; that is, if cq1 or cq2 is const, then cq12
is const. If E2 is declared to be a mutable member, then the type of E1.E2 is “vq12 T”. If E2 is not
declared to be a mutable member, then the type of E1.E2 is “cq12 vq12 T”.
If E2 is a (possibly overloaded) member function, function overload resolution (13.3) is used to deter-
mine whether E1.E2 refers to a static or a non-static member function.
—

If it refers to a static member function and the type of E2 is “function of parameter-type-list
returning T”, then E1.E2 is an lvalue; the expression designates the static member function. The
type of E1.E2 is the same type as that of E2, namely “function of parameter-type-list returning
T”.
Otherwise, if E1.E2 refers to a non-static member function and the type of E2 is “function of
parameter-type-list cv ref-qualiﬁeropt returning T”, then E1.E2 is a prvalue. The expression
designates a non-static member function. The expression can be used only as the left-hand
operand of a member function call (9.3). [ Note: Any redundant set of parentheses surrounding
the expression is ignored (5.1). — end note ] The type of E1.E2 is “function of parameter-type-list
cv returning T”.

—
—

If E2 is a nested type, the expression E1.E2 is ill-formed.
If E2 is a member enumerator and the type of E2 is T, the expression E1.E2 is a prvalue. The type of
E1.E2 is T.

(4.4)

(4.5)

5

1 The value of a postﬁx ++ expression is the value of its operand.

If E2 is a non-static data member or a non-static member function, the program is ill-formed if the class of
which E2 is directly a member is an ambiguous base (10.2) of the naming class (11.2) of E2.
[ Note: The
program is also ill-formed if the naming class is an ambiguous base of the class type of the object expression;
see 11.2. — end note ]
5.2.6 Increment and decrement

[expr.post.incr]
[ Note: the value obtained is a copy of
the original value — end note ] The operand shall be a modiﬁable lvalue. The type of the operand shall
be an arithmetic type or a pointer to a complete object type. The value of the operand object is modiﬁed
by adding 1 to it, unless the object is of type bool, in which case it is set to true.
[ Note: this use is
deprecated, see Annex D. — end note ] The value computation of the ++ expression is sequenced before
the modiﬁcation of the operand object. With respect to an indeterminately-sequenced function call, the
operation of postﬁx ++ is a single evaluation. [ Note: Therefore, a function call shall not intervene between
the lvalue-to-rvalue conversion and the side eﬀect associated with any single postﬁx ++ operator. — end
note ] The result is a prvalue. The type of the result is the cv-unqualiﬁed version of the type of the operand.
If the operand is a bit-ﬁeld that cannot represent the incremented value, the resulting value of the bit-ﬁeld
is implementation-deﬁned. See also 5.7 and 5.18.

2 The operand of postﬁx -- is decremented analogously to the postﬁx ++ operator, except that the operand

shall not be of type bool. [ Note: For preﬁx increment and decrement, see 5.3.2. — end note ]

§ 5.2.6

106

c(cid:13) ISO/IEC

N4296

2

5.2.7 Dynamic cast

[expr.dynamic.cast]
1 The result of the expression dynamic_cast<T>(v) is the result of converting the expression v to type T. T
shall be a pointer or reference to a complete class type, or “pointer to cv void.” The dynamic_cast operator
shall not cast away constness (5.2.11).
If T is a pointer type, v shall be a prvalue of a pointer to complete class type, and the result is a prvalue
of type T. If T is an lvalue reference type, v shall be an lvalue of a complete class type, and the result is
an lvalue of the type referred to by T. If T is an rvalue reference type, v shall be an expression having a
complete class type, and the result is an xvalue of the type referred to by T.
If the type of v is the same as T, or it is the same as T except that the class object type in T is more
cv-qualiﬁed than the class object type in v, the result is v (converted if necessary).
If the value of v is a null pointer value in the pointer case, the result is the null pointer value of type T.
If T is “pointer to cv1 B” and v has type “pointer to cv2 D” such that B is a base class of D, the result is a
pointer to the unique B subobject of the D object pointed to by v. Similarly, if T is “reference to cv1 B” and
v has type cv2 D such that B is a base class of D, the result is the unique B subobject of the D object referred
to by v. 67 The result is an lvalue if T is an lvalue reference, or an xvalue if T is an rvalue reference. In
both the pointer and reference cases, the program is ill-formed if cv2 has greater cv-qualiﬁcation than cv1
or if B is an inaccessible or ambiguous base class of D. [ Example:

3

4

5

struct B { };
struct D : B { };
void foo(D* dp) {

}

— end example ]

B*

bp = dynamic_cast<B*>(dp);

// equivalent to B* bp = dp;

6 Otherwise, v shall be a pointer to or a glvalue of a polymorphic type (10.3).
7

If T is “pointer to cv void,” then the result is a pointer to the most derived object pointed to by v. Otherwise,
a run-time check is applied to see if the object pointed or referred to by v can be converted to the type
pointed or referred to by T.
If C is the class type to which T points or refers, the run-time check logically executes as follows:

—

—

—

If, in the most derived object pointed (referred) to by v, v points (refers) to a public base class
subobject of a C object, and if only one object of type C is derived from the subobject pointed (referred)
to by v the result points (refers) to that C object.
Otherwise, if v points (refers) to a public base class subobject of the most derived object, and the
type of the most derived object has a base class, of type C, that is unambiguous and public, the result
points (refers) to the C subobject of the most derived object.
Otherwise, the run-time check fails.

8

(8.1)

(8.2)

(8.3)

9 The value of a failed cast to pointer type is the null pointer value of the required result type. A failed
cast to reference type throws an exception (15.1) of a type that would match a handler (15.3) of type
std::bad_cast (18.7.2).
[ Example:

class A { virtual void f(); };
class B { virtual void g(); };
class D : public virtual A, private B { };
void g() {

67) The most derived object (1.8) pointed or referred to by v can contain other B objects as base classes, but these are ignored.

§ 5.2.7

107

c(cid:13) ISO/IEC

N4296

d;
bp = (B*)&d;
ap = &d;
dr = dynamic_cast<D&>(*bp);

D
B*
A*
D&
ap = dynamic_cast<A*>(bp);
bp = dynamic_cast<B*>(ap);
ap = dynamic_cast<A*>(&d);
bp = dynamic_cast<B*>(&d);

}

// cast needed to break protection
// public derivation, no cast needed
// fails
// fails
// fails
// succeeds
// ill-formed (not a run-time check)

class E : public D, public B { };
class F : public E, public D { };
void h() {

F
A*
D*

f;
ap
dp

= &f;
= dynamic_cast<D*>(ap);

E*
E*

= (E*)ap;

ep
ep1 = dynamic_cast<E*>(ap);

}

// succeeds: ﬁnds unique A
// fails: yields 0
// f has two D subobjects
// ill-formed: cast from virtual base
// succeeds

— end example ] [ Note: 12.7 describes the behavior of a dynamic_cast applied to an object under construc-
tion or destruction. — end note ]
5.2.8 Type identiﬁcation

[expr.typeid]
1 The result of a typeid expression is an lvalue of static type const std::type_info (18.7.1) and dynamic type
const std::type_info or const name where name is an implementation-deﬁned class publicly derived from
std :: type_info which preserves the behavior described in 18.7.1.68 The lifetime of the object referred to by
the lvalue extends to the end of the program. Whether or not the destructor is called for the std::type_info
object at the end of the program is unspeciﬁed.

2 When typeid is applied to a glvalue expression whose type is a polymorphic class type (10.3), the result refers
to a std::type_info object representing the type of the most derived object (1.8) (that is, the dynamic
type) to which the glvalue refers. If the glvalue expression is obtained by applying the unary * operator to
a pointer69 and the pointer is a null pointer value (4.10), the typeid expression throws an exception (15.1)
of a type that would match a handler of type std::bad_typeid exception (18.7.3).

3 When typeid is applied to an expression other than a glvalue of a polymorphic class type, the result refers
to a std::type_info object representing the static type of the expression. Lvalue-to-rvalue (4.1), array-to-
pointer (4.2), and function-to-pointer (4.3) conversions are not applied to the expression. If the type of the
expression is a class type, the class shall be completely-deﬁned. The expression is an unevaluated operand
(Clause 5).

4 When typeid is applied to a type-id, the result refers to a std::type_info object representing the type of
the type-id. If the type of the type-id is a reference to a possibly cv-qualiﬁed type, the result of the typeid
expression refers to a std::type_info object representing the cv-unqualiﬁed referenced type. If the type of
the type-id is a class type or a reference to a class type, the class shall be completely-deﬁned.
If the type of the expression or type-id is a cv-qualiﬁed type, the result of the typeid expression refers to a
std::type_info object representing the cv-unqualiﬁed type. [ Example:

5

class D { /* ...
D d1;

*/ };

68) The recommended name for such a class is extended_type_info.
69) If p is an expression of pointer type, then *p, (*p), *(p), ((*p)), *((p)), and so on all meet this requirement.

§ 5.2.8

108

c(cid:13) ISO/IEC

const D d2;

typeid(d1) == typeid(d2);
typeid(D)
typeid(D)
typeid(D)

// yields true
== typeid(const D); // yields true
// yields true
== typeid(d2);
== typeid(const D&); // yields true

N4296

6

7

— end example ]
If the header <typeinfo> (18.7.1) is not included prior to a use of typeid, the program is ill-formed.
[ Note: 12.7 describes the behavior of typeid applied to an object under construction or destruction. — end
note ]
5.2.9 Static cast

[expr.static.cast]
1 The result of the expression static_cast<T>(v) is the result of converting the expression v to type T. If T
is an lvalue reference type or an rvalue reference to function type, the result is an lvalue; if T is an rvalue
reference to object type, the result is an xvalue; otherwise, the result is a prvalue. The static_cast operator
shall not cast away constness (5.2.11).

2 An lvalue of type “cv1 B,” where B is a class type, can be cast to type “reference to cv2 D,” where D is a class
derived (Clause 10) from B, if a valid standard conversion from “pointer to D” to “pointer to B” exists (4.10),
cv2 is the same cv-qualiﬁcation as, or greater cv-qualiﬁcation than, cv1, and B is neither a virtual base class
of D nor a base class of a virtual base class of D. The result has type “cv2 D.” An xvalue of type “cv1 B”
may be cast to type “rvalue reference to cv2 D” with the same constraints as for an lvalue of type “cv1 B.”
If the object of type “cv1 B” is actually a subobject of an object of type D, the result refers to the enclosing
object of type D. Otherwise, the behavior is undeﬁned. [ Example:

struct B { };
struct D : public B { };
D d;
B &br = d;

static_cast<D&>(br);

// produces lvalue to the original d object

— end example ]

3 A glvalue, class prvalue, or array prvalue of type “cv1 T1” can be cast to type “rvalue reference to cv2 T2” if
“cv2 T2” is reference-compatible with “cv1 T1” (8.5.3). If the value is not a bit-ﬁeld, the result refers to the
object or the speciﬁed base class subobject thereof; otherwise, the lvalue-to-rvalue conversion (4.1) is applied
to the bit-ﬁeld and the resulting prvalue is used as the expression of the static_cast for the remainder
of this section. If T2 is an inaccessible (Clause 11) or ambiguous (10.2) base class of T1, a program that
necessitates such a cast is ill-formed.

4 An expression e can be explicitly converted to a type T using a static_cast of the form static_cast<T>(e)
if the declaration T t(e); is well-formed, for some invented temporary variable t (8.5). The eﬀect of such an
explicit conversion is the same as performing the declaration and initialization and then using the temporary
variable as the result of the conversion. The expression e is used as a glvalue if and only if the initialization
uses it as a glvalue.

5 Otherwise, the static_cast shall perform one of the conversions listed below. No other conversion shall be

performed explicitly using a static_cast.

6 Any expression can be explicitly converted to type cv void, in which case it becomes a discarded-value
expression (Clause 5). [ Note: however, if the value is in a temporary object (12.2), the destructor for that
object is not executed until the usual time, and the value of the object is preserved for the purpose of
executing the destructor. — end note ]

§ 5.2.9

109

c(cid:13) ISO/IEC

N4296

7 The inverse of any standard conversion sequence (Clause 4) not containing an lvalue-to-rvalue (4.1), array-
to-pointer (4.2), function-to-pointer (4.3), null pointer (4.10), null member pointer (4.11), or boolean (4.12)
conversion, can be performed explicitly using static_cast. A program is ill-formed if it uses static_cast
to perform the inverse of an ill-formed standard conversion sequence. [ Example:

struct B { };
struct D : private B { };
void f() {

}

static_cast<D*>((B*)0);
static_cast<int B::*>((int D::*)0);

// Error: B is a private base of D.
// Error: B is a private base of D.

— end example ]

8 The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) conversions are applied to
the operand. Such a static_cast is subject to the restriction that the explicit conversion does not cast
away constness (5.2.11), and the following additional rules for speciﬁc cases:

9 A value of a scoped enumeration type (7.2) can be explicitly converted to an integral type. When that type
is cv bool, the resulting value is false if the original value is zero and true for all other values. For the
remaining integral types, the value is unchanged if the original value can be represented by the speciﬁed type.
Otherwise, the resulting value is unspeciﬁed. A value of a scoped enumeration type can also be explicitly
converted to a ﬂoating-point type; the result is the same as that of converting from the original value to the
ﬂoating-point type.

10 A value of integral or enumeration type can be explicitly converted to a complete enumeration type. The value
is unchanged if the original value is within the range of the enumeration values (7.2). Otherwise, the behavior
is undeﬁned. A value of ﬂoating-point type can also be explicitly converted to an enumeration type. The
resulting value is the same as converting the original value to the underlying type of the enumeration (4.9),
and subsequently to the enumeration type.

11 A prvalue of type “pointer to cv1 B,” where B is a class type, can be converted to a prvalue of type “pointer
to cv2 D,” where D is a class derived (Clause 10) from B, if a valid standard conversion from “pointer to D”
to “pointer to B” exists (4.10), cv2 is the same cv-qualiﬁcation as, or greater cv-qualiﬁcation than, cv1, and
B is neither a virtual base class of D nor a base class of a virtual base class of D. The null pointer value (4.10)
is converted to the null pointer value of the destination type. If the prvalue of type “pointer to cv1 B” points
to a B that is actually a subobject of an object of type D, the resulting pointer points to the enclosing object
of type D. Otherwise, the behavior is undeﬁned.

12 A prvalue of type “pointer to member of D of type cv1 T” can be converted to a prvalue of type “pointer to
member of B” of type cv2 T, where B is a base class (Clause 10) of D, if a valid standard conversion from
“pointer to member of B of type T” to “pointer to member of D of type T” exists (4.11), and cv2 is the same
cv-qualiﬁcation as, or greater cv-qualiﬁcation than, cv1.70 The null member pointer value (4.11) is converted
to the null member pointer value of the destination type. If class B contains the original member, or is a
base or derived class of the class containing the original member, the resulting pointer to member points to
the original member. Otherwise, the behavior is undeﬁned.
[ Note: although class B need not contain the
original member, the dynamic type of the object with which indirection through the pointer to member is
performed must contain the original member; see 5.5. — end note ]

13 A prvalue of type “pointer to cv1 void” can be converted to a prvalue of type “pointer to cv2 T,” where T is
an object type and cv2 is the same cv-qualiﬁcation as, or greater cv-qualiﬁcation than, cv1. The null pointer
value is converted to the null pointer value of the destination type. If the original pointer value represents
the address A of a byte in memory and A satisﬁes the alignment requirement of T, then the resulting pointer
value represents the same address as the original pointer value, that is, A. The result of any other such
70) Function types (including those used in pointer to member function types) are never cv-qualiﬁed; see 8.3.5.

§ 5.2.9

110

c(cid:13) ISO/IEC

N4296

pointer conversion is unspeciﬁed. A value of type pointer to object converted to “pointer to cv void” and
back, possibly with diﬀerent cv-qualiﬁcation, shall have its original value. [ Example:

T* p1 = new T;
const T* p2 = static_cast<const T*>(static_cast<void*>(p1));
bool b = p1 == p2; // b will have the value true.

— end example ]
5.2.10 Reinterpret cast

[expr.reinterpret.cast]
1 The result of the expression reinterpret_cast<T>(v) is the result of converting the expression v to type
T. If T is an lvalue reference type or an rvalue reference to function type, the result is an lvalue; if T is an
rvalue reference to object type, the result is an xvalue; otherwise, the result is a prvalue and the lvalue-to-
rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are performed on the
expression v. Conversions that can be performed explicitly using reinterpret_cast are listed below. No
other conversion can be performed explicitly using reinterpret_cast.

2 The reinterpret_cast operator shall not cast away constness (5.2.11). An expression of integral, enumer-
ation, pointer, or pointer-to-member type can be explicitly converted to its own type; such a cast yields the
value of its operand.
[ Note: The mapping performed by reinterpret_cast might, or might not, produce a representation dif-
ferent from the original value. — end note ]

3

4 A pointer can be explicitly converted to any integral type large enough to hold it. The mapping function is
implementation-deﬁned. [ Note: It is intended to be unsurprising to those who know the addressing structure
of the underlying machine. — end note ] A value of type std::nullptr_t can be converted to an integral
type; the conversion has the same meaning and validity as a conversion of (void*)0 to the integral type.
[ Note: A reinterpret_cast cannot be used to convert a value of any type to the type std::nullptr_t.
— end note ]

5 A value of integral type or enumeration type can be explicitly converted to a pointer. A pointer converted
to an integer of suﬃcient size (if any such exists on the implementation) and back to the same pointer type
will have its original value; mappings between pointers and integers are otherwise implementation-deﬁned.
[ Note: Except as described in 3.7.4.3, the result of such a conversion will not be a safely-derived pointer
value. — end note ]

6 A function pointer can be explicitly converted to a function pointer of a diﬀerent type. The eﬀect of calling
a function through a pointer to a function type (8.3.5) that is not the same as the type used in the deﬁnition
of the function is undeﬁned. Except that converting a prvalue of type “pointer to T1” to the type “pointer to
T2” (where T1 and T2 are function types) and back to its original type yields the original pointer value, the
result of such a pointer conversion is unspeciﬁed. [ Note: see also 4.10 for more details of pointer conversions.
— end note ]

7 An object pointer can be explicitly converted to an object pointer of a diﬀerent type.71 When a prvalue v of
object pointer type is converted to the object pointer type “pointer to cv T”, the result is static_cast<cv
T*>(static_cast<cv void*>(v)). Converting a prvalue of type “pointer to T1” to the type “pointer to
T2” (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than
those of T1) and back to its original type yields the original pointer value.

8 Converting a function pointer to an object pointer type or vice versa is conditionally-supported. The meaning
of such a conversion is implementation-deﬁned, except that if an implementation supports conversions in
both directions, converting a prvalue of one type to the other type and back, possibly with diﬀerent cv-
qualiﬁcation, shall yield the original pointer value.
71) The types may have diﬀerent cv-qualiﬁers, subject to the overall restriction that a reinterpret_cast cannot cast away
constness.

§ 5.2.10

111

c(cid:13) ISO/IEC

N4296

9 The null pointer value (4.10) is converted to the null pointer value of the destination type.

[ Note: A null
pointer constant of type std::nullptr_t cannot be converted to a pointer type, and a null pointer constant
of integral type is not necessarily converted to a null pointer value. — end note ]

10 A prvalue of type “pointer to member of X of type T1” can be explicitly converted to a prvalue of a diﬀerent
type “pointer to member of Y of type T2” if T1 and T2 are both function types or both object types.72 The
null member pointer value (4.11) is converted to the null member pointer value of the destination type. The
result of this conversion is unspeciﬁed, except in the following cases:

(10.1)

(10.2)

—

—

converting a prvalue of type “pointer to member function” to a diﬀerent pointer to member function
type and back to its original type yields the original pointer to member value.
converting a prvalue of type “pointer to data member of X of type T1” to the type “pointer to data
member of Y of type T2” (where the alignment requirements of T2 are no stricter than those of T1)
and back to its original type yields the original pointer to member value.

11 A glvalue expression of type T1 can be cast to the type “reference to T2” if an expression of type “pointer
to T1” can be explicitly converted to the type “pointer to T2” using a reinterpret_cast. The result refers
to the same object as the source glvalue, but with the speciﬁed type. [ Note: That is, for lvalues, a reference
cast reinterpret_cast<T&>(x) has the same eﬀect as the conversion *reinterpret_cast<T*>(&x) with
the built-in & and * operators (and similarly for reinterpret_cast<T&&>(x)). — end note ] No temporary
is created, no copy is made, and constructors (12.1) or conversion functions (12.3) are not called.73
5.2.11 Const cast

[expr.const.cast]
1 The result of the expression const_cast<T>(v) is of type T. If T is an lvalue reference to object type, the
result is an lvalue; if T is an rvalue reference to object type, the result is an xvalue; otherwise, the result
is a prvalue and the lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard
conversions are performed on the expression v. Conversions that can be performed explicitly using const_-
cast are listed below. No other conversion shall be performed explicitly using const_cast.
[ Note: Subject to the restrictions in this section, an expression may be cast to its own type using a const_-
cast operator. — end note ]

2

3 For two similar types T1 and T2 (4.4), a prvalue of type T1 may be explicitly converted to the type T2 using

a const_cast. The result of a const_cast refers to the original entity. [ Example:

typedef int *A[3];
typedef const int *const CA[3]; // array of 3 const pointer to const int

// array of 3 pointer to int

CA &&r = A{}; // ok, reference binds to temporary array object after qualiﬁcation conversion to type CA
A &&r1 = const_cast<A>(CA{});
A &&r2 = const_cast<A&&>(CA{}); // ok

// error: temporary array decayed to pointer

— end example ]

4 For two object types T1 and T2, if a pointer to T1 can be explicitly converted to the type “pointer to T2”

using a const_cast, then the following conversions can also be made:

(4.1)

(4.2)

—
—

an lvalue of type T1 can be explicitly converted to an lvalue of type T2 using the cast const_cast<T2&>;
a glvalue of type T1 can be explicitly converted to an xvalue of type T2 using the cast const_-
cast<T2&&>; and

72) T1 and T2 may have diﬀerent cv-qualiﬁers, subject to the overall restriction that a reinterpret_cast cannot cast away
constness.
73) This is sometimes referred to as a type pun.

§ 5.2.11

112

c(cid:13) ISO/IEC

N4296

(4.3)

—

if T1 is a class type, a prvalue of type T1 can be explicitly converted to an xvalue of type T2 using the
cast const_cast<T2&&>.

The result of a reference const_cast refers to the original object.

5 A null pointer value (4.10) is converted to the null pointer value of the destination type. The null member

pointer value (4.11) is converted to the null member pointer value of the destination type.
[ Note: Depending on the type of the object, a write operation through the pointer, lvalue or pointer
to data member resulting from a const_cast that casts away a const-qualiﬁer74 may produce undeﬁned
behavior (7.1.6.1). — end note ]

6

7 A conversion from a type T1 to a type T2 casts away constness if T1 and T2 are diﬀerent, there is a

cv-decomposition (4.4) of T1 yielding n such that T2 has a cv-decomposition of the form

cv2

0 P 2

0 cv2

1 P 2

1 ··· cv2

n−1 P 2

n−1 cv2

n U2,

and there is no qualiﬁcation conversion that converts T1 to

cv2

0 P 1

0 cv2

1 P 1

1 ··· cv2

n−1 P 1

n−1 cv2

n U1.

9

8 Casting from an lvalue of type T1 to an lvalue of type T2 using an lvalue reference cast or casting from an
expression of type T1 to an xvalue of type T2 using an rvalue reference cast casts away constness if a cast
from a prvalue of type “pointer to T1” to the type “pointer to T2” casts away constness.
[ Note: some conversions which involve only changes in cv-qualiﬁcation cannot be done using const_cast.
For instance, conversions between pointers to functions are not covered because such conversions lead to
values whose use causes undeﬁned behavior. For the same reasons, conversions between pointers to member
functions, and in particular, the conversion from a pointer to a const member function to a pointer to a
non-const member function, are not covered. — end note ]
5.3 Unary expressions

[expr.unary]

1 Expressions with unary operators group right-to-left.

unary-expression:

postﬁx-expression
++ cast-expression
-- cast-expression
unary-operator cast-expression
sizeof unary-expression
sizeof ( type-id )
sizeof ... ( identiﬁer )
alignof ( type-id )
noexcept-expression
new-expression
delete-expression
unary-operator: one of

* & + - ! ~

5.3.1 Unary operators

[expr.unary.op]
1 The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an
object type, or a pointer to a function type and the result is an lvalue referring to the object or function
to which the expression points.
If the type of the expression is “pointer to T,” the type of the result is
“T.” [ Note: indirection through a pointer to an incomplete type (other than cv void) is valid. The lvalue
thus obtained can be used in limited ways (to initialize a reference, for example); this lvalue must not be
converted to a prvalue, see 4.1. — end note ]
74) const_cast is not limited to conversions that cast away a const-qualiﬁer.

§ 5.3.1

113

c(cid:13) ISO/IEC

N4296

2 The result of each of the following unary operators is a prvalue.
3 The result of the unary & operator is a pointer to its operand. The operand shall be an lvalue or a qualiﬁed-
id. If the operand is a qualiﬁed-id naming a non-static or variant member m of some class C with type T,
the result has type “pointer to member of class C of type T” and is a prvalue designating C::m. Otherwise,
if the type of the expression is T, the result has type “pointer to T” and is a prvalue that is the address
of the designated object (1.7) or a pointer to the designated function. [ Note: In particular, the address of
an object of type “cv T” is “pointer to cv T”, with the same cv-qualiﬁcation. — end note ] For purposes of
pointer arithmetic (5.7) and comparison (5.9, 5.10), an object that is not an array element whose address is
taken in this way is considered to belong to an array with one element of type T. [ Example:

struct A { int i; };
struct B : A { };
... &B::i ...
int a;
int* p1 = &a;
int* p2 = p1 + 1;
bool b = p2 > p1;

// has type int A::*

// deﬁned behavior
// deﬁned behavior, with value true

— end example ] [ Note: a pointer to member formed from a mutable non-static data member (7.1.1) does
not reﬂect the mutable speciﬁer associated with the non-static data member. — end note ]

[ Note:

4 A pointer to member is only formed when an explicit & is used and its operand is a qualiﬁed-id not enclosed
in parentheses.
that is, the expression &(qualified-id), where the qualiﬁed-id is enclosed in
parentheses, does not form an expression of type “pointer to member.” Neither does qualified-id, because
there is no implicit conversion from a qualiﬁed-id for a non-static member function to the type “pointer to
member function” as there is from an lvalue of function type to the type “pointer to function” (4.3). Nor is
&unqualified-id a pointer to member, even within the scope of the unqualiﬁed-id’s class. — end note ]
If & is applied to an lvalue of incomplete class type and the complete type declares operator&(), it is
unspeciﬁed whether the operator has the built-in meaning or the operator function is called. The operand
of & shall not be a bit-ﬁeld.

5

6 The address of an overloaded function (Clause 13) can be taken only in a context that uniquely determines
which version of the overloaded function is referred to (see 13.4). [ Note: since the context might determine
whether the operand is a static or non-static member function, the context can also aﬀect whether the
expression has type “pointer to function” or “pointer to member function.” — end note ]

7 The operand of the unary + operator shall have arithmetic, unscoped enumeration, or pointer type and the
result is the value of the argument. Integral promotion is performed on integral or enumeration operands.
The type of the result is the type of the promoted operand.

8 The operand of the unary - operator shall have arithmetic or unscoped enumeration type and the result
is the negation of its operand. Integral promotion is performed on integral or enumeration operands. The
negative of an unsigned quantity is computed by subtracting its value from 2n, where n is the number of
bits in the promoted operand. The type of the result is the type of the promoted operand.

9 The operand of the logical negation operator ! is contextually converted to bool (Clause 4); its value is

true if the converted operand is false and false otherwise. The type of the result is bool.

10 The operand of ~ shall have integral or unscoped enumeration type; the result is the one’s complement of
its operand. Integral promotions are performed. The type of the result is the type of the promoted operand.
There is an ambiguity in the unary-expression ~X(), where X is a class-name or decltype-speciﬁer. The
ambiguity is resolved in favor of treating ~ as a unary complement rather than treating ~X as referring to a
destructor.

§ 5.3.1

114

c(cid:13) ISO/IEC

N4296

5.3.2 Increment and decrement

[expr.pre.incr]
1 The operand of preﬁx ++ is modiﬁed by adding 1, or set to true if it is bool (this use is deprecated). The
operand shall be a modiﬁable lvalue. The type of the operand shall be an arithmetic type or a pointer to
a completely-deﬁned object type. The result is the updated operand; it is an lvalue, and it is a bit-ﬁeld if
the operand is a bit-ﬁeld. If x is not of type bool, the expression ++x is equivalent to x+=1 [ Note: See the
discussions of addition (5.7) and assignment operators (5.18) for information on conversions. — end note ]
2 The operand of preﬁx -- is modiﬁed by subtracting 1. The operand shall not be of type bool. The
requirements on the operand of preﬁx -- and the properties of its result are otherwise the same as those of
preﬁx ++. [ Note: For postﬁx increment and decrement, see 5.2.6. — end note ]
5.3.3 Sizeof

[expr.sizeof]
1 The sizeof operator yields the number of bytes in the object representation of its operand. The operand is
either an expression, which is an unevaluated operand (Clause 5), or a parenthesized type-id. The sizeof
operator shall not be applied to an expression that has function or incomplete type, to an enumeration
type whose underlying type is not ﬁxed before all its enumerators have been declared, to the parenthesized
name of such types, or to a glvalue that designates a bit-ﬁeld. sizeof(char), sizeof(signed char) and
sizeof(unsigned char) are 1. The result of sizeof applied to any other fundamental type (3.9.1) is
implementation-deﬁned. [ Note: in particular, sizeof(bool), sizeof(char16_t), sizeof(char32_t), and
sizeof(wchar_t) are implementation-deﬁned.75 — end note ] [ Note: See 1.7 for the deﬁnition of byte
and 3.9 for the deﬁnition of object representation. — end note ]

2 When applied to a reference or a reference type, the result is the size of the referenced type. When applied
to a class, the result is the number of bytes in an object of that class including any padding required for
placing objects of that type in an array. The size of a most derived class shall be greater than zero (1.8).
The result of applying sizeof to a base class subobject is the size of the base class type.76 When applied
to an array, the result is the total number of bytes in the array. This implies that the size of an array of n
elements is n times the size of an element.

3 The sizeof operator can be applied to a pointer to a function, but shall not be applied directly to a function.
4 The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are not

applied to the operand of sizeof.

5 The identiﬁer in a sizeof... expression shall name a parameter pack. The sizeof... operator yields
the number of arguments provided for the parameter pack identiﬁer. A sizeof... expression is a pack
expansion (14.5.3). [ Example:

template<class... Types>
struct count {

static const std::size_t value = sizeof...(Types);

};

— end example ]

6 The result of sizeof and sizeof... is a constant of type std::size_t. [ Note: std::size_t is deﬁned in

the standard header <cstddef> (18.2). — end note ]
5.3.4 New

[expr.new]
1 The new-expression attempts to create an object of the type-id (8.1) or new-type-id to which it is applied.
The type of that object is the allocated type. This type shall be a complete object type, but not an
abstract class type or array thereof (1.8, 3.9, 10.4). It is implementation-deﬁned whether over-aligned types
75) sizeof(bool) is not required to be 1.
76) The actual size of a base class subobject may be less than the result of applying sizeof to the subobject, due to virtual
base classes and less strict padding requirements on base class subobjects.

§ 5.3.4

115

c(cid:13) ISO/IEC

N4296

[ Note: because references are not objects, references cannot be created by new-
are supported (3.11).
expressions. — end note ] [ Note: the type-id may be a cv-qualiﬁed type, in which case the object created
by the new-expression has a cv-qualiﬁed type. — end note ]

new-expression:

::optnew new-placementopt new-type-id new-initializeropt
::optnew new-placementopt( type-id ) new-initializeropt

new-placement:

( expression-list )

new-type-id:

type-speciﬁer-seq new-declaratoropt

new-declarator:

ptr-operator new-declaratoropt
noptr-new-declarator

noptr-new-declarator:

[ expression ] attribute-speciﬁer-seqopt
noptr-new-declarator [ constant-expression ] attribute-speciﬁer-seqopt

new-initializer:

( expression-listopt)
braced-init-list

Entities created by a new-expression have dynamic storage duration (3.7.4). [ Note: the lifetime of such an
entity is not necessarily restricted to the scope in which it is created. — end note ] If the entity is a non-
array object, the new-expression returns a pointer to the object created. If it is an array, the new-expression
returns a pointer to the initial element of the array.
If a placeholder type (7.1.6.4) appears in the type-speciﬁer-seq of a new-type-id or type-id of a new-expression,
the new-expression shall contain a new-initializer of the form

2

( assignment-expression )

The allocated type is deduced from the new-initializer as follows: Let e be the assignment-expression in the
new-initializer and T be the new-type-id or type-id of the new-expression, then the allocated type is the type
deduced for the variable x in the invented declaration (7.1.6.4):

T x(e);

[ Example:

new auto(1);
auto x = new auto(’a’);

// allocated type is int
// allocated type is char, x is of type char*

— end example ]

3 The new-type-id in a new-expression is the longest possible sequence of new-declarators. [ Note: this prevents
ambiguities between the declarator operators &, &&, *, and [] and their expression counterparts. — end
note ] [ Example:
new int * i;

// syntax error: parsed as (new int*) i, not as (new int)*i

The * is the pointer declarator and not the multiplication operator. — end example ]
[ Note: parentheses in a new-type-id of a new-expression can have surprising eﬀects. [ Example:

4

new int(*[10])();

// error

is ill-formed because the binding is

(new int) (*[10])();

// error

§ 5.3.4

116

c(cid:13) ISO/IEC

N4296

Instead, the explicitly parenthesized version of the new operator can be used to create objects of compound
types (3.9.2):

new (int (*[10])());

allocates an array of 10 pointers to functions (taking no argument and returning int. — end example ]
— end note ]

5 When the allocated object is an array (that is, the noptr-new-declarator syntax is used or the new-type-id or
type-id denotes an array type), the new-expression yields a pointer to the initial element (if any) of the array.
[ Note: both new int and new int[10] have type int* and the type of new int[i][10] is int (*)[10]
— end note ] The attribute-speciﬁer-seq in a noptr-new-declarator appertains to the associated array type.
6 Every constant-expression in a noptr-new-declarator shall be a converted constant expression (5.20) of type
std::size_t and shall evaluate to a strictly positive value. The expression in a noptr-new-declarator is
implicitly converted to std::size_t.
[ Example: given the deﬁnition int n = 42, new float[n][5] is
well-formed (because n is the expression of a noptr-new-declarator), but new float[5][n] is ill-formed
(because n is not a constant expression). — end example ]
7 The expression in a noptr-new-declarator is erroneous if:

(7.1)

(7.2)

(7.3)

(7.4)

—
—

—

—

the expression is of non-class type and its value before converting to std::size_t is less than zero;
the expression is of class type and its value before application of the second standard conversion (13.3.3.1.2)77
is less than zero;
its value is such that the size of the allocated object would exceed the implementation-deﬁned limit
(annex B); or
the new-initializer is a braced-init-list and the number of array elements for which initializers are
provided (including the terminating ’\0’ in a string literal (2.13.5)) exceeds the number of elements
to initialize.

If the expression, after converting to std::size_t, is a core constant expression and the expression is
erroneous, the program is ill-formed. Otherwise, a new-expression with an erroneous expression does not call
an allocation function and terminates by throwing an exception of a type that would match a handler (15.3)
of type std::bad_array_new_length (18.6.2.2). When the value of the expression is zero, the allocation
function is called to allocate an array with no elements.

8 A new-expression may obtain storage for the object by calling an allocation function (3.7.4.1).

If the
new-expression terminates by throwing an exception, it may release storage by calling a deallocation func-
tion (3.7.4.2). If the allocated type is a non-array type, the allocation function’s name is operator new and
the deallocation function’s name is operator delete. If the allocated type is an array type, the allocation
function’s name is operator new[] and the deallocation function’s name is operator delete[]. [ Note: an
implementation shall provide default deﬁnitions for the global allocation functions (3.7.4, 18.6.1.1, 18.6.1.2).
A C++ program can provide alternative deﬁnitions of these functions (17.6.4.6) and/or class-speciﬁc ver-
sions (12.5). — end note ]
If the new-expression begins with a unary :: operator, the allocation function’s name is looked up in the
global scope. Otherwise, if the allocated type is a class type T or array thereof, the allocation function’s
name is looked up in the scope of T. If this lookup fails to ﬁnd the name, or if the allocated type is not a
class type, the allocation function’s name is looked up in the global scope.

9

10 An implementation is allowed to omit a call to a replaceable global allocation function (18.6.1.1, 18.6.1.2).
When it does so, the storage is instead provided by the implementation or provided by extending the
77) If the conversion function returns a signed integer type, the second standard conversion converts to the unsigned type
std::size_t and thus thwarts any attempt to detect a negative value afterwards.

§ 5.3.4

117

c(cid:13) ISO/IEC

N4296

allocation of another new-expression. The implementation may extend the allocation of a new-expression e1
to provide storage for a new-expression e2 if the following would be true were the allocation not extended:

(10.1)

(10.2)

(10.3)

(10.4)

(10.5)

(10.6)

—
—
—
—

—
—

the evaluation of e1 is sequenced before the evaluation of e2, and
e2 is evaluated whenever e1 obtains storage, and
both e1 and e2 invoke the same replaceable global allocation function, and
if the allocation function invoked by e1 and e2 is throwing, any exceptions thrown in the evaluation
of either e1 or e2 would be ﬁrst caught in the same handler, and
the pointer values produced by e1 and e2 are operands to evaluated delete-expressions, and
the evaluation of e2 is sequenced before the evaluation of the delete-expression whose operand is the
pointer value produced by e1.

[ Example:

void mergeable(int x) {

// These allocations are safe for merging:
std::unique_ptr<char[]> a{new (std::nothrow) char[8]};
std::unique_ptr<char[]> b{new (std::nothrow) char[8]};
std::unique_ptr<char[]> c{new (std::nothrow) char[x]};

g(a.get(), b.get(), c.get());

}

void unmergeable(int x) {

std::unique_ptr<char[]> a{new char[8]};
try {

// Merging this allocation would change its catch handler.
std::unique_ptr<char[]> b{new char[x]};

} catch (const std::bad_alloc& e) {

std::cerr << "Allocation failed: " << e.what() << std::endl;
throw;

}

}

— end example ]

11 When a new-expression calls an allocation function and that allocation has not been extended, the new-
expression passes the amount of space requested to the allocation function as the ﬁrst argument of type
std::size_t. That argument shall be no less than the size of the object being created; it may be greater
than the size of the object being created only if the object is an array. For arrays of char and unsigned
char, the diﬀerence between the result of the new-expression and the address returned by the allocation
function shall be an integral multiple of the strictest fundamental alignment requirement (3.11) of any object
type whose size is no greater than the size of the array being created. [ Note: Because allocation functions are
assumed to return pointers to storage that is appropriately aligned for objects of any type with fundamental
alignment, this constraint on array allocation overhead permits the common idiom of allocating character
arrays into which objects of other types will later be placed. — end note ]

12 When a new-expression calls an allocation function and that allocation has been extended, the size argument
to the allocation call shall be no greater than the sum of the sizes for the omitted calls as speciﬁed above,
plus the size for the extended call had it not been extended, plus any padding necessary to align the allocated
objects within the allocated memory.

§ 5.3.4

118

c(cid:13) ISO/IEC

N4296

13 The new-placement syntax is used to supply additional arguments to an allocation function. If used, overload
resolution is performed on a function call created by assembling an argument list consisting of the amount of
space requested (the ﬁrst argument) and the expressions in the new-placement part of the new-expression (the
second and succeeding arguments). The ﬁrst of these arguments has type std::size_t and the remaining
arguments have the corresponding types of the expressions in the new-placement; such an expression is called
a placement new-expression.
[ Example:

14

(14.1)

(14.2)

(14.3)

(14.4)

—
—
—
—

new T results in a call of operator new(sizeof(T)),
new(2,f) T results in a call of operator new(sizeof(T),2,f),
new T[5] results in a call of operator new[](sizeof(T)*5+x), and
new(2,f) T[5] results in a call of operator new[](sizeof(T)*5+y,2,f).

Here, x and y are non-negative unspeciﬁed values representing array allocation overhead; the result of the
new-expression will be oﬀset by this amount from the value returned by operator new[]. This overhead
may be applied in all array new-expressions, including those referencing the library function operator
new[](std::size_t, void*) and other placement allocation functions. The amount of overhead may vary
from one invocation of new to another. — end example ]
[ Note: unless an allocation function has a non-throwing exception speciﬁcation (15.4), it indicates failure to
allocate storage by throwing a std::bad_alloc exception (3.7.4.1, Clause 15, 18.6.2.1); it returns a non-null
pointer otherwise. If the allocation function has a non-throwing exception speciﬁcation, it returns null to
indicate failure to allocate storage and a non-null pointer otherwise. — end note ] If the allocation function
is a reserved placement allocation function (18.6.1.3) that returns null, the behavior is undeﬁned. Otherwise,
if the allocation function returns null, initialization shall not be done, the deallocation function shall not be
called, and the value of the new-expression shall be null.
[ Note: when the allocation function returns a value other than null, it must be a pointer to a block of storage
in which space for the object has been reserved. The block of storage is assumed to be appropriately aligned
and of the requested size. The address of the created object will not necessarily be the same as that of the
block if the object is an array. — end note ]

15

16

17 A new-expression that creates an object of type T initializes that object as follows:

(17.1)

(17.2)

—

—

If the new-initializer is omitted, the object is default-initialized (8.5).
performed, the object has an indeterminate value. — end note ]
Otherwise, the new-initializer is interpreted according to the initialization rules of 8.5 for direct-
initialization.

[ Note: If no initialization is

19

18 The invocation of the allocation function is indeterminately sequenced with respect to the evaluations of
expressions in the new-initializer. Initialization of the allocated object is sequenced before the value com-
putation of the new-expression. It is unspeciﬁed whether expressions in the new-initializer are evaluated if
the allocation function returns the null pointer or exits using an exception.
If the new-expression creates an object or an array of objects of class type, access and ambiguity control
are done for the allocation function, the deallocation function (12.5), and the constructor (12.1).
If the
new-expression creates an array of objects of class type, the destructor is potentially invoked (12.4).
If any part of the object initialization described above78 terminates by throwing an exception, storage has
been obtained for the object, and a suitable deallocation function can be found, the deallocation function is
called to free the memory in which the object was being constructed, after which the exception continues to
78) This may include evaluating a new-initializer and/or calling a constructor.

20

§ 5.3.4

119

c(cid:13) ISO/IEC

N4296

propagate in the context of the new-expression. If no unambiguous matching deallocation function can be
found, propagating the exception does not cause the object’s memory to be freed. [ Note: This is appropriate
when the called allocation function does not allocate memory; otherwise, it is likely to result in a memory
leak. — end note ]
If the new-expression begins with a unary :: operator, the deallocation function’s name is looked up in the
global scope. Otherwise, if the allocated type is a class type T or an array thereof, the deallocation function’s
name is looked up in the scope of T. If this lookup fails to ﬁnd the name, or if the allocated type is not a
class type or array thereof, the deallocation function’s name is looked up in the global scope.

21

22 A declaration of a placement deallocation function matches the declaration of a placement allocation function
if it has the same number of parameters and, after parameter transformations (8.3.5), all parameter types
If the lookup ﬁnds a single matching deallocation function, that function
except the ﬁrst are identical.
will be called; otherwise, no deallocation function will be called.
If the lookup ﬁnds the two-parameter
form of a usual deallocation function (3.7.4.2) and that function, considered as a placement deallocation
function, would have been selected as a match for the allocation function, the program is ill-formed. For
a non-placement allocation function, the normal deallocation function lookup is used to ﬁnd the matching
deallocation function (5.3.5) [ Example:

struct S {

// Placement allocation function:
static void* operator new(std::size_t, std::size_t);

// Usual (non-placement) deallocation function:
static void operator delete(void*, std::size_t);

};

S* p = new (0) S;

// ill-formed: non-placement deallocation function matches
// placement allocation function

23

— end example ]
If a new-expression calls a deallocation function, it passes the value returned from the allocation function
call as the ﬁrst argument of type void*. If a placement deallocation function is called, it is passed the same
additional arguments as were passed to the placement allocation function, that is, the same arguments as
those speciﬁed with the new-placement syntax.
If the implementation is allowed to make a copy of any
argument as part of the call to the allocation function, it is allowed to make a copy (of the same original
value) as part of the call to the deallocation function or to reuse the copy made as part of the call to the
allocation function. If the copy is elided in one place, it need not be elided in the other.
5.3.5 Delete

[expr.delete]
1 The delete-expression operator destroys a most derived object (1.8) or array created by a new-expression.

delete-expression:

::optdelete cast-expression
::optdelete [ ] cast-expression

The ﬁrst alternative is for non-array objects, and the second is for arrays. Whenever the delete keyword
is immediately followed by empty square brackets, it shall be interpreted as the second alternative.79 The
operand shall be of pointer to object type or of class type. If of class type, the operand is contextually
implicitly converted (Clause 4) to a pointer to object type.80 The delete-expression’s result has type void.
If the operand has a class type, the operand is converted to a pointer type by calling the above-mentioned
conversion function, and the converted operand is used in place of the original operand for the remainder of
79) A lambda expression with a lambda-introducer that consists of empty square brackets can follow the delete keyword if
the lambda expression is enclosed in parentheses.
80) This implies that an object cannot be deleted using a pointer of type void* because void is not an object type.

2

§ 5.3.5

120

c(cid:13) ISO/IEC

N4296

this section. In the ﬁrst alternative (delete object), the value of the operand of delete may be a null pointer
value, a pointer to a non-array object created by a previous new-expression, or a pointer to a subobject (1.8)
representing a base class of such an object (Clause 10). If not, the behavior is undeﬁned. In the second
alternative (delete array), the value of the operand of delete may be a null pointer value or a pointer
value that resulted from a previous array new-expression.81 If not, the behavior is undeﬁned. [ Note: this
means that the syntax of the delete-expression must match the type of the object allocated by new, not
the syntax of the new-expression. — end note ] [ Note: a pointer to a const type can be the operand of a
delete-expression; it is not necessary to cast away the constness (5.2.11) of the pointer expression before it
is used as the operand of the delete-expression. — end note ]
In the ﬁrst alternative (delete object), if the static type of the object to be deleted is diﬀerent from its
dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the
static type shall have a virtual destructor or the behavior is undeﬁned. In the second alternative (delete
array) if the dynamic type of the object to be deleted diﬀers from its static type, the behavior is undeﬁned.

3

4 The cast-expression in a delete-expression shall be evaluated exactly once.
5

If the object being deleted has incomplete class type at the point of deletion and the complete class has a
non-trivial destructor or a deallocation function, the behavior is undeﬁned.
If the value of the operand of the delete-expression is not a null pointer value, the delete-expression will
invoke the destructor (if any) for the object or the elements of the array being deleted. In the case of an
array, the elements will be destroyed in order of decreasing address (that is, in reverse order of the completion
of their constructor; see 12.6.2).
If the value of the operand of the delete-expression is not a null pointer value, then:

6

7

(7.1)

—

(7.2)

—

(7.3)

—

If the allocation call for the new-expression for the object to be deleted was not omitted and the
allocation was not extended (5.3.4), the delete-expression shall call a deallocation function (3.7.4.2).
The value returned from the allocation call of the new-expression shall be passed as the ﬁrst argument
to the deallocation function.
Otherwise, if the allocation was extended or was provided by extending the allocation of another new-
expression, and the delete-expression for every other pointer value produced by a new-expression that
had storage provided by the extended new-expression has been evaluated, the delete-expression shall
call a deallocation function. The value returned from the allocation call of the extended new-expression
shall be passed as the ﬁrst argument to the deallocation function.
Otherwise, the delete-expression will not call a deallocation function (3.7.4.2).

Otherwise, it is unspeciﬁed whether the deallocation function will be called. [ Note: The deallocation function
is called regardless of whether the destructor for the object or some element of the array throws an exception.
— end note ]
[ Note: An implementation provides default deﬁnitions of the global deallocation functions operator delete()
for non-arrays (18.6.1.1) and operator delete[]() for arrays (18.6.1.2). A C++ program can provide al-
ternative deﬁnitions of these functions (17.6.4.6), and/or class-speciﬁc versions (12.5). — end note ]

8

9 When the keyword delete in a delete-expression is preceded by the unary :: operator, the deallocation
function’s name is looked up in global scope. Otherwise, the lookup considers class-speciﬁc deallocation
functions (12.5).
If no class-speciﬁc deallocation function is found, the deallocation function’s name is
looked up in global scope.
If deallocation function lookup ﬁnds both a usual deallocation function with only a pointer parameter and
a usual deallocation function with both a pointer parameter and a size parameter, the function to be called
is selected as follows:
81) For non-zero-length arrays, this is the same as a pointer to the ﬁrst element of the array created by that new-expression.
Zero-length arrays do not have a ﬁrst element.

10

§ 5.3.5

121

c(cid:13) ISO/IEC

N4296

(10.1)

(10.2)

—

—

If the type is complete and if, for the second alternative (delete array) only, the operand is a pointer to
a class type with a non-trivial destructor or a (possibly multi-dimensional) array thereof, the function
with two parameters is selected.
Otherwise, it is unspeciﬁed which of the two deallocation functions is selected.

11 When a delete-expression is executed, the selected deallocation function shall be called with the address of
the block of storage to be reclaimed as its ﬁrst argument and (if the two-parameter deallocation function is
used) the size of the block as its second argument.82

12 Access and ambiguity control are done for both the deallocation function and the destructor (12.4, 12.5).

5.3.6 Alignof

[expr.alignof]
1 An alignof expression yields the alignment requirement of its operand type. The operand shall be a type-id

representing a complete object type, or an array thereof, or a reference to one of those types.

2 The result is an integral constant of type std::size_t.
3 When alignof is applied to a reference type, the result is the alignment of the referenced type. When

alignof is applied to an array type, the result is the alignment of the element type.
5.3.7 noexcept operator

[expr.unary.noexcept]
1 The noexcept operator determines whether the evaluation of its operand, which is an unevaluated operand

(Clause 5), can throw an exception (15.1).

noexcept-expression:

noexcept ( expression )

2 The result of the noexcept operator is a constant of type bool and is a prvalue.
3 The result of the noexcept operator is true if the set of potential exceptions of the expression (15.4) is

empty, and false otherwise.
5.4 Explicit type conversion (cast notation)

[expr.cast]
1 The result of the expression (T) cast-expression is of type T. The result is an lvalue if T is an lvalue reference
type or an rvalue reference to function type and an xvalue if T is an rvalue reference to object type; otherwise
the result is a prvalue.
[ Note: if T is a non-class type that is cv-qualiﬁed, the cv-qualiﬁers are discarded
when determining the type of the resulting prvalue; see Clause 5. — end note ]

2 An explicit type conversion can be expressed using functional notation (5.2.3), a type conversion operator

(dynamic_cast, static_cast, reinterpret_cast, const_cast), or the cast notation.

cast-expression:

unary-expression
( type-id ) cast-expression

3 Any type conversion not mentioned below and not explicitly deﬁned by the user (12.3) is ill-formed.
4 The conversions performed by
a const_cast (5.2.11),
a static_cast (5.2.9),
a static_cast followed by a const_cast,
a reinterpret_cast (5.2.10), or

—
—
—
—
82) If the static type of the object to be deleted is complete and is diﬀerent from the dynamic type, and the destructor is not
virtual, the size might be incorrect, but that case is already undeﬁned, as stated above.

(4.1)

(4.2)

(4.3)

(4.4)

§ 5.4

122

c(cid:13) ISO/IEC

N4296

(4.5)

—

a reinterpret_cast followed by a const_cast,

can be performed using the cast notation of explicit type conversion. The same semantic restrictions and be-
haviors apply, with the exception that in performing a static_cast in the following situations the conversion
is valid even if the base class is inaccessible:

(4.6)

(4.7)

(4.8)

—

—

—

a pointer to an object of derived class type or an lvalue or rvalue of derived class type may be explicitly
converted to a pointer or reference to an unambiguous base class type, respectively;
a pointer to member of derived class type may be explicitly converted to a pointer to member of an
unambiguous non-virtual base class type;
a pointer to an object of an unambiguous non-virtual base class type, a glvalue of an unambiguous
non-virtual base class type, or a pointer to member of an unambiguous non-virtual base class type
may be explicitly converted to a pointer, a reference, or a pointer to member of a derived class type,
respectively.

If a conversion can be interpreted in more than one of the ways listed above, the interpretation that appears
ﬁrst in the list is used, even if a cast resulting from that interpretation is ill-formed. If a conversion can be
interpreted in more than one way as a static_cast followed by a const_cast, the conversion is ill-formed.
[ Example:

struct A { };
struct I1 : A { };
struct I2 : A { };
struct D : I1, I2 { };
A* foo( D* p ) {

}

return (A*)( p ); // ill-formed static_cast interpretation

— end example ]

5 The operand of a cast using the cast notation can be a prvalue of type “pointer to incomplete class type”.
The destination type of a cast using the cast notation can be “pointer to incomplete class type”. If both the
operand and destination types are class types and one or both are incomplete, it is unspeciﬁed whether the
static_cast or the reinterpret_cast interpretation is used, even if there is an inheritance relationship
between the two classes.
[ Note: For example, if the classes were deﬁned later in the translation unit, a
multi-pass compiler would be permitted to interpret a cast between pointers to the classes as if the class
types were complete at the point of the cast. — end note ]
5.5 Pointer-to-member operators

[expr.mptr.oper]

1 The pointer-to-member operators ->* and .* group left-to-right.

pm-expression:

cast-expression
pm-expression .* cast-expression
pm-expression ->* cast-expression

2 The binary operator .* binds its second operand, which shall be of type “pointer to member of T” to its
ﬁrst operand, which shall be of class T or of a class of which T is an unambiguous and accessible base class.
The result is an object or a function of the type speciﬁed by the second operand.

3 The binary operator ->* binds its second operand, which shall be of type “pointer to member of T” to its
ﬁrst operand, which shall be of type “pointer to T” or “pointer to a class of which T is an unambiguous and
accessible base class.” The expression E1->*E2 is converted into the equivalent form (*(E1)).*E2.

4 Abbreviating pm-expression.*cast-expression as E1.*E2, E1 is called the object expression. If the dynamic

type of E1 does not contain the member to which E2 refers, the behavior is undeﬁned.

§ 5.5

123

c(cid:13) ISO/IEC

N4296

5 The restrictions on cv-qualiﬁcation, and the manner in which the cv-qualiﬁers of the operands are combined
to produce the cv-qualiﬁers of the result, are the same as the rules for E1.E2 given in 5.2.5. [ Note: it is not
possible to use a pointer to member that refers to a mutable member to modify a const class object. For
example,

struct S {

S() : i(0) { }
mutable int i;

};
void f()
{
const S cs;
int S::* pm = &S::i;
cs.*pm = 88;
}

// pm refers to mutable member S::i
// ill-formed: cs is a const object

6

— end note ]
If the result of .* or ->* is a function, then that result can be used only as the operand for the function call
operator (). [ Example:

(ptr_to_obj->*ptr_to_mfct)(10);

calls the member function denoted by ptr_to_mfct for the object pointed to by ptr_to_obj. — end
example ] In a .* expression whose object expression is an rvalue, the program is ill-formed if the second
operand is a pointer to member function with ref-qualiﬁer &. In a .* expression whose object expression is
an lvalue, the program is ill-formed if the second operand is a pointer to member function with ref-qualiﬁer
&&. The result of a .* expression whose second operand is a pointer to a data member is an lvalue if the
ﬁrst operand is an lvalue and an xvalue otherwise. The result of a .* expression whose second operand is a
pointer to a member function is a prvalue. If the second operand is the null pointer to member value (4.11),
the behavior is undeﬁned.
5.6 Multiplicative operators

[expr.mul]

1 The multiplicative operators *, /, and % group left-to-right.

multiplicative-expression:

pm-expression
multiplicative-expression * pm-expression
multiplicative-expression / pm-expression
multiplicative-expression % pm-expression

2 The operands of * and / shall have arithmetic or unscoped enumeration type; the operands of % shall have
integral or unscoped enumeration type. The usual arithmetic conversions are performed on the operands
and determine the type of the result.

3 The binary * operator indicates multiplication.
4 The binary / operator yields the quotient, and the binary % operator yields the remainder from the division
of the ﬁrst expression by the second. If the second operand of / or % is zero the behavior is undeﬁned. For
integral operands the / operator yields the algebraic quotient with any fractional part discarded;83 if the
quotient a/b is representable in the type of the result, (a/b)*b + a%b is equal to a; otherwise, the behavior
of both a/b and a%b is undeﬁned.
5.7 Additive operators

[expr.add]
1 The additive operators + and - group left-to-right. The usual arithmetic conversions are performed for

operands of arithmetic or enumeration type.
83) This is often called truncation towards zero.

§ 5.7

124

c(cid:13) ISO/IEC

N4296

additive-expression:

multiplicative-expression
additive-expression + multiplicative-expression
additive-expression - multiplicative-expression

For addition, either both operands shall have arithmetic or unscoped enumeration type, or one operand shall
be a pointer to a completely-deﬁned object type and the other shall have integral or unscoped enumeration
type.

2 For subtraction, one of the following shall hold:

(2.1)

(2.2)

(2.3)

—
—

—

both operands have arithmetic or unscoped enumeration type; or
both operands are pointers to cv-qualiﬁed or cv-unqualiﬁed versions of the same completely-deﬁned
object type; or
the left operand is a pointer to a completely-deﬁned object type and the right operand has integral or
unscoped enumeration type.

3 The result of the binary + operator is the sum of the operands. The result of the binary - operator is the

diﬀerence resulting from the subtraction of the second operand from the ﬁrst.

4 When an expression that has integral type is added to or subtracted from a pointer, the result has the type
of the pointer operand. If the pointer operand points to an element of an array object84, and the array is
large enough, the result points to an element oﬀset from the original element such that the diﬀerence of
the subscripts of the resulting and original array elements equals the integral expression. In other words, if
the expression P points to the i-th element of an array object, the expressions (P)+N (equivalently, N+(P))
and (P)-N (where N has the value n) point to, respectively, the i + n-th and i − n-th elements of the array
object, provided they exist. Moreover, if the expression P points to the last element of an array object,
the expression (P)+1 points one past the last element of the array object, and if the expression Q points
one past the last element of an array object, the expression (Q)-1 points to the last element of the array
object. If both the pointer operand and the result point to elements of the same array object, or one past
the last element of the array object, the evaluation shall not produce an overﬂow; otherwise, the behavior is
undeﬁned.

5 When two pointers to elements of the same array object are subtracted, the result is the diﬀerence of the
subscripts of the two array elements. The type of the result is an implementation-deﬁned signed integral
type; this type shall be the same type that is deﬁned as std::ptrdiff_t in the <cstddef> header (18.2). As
with any other arithmetic overﬂow, if the result does not ﬁt in the space provided, the behavior is undeﬁned.
In other words, if the expressions P and Q point to, respectively, the i-th and j-th elements of an array object,
the expression (P)-(Q) has the value i − j provided the value ﬁts in an object of type std::ptrdiff_t.
Moreover, if the expression P points either to an element of an array object or one past the last element of
an array object, and the expression Q points to the last element of the same array object, the expression
((Q)+1)-(P) has the same value as ((Q)-(P))+1 and as -((P)-((Q)+1)), and has the value zero if the
expression P points one past the last element of the array object, even though the expression (Q)+1 does not
point to an element of the array object. Unless both pointers point to elements of the same array object, or
one past the last element of the array object, the behavior is undeﬁned.85

6 For addition or subtraction, if the expressions P or Q have type “pointer to cv T”, where T and the array
element type are not similar (4.4), the behavior is undeﬁned. [ Note: In particular, a pointer to a base class
cannot be used for pointer arithmetic when the array contains objects of a derived class type. — end note ]
84) An object that is not an array element is considered to belong to a single-element array for this purpose; see 5.3.1.
85) Another way to approach pointer arithmetic is ﬁrst to convert the pointer(s) to character pointer(s): In this scheme the
integral value of the expression added to or subtracted from the converted pointer is ﬁrst multiplied by the size of the object
originally pointed to, and the resulting pointer is converted back to the original type. For pointer subtraction, the result of the
diﬀerence between the character pointers is similarly divided by the size of the object originally pointed to.

When viewed in this way, an implementation need only provide one extra byte (which might overlap another object in the

program) just after the end of the object in order to satisfy the “one past the last element” requirements.

§ 5.7

125

c(cid:13) ISO/IEC

N4296

7

If the value 0 is added to or subtracted from a pointer value, the result compares equal to the original pointer
value. If two pointers point to the same object or both point one past the end of the same array or both
are null, and the two pointers are subtracted, the result compares equal to the value 0 converted to the type
std::ptrdiff_t.
5.8 Shift operators

[expr.shift]

1 The shift operators << and >> group left-to-right.

shift-expression:

additive-expression
shift-expression << additive-expression
shift-expression >> additive-expression

The operands shall be of integral or unscoped enumeration type and integral promotions are performed.
The type of the result is that of the promoted left operand. The behavior is undeﬁned if the right operand
is negative, or greater than or equal to the length in bits of the promoted left operand.

2 The value of E1 << E2 is E1 left-shifted E2 bit positions; vacated bits are zero-ﬁlled. If E1 has an unsigned
type, the value of the result is E1 × 2E2, reduced modulo one more than the maximum value representable
in the result type. Otherwise, if E1 has a signed type and non-negative value, and E1 × 2E2 is representable
in the corresponding unsigned type of the result type, then that value, converted to the result type, is the
resulting value; otherwise, the behavior is undeﬁned.

3 The value of E1 >> E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type or if E1 has a signed
type and a non-negative value, the value of the result is the integral part of the quotient of E1/2E2. If E1
has a signed type and a negative value, the resulting value is implementation-deﬁned.
5.9 Relational operators

[expr.rel]
[ Example: a<b<c means (a<b)<c and not (a<b)&&(b<c).

1 The relational operators group left-to-right.

— end example ]

relational-expression:
shift-expression
relational-expression < shift-expression
relational-expression > shift-expression
relational-expression <= shift-expression
relational-expression >= shift-expression

The operands shall have arithmetic, enumeration, or pointer type. The operators < (less than), > (greater
than), <= (less than or equal to), and >= (greater than or equal to) all yield false or true. The type of the
result is bool.

2 The usual arithmetic conversions are performed on operands of arithmetic or enumeration type. If both
operands are pointers, pointer conversions (4.10) and qualiﬁcation conversions (4.4) are performed to bring
them to their composite pointer type (Clause 5). After conversions, the operands shall have the same type.

3 Comparing pointers to objects86 is deﬁned as follows:

(3.1)

(3.2)

(3.3)

—

—

—

If two pointers point to diﬀerent elements of the same array, or to subobjects thereof, the pointer to
the element with the higher subscript compares greater.
If one pointer points to an element of an array, or to a subobject thereof, and another pointer points
one past the last element of the array, the latter pointer compares greater.
If two pointers point to diﬀerent non-static data members of the same object, or to subobjects of such
members, recursively, the pointer to the later declared member compares greater provided the two
members have the same access control (Clause 11) and provided their class is not a union.

86) An object that is not an array element is considered to belong to a single-element array for this purpose; see 5.3.1.

§ 5.9

126

c(cid:13) ISO/IEC

N4296

4

5

If two operands p and q compare equal (5.10), p<=q and p>=q both yield true and p<q and p>q both yield
false. Otherwise, if a pointer p compares greater than a pointer q, p>=q, p>q, q<=p, and q<p all yield true
and p<=q, p<q, q>=p, and q>p all yield false. Otherwise, the result of each of the operators is unspeciﬁed.
If both operands (after conversions) are of arithmetic or enumeration type, each of the operators shall yield
true if the speciﬁed relationship is true and false if it is false.
5.10 Equality operators

[expr.eq]

equality-expression:

relational-expression
equality-expression == relational-expression
equality-expression != relational-expression

2

1 The == (equal to) and the != (not equal to) operators group left-to-right. The operands shall have arithmetic,
enumeration, pointer, or pointer to member type, or type std::nullptr_t. The operators == and != both
yield true or false, i.e., a result of type bool. In each case below, the operands shall have the same type
after the speciﬁed conversions have been applied.
If at least one of the operands is a pointer, pointer conversions (4.10) and qualiﬁcation conversions (4.4) are
performed on both operands to bring them to their composite pointer type (Clause 5). Comparing pointers
is deﬁned as follows: Two pointers compare equal if they are both null, both point to the same function, or
both represent the same address (3.9.2), otherwise they compare unequal.
If at least one of the operands is a pointer to member, pointer to member conversions (4.11) and qualiﬁcation
conversions (4.4) are performed on both operands to bring them to their composite pointer type (Clause 5).
Comparing pointers to members is deﬁned as follows:

3

(3.1)

(3.2)

(3.3)

(3.4)

—
—
—
—

If two pointers to members are both the null member pointer value, they compare equal.
If only one of two pointers to members is the null member pointer value, they compare unequal.
If either is a pointer to a virtual member function, the result is unspeciﬁed.
If one refers to a member of class C1 and the other refers to a member of a diﬀerent class C2, where
neither is a base class of the other, the result is unspeciﬁed. [ Example:

struct A {};
struct B : A { int x; };
struct C : A { int x; };

int A::*bx = (int(A::*))&B::x;
int A::*cx = (int(A::*))&C::x;

bool b1 = (bx == cx);

// unspeciﬁed

(3.5)

(3.6)

—
—

— end example ]
If both refer to (possibly diﬀerent) members of the same union (9.5), they compare equal.
Otherwise, two pointers to members compare equal if they would refer to the same member of the
same most derived object (1.8) or the same subobject if indirection with a hypothetical object of the
associated class type were performed, otherwise they compare unequal. [ Example:

struct B {
int f();

};
struct L : B { };
struct R : B { };

§ 5.10

127

c(cid:13) ISO/IEC

N4296

struct D : L, R { };

int (B::*pb)() = &B::f;
int (L::*pl)() = pb;
int (R::*pr)() = pb;
int (D::*pdl)() = pl;
int (D::*pdr)() = pr;
bool x = (pdl == pdr);
bool y = (pb == pl);

— end example ]

// false
// true

5

6

4 Two operands of type std::nullptr_t or one operand of type std::nullptr_t and the other a null pointer

constant compare equal.
If two operands compare equal, the result is true for the == operator and false for the != operator. If two
operands compare unequal, the result is false for the == operator and true for the != operator. Otherwise,
the result of each of the operators is unspeciﬁed.
If both operands are of arithmetic or enumeration type, the usual arithmetic conversions are performed on
both operands; each of the operators shall yield true if the speciﬁed relationship is true and false if it is
false.
5.11 Bitwise AND operator

[expr.bit.and]

1 The usual arithmetic conversions are performed; the result is the bitwise AND function of the operands. The

and-expression:

equality-expression
and-expression & equality-expression

operator applies only to integral or unscoped enumeration operands.
5.12 Bitwise exclusive OR operator

exclusive-or-expression:

and-expression
exclusive-or-expression ˆ and-expression

[expr.xor]

[expr.log.and]

1 The usual arithmetic conversions are performed; the result is the bitwise exclusive OR function of the

operands. The operator applies only to integral or unscoped enumeration operands.
5.13 Bitwise inclusive OR operator

[expr.or]

1 The usual arithmetic conversions are performed; the result is the bitwise inclusive OR function of its operands.

inclusive-or-expression:

exclusive-or-expression
inclusive-or-expression | exclusive-or-expression

The operator applies only to integral or unscoped enumeration operands.
5.14 Logical AND operator

logical-and-expression:

inclusive-or-expression
logical-and-expression && inclusive-or-expression

1 The && operator groups left-to-right. The operands are both contextually converted to bool (Clause 4).
The result is true if both operands are true and false otherwise. Unlike &, && guarantees left-to-right
evaluation: the second operand is not evaluated if the ﬁrst operand is false.

2 The result is a bool. If the second expression is evaluated, every value computation and side eﬀect associated
with the ﬁrst expression is sequenced before every value computation and side eﬀect associated with the
second expression.

§ 5.14

128

c(cid:13) ISO/IEC

5.15 Logical OR operator

N4296

[expr.log.or]

logical-or-expression:

logical-and-expression
logical-or-expression || logical-and-expression

1 The || operator groups left-to-right. The operands are both contextually converted to bool (Clause 4). It
returns true if either of its operands is true, and false otherwise. Unlike |, || guarantees left-to-right
evaluation; moreover, the second operand is not evaluated if the ﬁrst operand evaluates to true.

2 The result is a bool. If the second expression is evaluated, every value computation and side eﬀect associated
with the ﬁrst expression is sequenced before every value computation and side eﬀect associated with the
second expression.
5.16 Conditional operator

[expr.cond]

conditional-expression:

logical-or-expression
logical-or-expression ? expression : assignment-expression

1 Conditional expressions group right-to-left. The ﬁrst expression is contextually converted to bool (Clause 4).
It is evaluated and if it is true, the result of the conditional expression is the value of the second expression,
otherwise that of the third expression. Only one of the second and third expressions is evaluated. Every value
computation and side eﬀect associated with the ﬁrst expression is sequenced before every value computation
and side eﬀect associated with the second or third expression.
If either the second or the third operand has type void, one of the following shall hold:

2

(2.1)

(2.2)

—

—

The second or the third operand (but not both) is a (possibly parenthesized) throw-expression (5.17);
the result is of the type and value category of the other. The conditional-expression is a bit-ﬁeld if
that operand is a bit-ﬁeld.
Both the second and the third operands have type void; the result is of type void and is a prvalue.
[ Note: This includes the case where both operands are throw-expressions. — end note ]

3 Otherwise, if the second and third operand have diﬀerent types and either has (possibly cv-qualiﬁed) class
type, or if both are glvalues of the same value category and the same type except for cv-qualiﬁcation, an
attempt is made to convert each of those operands to the type of the other. The process for determining
whether an operand expression E1 of type T1 can be converted to match an operand expression E2 of type
T2 is deﬁned as follows:

—

—

—

(3.1)

(3.2)

(3.3)

(3.3.1)

If E2 is an lvalue: E1 can be converted to match E2 if E1 can be implicitly converted (Clause 4) to the
type “lvalue reference to T2”, subject to the constraint that in the conversion the reference must bind
directly (8.5.3) to an lvalue.
If E2 is an xvalue: E1 can be converted to match E2 if E1 can be implicitly converted to the type
“rvalue reference to T2”, subject to the constraint that the reference must bind directly.
If E2 is a prvalue or if neither of the conversions above can be done and at least one of the operands
has (possibly cv-qualiﬁed) class type:
—

if E1 and E2 have class type, and the underlying class types are the same or one is a base class
of the other: E1 can be converted to match E2 if the class of T2 is the same type as, or a base
class of, the class of T1, and the cv-qualiﬁcation of T2 is the same cv-qualiﬁcation as, or a greater
cv-qualiﬁcation than, the cv-qualiﬁcation of T1. If the conversion is applied, E1 is changed to a
prvalue of type T2 by copy-initializing a temporary of type T2 from E1 and using that temporary
as the converted operand.
Otherwise (if E1 or E2 has a non-class type, or if they both have class types but the underlying
classes are not the same and neither is a base class of the other): E1 can be converted to match

(3.3.2)

—

§ 5.16

129

c(cid:13) ISO/IEC

N4296

E2 if E1 can be implicitly converted to the type that E2 would have after applying the lvalue-to-
rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions.

Using this process, it is determined whether the second operand can be converted to match the third operand,
and whether the third operand can be converted to match the second operand. If both can be converted,
or one can be converted but the conversion is ambiguous, the program is ill-formed.
If neither can be
converted, the operands are left unchanged and further checking is performed as described below. If exactly
one conversion is possible, that conversion is applied to the chosen operand and the converted operand is
used in place of the original operand for the remainder of this section.
If the second and third operands are glvalues of the same value category and have the same type, the result
is of that type and value category and it is a bit-ﬁeld if the second or the third operand is a bit-ﬁeld, or if
both are bit-ﬁelds.

4

5 Otherwise, the result is a prvalue. If the second and third operands do not have the same type, and either
has (possibly cv-qualiﬁed) class type, overload resolution is used to determine the conversions (if any) to be
applied to the operands (13.3.1.2, 13.6). If the overload resolution fails, the program is ill-formed. Otherwise,
the conversions thus determined are applied, and the converted operands are used in place of the original
operands for the remainder of this section.

6 Lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are per-

formed on the second and third operands. After those conversions, one of the following shall hold:

(6.1)

(6.2)

(6.3)

(6.4)

(6.5)

—

—

—

—

—

The second and third operands have the same type; the result is of that type. If the operands have
class type, the result is a prvalue temporary of the result type, which is copy-initialized from either
the second operand or the third operand depending on the value of the ﬁrst operand.
The second and third operands have arithmetic or enumeration type; the usual arithmetic conversions
are performed to bring them to a common type, and the result is of that type.
One or both of the second and third operands have pointer type; pointer conversions (4.10) and
qualiﬁcation conversions (4.4) are performed to bring them to their composite pointer type (Clause 5).
The result is of the composite pointer type.
One or both of the second and third operands have pointer to member type; pointer to member
conversions (4.11) and qualiﬁcation conversions (4.4) are performed to bring them to their composite
pointer type (Clause 5). The result is of the composite pointer type.
Both the second and third operands have type std::nullptr_t or one has that type and the other is
a null pointer constant. The result is of type std::nullptr_t.

5.17 Throwing an exception

[expr.throw]

throw-expression:

throw assignment-expressionopt

1 A throw-expression is of type void.
2 Evaluating a throw-expression with an operand throws an exception (15.1); the type of the exception object
is determined by removing any top-level cv-qualiﬁers from the static type of the operand and adjusting the
type from “array of T” or “function returning T” to “pointer to T” or “pointer to function returning T,”
respectively.

3 A throw-expression with no operand rethrows the currently handled exception (15.3). The exception is
reactivated with the existing exception object; no new exception object is created. The exception is no
longer considered to be caught. [ Example: Code that must be executed because of an exception, but cannot
completely handle the exception itself, can be written like this:

§ 5.17

130

c(cid:13) ISO/IEC

N4296

try {

// ...

}

} catch (...) {

// catch all exceptions

// respond (partially) to exception
throw;

// pass the exception to some
// other handler

4

— end example ]
If no exception is presently being handled, evaluating a throw-expression with no operand calls std::
terminate() (15.5.1).
5.18 Assignment and compound assignment operators

[expr.ass]
1 The assignment operator (=) and the compound assignment operators all group right-to-left. All require a
modiﬁable lvalue as their left operand and return an lvalue referring to the left operand. The result in all
cases is a bit-ﬁeld if the left operand is a bit-ﬁeld. In all cases, the assignment is sequenced after the value
computation of the right and left operands, and before the value computation of the assignment expression.
With respect to an indeterminately-sequenced function call, the operation of a compound assignment is
a single evaluation.
[ Note: Therefore, a function call shall not intervene between the lvalue-to-rvalue
conversion and the side eﬀect associated with any single compound assignment operator. — end note ]

assignment-expression:

conditional-expression
logical-or-expression assignment-operator initializer-clause
throw-expression

assignment-operator: one of

= *= /= %= += -= >>= <<= &= ˆ= |=

2

3

4

5

In simple assignment (=), the value of the expression replaces that of the object referred to by the left
operand.
If the left operand is not of class type, the expression is implicitly converted (Clause 4) to the cv-unqualiﬁed
type of the left operand.
If the left operand is of class type, the class shall be complete. Assignment to objects of a class is deﬁned
by the copy/move assignment operator (12.8, 13.5.3).
[ Note: For class objects, assignment is not in general the same as initialization (8.5, 12.1, 12.6, 12.8). — end
note ]

6 When the left operand of an assignment operator is a bit-ﬁeld that cannot represent the value of the

expression, the resulting value of the bit-ﬁeld is implementation-deﬁned.

8

7 The behavior of an expression of the form E1 op = E2 is equivalent to E1 = E1 op E2 except that E1 is
In += and -=, E1 shall either have arithmetic type or be a pointer to a possibly

evaluated only once.
cv-qualiﬁed completely-deﬁned object type. In all other cases, E1 shall have arithmetic type.
If the value being stored in an object is accessed from another object that overlaps in any way the storage of
the ﬁrst object, then the overlap shall be exact and the two objects shall have the same type, otherwise the
behavior is undeﬁned. [ Note: This restriction applies to the relationship between the left and right sides of
the assignment operation; it is not a statement about how the target of the assignment may be aliased in
general. See 3.10. — end note ]

9 A braced-init-list may appear on the right-hand side of

(9.1)

—

an assignment to a scalar, in which case the initializer list shall have at most a single element. The
meaning of x={v}, where T is the scalar type of the expression x, is that of x=T{v}. The meaning of
x={} is x=T{}.

§ 5.18

131

c(cid:13) ISO/IEC

N4296

(9.2)

—

an assignment to an object of class type, in which case the initializer list is passed as the argument to
the assignment operator function selected by overload resolution (13.5.3, 13.3).

[ Example:

complex<double> z;
z = { 1,2 };
z += { 1, 2 };
int a, b;
a = b = { 1 };
a = { 1 } = b;

— end example ]
5.19 Comma operator

// meaning z.operator=({1,2})
// meaning z.operator+=({1,2})

// meaning a=b=1;
// syntax error

[expr.comma]

1 The comma operator groups left-to-right.

expression:

assignment-expression
expression , assignment-expression

A pair of expressions separated by a comma is evaluated left-to-right; the left expression is a discarded-
value expression (Clause 5).87 Every value computation and side eﬀect associated with the left expression
is sequenced before every value computation and side eﬀect associated with the right expression. The type
and value of the result are the type and value of the right operand; the result is of the same value category
as its right operand, and is a bit-ﬁeld if its right operand is a glvalue and a bit-ﬁeld. If the value of the right
operand is a temporary (12.2), the result is that temporary.
In contexts where comma is given a special meaning, [ Example: in lists of arguments to functions (5.2.2)
and lists of initializers (8.5) — end example ] the comma operator as described in Clause 5 can appear only
in parentheses. [ Example:

2

f(a, (t=3, t+2), c);

has three arguments, the second of which has the value 5. — end example ]
5.20 Constant expressions

[expr.const]
1 Certain contexts require expressions that satisfy additional requirements as detailed in this sub-clause; other
contexts have diﬀerent semantics depending on whether or not an expression satisﬁes these requirements.
Expressions that satisfy these requirements are called constant expressions.
[ Note: Constant expressions
can be evaluated during translation. — end note ]

constant-expression:

conditional-expression

2 A conditional-expression e is a core constant expression unless the evaluation of e, following the rules of the

abstract machine (1.9), would evaluate one of the following expressions:

(2.1)

(2.2)

(2.3)

—

—

this (5.1.1), except in a constexpr function or a constexpr constructor that is being evaluated as
part of e;
an invocation of a function other than a constexpr constructor for a literal class, a constexpr function,
or an implicit invocation of a trivial destructor (12.4) [ Note: Overload resolution (13.3) is applied as
usual — end note ];
an invocation of an undeﬁned constexpr function or an undeﬁned constexpr constructor;

—
87) However, an invocation of an overloaded comma operator is an ordinary function call; hence, the evaluations of its argument
expressions are unsequenced relative to one another (see 1.9).

§ 5.20

132

c(cid:13) ISO/IEC

N4296

(2.4)

(2.5)

(2.6)

(2.7)
(2.7.1)

(2.7.2)

(2.7.3)

(2.7.4)

(2.8)

(2.9)

(2.9.1)

(2.9.2)

(2.10)

(2.11)

(2.12)

(2.13)

(2.14)

(2.15)

(2.16)

(2.17)

(2.18)

(2.19)

(2.20)

—
—

—
—

—

—

—

—
—
—
—
—

—
—
—
—
—

an expression that would exceed the implementation-deﬁned limits (see Annex B);
an operation that would have undeﬁned behavior [ Note: including, for example, signed integer over-
ﬂow (Clause 5), certain pointer arithmetic (5.7), division by zero (5.6), or certain shift operations (5.8)
— end note ];
a lambda-expression (5.1.2);
an lvalue-to-rvalue conversion (4.1) unless it is applied to
—

a non-volatile glvalue of integral or enumeration type that refers to a complete non-volatile const
object with a preceding initialization, initialized with a constant expression, or
a non-volatile glvalue that refers to a subobject of a string literal (2.13.5), or
a non-volatile glvalue that refers to a non-volatile object deﬁned with constexpr, or that refers
to a non-mutable sub-object of such an object, or
a non-volatile glvalue of literal type that refers to a non-volatile object whose lifetime began
within the evaluation of e;

—
—

—

it is initialized with a constant expression or
it is a non-static data member of an object whose lifetime began within the evaluation of e;

an lvalue-to-rvalue conversion (4.1) or modiﬁcation (5.18, 5.2.6, 5.3.2) that is applied to a glvalue that
refers to a non-active member of a union or a subobject thereof;
an id-expression that refers to a variable or data member of reference type unless the reference has a
preceding initialization and either
—
—
in a lambda-expression, a reference to this or to a variable with automatic storage duration deﬁned
outside that lambda-expression, where the reference would be an odr-use (3.2, 5.1.2);
a conversion from type cv void * to a pointer-to-object type;
a dynamic cast (5.2.7);
a reinterpret_cast (5.2.10);
a pseudo-destructor call (5.2.4);
modiﬁcation of an object (5.18, 5.2.6, 5.3.2) unless it is applied to a non-volatile lvalue of literal type
that refers to a non-volatile object whose lifetime began within the evaluation of e;
a typeid expression (5.2.8) whose operand is a glvalue of a polymorphic class type;
a new-expression (5.3.4);
a delete-expression (5.3.5);
a relational (5.9) or equality (5.10) operator where the result is unspeciﬁed; or
a throw-expression (5.17).

[ Example:

§ 5.20

133

c(cid:13) ISO/IEC

N4296

int x;
struct A {

// not constant

constexpr A(bool b) : m(b?42:x) { }
int m;

};
constexpr int v = A(true).m;

constexpr int w = A(false).m;

constexpr int f1(int k) {

constexpr int x = k;

return x;

}
constexpr int f2(int k) {

int x = k;

return x;

}

constexpr int incr(int &n) {

return ++n;

}
constexpr int g(int k) {

constexpr int x = incr(k);

return x;

}
constexpr int h(int k) {

int x = incr(k);

return x;

}
constexpr int y = h(1);

— end example ]

// OK: constructor call initializes
// m with the value 42
// error: initializer for m is
// x, which is non-constant

// error: x is not initialized by a
// constant expression because lifetime of k
// began outside the initializer of x

// OK: not required to be a constant expression
// because x is not constexpr

// error: incr(k) is not a core constant
// expression because lifetime of k
// began outside the expression incr(k)

// OK: incr(k) is not required to be a core
// constant expression

// OK: initializes y with the value 2
// h(1) is a core constant expression because
// the lifetime of k begins inside h(1)

3 An integral constant expression is an expression of integral or unscoped enumeration type, implicitly con-
verted to a prvalue, where the converted expression is a core constant expression. [ Note: Such expressions
may be used as array bounds (8.3.4, 5.3.4), as bit-ﬁeld lengths (9.6), as enumerator initializers if the under-
lying type is not ﬁxed (7.2), and as alignments (7.6.2). — end note ]

4 A converted constant expression of type T is an expression, implicitly converted to type T, where the converted

expression is a constant expression and the implicit conversion sequence contains only

(4.1)

(4.2)

(4.3)

(4.4)

—
—
—
—

user-deﬁned conversions,
lvalue-to-rvalue conversions (4.1),
array-to-pointer conversions (4.2),
function-to-pointer conversions (4.3),

§ 5.20

134

c(cid:13) ISO/IEC

N4296

(4.5)

(4.6)

(4.7)

(4.8)

(4.9)

—
—
—
—
—

qualiﬁcation conversions (4.4),
integral promotions (4.5),
integral conversions (4.7) other than narrowing conversions (8.5.4),
null pointer conversions (4.10) from std::nullptr_t, and
null member pointer conversions (4.11) from std::nullptr_t,

and where the reference binding (if any) binds directly.
[ Note: such expressions may be used in new
expressions (5.3.4), as case expressions (6.4.2), as enumerator initializers if the underlying type is ﬁxed (7.2),
as array bounds (8.3.4), and as non-type template arguments (14.3). — end note ]

5 A constant expression is either a glvalue core constant expression whose value refers to an entity that is a
permitted result of a constant expression (as deﬁned below), or a prvalue core constant expression whose
value is an object where, for that object and its subobjects:

(5.1)

(5.2)

—

—

each non-static data member of reference type refers to an entity that is a permitted result of a constant
expression, and
if the object or subobject is of pointer type, it contains the address of an object with static storage
duration, the address past the end of such an object (5.7), the address of a function, or a null pointer
value.

An entity is a permitted result of a constant expression if it is an object with static storage duration that is
either not a temporary object or is a temporary object whose value satisﬁes the above constraints, or it is a
function.
[ Note: Since this International Standard imposes no restrictions on the accuracy of ﬂoating-point operations,
it is unspeciﬁed whether the evaluation of a ﬂoating-point expression during translation yields the same
result as the evaluation of the same expression (or the same operations on the same values) during program
execution.88 [ Example:

bool f() {

}

char array[1 + int(1 + 0.2 - 0.1 - 0.1)]; // Must be evaluated during translation
int size = 1 + int(1 + 0.2 - 0.1 - 0.1);
return sizeof(array) == size;

// May be evaluated at runtime

It is unspeciﬁed whether the value of f() will be true or false. — end example ] — end note ]
If an expression of literal class type is used in a context where an integral constant expression is required,
then that expression is contextually implicitly converted (Clause 4) to an integral or unscoped enumeration
type and the selected conversion function shall be constexpr. [ Example:

6

7

constexpr A(int i) : val(i) { }
constexpr operator int() const { return val; }
constexpr operator long() const { return 43; }

struct A {

private:

int val;

};
template<int> struct X { };
constexpr A a = 42;
X<a> x;
int ary[a];
88) Nonetheless, implementations are encouraged to provide consistent results, irrespective of whether the evaluation was
performed during translation and/or during program execution.

// OK: unique conversion to int
// error: ambiguous conversion

§ 5.20

135

c(cid:13) ISO/IEC

— end example ]

N4296

§ 5.20

136

The optional attribute-speciﬁer-seq appertains to the respective statement.
6.1 Labeled statement
1 A statement can be labeled.

labeled-statement:

attribute-speciﬁer-seqopt identiﬁer : statement
attribute-speciﬁer-seqoptcase constant-expression : statement
attribute-speciﬁer-seqoptdefault : statement

[stmt.label]

c(cid:13) ISO/IEC

N4296

6 Statements

[stmt.stmt]

1 Except as indicated, statements are executed in sequence.

statement:

labeled-statement
attribute-speciﬁer-seqopt expression-statement
attribute-speciﬁer-seqopt compound-statement
attribute-speciﬁer-seqopt selection-statement
attribute-speciﬁer-seqopt iteration-statement
attribute-speciﬁer-seqopt jump-statement
declaration-statement
attribute-speciﬁer-seqopt try-block

The optional attribute-speciﬁer-seq appertains to the label. An identiﬁer label declares the identiﬁer. The
only use of an identiﬁer label is as the target of a goto. The scope of a label is the function in which it
appears. Labels shall not be redeclared within a function. A label can be used in a goto statement before
its deﬁnition. Labels have their own name space and do not interfere with other identiﬁers.

2 Case labels and default labels shall occur only in switch statements.

6.2 Expression statement

1 Expression statements have the form

expression-statement:
expressionopt;

[stmt.expr]

The expression is a discarded-value expression (Clause 5). All side eﬀects from an expression statement
are completed before the next statement is executed. An expression statement with the expression missing
is called a null statement.
[ Note: Most statements are expression statements — usually assignments or
function calls. A null statement is useful to carry a label just before the } of a compound statement and to
supply a null body to an iteration statement such as a while statement (6.5.1). — end note ]
6.3 Compound statement or block

[stmt.block]
1 So that several statements can be used where one is expected, the compound statement (also, and equiva-

lently, called “block”) is provided.

compound-statement:

{ statement-seqopt}

statement-seq:

statement
statement-seq statement

A compound statement deﬁnes a block scope (3.3). [ Note: A declaration is a statement (6.7). — end note ]

§ 6.3

137

if ( condition ) statement
if ( condition ) statement else statement
switch ( condition ) statement

condition:

expression
attribute-speciﬁer-seqopt decl-speciﬁer-seq declarator = initializer-clause
attribute-speciﬁer-seqopt decl-speciﬁer-seq declarator braced-init-list

c(cid:13) ISO/IEC

6.4 Selection statements

N4296

[stmt.select]

1 Selection statements choose one of several ﬂows of control.

selection-statement:

See 8.3 for the optional attribute-speciﬁer-seq in a condition. In Clause 6, the term substatement refers to
the contained statement or statements that appear in the syntax notation. The substatement in a selection-
statement (each substatement, in the else form of the if statement) implicitly deﬁnes a block scope (3.3).
If the substatement in a selection-statement is a single statement and not a compound-statement, it is as if
it was rewritten to be a compound-statement containing the original substatement. [ Example:

if (x)

int i;

can be equivalently rewritten as

if (x) {
int i;

}

Thus after the if statement, i is no longer in scope. — end example ]

2 The rules for conditions apply both to selection-statements and to the for and while statements (6.5).
The declarator shall not specify a function or an array. The decl-speciﬁer-seq shall not deﬁne a class or
enumeration. If the auto type-speciﬁer appears in the decl-speciﬁer-seq, the type of the identiﬁer being declared
is deduced from the initializer as described in 7.1.6.4.

3 A name introduced by a declaration in a condition (either introduced by the decl-speciﬁer-seq or the declara-
tor of the condition) is in scope from its point of declaration until the end of the substatements controlled
by the condition. If the name is re-declared in the outermost block of a substatement controlled by the
condition, the declaration that re-declares the name is ill-formed. [ Example:

if (int x = f()) {

int x;

}
else {

int x;

}

// ill-formed, redeclaration of x

// ill-formed, redeclaration of x

— end example ]

4 The value of a condition that is an initialized declaration in a statement other than a switch statement is the
value of the declared variable contextually converted to bool (Clause 4). If that conversion is ill-formed, the
program is ill-formed. The value of a condition that is an initialized declaration in a switch statement is the
value of the declared variable if it has integral or enumeration type, or of that variable implicitly converted
to integral or enumeration type otherwise. The value of a condition that is an expression is the value of the
expression, contextually converted to bool for statements other than switch; if that conversion is ill-formed,
the program is ill-formed. The value of the condition will be referred to as simply “the condition” where the
usage is unambiguous.
If a condition can be syntactically resolved as either an expression or the declaration of a block-scope name,
it is interpreted as a declaration.

5

§ 6.4

138

c(cid:13) ISO/IEC

N4296

6

1

In the decl-speciﬁer-seq of a condition, each decl-speciﬁer shall be either a type-speciﬁer or constexpr.
6.4.1 The if statement
[stmt.if]
If the condition (6.4) yields true the ﬁrst substatement is executed. If the else part of the selection statement
is present and the condition yields false, the second substatement is executed. If the ﬁrst substatement
is reached via a label, the condition is not evaluated and the second substatement is not executed. In the
second form of if statement (the one including else), if the ﬁrst substatement is also an if statement then
that inner if statement shall contain an else part.89
6.4.2 The switch statement

[stmt.switch]
1 The switch statement causes control to be transferred to one of several statements depending on the value

of a condition.

2 The condition shall be of integral type, enumeration type, or class type. If of class type, the condition is
contextually implicitly converted (Clause 4) to an integral or enumeration type. If the (possibly converted)
type is subject to integral promotions (4.5), the condition is converted to the promoted type. Any statement
within the switch statement can be labeled with one or more case labels as follows:

case constant-expression :

where the constant-expression shall be a converted constant expression (5.20) of the adjusted type of the
switch condition. No two of the case constants in the same switch shall have the same value after conversion.

3 There shall be at most one label of the form

default :

within a switch statement.

4 Switch statements can be nested; a case or default label is associated with the smallest switch enclosing

it.

5 When the switch statement is executed, its condition is evaluated and compared with each case constant. If
one of the case constants is equal to the value of the condition, control is passed to the statement following
the matched case label. If no case constant matches the condition, and if there is a default label, control
passes to the statement labeled by the default label. If no case matches and if there is no default then
none of the statements in the switch is executed.

6 case and default labels in themselves do not alter the ﬂow of control, which continues unimpeded across
such labels. To exit from a switch, see break, 6.6.1.
[ Note: Usually, the substatement that is the subject
of a switch is compound and case and default labels appear on the top-level statements contained within
the (compound) substatement, but this is not required. Declarations can appear in the substatement of a
switch-statement. — end note ]
6.5 Iteration statements
Iteration statements specify looping.

[stmt.iter]

1

iteration-statement:

while ( condition ) statement
do statement while ( expression ) ;
for ( for-init-statement conditionopt; expressionopt) statement
for ( for-range-declaration : for-range-initializer ) statement

for-init-statement:

expression-statement
simple-declaration

89) In other words, the else is associated with the nearest un-elsed if.

§ 6.5

139

c(cid:13) ISO/IEC

N4296

for-range-declaration:

attribute-speciﬁer-seqopt decl-speciﬁer-seq declarator

for-range-initializer:

expression
braced-init-list

See 8.3 for the optional attribute-speciﬁer-seq in a for-range-declaration.
with a semicolon. — end note ]

[ Note: A for-init-statement ends

2 The substatement in an iteration-statement implicitly deﬁnes a block scope (3.3) which is entered and exited

each time through the loop.
If the substatement in an iteration-statement is a single statement and not a compound-statement, it is as if
it was rewritten to be a compound-statement containing the original statement. [ Example:

while (--x >= 0)

int i;

can be equivalently rewritten as

while (--x >= 0) {

int i;

}

3 Thus after the while statement, i is no longer in scope. — end example ]
4

[ Note: The requirements on conditions in iteration statements are described in 6.4. — end note ]
6.5.1 The while statement
[stmt.while]
In the while statement the substatement is executed repeatedly until the value of the condition (6.4) becomes
false. The test takes place before each execution of the substatement.

1

2 When the condition of a while statement is a declaration, the scope of the variable that is declared extends

from its point of declaration (3.3.2) to the end of the while statement. A while statement of the form

while (T t = x) statement

is equivalent to

label:
{

T t = x;
if (t) {

statement
goto label;

}

}

// start of condition scope

// end of condition scope

The variable created in a condition is destroyed and created with each iteration of the loop. [ Example:

struct A {
int val;
A(int i) : val(i) { }
~A() { }
operator bool() { return val != 0; }

};
int i = 1;
while (A a = i) {

// ...
i = 0;

}

§ 6.5.1

140

c(cid:13) ISO/IEC

N4296

In the while-loop, the constructor and destructor are each called twice, once for the condition that succeeds
and once for the condition that fails. — end example ]
6.5.2 The do statement

[stmt.do]
1 The expression is contextually converted to bool (Clause 4); if that conversion is ill-formed, the program is

ill-formed.
In the do statement the substatement is executed repeatedly until the value of the expression becomes false.
The test takes place after each execution of the statement.
6.5.3 The for statement

[stmt.for]

2

1 The for statement

for ( for-init-statement conditionopt; expressionopt) statement

is equivalent to

{

}

for-init-statement
while ( condition ) {

statement
expression ;

}

except that names declared in the for-init-statement are in the same declarative region as those declared in
the condition, and except that a continue in statement (not enclosed in another iteration statement) will
execute expression before re-evaluating condition. [ Note: Thus the ﬁrst statement speciﬁes initialization for
the loop; the condition (6.4) speciﬁes a test, made before each iteration, such that the loop is exited when
the condition becomes false; the expression often speciﬁes incrementing that is done after each iteration.
— end note ]

2 Either or both of the condition and the expression can be omitted. A missing condition makes the implied

while clause equivalent to while(true).
If the for-init-statement is a declaration, the scope of the name(s) declared extends to the end of the for
statement. [ Example:

3

int i = 42;
int a[10];

for (int i = 0; i < 10; i++)

a[i] = i;

int j = i;

// j = 42

— end example ]
6.5.4 The range-based for statement

1 For a range-based for statement of the form

for ( for-range-declaration : expression ) statement

let range-init be equivalent to the expression surrounded by parentheses90

( expression )

[stmt.ranged]

90) this ensures that a top-level comma operator cannot be reinterpreted as a delimiter between init-declarators in the decla-
ration of __range.

§ 6.5.4

141

c(cid:13) ISO/IEC

N4296

and for a range-based for statement of the form

for ( for-range-declaration : braced-init-list ) statement

let range-init be equivalent to the braced-init-list. In each case, a range-based for statement is equivalent
to

auto && __range = range-init;
for ( auto __begin = begin-expr,

__end = end-expr;

__begin != __end;
++__begin ) {

for-range-declaration = *__begin;
statement

{

}

}

where __range, __begin, and __end are variables deﬁned for exposition only, and _RangeT is the type of
the expression, and begin-expr and end-expr are determined as follows:

(1.1)

(1.2)

(1.3)

—

—

—

if _RangeT is an array type, begin-expr and end-expr are __range and __range + __bound, respec-
tively, where __bound is the array bound.
If _RangeT is an array of unknown size or an array of
incomplete type, the program is ill-formed;
if _RangeT is a class type, the unqualiﬁed-ids begin and end are looked up in the scope of class _RangeT
as if by class member access lookup (3.4.5), and if either (or both) ﬁnds at least one declaration, begin-
expr and end-expr are __range.begin() and __range.end(), respectively;
otherwise, begin-expr and end-expr are begin(__range) and end(__range), respectively, where begin
and end are looked up in the associated namespaces (3.4.2). [ Note: Ordinary unqualiﬁed lookup (3.4.1)
is not performed. — end note ]

[ Example:

int array[5] = { 1, 2, 3, 4, 5 };
for (int& x : array)

x *= 2;

2

— end example ]
In the decl-speciﬁer-seq of a for-range-declaration, each decl-speciﬁer shall be either a type-speciﬁer or
constexpr. The decl-speciﬁer-seq shall not deﬁne a class or enumeration.
6.6 Jump statements

[stmt.jump]

1 Jump statements unconditionally transfer control.

jump-statement:

break ;
continue ;
return expressionopt;
return braced-init-list ;
goto identiﬁer ;

2 On exit from a scope (however accomplished), objects with automatic storage duration (3.7.3) that have been
constructed in that scope are destroyed in the reverse order of their construction. [ Note: For temporaries,
see 12.2. — end note ] Transfer out of a loop, out of a block, or back past an initialized variable with
automatic storage duration involves the destruction of objects with automatic storage duration that are in
scope at the point transferred from but not at the point transferred to. (See 6.7 for transfers into blocks).

§ 6.6

142

c(cid:13) ISO/IEC

N4296

[ Note: However, the program can be terminated (by calling std::exit() or std::abort() (18.5), for
example) without destroying class objects with automatic storage duration. — end note ]
6.6.1 The break statement

[stmt.break]
1 The break statement shall occur only in an iteration-statement or a switch statement and causes termination
of the smallest enclosing iteration-statement or switch statement; control passes to the statement following
the terminated statement, if any.
6.6.2 The continue statement

[stmt.cont]
1 The continue statement shall occur only in an iteration-statement and causes control to pass to the loop-
continuation portion of the smallest enclosing iteration-statement, that is, to the end of the loop. More
precisely, in each of the statements

while (foo) {

{

}

// ...

contin: ;
}

do {
{

}

// ...

contin: ;
} while (foo);

for (;;) {

{

}

// ...

contin: ;
}

a continue not contained in an enclosed iteration statement is equivalent to goto contin.
6.6.3 The return statement

[stmt.return]

1 A function returns to its caller by the return statement.
2 The expression or braced-init-list of a return statement is called its operand. A return statement with
no operand shall be used only in a function whose return type is cv void, a constructor (12.1), or a
destructor (12.4). A return statement with an operand of type void shall be used only in a function whose
return type is cv void. A return statement with any other operand shall be used only in a function whose
return type is not cv void; the return statement initializes the object or reference to be returned by copy-
initialization (8.5) from the operand. [ Note: A return statement can involve the construction and copy or
move of a temporary object (12.2). A copy or move operation associated with a return statement may be
elided or considered as an rvalue for the purpose of overload resolution in selecting a constructor (12.8).
— end note ] [ Example:

std::pair<std::string,int> f(const char* p, int x) {

return {p,x};

}

— end example ] Flowing oﬀ the end of a function is equivalent to a return with no value; this results in
undeﬁned behavior in a value-returning function.

3 The copy-initialization of the returned entity is sequenced before the destruction of temporaries at the end
of the full-expression established by the operand of the return statement, which, in turn, is sequenced before
the destruction of local variables (6.6) of the block enclosing the return statement.
6.6.4 The goto statement

[stmt.goto]
1 The goto statement unconditionally transfers control to the statement labeled by the identiﬁer. The identiﬁer

shall be a label (6.1) located in the current function.
6.7 Declaration statement

1 A declaration statement introduces one or more new identiﬁers into a block; it has the form

declaration-statement:
block-declaration

§ 6.7

[stmt.dcl]

143

c(cid:13) ISO/IEC

N4296

If an identiﬁer introduced by a declaration was previously declared in an outer block, the outer declaration
is hidden for the remainder of the block, after which it resumes its force.

3

2 Variables with automatic storage duration (3.7.3) are initialized each time their declaration-statement is
executed. Variables with automatic storage duration declared in the block are destroyed on exit from the
block (6.6).
It is possible to transfer into a block, but not in a way that bypasses declarations with initialization. A
program that jumps91 from a point where a variable with automatic storage duration is not in scope to a
point where it is in scope is ill-formed unless the variable has scalar type, class type with a trivial default
constructor and a trivial destructor, a cv-qualiﬁed version of one of these types, or an array of one of the
preceding types and is declared without an initializer (8.5). [ Example:

void f() {

// ...
goto lx;
// ...

ly:

lx:

X a = 1;
// ...

goto ly;

}

— end example ]

// ill-formed: jump into scope of a

// OK, jump implies destructor
// call for a followed by construction
// again immediately following label ly

4 The zero-initialization (8.5) of all block-scope variables with static storage duration (3.7.1) or thread storage
duration (3.7.2) is performed before any other initialization takes place. Constant initialization (3.6.2) of a
block-scope entity with static storage duration, if applicable, is performed before its block is ﬁrst entered.
An implementation is permitted to perform early initialization of other block-scope variables with static or
thread storage duration under the same conditions that an implementation is permitted to statically initialize
a variable with static or thread storage duration in namespace scope (3.6.2). Otherwise such a variable is
initialized the ﬁrst time control passes through its declaration; such a variable is considered initialized upon
the completion of its initialization. If the initialization exits by throwing an exception, the initialization
is not complete, so it will be tried again the next time control enters the declaration.
If control enters
the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for
completion of the initialization.92 If control re-enters the declaration recursively while the variable is being
initialized, the behavior is undeﬁned. [ Example:

int foo(int i) {

static int s = foo(2*i);
return i+1;

}

// recursive call - undeﬁned

— end example ]

5 The destructor for a block-scope object with static or thread storage duration will be executed if and only
if it was constructed. [ Note: 3.6.3 describes the order in which block-scope objects with static and thread
storage duration are destroyed. — end note ]
91) The transfer from the condition of a switch statement to a case label is considered a jump in this respect.
92) The implementation must not introduce any deadlock around execution of the initializer.

§ 6.7

144

c(cid:13) ISO/IEC

N4296

6.8 Ambiguity resolution

[stmt.ambig]
1 There is an ambiguity in the grammar involving expression-statements and declarations: An expression-
statement with a function-style explicit type conversion (5.2.3) as its leftmost subexpression can be indis-
tinguishable from a declaration where the ﬁrst declarator starts with a (. In those cases the statement is a
declaration.
[ Note: If the statement cannot syntactically be a declaration, there is no ambiguity, so this rule does not
apply. The whole statement might need to be examined to determine whether this is the case. This resolves
the meaning of many examples. [ Example: Assuming T is a simple-type-speciﬁer (7.1.6),

2

T(a)->m = 7;
T(a)++;
T(a,5)<<c;

// expression-statement
// expression-statement
// expression-statement

T(*d)(int);
T(e)[5];
T(f) = { 1, 2 };
T(*g)(double(3));

// declaration
// declaration
// declaration
// declaration

In the last example above, g, which is a pointer to T, is initialized to double(3). This is of course ill-formed
for semantic reasons, but that does not aﬀect the syntactic analysis. — end example ]
The remaining cases are declarations. [ Example:

class T {

// ...
public:
T();
T(int);
T(int, int);

};
T(a);
T(*b)();
T(c)=7;
T(d),e,f=3;
extern int h;
T(g)(h,2);

// declaration
// declaration
// declaration
// declaration

// declaration

— end example ] — end note ]

3 The disambiguation is purely syntactic; that is, the meaning of the names occurring in such a statement,
beyond whether they are type-names or not, is not generally used in or changed by the disambiguation. Class
templates are instantiated as necessary to determine if a qualiﬁed name is a type-name. Disambiguation
precedes parsing, and a statement disambiguated as a declaration may be an ill-formed declaration.
If,
during parsing, a name in a template parameter is bound diﬀerently than it would be bound during a trial
parse, the program is ill-formed. No diagnostic is required. [ Note: This can occur only when the name is
declared earlier in the declaration. — end note ] [ Example:

struct T1 {

T1 operator()(int x) { return T1(x); }
int operator=(int x) { return x; }
T1(int) { }

};
struct T2 { T2(int){ } };
int a, (*(*b)(T2))(int), c, d;

void f() {

§ 6.8

145

c(cid:13) ISO/IEC

N4296

// disambiguation requires this to be parsed as a declaration:
T1(a) = 3,
T2(4),
(*(*b)(T2(c)))(int(d));

// T2 will be declared as
// a variable of type T1
// but this will not allow
// the last part of the
// declaration to parse
// properly since it depends
// on T2 being a type-name

}

— end example ]

§ 6.8

146

c(cid:13) ISO/IEC

7 Declarations

N4296

[dcl.dcl]

1 Declarations generally specify how names are to be interpreted. Declarations have the form

declaration-seq:

declaration
declaration-seq declaration

declaration:

block-declaration
function-deﬁnition
template-declaration
explicit-instantiation
explicit-specialization
linkage-speciﬁcation
namespace-deﬁnition
empty-declaration
attribute-declaration

block-declaration:

simple-declaration
asm-deﬁnition
namespace-alias-deﬁnition
using-declaration
using-directive
static_assert-declaration
alias-declaration
opaque-enum-declaration

alias-declaration:

using identiﬁer attribute-speciﬁer-seqopt= type-id ;

simple-declaration:

decl-speciﬁer-seqopt init-declarator-listopt;
attribute-speciﬁer-seq decl-speciﬁer-seqopt init-declarator-list ;

static_assert-declaration:

static_assert ( constant-expression ) ;
static_assert ( constant-expression , string-literal ) ;

empty-declaration:

;

attribute-declaration:

attribute-speciﬁer-seq ;

[ Note: asm-deﬁnitions are described in 7.4, and linkage-speciﬁcations are described in 7.5. Function-
deﬁnitions are described in 8.4 and template-declarations are described in Clause 14. Namespace-deﬁnitions
are described in 7.3.1, using-declarations are described in 7.3.3 and using-directives are described in 7.3.4.
— end note ]

2 The simple-declaration

attribute-speciﬁer-seqopt decl-speciﬁer-seqopt init-declarator-listopt;

is divided into three parts. Attributes are described in 7.6. decl-speciﬁers, the principal components of a
decl-speciﬁer-seq, are described in 7.1. declarators, the components of an init-declarator-list, are described
in Clause 8. The attribute-speciﬁer-seq in a simple-declaration appertains to each of the entities declared by
the declarators of the init-declarator-list.
[ Note: In the declaration for an entity, attributes appertaining

Declarations

147

c(cid:13) ISO/IEC

N4296

to that entity may appear at the start of the declaration and after the declarator-id for that declaration.
— end note ] [ Example:

[[noreturn]] void f [[noreturn]] (); // OK

— end example ]

3 Except where otherwise speciﬁed, the meaning of an attribute-declaration is implementation-deﬁned.
4 A declaration occurs in a scope (3.3); the scope rules are summarized in 3.4. A declaration that declares a
function or deﬁnes a class, namespace, template, or function also has one or more scopes nested within it.
These nested scopes, in turn, can have declarations nested within them. Unless otherwise stated, utterances
in Clause 7 about components in, of, or contained by a declaration or subcomponent thereof refer only to
those components of the declaration that are not nested within scopes nested within the declaration.
In a simple-declaration, the optional init-declarator-list can be omitted only when declaring a class (Clause 9)
or enumeration (7.2), that is, when the decl-speciﬁer-seq contains either a class-speciﬁer, an elaborated-type-
speciﬁer with a class-key (9.1), or an enum-speciﬁer.
In these cases and whenever a class-speciﬁer or
enum-speciﬁer is present in the decl-speciﬁer-seq, the identiﬁers in these speciﬁers are among the names
being declared by the declaration (as class-names, enum-names, or enumerators, depending on the syntax).
In such cases, the decl-speciﬁer-seq shall introduce one or more names into the program, or shall redeclare
a name introduced by a previous declaration. [ Example:

5

// ill-formed
enum { };
typedef class { }; // ill-formed

6

— end example ]
In a static_assert-declaration the constant-expression shall be a constant expression (5.20) that can be
contextually converted to bool (Clause 4). If the value of the expression when so converted is true, the
declaration has no eﬀect. Otherwise, the program is ill-formed, and the resulting diagnostic message (1.4)
shall include the text of the string-literal, if one is supplied, except that characters not in the basic source
character set (2.3) are not required to appear in the diagnostic message. [ Example:

static_assert(sizeof(long) >= 8, "64-bit code generation required for this library.");

— end example ]

7 An empty-declaration has no eﬀect.
8 Each init-declarator in the init-declarator-list contains exactly one declarator-id, which is the name declared
by that init-declarator and hence one of the names declared by the declaration. The type-speciﬁers (7.1.6)
in the decl-speciﬁer-seq and the recursive declarator structure of the init-declarator describe a type (8.3),
which is then associated with the name being declared by the init-declarator.
If the decl-speciﬁer-seq contains the typedef speciﬁer, the declaration is called a typedef declaration and the
name of each init-declarator is declared to be a typedef-name, synonymous with its associated type (7.1.3).
If the decl-speciﬁer-seq contains no typedef speciﬁer, the declaration is called a function declaration if the
type associated with the name is a function type (8.3.5) and an object declaration otherwise.

9

10 Syntactic components beyond those found in the general form of declaration are added to a function decla-
ration to make a function-deﬁnition. An object declaration, however, is also a deﬁnition unless it contains
the extern speciﬁer and has no initializer (3.1). A deﬁnition causes the appropriate amount of storage to
be reserved and any appropriate initialization (8.5) to be done.

11 Only in function declarations for constructors, destructors, and type conversions can the decl-speciﬁer-seq

be omitted.93
93) The “implicit int” rule of C is no longer supported.

Declarations

148

c(cid:13) ISO/IEC

7.1 Speciﬁers

1 The speciﬁers that can be used in a declaration are

N4296

[dcl.spec]

decl-speciﬁer:

storage-class-speciﬁer
type-speciﬁer
function-speciﬁer
friend
typedef
constexpr
decl-speciﬁer-seq:

decl-speciﬁer attribute-speciﬁer-seqopt
decl-speciﬁer decl-speciﬁer-seq

The optional attribute-speciﬁer-seq in a decl-speciﬁer-seq appertains to the type determined by the preceding
decl-speciﬁers (8.3). The attribute-speciﬁer-seq aﬀects the type only for the declaration it appears in, not
other declarations involving the same type.

2 Each decl-speciﬁer shall appear at most once in the complete decl-speciﬁer-seq of a declaration, except that

long may appear twice.
If a type-name is encountered while parsing a decl-speciﬁer-seq, it is interpreted as part of the decl-speciﬁer-
seq if and only if there is no previous type-speciﬁer other than a cv-qualiﬁer in the decl-speciﬁer-seq. The
sequence shall be self-consistent as described below. [ Example:

3

typedef char* Pc;
static Pc;

// error: name missing

Here, the declaration static Pc is ill-formed because no name was speciﬁed for the static variable of type Pc.
To get a variable called Pc, a type-speciﬁer (other than const or volatile) has to be present to indicate that
the typedef-name Pc is the name being (re)declared, rather than being part of the decl-speciﬁer sequence.
For another example,
void f(const Pc);
void g(const int Pc);

// void f(char* const) (not const char*)
// void g(const int)

4

— end example ]
[ Note: Since signed, unsigned, long, and short by default imply int, a type-name appearing after one of
those speciﬁers is treated as the name being (re)declared. [ Example:

void h(unsigned Pc);
void k(unsigned int Pc);

// void h(unsigned int)
// void k(unsigned int)

— end example ] — end note ]
7.1.1 Storage class speciﬁers

1 The storage class speciﬁers are

[dcl.stc]

storage-class-speciﬁer:

register
static
thread_local
extern
mutable

At most one storage-class-speciﬁer shall appear in a given decl-speciﬁer-seq, except that thread_local may
appear with static or extern. If thread_local appears in any declaration of a variable it shall be present
in all declarations of that entity.
If a storage-class-speciﬁer appears in a decl-speciﬁer-seq, there can be

§ 7.1.1

149

c(cid:13) ISO/IEC

N4296

no typedef speciﬁer in the same decl-speciﬁer-seq and the init-declarator-list of the declaration shall not
be empty (except for an anonymous union declared in a named namespace or in the global namespace,
which shall be declared static (9.5)). The storage-class-speciﬁer applies to the name declared by each init-
declarator in the list and not to any names declared by other speciﬁers. A storage-class-speciﬁer other than
thread_local shall not be speciﬁed in an explicit specialization (14.7.3) or an explicit instantiation (14.7.2)
directive.

2 The register speciﬁer shall be applied only to names of variables declared in a block (6.3) or to function
parameters (8.4). It speciﬁes that the named variable has automatic storage duration (3.7.3). A variable
declared without a storage-class-speciﬁer at block scope or declared as a function parameter has automatic
storage duration by default.

3 A register speciﬁer is a hint to the implementation that the variable so declared will be heavily used.
[ Note: The hint can be ignored and in most implementations it will be ignored if the address of the variable
is taken. This use is deprecated (see D.2). — end note ]

4 The thread_local speciﬁer indicates that the named entity has thread storage duration (3.7.2). It shall be
applied only to the names of variables of namespace or block scope and to the names of static data members.
When thread_local is applied to a variable of block scope the storage-class-speciﬁer static is implied if
no other storage-class-speciﬁer appears in the decl-speciﬁer-seq.

5 The static speciﬁer can be applied only to names of variables and functions and to anonymous unions (9.5).
There can be no static function declarations within a block, nor any static function parameters. A static
speciﬁer used in the declaration of a variable declares the variable to have static storage duration (3.7.1),
unless accompanied by the thread_local speciﬁer, which declares the variable to have thread storage
duration (3.7.2). A static speciﬁer can be used in declarations of class members; 9.4 describes its eﬀect.
For the linkage of a name declared with a static speciﬁer, see 3.5.

6 The extern speciﬁer can be applied only to the names of variables and functions. The extern speciﬁer cannot
be used in the declaration of class members or function parameters. For the linkage of a name declared with
an extern speciﬁer, see 3.5.
[ Note: The extern keyword can also be used in explicit-instantiations and
linkage-speciﬁcations, but it is not a storage-class-speciﬁer in such contexts. — end note ]

7 The linkages implied by successive declarations for a given entity shall agree. That is, within a given scope,
each declaration declaring the same variable name or the same overloading of a function name shall imply
the same linkage. Each function in a given set of overloaded functions can have a diﬀerent linkage, however.
[ Example:

static char* f();
char* f()

{ /∗ ... ∗/ }

char* g();
static char* g()

{ /∗ ... ∗/ }

void h();
inline void h();

inline void l();
void l();

inline void m();
extern void m();

static void n();
inline void n();

§ 7.1.1

// f() has internal linkage
// f() still has internal linkage

// g() has external linkage
// error: inconsistent linkage

// external linkage

// external linkage

// external linkage

// internal linkage

150

N4296

c(cid:13) ISO/IEC

static int a;
int a;

static int b;
extern int b;

int c;
static int c;

extern int d;
static int d;

— end example ]

// a has internal linkage
// error: two deﬁnitions

// b has internal linkage
// b still has internal linkage

// c has external linkage
// error: inconsistent linkage

// d has external linkage
// error: inconsistent linkage

8 The name of a declared but undeﬁned class can be used in an extern declaration. Such a declaration can

only be used in ways that do not require a complete class type. [ Example:

struct S;
extern S a;
extern S f();
extern void g(S);

void h() {

g(a);
f();

}

// error: S is incomplete
// error: S is incomplete

— end example ]

9 The mutable speciﬁer shall appear only in the declaration of a non-static data member (9.2) whose type is

neither const-qualiﬁed nor a reference type. [ Example:

class X {

mutable const int* p;
mutable int* const q;

};

// OK
// ill-formed

— end example ]

10 The mutable speciﬁer on a class data member nulliﬁes a const speciﬁer applied to the containing class object
and permits modiﬁcation of the mutable class member even though the rest of the object is const (7.1.6.1).
7.1.2 Function speciﬁers
[dcl.fct.spec]

1 Function-speciﬁers can be used only in function declarations.

function-speciﬁer:

inline
virtual
explicit

2 A function declaration (8.3.5, 9.3, 11.3) with an inline speciﬁer declares an inline function. The inline
speciﬁer indicates to the implementation that inline substitution of the function body at the point of call
is to be preferred to the usual function call mechanism. An implementation is not required to perform this
inline substitution at the point of call; however, even if this inline substitution is omitted, the other rules
for inline functions deﬁned by 7.1.2 shall still be respected.

§ 7.1.2

151

c(cid:13) ISO/IEC

N4296

3 A function deﬁned within a class deﬁnition is an inline function. The inline speciﬁer shall not appear on
a block scope function declaration.94 If the inline speciﬁer is used in a friend declaration, that declaration
shall be a deﬁnition or the function shall have previously been declared inline.

4 An inline function shall be deﬁned in every translation unit in which it is odr-used and shall have exactly
the same deﬁnition in every case (3.2). [ Note: A call to the inline function may be encountered before its
deﬁnition appears in the translation unit. — end note ] If the deﬁnition of a function appears in a translation
unit before its ﬁrst declaration as inline, the program is ill-formed. If a function with external linkage is
declared inline in one translation unit, it shall be declared inline in all translation units in which it appears;
no diagnostic is required. An inline function with external linkage shall have the same address in all
translation units. A static local variable in an extern inline function always refers to the same object.
A type deﬁned within the body of an extern inline function is the same type in every translation unit.

5 The virtual speciﬁer shall be used only in the initial declaration of a non-static class member function;

see 10.3.

6 The explicit speciﬁer shall be used only in the declaration of a constructor or conversion function within

its class deﬁnition; see 12.3.1 and 12.3.2.
7.1.3 The typedef speciﬁer

[dcl.typedef]
1 Declarations containing the decl-speciﬁer typedef declare identiﬁers that can be used later for naming
fundamental (3.9.1) or compound (3.9.2) types. The typedef speciﬁer shall not be combined in a decl-
speciﬁer-seq with any other kind of speciﬁer except a type-speciﬁer, and it shall not be used in the decl-
speciﬁer-seq of a parameter-declaration (8.3.5) nor in the decl-speciﬁer-seq of a function-deﬁnition (8.4).

typedef-name:
identiﬁer

A name declared with the typedef speciﬁer becomes a typedef-name. Within the scope of its declaration, a
typedef-name is syntactically equivalent to a keyword and names the type associated with the identiﬁer in
the way described in Clause 8. A typedef-name is thus a synonym for another type. A typedef-name does
not introduce a new type the way a class declaration (9.1) or enum declaration does. [ Example: after

typedef int MILES, *KLICKSP;

the constructions
MILES distance;
extern KLICKSP metricp;

are all correct declarations; the type of distance is int and that of metricp is “pointer to int.” — end
example ]

2 A typedef-name can also be introduced by an alias-declaration. The identiﬁer following the using keyword
becomes a typedef-name and the optional attribute-speciﬁer-seq following the identiﬁer appertains to that
typedef-name. It has the same semantics as if it were introduced by the typedef speciﬁer. In particular, it
does not deﬁne a new type and it shall not appear in the type-id. [ Example:

using handler_t = void (*)(int);
extern handler_t ignore;
extern void (*ignore)(int);
using cell = pair<void*, cell*>;

// redeclare ignore
// ill-formed

3

— end example ]
In a given non-class scope, a typedef speciﬁer can be used to redeﬁne the name of any type declared in that
scope to refer to the type to which it already refers. [ Example:
94) The inline keyword has no eﬀect on the linkage of a function.

§ 7.1.3

152

c(cid:13) ISO/IEC

N4296

typedef struct s { /∗ ... ∗/ } s;
typedef int I;
typedef int I;
typedef I I;
— end example ]
In a given class scope, a typedef speciﬁer can be used to redeﬁne any class-name declared in that scope
that is not also a typedef-name to refer to the type to which it already refers. [ Example:

struct S {

typedef struct A { } A;
typedef struct B B;
typedef A A;

};

// OK
// OK
// error

— end example ]
If a typedef speciﬁer is used to redeﬁne in a given scope an entity that can be referenced using an elaborated-
type-speciﬁer, the entity can continue to be referenced by an elaborated-type-speciﬁer or as an enumeration
or class name in an enumeration or class deﬁnition respectively. [ Example:

struct S;
typedef struct S S;
int main() {

struct S* p;

// OK

}
struct S { };
— end example ]
In a given scope, a typedef speciﬁer shall not be used to redeﬁne the name of any type declared in that
scope to refer to a diﬀerent type. [ Example:

// OK

class complex { /∗ ... ∗/ };
typedef int complex;

// error: redeﬁnition

4

5

6

— end example ]

7 Similarly, in a given scope, a class or enumeration shall not be declared with the same name as a typedef-name

that is declared in that scope and refers to a type other than the class or enumeration itself. [ Example:

typedef int complex;
class complex { /* ...

*/ };

// error: redeﬁnition

8

— end example ]
[ Note: A typedef-name that names a class type, or a cv-qualiﬁed version thereof, is also a class-name (9.1).
If a typedef-name is used to identify the subject of an elaborated-type-speciﬁer (7.1.6.3), a class deﬁnition
(Clause 9), a constructor declaration (12.1), or a destructor declaration (12.4), the program is ill-formed.
— end note ] [ Example:

struct S {

S();
~S();

};

typedef struct S T;

S a = T();
struct T * p;

§ 7.1.3

// OK
// error

153

c(cid:13) ISO/IEC

N4296

9

— end example ]
If the typedef declaration deﬁnes an unnamed class (or enum), the ﬁrst typedef-name declared by the dec-
laration to be that class type (or enum type) is used to denote the class type (or enum type) for linkage
purposes only (3.5). [ Example:
typedef struct { } *ps, S;

// S is the class name for linkage purposes

— end example ]
7.1.4 The friend speciﬁer

1 The friend speciﬁer is used to specify access to class members; see 11.3.

[dcl.friend]

7.1.5 The constexpr speciﬁer

[dcl.constexpr]
1 The constexpr speciﬁer shall be applied only to the deﬁnition of a variable or variable template, the
declaration of a function or function template, or the declaration of a static data member of a literal
If any declaration of a function or function template has a constexpr speciﬁer, then all its
type (3.9).
declarations shall contain the constexpr speciﬁer.
[ Note: An explicit specialization can diﬀer from the
template declaration with respect to the constexpr speciﬁer. — end note ] [ Note: Function parameters
cannot be declared constexpr. — end note ] [ Example:
constexpr void square(int &x); // OK: declaration
// OK: deﬁnition
constexpr int bufsz = 1024;
// error: pixel is a type
constexpr struct pixel {

int x;
int y;
constexpr pixel(int);

};
constexpr pixel::pixel(int a)

: x(a), y(x)
{ square(x); }

constexpr pixel small(2);

// OK: declaration

// OK: deﬁnition

// error: square not deﬁned, so small(2)
// not constant (5.20) so constexpr not satisﬁed

constexpr void square(int &x) { // OK: deﬁnition

x *= x;

}
constexpr pixel large(4);
int next(constexpr int x) {

return x + 1;

}
extern constexpr int memsz;

// OK: square deﬁned
// error: not for parameters

// error: not a deﬁnition

— end example ]

2 A constexpr speciﬁer used in the declaration of a function that is not a constructor declares that function
to be a constexpr function. Similarly, a constexpr speciﬁer used in a constructor declaration declares that
constructor to be a constexpr constructor. constexpr functions and constexpr constructors are implicitly
inline (7.1.2).

3 The deﬁnition of a constexpr function shall satisfy the following constraints:

(3.1)

(3.2)

(3.3)

—
—
—

it shall not be virtual (10.3);
its return type shall be a literal type;
each of its parameter types shall be a literal type;

§ 7.1.5

154

c(cid:13) ISO/IEC

N4296

(3.4)
(3.4.1)

(3.4.2)

(3.4.3)

(3.4.4)

—

its function-body shall be = delete, = default, or a compound-statement that does not contain
—
—
—
—

an asm-deﬁnition,
a goto statement,
a try-block, or
a deﬁnition of a variable of non-literal type or of static or thread storage duration or for which
no initialization is performed.

[ Example:

constexpr int square(int x)

{ return x * x; }

constexpr long long_max()
{ return 2147483647; }

constexpr int abs(int x) {

if (x < 0)
x = -x;
return x;

// OK

// OK

// OK

// error: variable has static storage duration

// error: variable is uninitialized

}
constexpr int first(int n) {

static int value = n;
return value;

}
constexpr int uninit() {

int a;
return a;

}
constexpr int prev(int x)

{ return --x; }

// OK
constexpr int g(int x, int n) { // OK

int r = 1;
while (--n > 0) r *= x;
return r;

}

— end example ]

4 The deﬁnition of a constexpr constructor shall satisfy the following constraints:

(4.1)

(4.2)

(4.3)

(4.4)

(4.5)

(4.6)

(4.7)

(4.8)

—
—
—

the class shall not have any virtual base classes;
each of the parameter types shall be a literal type;
its function-body shall not be a function-try-block;

In addition, either its function-body shall be = delete, or it shall satisfy the following constraints:

—

—
—
—

—

either its function-body shall be = default, or the compound-statement of its function-body shall satisfy
the constraints for a function-body of a constexpr function;
every non-variant non-static data member and base class sub-object shall be initialized (12.6.2);
if the class is a union having variant members (9.5), exactly one of them shall be initialized;
if the class is a union-like class, but is not a union, for each of its anonymous union members having
variant members, exactly one of them shall be initialized;
for a non-delegating constructor, every constructor selected to initialize non-static data members and
base class sub-objects shall be a constexpr constructor;

§ 7.1.5

155

c(cid:13) ISO/IEC

N4296

(4.9)

—

for a delegating constructor, the target constructor shall be a constexpr constructor.

[ Example:

constexpr explicit Length(int i = 0) : val(i) { }

struct Length {

private:

int val;

};

— end example ]

5 For a non-template, non-defaulted constexpr function or a non-template, non-defaulted, non-inheriting
constexpr constructor, if no argument values exist such that an invocation of the function or constructor
could be an evaluated subexpression of a core constant expression (5.20), or, for a constructor, a constant
initializer for some object (3.6.2), the program is ill-formed; no diagnostic required. [ Example:

constexpr int f(bool b)

{ return b ? throw 0 : 0; }

constexpr int f() { return f(true); }

struct B {

constexpr B(int x) : i(0) { }
int i;

};

// OK
// ill-formed, no diagnostic required

// x is unused

int global;

struct D : B {

constexpr D() : B(global) { }

};

// ill-formed, no diagnostic required
// lvalue-to-rvalue conversion on non-constant global

6

— end example ]
If the instantiated template specialization of a constexpr function template or member function of a class
template would fail to satisfy the requirements for a constexpr function or constexpr constructor, that
specialization is still a constexpr function or constexpr constructor, even though a call to such a function
cannot appear in a constant expression. If no specialization of the template would satisfy the requirements for
a constexpr function or constexpr constructor when considered as a non-template function or constructor,
the template is ill-formed; no diagnostic required.

7 A call to a constexpr function produces the same result as a call to an equivalent non-constexpr function

in all respects except that a call to a constexpr function can appear in a constant expression.

8 The constexpr speciﬁer has no eﬀect on the type of a constexpr function or a constexpr constructor.

[ Example:

constexpr int bar(int x, int y) // OK

{ return x + y + x*y; }

// ...
int bar(int x, int y)

{ return x * 2 + 3 * y; }

// error: redeﬁnition of bar

— end example ]

9 A constexpr speciﬁer used in an object declaration declares the object as const. Such an object shall have
literal type and shall be initialized. If it is initialized by a constructor call, that call shall be a constant

§ 7.1.5

156

c(cid:13) ISO/IEC

N4296

expression (5.20). Otherwise, or if a constexpr speciﬁer is used in a reference declaration, every full-
expression that appears in its initializer shall be a constant expression.
[ Note: Each implicit conversion
used in converting the initializer expressions and each constructor call used for the initialization is part of
such a full-expression. — end note ] [ Example:

struct pixel {

int x, y;

};
constexpr pixel ur = { 1294, 1024 };// OK
constexpr pixel origin;

// error: initializer missing

— end example ]
7.1.6 Type speciﬁers

1 The type-speciﬁers are

[dcl.type]

type-speciﬁer:

trailing-type-speciﬁer
class-speciﬁer
enum-speciﬁer
trailing-type-speciﬁer:

simple-type-speciﬁer
elaborated-type-speciﬁer
typename-speciﬁer
cv-qualiﬁer
type-speciﬁer-seq:

type-speciﬁer attribute-speciﬁer-seqopt
type-speciﬁer type-speciﬁer-seq

trailing-type-speciﬁer-seq:

trailing-type-speciﬁer attribute-speciﬁer-seqopt
trailing-type-speciﬁer trailing-type-speciﬁer-seq

The optional attribute-speciﬁer-seq in a type-speciﬁer-seq or a trailing-type-speciﬁer-seq appertains to the
type denoted by the preceding type-speciﬁers (8.3). The attribute-speciﬁer-seq aﬀects the type only for the
declaration it appears in, not other declarations involving the same type.

2 As a general rule, at most one type-speciﬁer is allowed in the complete decl-speciﬁer-seq of a declaration or

in a type-speciﬁer-seq or trailing-type-speciﬁer-seq. The only exceptions to this rule are the following:

(2.1)

(2.2)

(2.3)

(2.4)

(2.5)

(2.6)

—
—
—
—
—
—

const can be combined with any type speciﬁer except itself.
volatile can be combined with any type speciﬁer except itself.
signed or unsigned can be combined with char, long, short, or int.
short or long can be combined with int.
long can be combined with double.
long can be combined with long.

3 Except in a declaration of a constructor, destructor, or conversion function, at least one type-speciﬁer
that is not a cv-qualiﬁer shall appear in a complete type-speciﬁer-seq or a complete decl-speciﬁer-seq.95
A type-speciﬁer-seq shall not deﬁne a class or enumeration unless it appears in the type-id of an alias-
declaration (7.1.3) that is not the declaration of a template-declaration.
95) There is no special provision for a decl-speciﬁer-seq that lacks a type-speciﬁer or that has a type-speciﬁer that only speciﬁes
cv-qualiﬁers. The “implicit int” rule of C is no longer supported.

§ 7.1.6

157

c(cid:13) ISO/IEC

N4296

4

[ Note: enum-speciﬁers, class-speciﬁers, and typename-speciﬁers are discussed in 7.2, Clause 9, and 14.6,
respectively. The remaining type-speciﬁers are discussed in the rest of this section. — end note ]
7.1.6.1 The cv-qualiﬁers

[dcl.type.cv]
1 There are two cv-qualiﬁers, const and volatile. Each cv-qualiﬁer shall appear at most once in a cv-
qualiﬁer-seq. If a cv-qualiﬁer appears in a decl-speciﬁer-seq, the init-declarator-list of the declaration shall
not be empty. [ Note: 3.9.3 and 8.3.5 describe how cv-qualiﬁers aﬀect object and function types. — end note ]
Redundant cv-qualiﬁcations are ignored. [ Note: For example, these could be introduced by typedefs. — end
note ]
[ Note: Declaring a variable const can aﬀect its linkage (7.1.1) and its usability in constant expressions (5.20).
As described in 8.5, the deﬁnition of an object or subobject of const-qualiﬁed type must specify an initializer
or be subject to default-initialization. — end note ]

2

3 A pointer or reference to a cv-qualiﬁed type need not actually point or refer to a cv-qualiﬁed object, but it
is treated as if it does; a const-qualiﬁed access path cannot be used to modify an object even if the object
referenced is a non-const object and can be modiﬁed through some other access path. [ Note: Cv-qualiﬁers
are supported by the type system so that they cannot be subverted without casting (5.2.11). — end note ]
4 Except that any class member declared mutable (7.1.1) can be modiﬁed, any attempt to modify a const

object during its lifetime (3.8) results in undeﬁned behavior. [ Example:
// cv-qualiﬁed (initialized as required)
// ill-formed: attempt to modify const

const int ci = 3;
ci = 4;

int i = 2;
const int* cip;
cip = &i;
*cip = 4;

// not cv-qualiﬁed
// pointer to const int
// OK: cv-qualiﬁed access path to unqualiﬁed
// ill-formed: attempt to modify through ptr to const

int* ip;
ip = const_cast<int*>(cip);
*ip = 4;

// cast needed to convert const int* to int*
// deﬁned: *ip points to i, a non-const object

const int* ciq = new const int (3);
int* iq = const_cast<int*>(ciq);
*iq = 4;

// initialized as required
// cast required
// undeﬁned: modiﬁes a const object

5 For another example

struct X {

mutable int i;
int j;

};
struct Y {

X x;
Y();

};

const Y y;
y.x.i++;
y.x.j++;
Y* p = const_cast<Y*>(&y);
p->x.i = 99;
p->x.j = 99;

// well-formed: mutable member can be modiﬁed
// ill-formed: const-qualiﬁed member modiﬁed
// cast away const-ness of y
// well-formed: mutable member can be modiﬁed
// undeﬁned: modiﬁes a const member

— end example ]

§ 7.1.6.1

158

c(cid:13) ISO/IEC

N4296

7

6 What constitutes an access to an object that has volatile-qualiﬁed type is implementation-deﬁned. If an
attempt is made to refer to an object deﬁned with a volatile-qualiﬁed type through the use of a glvalue with
a non-volatile-qualiﬁed type, the program behavior is undeﬁned.
[ Note: volatile is a hint to the implementation to avoid aggressive optimization involving the object
because the value of the object might be changed by means undetectable by an implementation. Furthermore,
for some implementations, volatile might indicate that special hardware instructions are required to access
the object. See 1.9 for detailed semantics. In general, the semantics of volatile are intended to be the
same in C++ as they are in C. — end note ]
7.1.6.2 Simple type speciﬁers

[dcl.type.simple]

1 The simple type speciﬁers are

simple-type-speciﬁer:

nested-name-speciﬁeropt type-name
nested-name-speciﬁer template simple-template-id
char
char16_t
char32_t
wchar_t
bool
short
int
long
signed
unsigned
float
double
void
auto
decltype-speciﬁer

type-name:

class-name
enum-name
typedef-name
simple-template-id

decltype-speciﬁer:

decltype ( expression )
decltype ( auto )

2 The simple-type-speciﬁer auto is a placeholder for a type to be deduced (7.1.6.4). The other simple-type-
speciﬁers specify either a previously-declared type, a type determined from an expression, or one of the
fundamental types (3.9.1). Table 9 summarizes the valid combinations of simple-type-speciﬁers and the
types they specify.

3 When multiple simple-type-speciﬁers are allowed, they can be freely intermixed with other decl-speciﬁers in
any order.
[ Note: It is implementation-deﬁned whether objects of char type are represented as signed or
unsigned quantities. The signed speciﬁer forces char objects to be signed; it is redundant in other contexts.
— end note ]

§ 7.1.6.2

159

c(cid:13) ISO/IEC

N4296

Table 9 — simple-type-speciﬁers and the types they specify
Speciﬁer(s)
type-name
simple-template-id
char
unsigned char
signed char
char16_t
char32_t
bool
unsigned
unsigned int
signed
signed int
int
unsigned short int
unsigned short
unsigned long int
unsigned long
unsigned long long int
unsigned long long
signed long int
signed long
signed long long int
signed long long
long long int
long long
long int
long
signed short int
signed short
short int
short
wchar_t
ﬂoat
double
long double
void
auto
decltype(expression)

Type
the type named
the type as deﬁned in 14.2
“char”
“unsigned char”
“signed char”
“char16_t”
“char32_t”
“bool”
“unsigned int”
“unsigned int”
“int”
“int”
“int”
“unsigned short int”
“unsigned short int”
“unsigned long int”
“unsigned long int”
“unsigned long long int”
“unsigned long long int”
“long int”
“long int”
“long long int”
“long long int”
“long long int”
“long long int”
“long int”
“long int”
“short int”
“short int”
“short int”
“short int”
“wchar_t”
“ﬂoat”
“double”
“long double”
“void”
placeholder for a type to be deduced
the type as deﬁned below

§ 7.1.6.2

160

c(cid:13) ISO/IEC

N4296

4 For an expression e, the type denoted by decltype(e) is deﬁned as follows:

(4.1)

(4.2)

(4.3)

(4.4)

—

—
—
—

if e is an unparenthesized id-expression or an unparenthesized class member access (5.2.5), decltype(e)
is the type of the entity named by e. If there is no such entity, or if e names a set of overloaded func-
tions, the program is ill-formed;
otherwise, if e is an xvalue, decltype(e) is T&&, where T is the type of e;
otherwise, if e is an lvalue, decltype(e) is T&, where T is the type of e;
otherwise, decltype(e) is the type of e.

The operand of the decltype speciﬁer is an unevaluated operand (Clause 5).
[ Example:

const int&& foo();
int i;
struct A { double x; };
const A* a = new A();
decltype(foo()) x1 = 17;
decltype(i) x2;
decltype(a->x) x3;
decltype((a->x)) x4 = x3;

// type is const int&&
// type is int
// type is double
// type is const double&

5

— end example ] [ Note: The rules for determining types involving decltype(auto) are speciﬁed in 7.1.6.4.
— end note ]
[ Note: in the case where the operand of a decltype-speciﬁer is a function call and the return type of the
function is a class type, a special rule (5.2.2) ensures that the return type is not required to be complete (as
it would be if the call appeared in a sub-expression or outside of a decltype-speciﬁer). In this context, the
common purpose of writing the expression is merely to refer to its type. In that sense, a decltype-speciﬁer
is analogous to a use of a typedef-name, so the usual reasons for requiring a complete type do not apply. In
particular, it is not necessary to allocate storage for a temporary object or to enforce the semantic constraints
associated with invoking the type’s destructor. [ Example:

template<class T> struct A { ~A() = delete; };
template<class T> auto h()

-> A<T>;

-> T;

template<class T> auto i(T)

template<class T> auto f(T)

-> decltype(i(h<T>()));

template<class T> auto f(T)

-> void;

auto g() -> void {

f(42);

}
template<class T> auto q(T)

-> decltype((h<T>()));

void r() {

§ 7.1.6.2

// identity

// #1
// forces completion of A<T> and implicitly uses
// A<T>::~A() for the temporary introduced by the
// use of h(). (A temporary is not introduced
// as a result of the use of i().)
// #2

// OK: calls #2. (#1 is not a viable candidate: type
// deduction fails (14.8.2) because A<int>::~A()
// is implicitly used in its decltype-speciﬁer)

// does not force completion of A<T>; A<T>::~A() is
// not implicitly used within the context of this decltype-speciﬁer

161

c(cid:13) ISO/IEC

q(42);

}

N4296

// Error: deduction against q succeeds, so overload resolution
// selects the specialization “q(T) -> decltype((h<T>())) [with T=int]”.
// The return type is A<int>, so a temporary is introduced and its
// destructor is used, so the program is ill-formed.

— end example ] — end note ]
7.1.6.3 Elaborated type speciﬁers

[dcl.type.elab]

elaborated-type-speciﬁer:

class-key attribute-speciﬁer-seqopt nested-name-speciﬁeropt identiﬁer
class-key simple-template-id
class-key nested-name-speciﬁer templateopt simple-template-id
enum nested-name-speciﬁeropt identiﬁer

1 An attribute-speciﬁer-seq shall not appear in an elaborated-type-speciﬁer unless the latter is the sole con-
stituent of a declaration. If an elaborated-type-speciﬁer is the sole constituent of a declaration, the declaration
is ill-formed unless it is an explicit specialization (14.7.3), an explicit instantiation (14.7.2) or it has one of
the following forms:

class-key attribute-speciﬁer-seqopt identiﬁer ;
friend class-key ::opt identiﬁer ;
friend class-key ::opt simple-template-id ;
friend class-key nested-name-speciﬁer identiﬁer ;
friend class-key nested-name-speciﬁer templateopt simple-template-id ;

In the ﬁrst case, the attribute-speciﬁer-seq, if any, appertains to the class being declared; the attributes in
the attribute-speciﬁer-seq are thereafter considered attributes of the class whenever it is named.

2 3.4.4 describes how name lookup proceeds for the identiﬁer in an elaborated-type-speciﬁer. If the identiﬁer
resolves to a class-name or enum-name, the elaborated-type-speciﬁer introduces it into the declaration the
same way a simple-type-speciﬁer introduces its type-name. If the identiﬁer resolves to a typedef-name or
the simple-template-id resolves to an alias template specialization, the elaborated-type-speciﬁer is ill-formed.
[ Note: This implies that, within a class template with a template type-parameter T, the declaration

friend class T;

is ill-formed. However, the similar declaration friend T; is allowed (11.3). — end note ]

3 The class-key or enum keyword present in the elaborated-type-speciﬁer shall agree in kind with the dec-
laration to which the name in the elaborated-type-speciﬁer refers. This rule also applies to the form of
elaborated-type-speciﬁer that declares a class-name or friend class since it can be construed as referring to
the deﬁnition of the class. Thus, in any elaborated-type-speciﬁer, the enum keyword shall be used to refer to
an enumeration (7.2), the union class-key shall be used to refer to a union (Clause 9), and either the class
or struct class-key shall be used to refer to a class (Clause 9) declared using the class or struct class-key.
[ Example:

enum class E { a, b };
enum E x = E::a;

// OK

— end example ]
7.1.6.4 auto speciﬁer

[dcl.spec.auto]
1 The auto and decltype(auto) type-speciﬁers are used to designate a placeholder type that will be replaced
later by deduction from an initializer. The auto type-speciﬁer is also used to introduce a function type
having a trailing-return-type or to signify that a lambda is a generic lambda.

§ 7.1.6.4

162

c(cid:13) ISO/IEC

N4296

2 The placeholder type can appear with a function declarator in the decl-speciﬁer-seq, type-speciﬁer-seq,
conversion-function-id, or trailing-return-type, in any context where such a declarator is valid. If the func-
tion declarator includes a trailing-return-type (8.3.5), that speciﬁes the declared return type of the function.
Otherwise, the function declarator shall declare a function. If the declared return type of the function con-
tains a placeholder type, the return type of the function is deduced from return statements in the body of
the function, if any.
If the auto type-speciﬁer appears as one of the decl-speciﬁers in the decl-speciﬁer-seq of a parameter-
declaration of a lambda-expression, the lambda is a generic lambda (5.1.2). [ Example:

3

auto glambda = [](int i, auto a) { return i; }; // OK: a generic lambda

— end example ]

4 The type of a variable declared using auto or decltype(auto) is deduced from its initializer. This use is al-
lowed when declaring variables in a block (6.3), in namespace scope (3.3.6), and in a for-init-statement (6.5.3).
auto or decltype(auto) shall appear as one of the decl-speciﬁers in the decl-speciﬁer-seq and the decl-
speciﬁer-seq shall be followed by one or more init-declarators, each of which shall have a non-empty initial-
izer. In an initializer of the form

( expression-list )

the expression-list shall be a single assignment-expression.
[ Example:

// OK: x has type int

auto x = 5;
const auto *v = &x, u = 6; // OK: v has type const int*, u has type const int
static auto y = 0.0;
auto int r;
auto f() -> int;
auto g() { return 0.0; }
auto h();

// OK: y has type double
// error: auto is not a storage-class-speciﬁer
// OK: f returns int
// OK: g returns double
// OK: h’s return type will be deduced when it is deﬁned

— end example ]

5 A placeholder type can also be used in declaring a variable in the condition of a selection statement (6.4) or
an iteration statement (6.5), in the type-speciﬁer-seq in the new-type-id or type-id of a new-expression (5.3.4), in
a for-range-declaration, and in declaring a static data member with a brace-or-equal-initializer that appears
within the member-speciﬁcation of a class deﬁnition (9.4.2).

6 A program that uses auto or decltype(auto) in a context not explicitly allowed in this section is ill-formed.
7 When a variable declared using a placeholder type is initialized, or a return statement occurs in a function
declared with a return type that contains a placeholder type, the deduced return type or variable type is
determined from the type of its initializer. In the case of a return with no operand or with an operand
of type void, the declared return type shall be auto and the deduced return type is void. Otherwise,
If the placeholder is the auto
let T be the declared type of the variable or return type of the function.
type-speciﬁer, the deduced type is determined using the rules for template argument deduction.
If the
initialization is direct-list-initialization then the braced-init-list shall contain only a single initializer-clause
L. If the deduction is for a return statement and the initializer is a braced-init-list (8.5.4), the program is
ill-formed. Otherwise, obtain P from T by replacing the occurrences of auto with either a new invented type
template parameter U or, if the initialization is copy-list-initialization, with std::initializer_list<U>.
Deduce a value for U using the rules of template argument deduction from a function call (14.8.2.1), where
P is a function template parameter type and the corresponding argument is the initializer, or L in the case
of direct-list-initialization. If the deduction fails, the declaration is ill-formed. Otherwise, the type deduced
for the variable or return type is obtained by substituting the deduced U into P. [ Example:

§ 7.1.6.4

163

N4296

// decltype(x1) is std::initializer_list<int>
// error: cannot deduce element type
// error: not a single element
// decltype(x4) is std::initializer_list<int>
// decltype(x5) is int

c(cid:13) ISO/IEC

auto x1 = { 1, 2 };
auto x2 = { 1, 2.0 };
auto x3{ 1, 2 };
auto x4 = { 3 };
auto x5{ 3 };

— end example ]
[ Example:

const auto &i = expr;

The type of i is the deduced type of the parameter u in the call f(expr) of the following invented function
template:

template <class U> void f(const U& u);

— end example ]
If the placeholder is the decltype(auto) type-speciﬁer, the declared type of the variable or return type of
the function shall be the placeholder alone. The type deduced for the variable or return type is determined
as described in 7.1.6.2, as though the initializer had been the operand of the decltype. [ Example:

int i;
int&& f();
x3a = i;
auto
decltype(auto) x3d = i;
auto
x4a = (i);
decltype(auto) x4d = (i);
auto
x5a = f();
decltype(auto) x5d = f();
auto
decltype(auto) x6d = { 1, 2 }; // error, { 1, 2 } is not an expression
auto
*x7a = &i;
decltype(auto)*x7d = &i;

// decltype(x3a) is int
// decltype(x3d) is int
// decltype(x4a) is int
// decltype(x4d) is int&
// decltype(x5a) is int
// decltype(x5d) is int&&

x6a = { 1, 2 }; // decltype(x6a) is std::initializer_list<int>

// decltype(x7a) is int*
// error, declared type is not plain decltype(auto)

8

— end example ]
If the init-declarator-list contains more than one init-declarator, they shall all form declarations of variables.
The type of each declared variable is determined as described above, and if the type that replaces the
placeholder type is not the same in each deduction, the program is ill-formed.
[ Example:

auto x = 5, *y = &x;
auto a = 5, b = { 1, 2 };

// OK: auto is int
// error: diﬀerent types for auto

9

10

— end example ]
If a function with a declared return type that contains a placeholder type has multiple return statements,
the return type is deduced for each return statement. If the type deduced is not the same in each deduction,
the program is ill-formed.
If a function with a declared return type that uses a placeholder type has no return statements, the return
type is deduced as though from a return statement with no operand at the closing brace of the function
body. [ Example:

f() { } // OK, return type is void

auto
auto* g() { } // error, cannot deduce auto* from void()

§ 7.1.6.4

164

c(cid:13) ISO/IEC

N4296

11

— end example ]
If the type of an entity with an undeduced placeholder type is needed to determine the type of an expression,
the program is ill-formed. Once a return statement has been seen in a function, however, the return type
deduced from that statement can be used in the rest of the function, including in other return statements.
[ Example:

auto n = n;
auto f();
void g() { &f; }
auto sum(int i) {

if (i == 1)
return i;

else

// error, n’s type is unknown

// error, f’s return type is unknown

// sum’s return type is int

return sum(i-1)+i; // OK, sum’s return type has been deduced

}

— end example ]

12 Return type deduction for a function template with a placeholder in its declared type occurs when the
deﬁnition is instantiated even if the function body contains a return statement with a non-type-dependent
operand.
[ Note: Therefore, any use of a specialization of the function template will cause an implicit
instantiation. Any errors that arise from this instantiation are not in the immediate context of the function
type and can result in the program being ill-formed. — end note ] [ Example:

template <class T> auto f(T t) { return t; } // return type deduced at instantiation time
// instantiates f<int> to deduce return type
typedef decltype(f(1)) fint_t;
template<class T> auto f(T* t) { return *t; }
void g() { int (*p)(int*) = &f; }

// instantiates both fs to determine return types,
// chooses second

— end example ]

13 Redeclarations or specializations of a function or function template with a declared return type that uses a

placeholder type shall also use that placeholder, not a deduced type. [ Example:

auto f();
auto f() { return 42; } // return type is int
auto f();
int f();
decltype(auto) f();

// OK
// error, cannot be overloaded with auto f()
// error, auto and decltype(auto) don’t match

template <typename T> auto g(T t) { return t; } // #1
template auto g(int);
template char g(char);
template<> auto g(double);

// OK, return type is int
// error, no matching template
// OK, forward declaration with unknown return type

template <class T> T g(T t) { return t; } // OK, not functionally equivalent to #1
// OK, now there is a matching template
template char g(char);
// still matches #1
template auto g(float);

void h() { return g(42); } // error, ambiguous

template <typename T> struct A {

friend T frf(T);

};
auto frf(int i) { return i; } // not a friend of A<int>

§ 7.1.6.4

165

c(cid:13) ISO/IEC

— end example ]

N4296

14 A function declared with a return type that uses a placeholder type shall not be virtual (10.3).
15 An explicit instantiation declaration (14.7.2) does not cause the instantiation of an entity declared using a
placeholder type, but it also does not prevent that entity from being instantiated as needed to determine its
type. [ Example:

template <typename T> auto f(T t) { return t; }
extern template auto f(int); // does not instantiate f<int>
int (*p)(int) = f;

// instantiates f<int> to determine its return type, but an explicit
// instantiation deﬁnition is still required somewhere in the program

— end example ]
7.2 Enumeration declarations

[dcl.enum]
1 An enumeration is a distinct type (3.9.2) with named constants. Its name becomes an enum-name, within

its scope.

enum-name:

identiﬁer
enum-speciﬁer:

enum-head { enumerator-listopt}
enum-head { enumerator-list , }

enum-head:

enum-baseopt
opaque-enum-declaration:

enum-key attribute-speciﬁer-seqopt identiﬁeropt enum-baseopt
enum-key attribute-speciﬁer-seqopt nested-name-speciﬁer identiﬁer

enum-key attribute-speciﬁer-seqopt identiﬁer enum-baseopt;

enum-key:
enum
enum class
enum struct

enum-base:

: type-speciﬁer-seq

enumerator-list:

enumerator-deﬁnition
enumerator-list , enumerator-deﬁnition

enumerator-deﬁnition:

enumerator
enumerator = constant-expression

enumerator:

identiﬁer attribute-speciﬁer-seqopt

The optional attribute-speciﬁer-seq in the enum-head and the opaque-enum-declaration appertains to the
enumeration; the attributes in that attribute-speciﬁer-seq are thereafter considered attributes of the enu-
meration whenever it is named. A : following “enum identiﬁer” is parsed as part of an enum-base. [ Note:
This resolves a potential ambiguity between the declaration of an enumeration with an enum-base and the
declaration of an unnamed bit-ﬁeld of enumeration type. [ Example:

struct S {

};

enum E : int {};
enum E : int {}; // error: redeclaration of enumeration

— end example ] — end note ]

§ 7.2

166

c(cid:13) ISO/IEC

N4296

2 The enumeration type declared with an enum-key of only enum is an unscoped enumeration, and its enumer-
ators are unscoped enumerators. The enum-keys enum class and enum struct are semantically equivalent;
an enumeration type declared with one of these is a scoped enumeration, and its enumerators are scoped
enumerators. The optional identiﬁer shall not be omitted in the declaration of a scoped enumeration. The
type-speciﬁer-seq of an enum-base shall name an integral type; any cv-qualiﬁcation is ignored. An opaque-
enum-declaration declaring an unscoped enumeration shall not omit the enum-base. The identiﬁers in an
enumerator-list are declared as constants, and can appear wherever constants are required. An enumerator-
deﬁnition with = gives the associated enumerator the value indicated by the constant-expression. If the ﬁrst
enumerator has no initializer, the value of the corresponding constant is zero. An enumerator-deﬁnition
without an initializer gives the enumerator the value obtained by increasing the value of the previous enu-
merator by one. [ Example:

enum { a, b, c=0 };
enum { d, e, f=e+2 };

deﬁnes a, c, and d to be zero, b and e to be 1, and f to be 3. — end example ] The optional attribute-
speciﬁer-seq in an enumerator appertains to that enumerator.

3 An opaque-enum-declaration is either a redeclaration of an enumeration in the current scope or a declaration
of a new enumeration. [ Note: An enumeration declared by an opaque-enum-declaration has ﬁxed underlying
type and is a complete type. The list of enumerators can be provided in a later redeclaration with an enum-
speciﬁer. — end note ] A scoped enumeration shall not be later redeclared as unscoped or with a diﬀerent
underlying type. An unscoped enumeration shall not be later redeclared as scoped and each redeclaration
shall include an enum-base specifying the same underlying type as in the original declaration.
If the enum-key is followed by a nested-name-speciﬁer, the enum-speciﬁer shall refer to an enumeration that
was previously declared directly in the class or namespace to which the nested-name-speciﬁer refers (i.e.,
neither inherited nor introduced by a using-declaration), and the enum-speciﬁer shall appear in a namespace
enclosing the previous declaration.

4

5 Each enumeration deﬁnes a type that is diﬀerent from all other types. Each enumeration also has an under-
lying type. The underlying type can be explicitly speciﬁed using an enum-base. For a scoped enumeration
type, the underlying type is int if it is not explicitly speciﬁed. In both of these cases, the underlying type
is said to be ﬁxed. Following the closing brace of an enum-speciﬁer, each enumerator has the type of its
enumeration. If the underlying type is ﬁxed, the type of each enumerator prior to the closing brace is the
underlying type and the constant-expression in the enumerator-deﬁnition shall be a converted constant ex-
pression of the underlying type (5.20). If the underlying type is not ﬁxed, the type of each enumerator prior
to the closing brace is determined as follows:

(5.1)

(5.2)

(5.3)

—

—
—

If an initializer is speciﬁed for an enumerator, the constant-expression shall be an integral constant
expression (5.20). If the expression has unscoped enumeration type, the enumerator has the underlying
type of that enumeration type, otherwise it has the same type as the expression.
If no initializer is speciﬁed for the ﬁrst enumerator, its type is an unspeciﬁed signed integral type.
Otherwise the type of the enumerator is the same as that of the preceding enumerator unless the
incremented value is not representable in that type, in which case the type is an unspeciﬁed integral
type suﬃcient to contain the incremented value. If no such type exists, the program is ill-formed.

6 An enumeration whose underlying type is ﬁxed is an incomplete type from its point of declaration (3.3.2)
to immediately after its enum-base (if any), at which point it becomes a complete type. An enumeration
whose underlying type is not ﬁxed is an incomplete type from its point of declaration to immediately after
the closing } of its enum-speciﬁer, at which point it becomes a complete type.

7 For an enumeration whose underlying type is not ﬁxed, the underlying type is an integral type that can
represent all the enumerator values deﬁned in the enumeration. If no integral type can represent all the

§ 7.2

167

c(cid:13) ISO/IEC

N4296

enumerator values, the enumeration is ill-formed. It is implementation-deﬁned which integral type is used
as the underlying type except that the underlying type shall not be larger than int unless the value of an
enumerator cannot ﬁt in an int or unsigned int. If the enumerator-list is empty, the underlying type is
as if the enumeration had a single enumerator with value 0.

8 For an enumeration whose underlying type is ﬁxed, the values of the enumeration are the values of the
underlying type. Otherwise, for an enumeration where emin is the smallest enumerator and emax is the
largest, the values of the enumeration are the values in the range bmin to bmax, deﬁned as follows: Let K
be 1 for a two’s complement representation and 0 for a one’s complement or sign-magnitude representation.
bmax is the smallest value greater than or equal to max(|emin| − K,|emax|) and equal to 2M − 1, where
M is a non-negative integer. bmin is zero if emin is non-negative and −(bmax + K) otherwise. The size of
the smallest bit-ﬁeld large enough to hold all the values of the enumeration type is max(M, 1) if bmin is
zero and M + 1 otherwise. It is possible to deﬁne an enumeration that has values not deﬁned by any of its
enumerators. If the enumerator-list is empty, the values of the enumeration are as if the enumeration had a
single enumerator with value 0.96

9 Two enumeration types are layout-compatible if they have the same underlying type.
10 The value of an enumerator or an object of an unscoped enumeration type is converted to an integer by

integral promotion (4.5). [ Example:

enum color { red, yellow, green=20, blue };
color col = red;
color* cp = &col;
if (*cp == blue)

// ...

makes color a type describing various colors, and then declares col as an object of that type, and cp as a
pointer to an object of that type. The possible values of an object of type color are red, yellow, green,
blue; these values can be converted to the integral values 0, 1, 20, and 21. Since enumerations are distinct
types, objects of type color can be assigned only values of type color.

color c = 1;

int i = yellow;

// error: type mismatch,
// no conversion from int to color

// OK: yellow converted to integral value 1
// integral promotion

Note that this implicit enum to int conversion is not provided for a scoped enumeration:

enum class Col { red, yellow, green };
int x = Col::red;
Col y = Col::red;
if (y) { }

// error: no Col to int conversion

// error: no Col to bool conversion

— end example ]

11 Each enum-name and each unscoped enumerator is declared in the scope that immediately contains the
enum-speciﬁer. Each scoped enumerator is declared in the scope of the enumeration. These names obey the
scope rules deﬁned for all names in (3.3) and (3.4).[ Example:

enum direction { left=’l’, right=’r’ };

void g()

{

direction d;
d = left;

// OK
// OK

96) This set of values is used to deﬁne promotion and conversion semantics for the enumeration type. It does not preclude an
expression of enumeration type from having a value that falls outside this range.

§ 7.2

168

}

};

— end example ] An enumerator declared in class scope can be referred to using the class member access
operators (::, . (dot) and -> (arrow)), see 5.2.5. [ Example:

struct X {

enum direction { left=’l’, right=’r’ };
int f(int i) { return i==left ? 0 : i==right ? 1 : 2; }

void g(X* p) {
direction d;
int i;
i = p->f(left);
i = p->f(X::right);
i = p->f(p->left);
// ...

}

// error: direction not in scope

// error: left not in scope
// OK
// OK

— end example ]
7.3 Namespaces

[basic.namespace]
1 A namespace is an optionally-named declarative region. The name of a namespace can be used to access
entities declared in that namespace; that is, the members of the namespace. Unlike other declarative regions,
the deﬁnition of a namespace can be split over several parts of one or more translation units.

2 The outermost declarative region of a translation unit is a namespace; see 3.3.6.

7.3.1 Namespace deﬁnition

[namespace.def]

1 The grammar for a namespace-deﬁnition is

c(cid:13) ISO/IEC

N4296

d = direction::right;

// OK

}

enum class altitude { high=’h’, low=’l’ };

void h()

{

altitude a;
a = high;
a = altitude::low;

// OK
// error: high not in scope
// OK

namespace-name:

identiﬁer
namespace-alias
namespace-deﬁnition:

named-namespace-deﬁnition
unnamed-namespace-deﬁnition nested-namespace-deﬁnition

named-namespace-deﬁnition:

inlineopt namespace attribute-speciﬁer-seqopt identiﬁer { namespace-body }

unnamed-namespace-deﬁnition:

inlineopt namespace attribute-speciﬁer-seqopt{ namespace-body }

nested-namespace-deﬁnition:

namespace enclosing-namespace-speciﬁer :: identiﬁer { namespace-body }

enclosing-namespace-speciﬁer:

identiﬁer enclosing-namespace-speciﬁer :: identiﬁer

§ 7.3.1

169

c(cid:13) ISO/IEC

namespace-body:

declaration-seqopt

N4296

2 Every namespace-deﬁnition shall appear in the global scope or in a namespace scope (3.3.6).
3

In a named-namespace-deﬁnition, the identiﬁer is the name of the namespace. If the identiﬁer, when looked
up (3.4.1), refers to a namespace-name (but not a namespace-alias) introduced in the declarative region
in which the named-namespace-deﬁnition appears, the namespace-deﬁnition extends the previously-declared
namespace. Otherwise, the identiﬁer is introduced as a namespace-name into the declarative region in which
the named-namespace-deﬁnition appears.

4 Because a namespace-deﬁnition contains declarations in its namespace-body and a namespace-deﬁnition is

itself a declaration, it follows that namespace-deﬁnitions can be nested. [ Example:

namespace Outer {

int i;
namespace Inner {

void f() { i++; }
int i;
void g() { i++; }

}

}

// Outer::i

// Inner::i

— end example ]

5 The enclosing namespaces of a declaration are those namespaces in which the declaration lexically appears,
except for a redeclaration of a namespace member outside its original namespace (e.g., a deﬁnition as
speciﬁed in 7.3.1.2). Such a redeclaration has the same enclosing namespaces as the original declaration.
[ Example:

namespace Q {

namespace V {

void f();
class C { void m(); };

// enclosing namespaces are the global namespace, Q, and Q::V

}
void V::f() { // enclosing namespaces are the global namespace, Q, and Q::V

extern void h(); // ... so this declares Q::V::h

}
void V::C::m() { // enclosing namespaces are the global namespace, Q, and Q::V
}

}

6

— end example ]
If the optional initial inline keyword appears in a namespace-deﬁnition for a particular namespace, that
namespace is declared to be an inline namespace. The inline keyword may be used on a namespace-
deﬁnition that extends a namespace only if it was previously used on the namespace-deﬁnition that initially
declared the namespace-name for that namespace.

7 The optional attribute-speciﬁer-seq in a named-namespace-deﬁnition appertains to the namespace being

deﬁned or extended.

8 Members of an inline namespace can be used in most respects as though they were members of the enclosing
namespace. Speciﬁcally, the inline namespace and its enclosing namespace are both added to the set of
associated namespaces used in argument-dependent lookup (3.4.2) whenever one of them is, and a using-
directive (7.3.4) that names the inline namespace is implicitly inserted into the enclosing namespace as for
an unnamed namespace (7.3.1.1). Furthermore, each member of the inline namespace can subsequently be
partially specialized (14.5.5), explicitly instantiated (14.7.2), or explicitly specialized (14.7.3) as though it
were a member of the enclosing namespace. Finally, looking up a name in the enclosing namespace via

§ 7.3.1

170

c(cid:13) ISO/IEC

N4296

explicit qualiﬁcation (3.4.3.2) will include members of the inline namespace brought in by the using-directive
even if there are declarations of that name in the enclosing namespace.

9 These properties are transitive: if a namespace N contains an inline namespace M, which in turn contains an
inline namespace O, then the members of O can be used as though they were members of M or N. The inline
namespace set of N is the transitive closure of all inline namespaces in N. The enclosing namespace set of O
is the set of namespaces consisting of the innermost non-inline namespace enclosing an inline namespace O,
together with any intervening inline namespaces.

10 A nested-namespace-deﬁnition with an enclosing-namespace-speciﬁer E, identiﬁer I and namespace-body B

is equivalent to

namespace E { namespace I { B } }

[ Example:

namespace A::B::C {

int i;

}

The above has the same eﬀect as:

namespace A {

namespace B {

namespace C {

int i;

}

}

}

— end example ]
7.3.1.1 Unnamed namespaces

1 An unnamed-namespace-deﬁnition behaves as if it were replaced by

[namespace.unnamed]

inlineoptnamespace unique { /* empty body */ }
using namespace unique ;
namespace unique { namespace-body }

where inline appears if and only if it appears in the unnamed-namespace-deﬁnition and all occurrences of
unique in a translation unit are replaced by the same identiﬁer, and this identiﬁer diﬀers from all other
identiﬁers in the translation unit. The optional attribute-speciﬁer-seq in the unnamed-namespace-deﬁnition
appertains to unique . [ Example:

namespace { int i; }
void f() { i++; }

// unique ::i
// unique ::i++

namespace A {
namespace {

int i;
int j;

}
void g() { i++; }

}

// A:: unique ::i
// A:: unique ::j

// A:: unique ::i++

using namespace A;
void h() {

i++;
A::i++;

§ 7.3.1.1

// error: unique ::i or A:: unique ::i
// A:: unique ::i

171

c(cid:13) ISO/IEC

j++;

}

// A:: unique ::j

N4296

— end example ]
7.3.1.2 Namespace member deﬁnitions

[namespace.memdef]
1 A declaration in a namespace N (excluding declarations in nested scopes) whose declarator-id is an unqualiﬁed-
id declares (or redeclares) a member of N, and may be a deﬁnition. [ Note: An explicit instantiation (14.7.2)
or explicit specialization (14.7.3) of a template does not introduce a name and thus may be declared using
an unqualiﬁed-id in a member of the enclosing namespace set, if the primary template is declared in an inline
namespace. — end note ] [ Example:

namespace X {

void f() { /∗ ... ∗/ } // OK: introduces X::f()

namespace M {

void g();

}
using M::g;
void g();

}

// OK: introduces X::M::g()

// error: conﬂicts with X::M::g()

— end example ]

2 Members of a named namespace can also be deﬁned outside that namespace by explicit qualiﬁcation (3.4.3.2)
of the name being deﬁned, provided that the entity being deﬁned was already declared in the namespace
and the deﬁnition appears after the point of declaration in a namespace that encloses the declaration’s
namespace. [ Example:

namespace Q {

namespace V {

void f();

}
void V::f() { /∗ ... ∗/ }
void V::g() { /∗ ... ∗/ }
namespace V {

void g();

// OK
// error: g() is not yet a member of V

}

}

}

namespace R {

void Q::V::g() { /∗ ... ∗/ } // error: R doesn’t enclose Q

3

— end example ]
If a friend declaration in a non-local class ﬁrst declares a class, function, class template or function tem-
plate97 the friend is a member of the innermost enclosing namespace. The friend declaration does not by
itself make the name visible to unqualiﬁed lookup (3.4.1) or qualiﬁed lookup (3.4.3). [ Note: The name of
the friend will be visible in its namespace if a matching declaration is provided at namespace scope (either
before or after the class deﬁnition granting friendship). — end note ] If a friend function or function template
is called, its name may be found by the name lookup that considers functions from namespaces and classes
associated with the types of the function arguments (3.4.2). If the name in a friend declaration is neither
qualiﬁed nor a template-id and the declaration is a function or an elaborated-type-speciﬁer, the lookup to
97) this implies that the name of the class or function is unqualiﬁed.

§ 7.3.1.2

172

c(cid:13) ISO/IEC

N4296

determine whether the entity has been previously declared shall not consider any scopes outside the inner-
most enclosing namespace. [ Note: The other forms of friend declarations cannot declare a new member of
the innermost enclosing namespace and thus follow the usual lookup rules. — end note ] [ Example:

// Assume f and g have not yet been declared.
void h(int);
template <class T> void f2(T);
namespace A {

class X {

friend void f(X);
class Y {

friend void g();
friend void h(int);

// A::f(X) is a friend

// A::g is a friend
// A::h is a friend
// ::h not considered
// ::f2<>(int) is a friend

friend void f2<>(int);

};

};

// A::f, A::g and A::h are not visible here
X x;
void g() { f(x); }
void f(X) { /* ...
void h(int) { /* ...
// A::f, A::g and A::h are visible here and known to be friends

// deﬁnition of A::g
// deﬁnition of A::f
// deﬁnition of A::h

*/ }

*/}

}

using A::x;

void h() {
A::f(x);
A::X::f(x);
A::X::Y::g();

}

// error: f is not a member of A::X
// error: g is not a member of A::X::Y

— end example ]
7.3.2 Namespace alias

[namespace.alias]
1 A namespace-alias-deﬁnition declares an alternate name for a namespace according to the following grammar:

namespace-alias:
identiﬁer

namespace-alias-deﬁnition:

namespace identiﬁer = qualiﬁed-namespace-speciﬁer ;

qualiﬁed-namespace-speciﬁer:

nested-name-speciﬁeropt namespace-name

2 The identiﬁer in a namespace-alias-deﬁnition is a synonym for the name of the namespace denoted by the
qualiﬁed-namespace-speciﬁer and becomes a namespace-alias. [ Note: When looking up a namespace-name
in a namespace-alias-deﬁnition, only namespace names are considered, see 3.4.6. — end note ]
In a declarative region, a namespace-alias-deﬁnition can be used to redeﬁne a namespace-alias declared in
that declarative region to refer only to the namespace to which it already refers.
[ Example: the following
declarations are well-formed:

3

namespace Company_with_very_long_name { /∗ ... ∗/ }
namespace CWVLN = Company_with_very_long_name;
namespace CWVLN = Company_with_very_long_name;

// OK: duplicate

§ 7.3.2

173

c(cid:13) ISO/IEC

namespace CWVLN = CWVLN;

N4296

— end example ]
7.3.3 The using declaration

[namespace.udecl]
1 A using-declaration introduces a name into the declarative region in which the using-declaration appears.

using-declaration:

using typenameopt nested-name-speciﬁer unqualiﬁed-id ;

The member name speciﬁed in a using-declaration is declared in the declarative region in which the using-
declaration appears.
[ Note: Only the speciﬁed name is so declared; specifying an enumeration name in
a using-declaration does not declare its enumerators in the using-declaration’s declarative region. — end
note ] If a using-declaration names a constructor (3.4.3.1), it implicitly declares a set of constructors in the
class in which the using-declaration appears (12.9); otherwise the name speciﬁed in a using-declaration is a
synonym for a set of declarations in another namespace or class.

2 Every using-declaration is a declaration and a member-declaration and so can be used in a class deﬁnition.

[ Example:

struct B {

void f(char);
void g(char);
enum E { e };
union { int x; };

};

struct D : B {
using B::f;
void f(int) { f(’c’); }
void g(int) { g(’c’); }

};

// calls B::f(char)
// recursively calls D::g(int)

— end example ]
In a using-declaration used as a member-declaration, the nested-name-speciﬁer shall name a base class of the
class being deﬁned. If such a using-declaration names a constructor, the nested-name-speciﬁer shall name a
direct base class of the class being deﬁned; otherwise it introduces the set of declarations found by member
name lookup (10.2, 3.4.3.1). [ Example:

class C {
int g();

};

class D2 : public B {

using B::f;
using B::e;
using B::x;
using C::g;

};

// OK: B is a base of D2
// OK: e is an enumerator of base B
// OK: x is a union member of base B
// error: C isn’t a base of D2

— end example ]
[ Note: Since destructors do not have names, a using-declaration cannot refer to a destructor for a base
class. Since specializations of member templates for conversion functions are not found by name lookup,
they are not considered when a using-declaration speciﬁes a conversion function (14.5.2). — end note ] If an
assignment operator brought from a base class into a derived class scope has the signature of a copy/move

§ 7.3.3

174

3

4

c(cid:13) ISO/IEC

N4296

assignment operator for the derived class (12.8), the using-declaration does not by itself suppress the implicit
declaration of the derived class assignment operator; the copy/move assignment operator from the base class
is hidden or overridden by the implicitly-declared copy/move assignment operator of the derived class, as
described below.

5 A using-declaration shall not name a template-id. [ Example:

struct A {

template <class T> void f(T);
template <class T> struct X { };

// ill-formed
// ill-formed

};
struct B : A {

using A::f<double>;
using A::X<int>;

};

— end example ]

6 A using-declaration shall not name a namespace.
7 A using-declaration shall not name a scoped enumerator.
8 A using-declaration for a class member shall be a member-declaration. [ Example:

struct X {

int i;
static int s;

};

void f() {

using X::i;

using X::s;

}

— end example ]

// error: X::i is a class member
// and this is not a member declaration.
// error: X::s is a class member
// and this is not a member declaration.

9 Members declared by a using-declaration can be referred to by explicit qualiﬁcation just like other member

names (3.4.3.2). [ Example:

void f();

namespace A {

void g();

}

namespace X {
using ::f;
using A::g;

}

// global f
// A’s g

void h()
{

X::f();
X::g();

}

// calls ::f
// calls A::g

— end example ]

§ 7.3.3

175

c(cid:13) ISO/IEC

N4296

10 A using-declaration is a declaration and can therefore be used repeatedly where (and only where) multiple

declarations are allowed. [ Example:

namespace A {

int i;

}

namespace A1 {
using A::i;
using A::i;

}

// OK: double declaration

void f() {

using A::i;
using A::i;

}

// error: double declaration

struct B {

int i;

};

struct X : B {
using B::i;
using B::i;

};

— end example ]

// error: double member declaration

11 Members added to the namespace after the using-declaration are not considered when a use of the name
is made.
[ Note: Thus, additional overloads added after the using-declaration are ignored, but default
function arguments (8.3.6), default template arguments (14.1), and template specializations (14.5.5, 14.7.3)
are considered. — end note ] [ Example:

namespace A {
void f(int);

}

using A::f;

namespace A {

void f(char);

}

}

void foo() {

f(’a’);

void bar() {
using A::f;

f(’a’);

}

// f is a synonym for A::f;
// that is, for A::f(int).

// calls f(int),
// even though f(char) exists.

// f is a synonym for A::f;
// that is, for A::f(int) and A::f(char).
// calls f(char)

12

— end example ]
[ Note: Partial specializations of class templates are found by looking up the primary class template and then
considering all partial specializations of that template. If a using-declaration names a class template, partial

§ 7.3.3

176

c(cid:13) ISO/IEC

N4296

specializations introduced after the using-declaration are eﬀectively visible because the primary template is
visible (14.5.5). — end note ]

13 Since a using-declaration is a declaration, the restrictions on declarations of the same name in the same

declarative region (3.3) also apply to using-declarations. [ Example:

namespace A {

int x;

}

namespace B {

int i;
struct g { };
struct x { };
void f(int);
void f(double);
void g(char);

}

}

void func() {

int i;
using B::i;
void f(char);
using B::f;
f(3.5);
using B::g;
g(’a’);
struct g g1;
using B::x;
using A::x;
x = 99;
struct x x1;

// OK: hides struct g

// error: i declared twice

// OK: each f is a function
// calls B::f(double)

// calls B::g(char)
// g1 has class type B::g

// OK: hides struct B::x
// assigns to A::x
// x1 has class type B::x

14

— end example ]
If a function declaration in namespace scope or block scope has the same name and the same parameter-
type-list (8.3.5) as a function introduced by a using-declaration, and the declarations do not declare the same
function, the program is ill-formed. If a function template declaration in namespace scope has the same
name, parameter-type-list, return type, and template parameter list as a function template introduced by
a using-declaration, the program is ill-formed. [ Note: Two using-declarations may introduce functions with
the same name and the same parameter-type-list. If, for a call to an unqualiﬁed function name, function
overload resolution selects the functions introduced by such using-declarations, the function call is ill-formed.
[ Example:

namespace B {
void f(int);
void f(double);

}
namespace C {
void f(int);
void f(double);
void f(char);

}

void h() {

using B::f;

§ 7.3.3

// B::f(int) and B::f(double)

177

c(cid:13) ISO/IEC

using C::f;
f(’h’);
f(1);
void f(int);

}

// C::f(int), C::f(double), and C::f(char)
// calls C::f(char)
// error: ambiguous: B::f(int) or C::f(int)?
// error: f(int) conﬂicts with C::f(int) and B::f(int)

N4296

— end example ] — end note ]

15 When a using-declaration brings names from a base class into a derived class scope, member functions and
member function templates in the derived class override and/or hide member functions and member function
templates with the same name, parameter-type-list (8.3.5), cv-qualiﬁcation, and ref-qualiﬁer (if any) in a
base class (rather than conﬂicting). [ Note: For using-declarations that name a constructor, see 12.9. — end
note ] [ Example:

struct B {

virtual void f(int);
virtual void f(char);
void g(int);
void h(int);

};

struct D : B {
using B::f;
void f(int);

using B::g;
void g(char);

using B::h;
void h(int);

};

// OK: D::f(int) overrides B::f(int);

// OK

// OK: D::h(int) hides B::h(int)

void k(D* p)
{

p->f(1);
p->f(’a’);
p->g(1);
p->g(’a’);

}

// calls D::f(int)
// calls B::f(char)
// calls B::g(int)
// calls D::g(char)

— end example ]

16 For the purpose of overload resolution, the functions which are introduced by a using-declaration into a
derived class will be treated as though they were members of the derived class. In particular, the implicit
this parameter shall be treated as if it were a pointer to the derived class rather than to the base class.
This has no eﬀect on the type of the function, and in all other respects the function remains a member of
the base class.

17 The access rules for inheriting constructors are speciﬁed in 12.9; otherwise all instances of the name mentioned
in a using-declaration shall be accessible. In particular, if a derived class uses a using-declaration to access
a member of a base class, the member name shall be accessible.
If the name is that of an overloaded
member function, then all functions named shall be accessible. The base class members mentioned by a
using-declaration shall be visible in the scope of at least one of the direct base classes of the class where the
using-declaration is speciﬁed. [ Note: Because a using-declaration designates a base class member (and not
a member subobject or a member function of a base class subobject), a using-declaration cannot be used to
resolve inherited member ambiguities. For example,

§ 7.3.3

178

c(cid:13) ISO/IEC

struct A { int x(); };
struct B : A { };
struct C : A {
using A::x;
int x(int);

};

N4296

struct D : B, C {

using C::x;
int x(double);

};
int f(D* d) {

return d->x();

// ambiguous: B::x or C::x

}

};

};

class A {
private:

void f(char);

public:

void f(int);

protected:

void g();

— end note ]

18 The alias created by the using-declaration has the usual accessibility for a member-declaration.

[ Note: A
using-declaration that names a constructor does not create aliases; see 12.9 for the pertinent accessibility
rules. — end note ] [ Example:

class B : public A {

using A::f;

public:

using A::g;

// error: A::f(char) is inaccessible

// B::g is a public synonym for A::g

19

— end example ]
If a using-declaration uses the keyword typename and speciﬁes a dependent name (14.6.2), the name intro-
duced by the using-declaration is treated as a typedef-name (7.1.3).
7.3.4 Using directive

[namespace.udir]

using-directive:

attribute-speciﬁer-seqoptusing namespace nested-name-speciﬁeropt namespace-name ;

1 A using-directive shall not appear in class scope, but may appear in namespace scope or in block scope.
[ Note: When looking up a namespace-name in a using-directive, only namespace names are considered,
see 3.4.6. — end note ] The optional attribute-speciﬁer-seq appertains to the using-directive.

2 A using-directive speciﬁes that the names in the nominated namespace can be used in the scope in which the
using-directive appears after the using-directive. During unqualiﬁed name lookup (3.4.1), the names appear
as if they were declared in the nearest enclosing namespace which contains both the using-directive and the
nominated namespace.
[ Note: In this context, “contains” means “contains directly or indirectly”. — end
note ]

3 A using-directive does not add any members to the declarative region in which it appears. [ Example:

namespace A {

§ 7.3.4

179

c(cid:13) ISO/IEC

N4296

i = 5;

// OK, C::i visible in B and hides A::i

int i;
namespace B {

namespace C {

int i;

}
using namespace A::B::C;
void f1() {

}
namespace D {

using namespace B;
using namespace C;
void f2() {

}

}

i = 5;

// ambiguous, B::C::i or A::i?

}
void f3() {

i = 5;

}

}
void f4() {

i = 5;

// uses A::i

// ill-formed; neither i is visible

}

}

}

}

namespace M {

int i;

namespace N {

int i;
using namespace M;

void f() {

using namespace N;
i = 7;

— end example ]

4 For unqualiﬁed lookup (3.4.1), the using-directive is transitive:

if a scope contains a using-directive that
nominates a second namespace that itself contains using-directives, the eﬀect is as if the using-directives
from the second namespace also appeared in the ﬁrst. [ Note: For qualiﬁed lookup, see 3.4.3.2. — end note ]
[ Example:

// error: both M::i and N::i are visible

For another example,

namespace A {

int i;

}
namespace B {

int i;
int j;
namespace C {

namespace D {

using namespace A;

§ 7.3.4

180

c(cid:13) ISO/IEC

N4296

int j;
int k;
int a = i;

}
using namespace D;
int k = 89;
int l = k;
int m = i;
int n = j;

// B::i hides A::i

// no problem yet
// ambiguous: C::k or D::k
// B::i hides A::i
// D::j hides B::j

}

}

5

6

— end example ]
If a namespace is extended (7.3.1) after a using-directive for that namespace is given, the additional members
of the extended namespace and the members of namespaces nominated by using-directives in the extending
namespace-deﬁnition can be used after the extending namespace-deﬁnition.
If name lookup ﬁnds a declaration for a name in two diﬀerent namespaces, and the declarations do not
declare the same entity and do not declare functions, the use of the name is ill-formed. [ Note: In particular,
the name of a variable, function or enumerator does not hide the name of a class or enumeration declared
in a diﬀerent namespace. For example,

namespace A {
class X { };
extern "C"
int g();
extern "C++" int h();

}
namespace B {
void X(int);
extern "C"
extern "C++" int h(int);

int g();

}
using namespace A;
using namespace B;

void f() {

X(1);
g();
h();

}

// error: name X found in two namespaces
// okay: name g refers to the same entity
// okay: overload resolution selects A::h

— end note ]

7 During overload resolution, all functions from the transitive search are considered for argument matching.
The set of declarations found by the transitive search is unordered. [ Note: In particular, the order in which
namespaces were considered and the relationships among the namespaces implied by the using-directives do
not cause preference to be given to any of the declarations found by the search. — end note ] An ambiguity
exists if the best match ﬁnds two functions with the same signature, even if one is in a namespace reachable
through using-directives in the namespace of the other.98 [ Example:

namespace D {

int d1;

98) During name lookup in a class hierarchy, some ambiguities may be resolved by considering whether one member hides
the other along some paths (10.2). There is no such disambiguation when considering the set of names found as a result of
following using-directives.

§ 7.3.4

181

c(cid:13) ISO/IEC

void f(char);

}
using namespace D;

int d1;

// OK: no conﬂict with D::d1

namespace E {

int e;
void f(int);

}

namespace D {

// namespace extension

int d2;
using namespace E;
void f(int);

}

}

void f() {

d1++;
::d1++;
D::d1++;
d2++;
e++;
f(1);
f(’a’);

// error: ambiguous ::d1 or D::d1?
// OK
// OK
// OK: D::d2
// OK: E::e
// error: ambiguous: D::f(int) or E::f(int)?
// OK: D::f(char)

N4296

[dcl.asm]

— end example ]
7.4 The asm declaration
1 An asm declaration has the form

asm-deﬁnition:

asm ( string-literal ) ;

The asm declaration is conditionally-supported; its meaning is implementation-deﬁned. [ Note: Typically it
is used to pass information through the implementation to an assembler. — end note ]
7.5 Linkage speciﬁcations

[dcl.link]
1 All function types, function names with external linkage, and variable names with external linkage have a
language linkage. [ Note: Some of the properties associated with an entity with language linkage are speciﬁc
to each implementation and are not described here. For example, a particular language linkage may be
associated with a particular form of representing names of objects and functions with external linkage, or
with a particular calling convention, etc. — end note ] The default language linkage of all function types,
function names, and variable names is C++ language linkage. Two function types with diﬀerent language
linkages are distinct types even if they are otherwise identical.

2 Linkage (3.5) between C++ and non-C++ code fragments can be achieved using a linkage-speciﬁcation:

linkage-speciﬁcation:

extern string-literal { declaration-seqopt}
extern string-literal declaration

The string-literal indicates the required language linkage. This International Standard speciﬁes the semantics
for the string-literals "C" and "C++". Use of a string-literal other than "C" or "C++" is conditionally-
supported, with implementation-deﬁned semantics. [ Note: Therefore, a linkage-speciﬁcation with a string-
literal that is unknown to the implementation requires a diagnostic. — end note ] [ Note: It is recommended

§ 7.5

182

c(cid:13) ISO/IEC

N4296

that the spelling of the string-literal be taken from the document deﬁning that language. For example, Ada
(not ADA) and Fortran or FORTRAN, depending on the vintage. — end note ]

3 Every implementation shall provide for linkage to functions written in the C programming language, "C",

and linkage to C++ functions, "C++". [ Example:

complex sqrt(complex);
extern "C" {

double sqrt(double);

}

// C++ linkage by default

// C linkage

— end example ]

4 Linkage speciﬁcations nest. When linkage speciﬁcations nest, the innermost one determines the language
linkage. A linkage speciﬁcation does not establish a scope. A linkage-speciﬁcation shall occur only in
namespace scope (3.3).
In a linkage-speciﬁcation, the speciﬁed language linkage applies to the function
types of all function declarators, function names with external linkage, and variable names with external
linkage declared within the linkage-speciﬁcation. [ Example:

extern "C" void f1(void(*pf)(int));

extern "C" typedef void FUNC();
FUNC f2;

extern "C" FUNC f3;

void (*pf2)(FUNC*);

extern "C" {

static void f4();

}

extern "C" void f5() {

extern void f4();

}

extern void f4();

void f6() {

extern void f4();

}

§ 7.5

// the name f1 and its function type have C language
// linkage; pf is a pointer to a C function

// the name f2 has C++ language linkage and the
// function’s type has C language linkage
// the name of function f3 and the function’s type
// have C language linkage
// the name of the variable pf2 has C++ linkage and
// the type of pf2 is pointer to C++ function that
// takes one parameter of type pointer to C function

// the name of the function f4 has
// internal linkage (not C language
// linkage) and the function’s type
// has C language linkage.

// OK: Name linkage (internal)
// and function type linkage (C
// language linkage) obtained from
// previous declaration.

// OK: Name linkage (internal)
// and function type linkage (C
// language linkage) obtained from
// previous declaration.

// OK: Name linkage (internal)
// and function type linkage (C
// language linkage) obtained from
// previous declaration.

183

c(cid:13) ISO/IEC

N4296

— end example ] A C language linkage is ignored in determining the language linkage of the names of class
members and the function type of class member functions. [ Example:

extern "C" typedef void FUNC_c();
class C {

void mf1(FUNC_c*);

FUNC_c mf2;

static FUNC_c* q;

};

extern "C" {
class X {
void mf();

void mf2(void(*)());

};

}

// the name of the function mf1 and the member
// function’s type have C++ language linkage; the
// parameter has type pointer to C function
// the name of the function mf2 and the member
// function’s type have C++ language linkage
// the name of the data member q has C++ language
// linkage and the data member’s type is pointer to
// C function

// the name of the function mf and the member
// function’s type have C++ language linkage
// the name of the function mf2 has C++ language
// linkage; the parameter has type pointer to
// C function

5

— end example ]
If two declarations declare functions with the same name and parameter-type-list (8.3.5) to be members of
the same namespace or declare objects with the same name to be members of the same namespace and the
declarations give the names diﬀerent language linkages, the program is ill-formed; no diagnostic is required
if the declarations appear in diﬀerent translation units. Except for functions with C++ linkage, a function
declaration without a linkage speciﬁcation shall not precede the ﬁrst linkage speciﬁcation for that function.
A function can be declared without a linkage speciﬁcation after an explicit linkage speciﬁcation has been
seen; the linkage explicitly speciﬁed in the earlier declaration is not aﬀected by such a function declaration.
6 At most one function with a particular name can have C language linkage. Two declarations for a function
with C language linkage with the same function name (ignoring the namespace names that qualify it) that
appear in diﬀerent namespace scopes refer to the same function. Two declarations for a variable with C
language linkage with the same name (ignoring the namespace names that qualify it) that appear in diﬀerent
namespace scopes refer to the same variable. An entity with C language linkage shall not be declared with
the same name as a variable in global scope, unless both declarations denote the same entity; no diagnostic
is required if the declarations appear in diﬀerent translation units. A variable with C language linkage shall
not be declared with the same name as a function with C language linkage (ignoring the namespace names
that qualify the respective names); no diagnostic is required if the declarations appear in diﬀerent translation
units. [ Note: Only one deﬁnition for an entity with a given name with C language linkage may appear in
the program (see 3.2); this implies that such an entity must not be deﬁned in more than one namespace
scope. — end note ] [ Example:

int x;
namespace A {

extern "C" int f();
extern "C" int g() { return 1; }
extern "C" int h();
extern "C" int x();

}

// ill-formed: same name as global-space object x

§ 7.5

184

c(cid:13) ISO/IEC

N4296

namespace B {

}

extern "C" int f();
extern "C" int g() { return 1; } // ill-formed, the function g

// A::f and B::f refer to the same function

// with C language linkage has two deﬁnitions

int A::f() { return 98; }
extern "C" int h() { return 97; }

//deﬁnition for the function f with C language linkage
// deﬁnition for the function h with C language linkage
// A::h and ::h refer to the same function

— end example ]

7 A declaration directly contained in a linkage-speciﬁcation is treated as if it contains the extern speci-
ﬁer (7.1.1) for the purpose of determining the linkage of the declared name and whether it is a deﬁnition.
Such a declaration shall not specify a storage class. [ Example:

extern "C" double f();
static double f();
extern "C" int i;
extern "C" {

int i;

}
extern "C" static void g();

// error
// declaration

// deﬁnition

// error

8

— end example ]
[ Note: Because the language linkage is part of a function type, when indirecting through a pointer to C
function, the function to which the resulting lvalue refers is considered a C function. — end note ]

9 Linkage from C++ to objects deﬁned in other languages and to objects deﬁned in C++ from other languages
is implementation-deﬁned and language-dependent. Only where the object layout strategies of two language
implementations are similar enough can such linkage be achieved.
7.6 Attributes
7.6.1 Attribute syntax and semantics

[dcl.attr]
[dcl.attr.grammar]
1 Attributes specify additional information for various source constructs such as types, variables, names,

blocks, or translation units.

attribute-speciﬁer-seq:

attribute-speciﬁer-seqopt attribute-speciﬁer

attribute-speciﬁer:

[ [ attribute-list ] ]
alignment-speciﬁer

alignment-speciﬁer:

alignas ( type-id ...opt)
alignas ( constant-expression ...opt)

attribute-list:

attributeopt
attribute-list , attributeopt
attribute ...
attribute-list , attribute ...

attribute:

attribute-token attribute-argument-clauseopt

attribute-token:
identiﬁer
attribute-scoped-token

§ 7.6.1

185

c(cid:13) ISO/IEC

N4296

attribute-scoped-token:

attribute-namespace :: identiﬁer

attribute-namespace:

identiﬁer

attribute-argument-clause:

( balanced-token-seq )

balanced-token-seq:

balanced-tokenopt
balanced-token-seq balanced-token

balanced-token:

( balanced-token-seq )
[ balanced-token-seq ]
{ balanced-token-seq }
any token other than a parenthesis, a bracket, or a brace

2

3

[ Note: For each individual attribute, the form of the balanced-token-seq will be speciﬁed. — end note ]
In an attribute-list, an ellipsis may appear only if that attribute’s speciﬁcation permits it. An attribute
followed by an ellipsis is a pack expansion (14.5.3). An attribute-speciﬁer that contains no attributes has no
eﬀect. The order in which the attribute-tokens appear in an attribute-list is not signiﬁcant. If a keyword (2.11)
or an alternative token (2.5) that satisﬁes the syntactic requirements of an identiﬁer (2.10) is contained
in an attribute-token, it is considered an identiﬁer. No name lookup (3.4) is performed on any of the
identiﬁers contained in an attribute-token. The attribute-token determines additional requirements on the
attribute-argument-clause (if any). The use of an attribute-scoped-token is conditionally-supported, with
implementation-deﬁned behavior.
[ Note: Each implementation should choose a distinctive name for the
attribute-namespace in an attribute-scoped-token. — end note ]

4 Each attribute-speciﬁer-seq is said to appertain to some entity or statement, identiﬁed by the syntactic
context where it appears (Clause 6, Clause 7, Clause 8).
If an attribute-speciﬁer-seq that appertains to
some entity or statement contains an attribute that is not allowed to apply to that entity or statement, the
program is ill-formed. If an attribute-speciﬁer-seq appertains to a friend declaration (11.3), that declaration
shall be a deﬁnition. No attribute-speciﬁer-seq shall appertain to an explicit instantiation (14.7.2).

5 For an attribute-token not speciﬁed in this International Standard, the behavior is implementation-deﬁned.
6 Two consecutive left square bracket tokens shall appear only when introducing an attribute-speciﬁer. [ Note:
If two consecutive left square brackets appear where an attribute-speciﬁer is not allowed, the program is
ill-formed even if the brackets match an alternative grammar production. — end note ] [ Example:

int p[10];
void f() {

int x = 42, y[5];
int(p[[x] { return x; }()]);

y[[] { return 2; }()] = 2;

}

// error: invalid attribute on a nested
// declarator-id and not a function-style cast of
// an element of p.
// error even though attributes are not allowed
// in this context.

— end example ]
7.6.2 Alignment speciﬁer

[dcl.align]
1 An alignment-speciﬁer may be applied to a variable or to a class data member, but it shall not be applied to
a bit-ﬁeld, a function parameter, an exception-declaration (15.3), or a variable declared with the register
storage class speciﬁer. An alignment-speciﬁer may also be applied to the declaration or deﬁnition of a
class (in an elaborated-type-speciﬁer (7.1.6.3) or class-head (Clause 9), respectively) and to the declaration

§ 7.6.2

186

c(cid:13) ISO/IEC

N4296

or deﬁnition of an enumeration (in an opaque-enum-declaration or enum-head, respectively (7.2)). An
alignment-speciﬁer with an ellipsis is a pack expansion (14.5.3).

2 When the alignment-speciﬁer is of the form alignas( constant-expression ):

(2.1)

(2.2)

(2.3)

(2.4)

(2.5)

(2.6)

—
—

—

—

—
—

the constant-expression shall be an integral constant expression
if the constant expression evaluates to a fundamental alignment, the alignment requirement of the
declared entity shall be the speciﬁed fundamental alignment
if the constant expression evaluates to an extended alignment and the implementation supports that
alignment in the context of the declaration, the alignment of the declared entity shall be that alignment
if the constant expression evaluates to an extended alignment and the implementation does not support
that alignment in the context of the declaration, the program is ill-formed
if the constant expression evaluates to zero, the alignment speciﬁer shall have no eﬀect
otherwise, the program is ill-formed.

3 When the alignment-speciﬁer is of the form alignas( type-id ), it shall have the same eﬀect as alignas(

alignof(type-id )) (5.3.6).

4 When multiple alignment-speciﬁers are speciﬁed for an entity, the alignment requirement shall be set to the

strictest speciﬁed alignment.

5 The combined eﬀect of all alignment-speciﬁers in a declaration shall not specify an alignment that is less
strict than the alignment that would be required for the entity being declared if all alignment-speciﬁers
appertaining to that entity were omitted. [ Example:

struct alignas(8) S {};
struct alignas(1) U {

// Error: U speciﬁes an alignment that is less strict than
// if the alignas(1) were omitted.

S s;

};

6

— end example ]
If the deﬁning declaration of an entity has an alignment-speciﬁer, any non-deﬁning declaration of that
entity shall either specify equivalent alignment or have no alignment-speciﬁer. Conversely, if any declaration
of an entity has an alignment-speciﬁer, every deﬁning declaration of that entity shall specify an equivalent
alignment. No diagnostic is required if declarations of an entity have diﬀerent alignment-speciﬁers in diﬀerent
translation units.
[ Example:

// Translation unit #1:
struct S { int x; } s, p = &s;

// Translation unit #2:
struct alignas(16) S;
extern S* p;

// error: deﬁnition of S lacks alignment; no
// diagnostic required

7

— end example ]
[ Example: An aligned buﬀer with an alignment requirement of A and holding N elements of type T other
than char, signed char, or unsigned char can be declared as:

alignas(T) alignas(A) T buffer[N];

§ 7.6.2

187

c(cid:13) ISO/IEC

N4296

Specifying alignas(T) ensures that the ﬁnal requested alignment will not be weaker than alignof(T), and
therefore the program will not be ill-formed. — end example ]
[ Example:

8

alignas(double) void f();
alignas(double) unsigned char c[sizeof(double)]; // array of characters, suitably aligned for a double
extern unsigned char c[sizeof(double)];
alignas(float)

// error: alignment applied to function

// no alignas necessary

extern unsigned char c[sizeof(double)];

// error: diﬀerent alignment in declaration

— end example ]
7.6.3 Noreturn attribute

1 The attribute-token noreturn speciﬁes that a function does not return.

[dcl.attr.noreturn]
It shall appear at most once in
each attribute-list and no attribute-argument-clause shall be present. The attribute may be applied to
the declarator-id in a function declaration. The ﬁrst declaration of a function shall specify the noreturn
attribute if any declaration of that function speciﬁes the noreturn attribute. If a function is declared with
the noreturn attribute in one translation unit and the same function is declared without the noreturn
attribute in another translation unit, the program is ill-formed; no diagnostic required.
If a function f is called where f was previously declared with the noreturn attribute and f eventually
returns, the behavior is undeﬁned. [ Note: The function may terminate by throwing an exception. — end
note ] [ Note: Implementations are encouraged to issue a warning if a function marked [[noreturn]] might
return. — end note ]
[ Example:

2

3

[[ noreturn ]] void f() {

throw "error";

// OK

[[ noreturn ]] void q(int i) { // behavior is undeﬁned if called with an argument <= 0

}

}

if (i > 0)

throw "positive";

— end example ]
7.6.4 Carries dependency attribute

[dcl.attr.depend]
1 The attribute-token carries_dependency speciﬁes dependency propagation into and out of functions. It
shall appear at most once in each attribute-list and no attribute-argument-clause shall be present. The
attribute may be applied to the declarator-id of a parameter-declaration in a function declaration or lambda,
in which case it speciﬁes that the initialization of the parameter carries a dependency to (1.10) each lvalue-
to-rvalue conversion (4.1) of that object. The attribute may also be applied to the declarator-id of a function
declaration, in which case it speciﬁes that the return value, if any, carries a dependency to the evaluation of
the function call expression.

2 The ﬁrst declaration of a function shall specify the carries_dependency attribute for its declarator-id if any
declaration of the function speciﬁes the carries_dependency attribute. Furthermore, the ﬁrst declaration of
a function shall specify the carries_dependency attribute for a parameter if any declaration of that function
speciﬁes the carries_dependency attribute for that parameter. If a function or one of its parameters is
declared with the carries_dependency attribute in its ﬁrst declaration in one translation unit and the
same function or one of its parameters is declared without the carries_dependency attribute in its ﬁrst
declaration in another translation unit, the program is ill-formed; no diagnostic required.

§ 7.6.4

188

c(cid:13) ISO/IEC

N4296

3

4

[ Note: The carries_dependency attribute does not change the meaning of the program, but may result in
generation of more eﬃcient code. — end note ]
[ Example:

/∗ Translation unit A. ∗/

struct foo { int* a; int* b; };
std::atomic<struct foo *> foo_head[10];
int foo_array[10][10];

[[carries_dependency]] struct foo* f(int i) {

return foo_head[i].load(memory_order_consume);

}

int g(int* x, int* y [[carries_dependency]]) {

return kill_dependency(foo_array[*x][*y]);

}
/∗ Translation unit B. ∗/

[[carries_dependency]] struct foo* f(int i);
int g(int* x, int* y [[carries_dependency]]);

int c = 3;

void h(int i) {
struct foo* p;

p = f(i);
do_something_with(g(&c, p->a));
do_something_with(g(p->a, &c));

}

5 The carries_dependency attribute on function f means that the return value carries a dependency out of
f, so that the implementation need not constrain ordering upon return from f. Implementations of f and
its caller may choose to preserve dependencies instead of emitting hardware memory ordering instructions
(a.k.a. fences).

6 Function g’s second parameter has a carries_dependency attribute, but its ﬁrst parameter does not. There-
fore, function h’s ﬁrst call to g carries a dependency into g, but its second call does not. The implementation
might need to insert a fence prior to the second call to g.
— end example ]
7.6.5 Deprecated attribute

[dcl.attr.deprecated]
1 The attribute-token deprecated can be used to mark names and entities whose use is still allowed, but is
discouraged for some reason.
[ Note: in particular, deprecated is appropriate for names and entities that
are deemed obsolescent or unsafe. — end note ] It shall appear at most once in each attribute-list. An
attribute-argument-clause may be present and, if present, it shall have the form:

( string-literal )

[ Note: the string-literal in the attribute-argument-clause could be used to explain the rationale for depreca-
tion and/or to suggest a replacing entity. — end note ]

§ 7.6.5

189

c(cid:13) ISO/IEC

N4296

2 The attribute may be applied to the declaration of a class, a typedef-name, a variable, a non-static data

member, a function, a namespace, an enumeration, an enumerator, or a template specialization.

3 A name or entity declared without the deprecated attribute can later be re-declared with the attribute and
vice-versa. [ Note: Thus, an entity initially declared without the attribute can be marked as deprecated by
a subsequent redeclaration. However, after an entity is marked as deprecated, later redeclarations do not
un-deprecate the entity. — end note ] Redeclarations using diﬀerent forms of the attribute (with or without
the attribute-argument-clause or with diﬀerent attribute-argument-clauses) are allowed.
[ Note: Implementations may use the deprecated attribute to produce a diagnostic message in case the
program refers to a name or entity other than to declare it, after a declaration that speciﬁes the attribute. The
diagnostic message may include the text provided within the attribute-argument-clause of any deprecated
attribute applied to the name or entity. — end note ]

4

§ 7.6.5

190

c(cid:13) ISO/IEC

8 Declarators

N4296

[dcl.decl]

1 A declarator declares a single variable, function, or type, within a declaration. The init-declarator-list
appearing in a declaration is a comma-separated sequence of declarators, each of which can have an initializer.

init-declarator-list:

init-declarator
init-declarator-list , init-declarator

init-declarator:

declarator initializeropt

2 The three components of a simple-declaration are the attributes (7.6), the speciﬁers (decl-speciﬁer-seq; 7.1)
and the declarators (init-declarator-list). The speciﬁers indicate the type, storage class or other properties
of the entities being declared. The declarators specify the names of these entities and (optionally) modify
the type of the speciﬁers with operators such as * (pointer to) and () (function returning). Initial values
can also be speciﬁed in a declarator; initializers are discussed in 8.5 and 12.6.

3 Each init-declarator in a declaration is analyzed separately as if it was in a declaration by itself.99
4 Declarators have the syntax

declarator:

ptr-declarator
noptr-declarator parameters-and-qualiﬁers trailing-return-type

ptr-declarator:

noptr-declarator
ptr-operator ptr-declarator

noptr-declarator:

declarator-id attribute-speciﬁer-seqopt
noptr-declarator parameters-and-qualiﬁers
noptr-declarator [ constant-expressionopt] attribute-speciﬁer-seqopt
( ptr-declarator )

parameters-and-qualiﬁers:

( parameter-declaration-clause ) cv-qualiﬁer-seqopt

ref-qualiﬁeropt exception-speciﬁcationopt attribute-speciﬁer-seqopt

99) A declaration with several declarators is usually equivalent to the corresponding sequence of declarations each with a single
declarator. That is
T D1, D2, ...

Dn;
is usually equivalent to

T D1; T D2; ...

T Dn;

where T is a decl-speciﬁer-seq and each Di is an init-declarator. An exception occurs when a name introduced by one of
the declarators hides a type name used by the decl-speciﬁers, so that when the same decl-speciﬁers are used in a subsequent
declaration, they do not have the same meaning, as in

struct S ...
S S, T; // declare two instances of struct S

;

which is not equivalent to

struct S ...
S S;
S T; // error

;

Another exception occurs when T is auto (7.1.6.4), for example:

auto i = 1, j = 2.0; // error: deduced types for i and j do not match

as opposed to

auto i = 1; // OK: i deduced to have type int
auto j = 2.0; // OK: j deduced to have type double

Declarators

191

c(cid:13) ISO/IEC

N4296

trailing-return-type:

ptr-operator:

-> trailing-type-speciﬁer-seq abstract-declaratoropt

* attribute-speciﬁer-seqopt cv-qualiﬁer-seqopt
& attribute-speciﬁer-seqopt
&& attribute-speciﬁer-seqopt
nested-name-speciﬁer * attribute-speciﬁer-seqopt cv-qualiﬁer-seqopt

cv-qualiﬁer-seq:

cv-qualiﬁer cv-qualiﬁer-seqopt

cv-qualiﬁer:
const
volatile

ref-qualiﬁer:

&
&&

declarator-id:

...opt id-expression

5 The optional attribute-speciﬁer-seq in a trailing-return-type appertains to the indicated return type. The
type-id in a trailing-return-type includes the longest possible sequence of abstract-declarators. [ Note: This
resolves the ambiguous binding of array and function declarators. [ Example:

auto f()->int(*)[4]; // function returning a pointer to array[4] of int

// not function returning array[4] of pointer to int

— end example ] — end note ]
8.1 Type names

[dcl.name]
1 To specify type conversions explicitly, and as an argument of sizeof, alignof, new, or typeid, the name of
a type shall be speciﬁed. This can be done with a type-id, which is syntactically a declaration for a variable
or function of that type that omits the name of the entity.

type-id:

type-speciﬁer-seq abstract-declaratoropt

abstract-declarator:

ptr-abstract-declarator
noptr-abstract-declaratoropt parameters-and-qualiﬁers trailing-return-type
abstract-pack-declarator

ptr-abstract-declarator:

noptr-abstract-declarator
ptr-operator ptr-abstract-declaratoropt

noptr-abstract-declarator:

noptr-abstract-declaratoropt parameters-and-qualiﬁers
noptr-abstract-declaratoropt[ constant-expressionopt ] attribute-speciﬁer-seqopt
( ptr-abstract-declarator )

abstract-pack-declarator:

noptr-abstract-pack-declarator
ptr-operator abstract-pack-declarator

noptr-abstract-pack-declarator:

noptr-abstract-pack-declarator parameters-and-qualiﬁers
noptr-abstract-pack-declarator [ constant-expressionopt ] attribute-speciﬁer-seqopt
...

It is possible to identify uniquely the location in the abstract-declarator where the identiﬁer would appear
if the construction were a declarator in a declaration. The named type is then the same as the type of the
hypothetical identiﬁer. [ Example:

§ 8.1

192

c(cid:13) ISO/IEC

N4296

int
int *
int *[3]
int (*)[3]
int *()
int (*)(double)

// int i
// int *pi
// int *p[3]
// int (*p3i)[3]
// int *f()
// int (*pf)(double)

name respectively the types “int,” “pointer to int,” “array of 3 pointers to int,” “pointer to array of 3 int,”
“function of (no parameters) returning pointer to int,” and “pointer to a function of (double) returning
int.” — end example ]

2 A type can also be named (often more easily) by using a typedef (7.1.3).

8.2 Ambiguity resolution

[dcl.ambig.res]
1 The ambiguity arising from the similarity between a function-style cast and a declaration mentioned in 6.8
can also occur in the context of a declaration. In that context, the choice is between a function declaration
with a redundant set of parentheses around a parameter name and an object declaration with a function-style
cast as the initializer. Just as for the ambiguities mentioned in 6.8, the resolution is to consider any construct
that could possibly be a declaration a declaration. [ Note: A declaration can be explicitly disambiguated by
a nonfunction-style cast, by an = to indicate initialization or by removing the redundant parentheses around
the parameter name. — end note ] [ Example:

struct S {
S(int);

};

void foo(double a) {

S w(int(a));
S x(int());
S y((int)a);
S z = int(a);

// function declaration
// function declaration
// object declaration
// object declaration

}

}

— end example ]

2 The ambiguity arising from the similarity between a function-style cast and a type-id can occur in diﬀerent
contexts. The ambiguity appears as a choice between a function-style cast expression and a declaration of a
type. The resolution is that any construct that could possibly be a type-id in its syntactic context shall be
considered a type-id.
[ Example:

3

#include <cstddef>
char* p;
void* operator new(std::size_t, int);
void foo() {

const int x = 63;
new (int(*p)) int;
new (int(*[x]));

// new-placement
// parenthesized type-id

4 For another example,
template <class T>
struct S {

T* p;

};

§ 8.2

193

c(cid:13) ISO/IEC

S<int()> x;
S<int(1)> y;

5 For another example,

void foo() {

sizeof(int(1));
sizeof(int());

}

6 For another example,

void foo() {
(int(1));
(int())1;

}

— end example ]

N4296

// type-id
// expression (ill-formed)

// expression
// type-id (ill-formed)

// expression
// type-id (ill-formed)

7 Another ambiguity arises in a parameter-declaration-clause of a function declaration, or in a type-id that
is the operand of a sizeof or typeid operator, when a type-name is nested in parentheses. In this case,
the choice is between the declaration of a parameter of type pointer to function and the declaration of a
parameter with redundant parentheses around the declarator-id. The resolution is to consider the type-name
as a simple-type-speciﬁer rather than a declarator-id. [ Example:

class C { };
void f(int(C)) { }

int g(C);

// void f(int(*fp)(C c)) { }
// not: void f(int C);

void foo() {

f(1);
f(g);

}

// error: cannot convert 1 to function pointer
// OK

For another example,

class C { };
void h(int *(C[10]));

// void h(int *(*_fp)(C _parm[10]));
// not: void h(int *C[10]);

— end example ]
8.3 Meaning of declarators

[dcl.meaning]
1 A list of declarators appears after an optional (Clause 7) decl-speciﬁer-seq (7.1). Each declarator contains
exactly one declarator-id; it names the identiﬁer that is declared. An unqualiﬁed-id occurring in a declarator-
id shall be a simple identiﬁer except for the declaration of some special functions (12.1, 12.3, 12.4, 13.5)
and for the declaration of template specializations or partial specializations (14.7). When the declarator-
id is qualiﬁed, the declaration shall refer to a previously declared member of the class or namespace to
which the qualiﬁer refers (or, in the case of a namespace, of an element of the inline namespace set of that
namespace (7.3.1)) or to a specialization thereof; the member shall not merely have been introduced by
a using-declaration in the scope of the class or namespace nominated by the nested-name-speciﬁer of the
declarator-id. The nested-name-speciﬁer of a qualiﬁed declarator-id shall not begin with a decltype-speciﬁer.
[ Note: If the qualiﬁer is the global :: scope resolution operator, the declarator-id refers to a name declared

§ 8.3

194

c(cid:13) ISO/IEC

N4296

in the global namespace scope. — end note ] The optional attribute-speciﬁer-seq following a declarator-id
appertains to the entity that is declared.

2 A static, thread_local, extern, register, mutable, friend, inline, virtual, or typedef speciﬁer ap-
plies directly to each declarator-id in an init-declarator-list; the type speciﬁed for each declarator-id depends
on both the decl-speciﬁer-seq and its declarator.

3 Thus, a declaration of a particular identiﬁer has the form

T D

where T is of the form attribute-speciﬁer-seqopt decl-speciﬁer-seq and D is a declarator. Following is a recursive
procedure for determining the type speciﬁed for the contained declarator-id by such a declaration.

4 First, the decl-speciﬁer-seq determines a type. In a declaration

T D

the decl-speciﬁer-seq T determines the type T. [ Example: in the declaration

int unsigned i;

5

6

1

2

the type speciﬁers int unsigned determine the type “unsigned int” (7.1.6.2). — end example ]
In a declaration attribute-speciﬁer-seqopt T D where D is an unadorned identiﬁer the type of this identiﬁer is
“T”.
In a declaration T D where D has the form

( D1 )

the type of the contained declarator-id is the same as that of the contained declarator-id in the declaration

T D1

Parentheses do not alter the type of the embedded declarator-id, but they can alter the binding of complex
declarators.
8.3.1 Pointers
In a declaration T D where D has the form

[dcl.ptr]

* attribute-speciﬁer-seqopt cv-qualiﬁer-seqoptD1

and the type of the identiﬁer in the declaration T D1 is “derived-declarator-type-list T,” then the type of the
identiﬁer of D is “derived-declarator-type-list cv-qualiﬁer-seq pointer to T.” The cv-qualiﬁers apply to the pointer
and not to the object pointed to. Similarly, the optional attribute-speciﬁer-seq (7.6.1) appertains to the
pointer and not to the object pointed to.
[ Example: the declarations

const int ci = 10, *pc = &ci, *const cpc = pc, **ppc;
int i, *p, *const cp = &i;

declare ci, a constant integer; pc, a pointer to a constant integer; cpc, a constant pointer to a constant
integer; ppc, a pointer to a pointer to a constant integer; i, an integer; p, a pointer to integer; and cp, a
constant pointer to integer. The value of ci, cpc, and cp cannot be changed after initialization. The value
of pc can be changed, and so can the object pointed to by cp. Examples of some correct operations are

i = ci;
*cp = ci;
pc++;
pc = cpc;

§ 8.3.1

195

N4296

c(cid:13) ISO/IEC

pc = p;
ppc = &pc;

Examples of ill-formed operations are

ci = 1;
ci++;
*pc = 2;
cp = &ci;
cpc++;
p = pc;
ppc = &p;

// error
// error
// error
// error
// error
// error
// error

Each is unacceptable because it would either change the value of an object declared const or allow it to be
changed through a cv-unqualiﬁed pointer later, for example:
// OK, but would make p point to ci ...
// ... because of previous error
// clobber ci

*ppc = &ci;

*p = 5;

— end example ]

3 See also 5.18 and 8.5.
4

[ Note: Forming a pointer to reference type is ill-formed; see 8.3.2. Forming a pointer to function type is
ill-formed if the function type has cv-qualiﬁers or a ref-qualiﬁer; see 8.3.5. Since the address of a bit-ﬁeld
(9.6) cannot be taken, a pointer can never point to a bit-ﬁeld. — end note ]
8.3.2 References
In a declaration T D where D has either of the forms

[dcl.ref]

1

& attribute-speciﬁer-seqoptD1
&& attribute-speciﬁer-seqoptD1

and the type of the identiﬁer in the declaration T D1 is “derived-declarator-type-list T,” then the type of the
identiﬁer of D is “derived-declarator-type-list reference to T.” The optional attribute-speciﬁer-seq appertains
to the reference type. Cv-qualiﬁed references are ill-formed except when the cv-qualiﬁers are introduced
through the use of a typedef-name (7.1.3, 14.1) or decltype-speciﬁer (7.1.6.2), in which case the cv-qualiﬁers
are ignored. [ Example:

typedef int& A;
const A aref = 3;

// ill-formed; lvalue reference to non-const initialized with rvalue

The type of aref is “lvalue reference to int”, not “lvalue reference to const int”. — end example ] [ Note:
A reference can be thought of as a name of an object. — end note ] A declarator that speciﬁes the type
“reference to cv void” is ill-formed.

2 A reference type that is declared using & is called an lvalue reference, and a reference type that is declared
using && is called an rvalue reference. Lvalue references and rvalue references are distinct types. Except
where explicitly noted, they are semantically equivalent and commonly referred to as references.
[ Example:

3

void f(double& a) { a += 3.14; }
// ...
double d = 0;
f(d);

declares a to be a reference parameter of f so the call f(d) will add 3.14 to d.

§ 8.3.2

196

c(cid:13) ISO/IEC

int v[20];
// ...
int& g(int i) { return v[i]; }
// ...
g(3) = 7;

N4296

declares the function g() to return a reference to an integer so g(3)=7 will assign 7 to the fourth element
of the array v. For another example,

struct link {
link* next;

};

link* first;

void h(link*& p) { // p is a reference to pointer

p->next = first;
first = p;
p = 0;

}

}

void k() {

link* q = new link;
h(q);

declares p to be a reference to a pointer to link so h(q) will leave q with the value zero. See also 8.5.3.
— end example ]
It is unspeciﬁed whether or not a reference requires storage (3.7).

4
5 There shall be no references to references, no arrays of references, and no pointers to references. The
declaration of a reference shall contain an initializer (8.5.3) except when the declaration contains an explicit
extern speciﬁer (7.1.1), is a class member (9.2) declaration within a class deﬁnition, or is the declaration
of a parameter or a return type (8.3.5); see 3.1. A reference shall be initialized to refer to a valid object or
function. [ Note: in particular, a null reference cannot exist in a well-deﬁned program, because the only way
to create such a reference would be to bind it to the “object” obtained by indirection through a null pointer,
which causes undeﬁned behavior. As described in 9.6, a reference cannot be bound directly to a bit-ﬁeld.
— end note ]
If a typedef-name (7.1.3, 14.1) or a decltype-speciﬁer (7.1.6.2) denotes a type TR that is a reference to a type
T, an attempt to create the type “lvalue reference to cv TR” creates the type “lvalue reference to T”, while
an attempt to create the type “rvalue reference to cv TR” creates the type TR. [ Example:

6

int i;
typedef int& LRI;
typedef int&& RRI;

LRI& r1 = i;
const LRI& r2 = i;
const LRI&& r3 = i;

RRI& r4 = i;
RRI&& r5 = 5;

decltype(r2)& r6 = i;
decltype(r2)&& r7 = i;

§ 8.3.2

// r1 has the type int&
// r2 has the type int&
// r3 has the type int&

// r4 has the type int&
// r5 has the type int&&

// r6 has the type int&
// r7 has the type int&

197

c(cid:13) ISO/IEC

N4296

— end example ]
[ Note: Forming a reference to function type is ill-formed if the function type has cv-qualiﬁers or a ref-
qualiﬁer; see 8.3.5. — end note ]
8.3.3 Pointers to members
In a declaration T D where D has the form

[dcl.mptr]

nested-name-speciﬁer * attribute-speciﬁer-seqopt cv-qualiﬁer-seqopt D1

and the nested-name-speciﬁer denotes a class, and the type of the identiﬁer in the declaration T D1 is “derived-
declarator-type-list T”, then the type of the identiﬁer of D is “derived-declarator-type-list cv-qualiﬁer-seq pointer
to member of class nested-name-speciﬁer of type T”. The optional attribute-speciﬁer-seq (7.6.1) appertains to
the pointer-to-member.
[ Example:

7

1

2

struct X {

void f(int);
int a;

};
struct Y;

int X::* pmi = &X::a;
void (X::* pmf)(int) = &X::f;
double X::* pmd;
char Y::* pmc;

declares pmi, pmf, pmd and pmc to be a pointer to a member of X of type int, a pointer to a member of
X of type void(int), a pointer to a member of X of type double and a pointer to a member of Y of type
char respectively. The declaration of pmd is well-formed even though X has no members of type double.
Similarly, the declaration of pmc is well-formed even though Y is an incomplete type. pmi and pmf can be
used like this:

X obj;
// ...
obj.*pmi = 7;

(obj.*pmf)(7);

— end example ]

// assign 7 to an integer
// member of obj
// call a function member of obj
// with the argument 7

3 A pointer to member shall not point to a static member of a class (9.4), a member with reference type, or

“cv void.”
[ Note: See also 5.3 and 5.5. The type “pointer to member” is distinct from the type “pointer”, that is, a
pointer to member is declared only by the pointer to member declarator syntax, and never by the pointer
declarator syntax. There is no “reference-to-member” type in C++. — end note ]
8.3.4 Arrays
In a declaration T D where D has the form

[dcl.array]

1

D1 [ constant-expressionopt] attribute-speciﬁer-seqopt

and the type of the identiﬁer in the declaration T D1 is “derived-declarator-type-list T”, then the type of the
identiﬁer of D is an array type; if the type of the identiﬁer of D contains the auto type-speciﬁer, the program
is ill-formed. T is called the array element type; this type shall not be a reference type, the (possibly cv-
qualiﬁed) type void, a function type or an abstract class type. If the constant-expression (5.20) is present, it

§ 8.3.4

198

c(cid:13) ISO/IEC

N4296

shall be a converted constant expression of type std::size_t and its value shall be greater than zero. The
constant expression speciﬁes the bound of (number of elements in) the array. If the value of the constant
expression is N, the array has N elements numbered 0 to N-1, and the type of the identiﬁer of D is “derived-
declarator-type-list array of N T”. An object of array type contains a contiguously allocated non-empty set
of N subobjects of type T. Except as noted below, if the constant expression is omitted, the type of the
identiﬁer of D is “derived-declarator-type-list array of unknown bound of T”, an incomplete object type. The
type “derived-declarator-type-list array of N T” is a diﬀerent type from the type “derived-declarator-type-list array
of unknown bound of T”, see 3.9. Any type of the form “cv-qualiﬁer-seq array of N T” is adjusted to “array
of N cv-qualiﬁer-seq T”, and similarly for “array of unknown bound of T”. The optional attribute-speciﬁer-seq
appertains to the array. [ Example:

typedef int A[5], AA[2][3];
typedef const A CA;
typedef const AA CAA;

// type is “array of 5 const int”
// type is “array of 2 array of 3 const int”

— end example ] [ Note: An “array of N cv-qualiﬁer-seq T” has cv-qualiﬁed type; see 3.9.3. — end note ]

2 An array can be constructed from one of the fundamental types (except void), from a pointer, from a pointer

to member, from a class, from an enumeration type, or from another array.

3 When several “array of” speciﬁcations are adjacent, a multidimensional array is created; only the ﬁrst of the
constant expressions that specify the bounds of the arrays may be omitted. In addition to declarations in
which an incomplete object type is allowed, an array bound may be omitted in some cases in the declaration
of a function parameter (8.3.5). An array bound may also be omitted when the declarator is followed by an
initializer (8.5). In this case the bound is calculated from the number of initial elements (say, N) supplied
(8.5.1), and the type of the identiﬁer of D is “array of N T.” Furthermore, if there is a preceding declaration
of the entity in the same scope in which the bound was speciﬁed, an omitted array bound is taken to be the
same as in that earlier declaration, and similarly for the deﬁnition of a static data member of a class.
[ Example:

4

float fa[17], *afp[17];

declares an array of float numbers and an array of pointers to float numbers. For another example,

static int x3d[3][5][7];

declares a static three-dimensional array of integers, with rank 3× 5× 7. In complete detail, x3d is an array
of three items; each item is an array of ﬁve arrays; each of the latter arrays is an array of seven integers.
Any of the expressions x3d, x3d[i], x3d[i][j], x3d[i][j][k] can reasonably appear in an expression.
Finally,

extern int x[10];
struct S {

static int y[10];

};

int x[];
int S::y[];

// OK: bound is 10
// OK: bound is 10

void f() {

extern int x[];
int i = sizeof(x);

}

// error: incomplete object type

— end example ]

§ 8.3.4

199

c(cid:13) ISO/IEC

N4296

5

6

[ Note: conversions aﬀecting expressions of array type are described in 4.2. Objects of array types cannot
be modiﬁed, see 3.10. — end note ]
[ Note: Except where it has been declared for a class (13.5.5), the subscript operator [] is interpreted in such
a way that E1[E2] is identical to *((E1)+(E2)). Because of the conversion rules that apply to +, if E1 is an
array and E2 an integer, then E1[E2] refers to the E2-th member of E1. Therefore, despite its asymmetric
appearance, subscripting is a commutative operation.

7 A consistent rule is followed for multidimensional arrays. If E is an n-dimensional array of rank i×j×. . .×k,
then E appearing in an expression that is subject to the array-to-pointer conversion (4.2) is converted to a
pointer to an (n−1)-dimensional array with rank j × . . .× k. If the * operator, either explicitly or implicitly
as a result of subscripting, is applied to this pointer, the result is the pointed-to (n − 1)-dimensional array,
which itself is immediately converted into a pointer.
[ Example: consider

8

int x[3][5];

Here x is a 3 × 5 array of integers. When x appears in an expression, it is converted to a pointer to (the
ﬁrst of three) ﬁve-membered arrays of integers. In the expression x[i] which is equivalent to *(x+i), x is
ﬁrst converted to a pointer as described; then x+i is converted to the type of x, which involves multiplying
i by the length of the object to which the pointer points, namely ﬁve integer objects. The results are added
and indirection applied to yield an array (of ﬁve integers), which in turn is converted to a pointer to the
ﬁrst of the integers. If there is another subscript the same argument applies again; this time the result is an
integer. — end example ] — end note ]
[ Note: It follows from all this that arrays in C++ are stored row-wise (last subscript varies fastest) and that
the ﬁrst subscript in the declaration helps determine the amount of storage consumed by an array but plays
no other part in subscript calculations. — end note ]
8.3.5 Functions
In a declaration T D where D has the form

[dcl.fct]

D1 ( parameter-declaration-clause ) cv-qualiﬁer-seqopt

ref-qualiﬁeropt exception-speciﬁcationopt attribute-speciﬁer-seqopt

9

1

2

and the type of the contained declarator-id in the declaration T D1 is “derived-declarator-type-list T”, the
type of the declarator-id in D is “derived-declarator-type-list function of (parameter-declaration-clause ) cv-qualiﬁer-
seqopt ref-qualiﬁeropt returning T”. The optional attribute-speciﬁer-seq appertains to the function type.
In a declaration T D where D has the form

D1 ( parameter-declaration-clause ) cv-qualiﬁer-seqopt

ref-qualiﬁeropt exception-speciﬁcationopt attribute-speciﬁer-seqopt trailing-return-type

and the type of the contained declarator-id in the declaration T D1 is “derived-declarator-type-list T”, T
shall be the single type-speciﬁer auto. The type of the declarator-id in D is “derived-declarator-type-list
function of (parameter-declaration-clause) cv-qualiﬁer-seqopt ref-qualiﬁeropt returning trailing-return-type”.
The optional attribute-speciﬁer-seq appertains to the function type.

3 A type of either form is a function type.100

parameter-declaration-clause:

parameter-declaration-listopt...opt
parameter-declaration-list , ...

parameter-declaration-list:

parameter-declaration
parameter-declaration-list , parameter-declaration

100) As indicated by syntax, cv-qualiﬁers are a signiﬁcant component in function return types.

§ 8.3.5

200

c(cid:13) ISO/IEC

N4296

parameter-declaration:

attribute-speciﬁer-seqopt decl-speciﬁer-seq declarator
attribute-speciﬁer-seqopt decl-speciﬁer-seq declarator = initializer-clause
attribute-speciﬁer-seqopt decl-speciﬁer-seq abstract-declaratoropt
attribute-speciﬁer-seqopt decl-speciﬁer-seq abstract-declaratoropt= initializer-clause

The optional attribute-speciﬁer-seq in a parameter-declaration appertains to the parameter.

4 The parameter-declaration-clause determines the arguments that can be speciﬁed, and their processing, when
the function is called.
[ Note: the parameter-declaration-clause is used to convert the arguments speciﬁed
on the function call; see 5.2.2. — end note ] If the parameter-declaration-clause is empty, the function takes
no arguments. A parameter list consisting of a single unnamed parameter of non-dependent type void is
equivalent to an empty parameter list. Except for this special case, a parameter shall not have type cv void.
If the parameter-declaration-clause terminates with an ellipsis or a function parameter pack (14.5.3), the
number of arguments shall be equal to or greater than the number of parameters that do not have a default
argument and are not function parameter packs. Where syntactically correct and where “...” is not part of
an abstract-declarator, “, ...” is synonymous with “...”. [ Example: the declaration

int printf(const char*, ...);

declares a function that can be called with varying numbers and types of arguments.

printf("hello world");
printf("a=%d b=%d", a, b);

However, the ﬁrst argument must be of a type that can be converted to a const char* — end example ]
[ Note: The standard header <cstdarg> contains a mechanism for accessing arguments passed using the
ellipsis (see 5.2.2 and 18.10). — end note ]

5 A single name can be used for several diﬀerent functions in a single scope; this is function overloading
(Clause 13). All declarations for a function shall agree exactly in both the return type and the parameter-
type-list. The type of a function is determined using the following rules. The type of each parameter
(including function parameter packs) is determined from its own decl-speciﬁer-seq and declarator. After
determining the type of each parameter, any parameter of type “array of T” or “function returning T” is
adjusted to be “pointer to T” or “pointer to function returning T,” respectively. After producing the list
of parameter types, any top-level cv-qualiﬁers modifying a parameter type are deleted when forming the
function type. The resulting list of transformed parameter types and the presence or absence of the ellipsis
or a function parameter pack is the function’s parameter-type-list.
[ Note: This transformation does not
aﬀect the types of the parameters. For example, int(*)(const int p, decltype(p)*) and int(*)(int,
const int*) are identical types. — end note ]

6 A function type with a cv-qualiﬁer-seq or a ref-qualiﬁer (including a type named by typedef-name (7.1.3,

14.1)) shall appear only as:

(6.1)

(6.2)

(6.3)

(6.4)

(6.5)

—
—
—
—
—

the function type for a non-static member function,
the function type to which a pointer to member refers,
the top-level function type of a function typedef declaration or alias-declaration,
the type-id in the default argument of a type-parameter (14.1), or
the type-id of a template-argument for a type-parameter (14.3.1).

[ Example:

typedef int FIC(int) const;
FIC f;

// ill-formed: does not declare a member function

§ 8.3.5

201

c(cid:13) ISO/IEC

N4296

struct S {

FIC f;

// OK

};
FIC S::*pm = &S::f; // OK

— end example ]

7 The eﬀect of a cv-qualiﬁer-seq in a function declarator is not the same as adding cv-qualiﬁcation on top
of the function type. In the latter case, the cv-qualiﬁers are ignored.
[ Note: a function type that has a
cv-qualiﬁer-seq is not a cv-qualiﬁed type; there are no cv-qualiﬁed function types. — end note ] [ Example:

typedef void F();
struct S {

const F f;

};

// OK: equivalent to: void f();

— end example ]

8 The return type, the parameter-type-list, the ref-qualiﬁer, and the cv-qualiﬁer-seq, but not the default
arguments (8.3.6) or the exception speciﬁcation (15.4), are part of the function type. [ Note: Function types
are checked during the assignments and initializations of pointers to functions, references to functions, and
pointers to member functions. — end note ]
[ Example: the declaration

9

int fseek(FILE*, long, int);

declares a function taking three arguments of the speciﬁed types, and returning int (7.1.6). — end example ]
10 Functions shall not have a return type of type array or function, although they may have a return type of
type pointer or reference to such things. There shall be no arrays of functions, although there can be arrays
of pointers to functions.

11 Types shall not be deﬁned in return or parameter types. The type of a parameter or the return type for a
function deﬁnition shall not be an incomplete (possibly cv-qualiﬁed) class type in the context of the function
deﬁnition unless the function is deleted (8.4.3).

12 A typedef of function type may be used to declare a function but shall not be used to deﬁne a function (8.4).

[ Example:

fv;
fv { }

typedef void F();
F
F
void fv() { }
— end example ]

// OK: equivalent to void fv();
// ill-formed
// OK: deﬁnition of fv

13 An identiﬁer can optionally be provided as a parameter name; if present in a function deﬁnition (8.4), it
names a parameter.
[ Note: In particular, parameter names are also optional in function deﬁnitions and
names used for a parameter in diﬀerent declarations and the deﬁnition of a function need not be the same.
If a parameter name is present in a function declaration that is not a deﬁnition, it cannot be used outside
of its function declarator because that is the extent of its potential scope (3.3.4). — end note ]
[ Example: the declaration

14

int i,

*pi,
f(),
*fpi(int),
(*pif)(const char*, const char*),
(*fpif(int))(int);

§ 8.3.5

202

c(cid:13) ISO/IEC

N4296

declares an integer i, a pointer pi to an integer, a function f taking no arguments and returning an integer,
a function fpi taking an integer argument and returning a pointer to an integer, a pointer pif to a function
which takes two pointers to constant characters and returns an integer, a function fpif taking an integer
argument and returning a pointer to a function that takes an integer argument and returns an integer. It
is especially useful to compare fpi and pif. The binding of *fpi(int) is *(fpi(int)), so the declaration
suggests, and the same construction in an expression requires, the calling of a function fpi, and then using
indirection through the (pointer) result to yield an integer. In the declarator (*pif)(const char*, const
char*), the extra parentheses are necessary to indicate that indirection through a pointer to a function yields
a function, which is then called. — end example ] [ Note: Typedefs and trailing-return-types are sometimes
convenient when the return type of a function is complex. For example, the function fpif above could have
been declared
typedef int
IFUNC*

IFUNC(int);

fpif(int);

or

auto fpif(int)->int(*)(int);

A trailing-return-type is most useful for a type that would be more complicated to specify before the
declarator-id:

template <class T, class U> auto add(T t, U u) -> decltype(t + u);

rather than

template <class T, class U> decltype((*(T*)0) + (*(U*)0)) add(T t, U u);

— end note ]

15 A non-template function is a function that is not a function template specialization.

template is not a function. — end note ]

[ Note: A function

16 A declarator-id or abstract-declarator containing an ellipsis shall only be used in a parameter-declaration.
Such a parameter-declaration is a parameter pack (14.5.3). When it is part of a parameter-declaration-clause,
the parameter pack is a function parameter pack (14.5.3).
[ Note: Otherwise, the parameter-declaration is
part of a template-parameter-list and the parameter pack is a template parameter pack; see 14.1. — end
note ] A function parameter pack is a pack expansion (14.5.3). [ Example:

template<typename... T> void f(T (* ...t)(int, int));

int add(int, int);
float subtract(int, int);

void g() {

f(add, subtract);

}

— end example ]

17 There is a syntactic ambiguity when an ellipsis occurs at the end of a parameter-declaration-clause without
a preceding comma. In this case, the ellipsis is parsed as part of the abstract-declarator if the type of the
parameter either names a template parameter pack that has not been expanded or contains auto; otherwise,
it is parsed as part of the parameter-declaration-clause.101
101) One can explicitly disambiguate the parse either by introducing a comma (so the ellipsis will be parsed as part of the
parameter-declaration-clause) or by introducing a name for the parameter (so the ellipsis will be parsed as part of the declarator-
id).

§ 8.3.5

203

c(cid:13) ISO/IEC

N4296

[dcl.fct.default]
8.3.6 Default arguments
If an initializer-clause is speciﬁed in a parameter-declaration this initializer-clause is used as a default
argument. Default arguments will be used in calls where trailing arguments are missing.
[ Example: the declaration

1

2

void point(int = 3, int = 4);

declares a function that can be called with zero, one, or two arguments of type int. It can be called in any
of these ways:
point(1,2);

point(1);

point();

The last two calls are equivalent to point(1,4) and point(3,4), respectively. — end example ]

3 A default argument shall be speciﬁed only in the parameter-declaration-clause of a function declaration or
lambda-declarator or in a template-parameter (14.1); in the latter case, the initializer-clause shall be an
assignment-expression. A default argument shall not be speciﬁed for a parameter pack. If it is speciﬁed in
a parameter-declaration-clause, it shall not occur within a declarator or abstract-declarator of a parameter-
declaration.102

4 For non-template functions, default arguments can be added in later declarations of a function in the
same scope. Declarations in diﬀerent scopes have completely distinct sets of default arguments. That is,
declarations in inner scopes do not acquire default arguments from declarations in outer scopes, and vice
versa. In a given function declaration, each parameter subsequent to a parameter with a default argument
shall have a default argument supplied in this or a previous declaration or shall be a function parameter pack.
A default argument shall not be redeﬁned by a later declaration (not even to the same value). [ Example:

void g(int = 0, ...);

void f(int, int);
void f(int, int = 7);
void h() {

f(3);
void f(int = 1, int);

}
void m() {

void f(int, int);
f(4);
void f(int, int = 5);
f(4);
void f(int, int = 5);

}
void n() {

f(6);

}

// OK, ellipsis is not a parameter so it can follow
// a parameter with a default argument

// OK, calls f(3, 7)
// error: does not use default
// from surrounding scope

// has no defaults
// error: wrong number of arguments
// OK
// OK, calls f(4, 5);
// error: cannot redeﬁne, even to
// same value

// OK, calls f(6, 7)

— end example ] For a given inline function deﬁned in diﬀerent translation units, the accumulated sets of
default arguments at the end of the translation units shall be the same; see 3.2. If a friend declaration speciﬁes
a default argument expression, that declaration shall be a deﬁnition and shall be the only declaration of the
function or function template in the translation unit.
102) This means that default arguments cannot appear, for example, in declarations of pointers to functions, references to
functions, or typedef declarations.

§ 8.3.6

204

c(cid:13) ISO/IEC

N4296

5 The default argument has the same semantic constraints as the initializer in a declaration of a variable of
the parameter type, using the copy-initialization semantics (8.5). The names in the default argument are
bound, and the semantic constraints are checked, at the point where the default argument appears. Name
lookup and checking of semantic constraints for default arguments in function templates and in member
functions of class templates are performed as described in 14.7.1. [ Example: in the following code, g will be
called with the value f(2):

int a = 1;
int f(int);
int g(int x = f(a));

// default argument: f(::a)

void h() {

a = 2;
{
int a = 3;
g();
}

}

// g(f(::a))

— end example ] [ Note: In member function declarations, names in default arguments are looked up as
described in 3.4.1. Access checking applies to names in default arguments as described in Clause 11. — end
note ]

6 Except for member functions of class templates, the default arguments in a member function deﬁnition that
appears outside of the class deﬁnition are added to the set of default arguments provided by the member
function declaration in the class deﬁnition; the program is ill-formed if a default constructor (12.1), copy
or move constructor, or copy or move assignment operator (12.8) is so declared. Default arguments for a
member function of a class template shall be speciﬁed on the initial declaration of the member function
within the class template. [ Example:

class C {

void f(int i = 3);
void g(int i, int j = 99);

};

// error: default argument already
void C::f(int i = 3) {
// speciﬁed in class scope
}
void C::g(int i = 88, int j) { // in this translation unit,
}

// C::g can be called with no argument

— end example ]

7 Local variables shall not be used in a default argument. [ Example:

void f() {

int i;
extern void g(int x = i);
// ...

//error

}

};

— end example ]

8 The keyword this shall not be used in a default argument of a member function. [ Example:

class A {

void f(A* p = this) { }

// error

§ 8.3.6

205

c(cid:13) ISO/IEC

— end example ]

N4296

9 A default argument is evaluated each time the function is called with no argument for the corresponding
parameter. The order of evaluation of function arguments is unspeciﬁed. Consequently, parameters of a
function shall not be used in a default argument, even if they are not evaluated. Parameters of a function
declared before a default argument are in scope and can hide namespace and class member names. [ Example:

int a;
int f(int a, int b = a);

typedef int I;
int g(float I, int b = I(2));
int h(int a, int b = sizeof(a));

// error: parameter a
// used as default argument

// error: parameter I found
// error, parameter a used
// in default argument

— end example ] Similarly, a non-static member shall not be used in a default argument, even if it is not
evaluated, unless it appears as the id-expression of a class member access expression (5.2.5) or unless it is
used to form a pointer to member (5.3.1). [ Example: the declaration of X::mem1() in the following example
is ill-formed because no object is supplied for the non-static member X::a used as an initializer.

int b;
class X {
int a;
int mem1(int i = a);

int mem2(int i = b);
static int b;

};

// error: non-static member a
// used as default argument
// OK; use X::b

The declaration of X::mem2() is meaningful, however, since no object is needed to access the static member
X::b. Classes, objects, and members are described in Clause 9. — end example ] A default argument is not
part of the type of a function. [ Example:

int f(int = 0);

void h() {

int j = f(1);
int k = f();

}

// OK, means f(0)

int (*p1)(int) = &f;
int (*p2)() = &f;

// error: type mismatch

— end example ] When a declaration of a function is introduced by way of a using-declaration (7.3.3), any
default argument information associated with the declaration is made known as well.
If the function is
redeclared thereafter in the namespace with additional default arguments, the additional arguments are also
known at any point following the redeclaration where the using-declaration is in scope.

10 A virtual function call (10.3) uses the default arguments in the declaration of the virtual function determined
by the static type of the pointer or reference denoting the object. An overriding function in a derived class
does not acquire default arguments from the function it overrides. [ Example:

struct A {

virtual void f(int a = 7);

};
struct B : public A {

void f(int a);

§ 8.3.6

206

c(cid:13) ISO/IEC

N4296

};
void m() {

B* pb = new B;
A* pa = pb;
pa->f();
pb->f();

}

// OK, calls pa->B::f(7)
// error: wrong number of arguments for B::f()

— end example ]
8.4 Function deﬁnitions
8.4.1 In general

[dcl.fct.def]
[dcl.fct.def.general]

1 Function deﬁnitions have the form

function-deﬁnition:

attribute-speciﬁer-seqopt decl-speciﬁer-seqopt declarator virt-speciﬁer-seqopt function-body

function-body:

ctor-initializeropt compound-statement
function-try-block
= default ;
= delete ;

Any informal reference to the body of a function should be interpreted as a reference to the non-terminal
function-body. The optional attribute-speciﬁer-seq in a function-deﬁnition appertains to the function. A
virt-speciﬁer-seq can be part of a function-deﬁnition only if it is a member-declaration (9.2).

2 The declarator in a function-deﬁnition shall have the form

D1 ( parameter-declaration-clause ) cv-qualiﬁer-seqopt

ref-qualiﬁeropt exception-speciﬁcationopt attribute-speciﬁer-seqopt trailing-return-typeopt

as described in 8.3.5. A function shall be deﬁned only in namespace or class scope.
[ Example: a simple example of a complete function deﬁnition is

3

int max(int a, int b, int c) {

int m = (a > b) ? a : b;
return (m > c) ? m : c;

}

Here int is the decl-speciﬁer-seq; max(int a, int b, int c) is the declarator; { /* ...
function-body. — end example ]

*/ } is the

4 A ctor-initializer is used only in a constructor; see 12.1 and 12.6.
5

[ Note: A cv-qualiﬁer-seq aﬀects the type of this in the body of a member function; see 8.3.2. — end note ]
[ Note: Unused parameters need not be named. For example,

void print(int a, int) {

std::printf("a = %d\n",a);

}

— end note ]
In the function-body, a function-local predeﬁned variable denotes a block-scope object of static storage du-
ration that is implicitly deﬁned (see 3.3.3).

8 The function-local predeﬁned variable __func__ is deﬁned as if a deﬁnition of the form

static const char __func__[] = "function-name ";

§ 8.4.1

207

6

7

c(cid:13) ISO/IEC

N4296

had been provided, where function-name is an implementation-deﬁned string. It is unspeciﬁed whether such
a variable has an address distinct from that of any other object in the program.103
[ Example:

struct S {

S() : s(__func__) { }
const char* s;

// OK

};
void f(const char* s = __func__); // error: __func__ is undeclared

— end example ]
8.4.2 Explicitly-defaulted functions

1 A function deﬁnition of the form:

[dcl.fct.def.default]

attribute-speciﬁer-seqopt decl-speciﬁer-seqopt declarator virt-speciﬁer-seqopt = default ;
is called an explicitly-defaulted deﬁnition. A function that is explicitly defaulted shall

(1.1)

(1.2)

—
—

(1.3)

—

be a special member function,
have the same declared function type (except for possibly diﬀering ref-qualiﬁers and except that in
the case of a copy constructor or copy assignment operator, the parameter type may be “reference to
non-const T”, where T is the name of the member function’s class) as if it had been implicitly declared,
and
not have default arguments.

2 An explicitly-defaulted function that is not deﬁned as deleted may be declared constexpr only if it would

have been implicitly declared as constexpr. If a function is explicitly defaulted on its ﬁrst declaration,

(2.1)

(2.2)

3

(3.1)

(3.2)

—
—

it is implicitly considered to be constexpr if the implicit declaration would be, and,
it has the same exception speciﬁcation as if it had been implicitly declared (15.4).

If a function that is explicitly defaulted is declared with an exception-speciﬁcation that is not compati-
ble (15.4) with the exception speciﬁcation on the implicit declaration, then

—
—

if the function is explicitly defaulted on its ﬁrst declaration, it is deﬁned as deleted;
otherwise, the program is ill-formed.

4

[ Example:

struct S {

constexpr S() = default;
S(int a = 0) = default;
void operator=(const S&) = default;
~S() throw(int) = default;

private:
int i;
S(S&);

};
S::S(S&) = default;

// ill-formed: implicit S() is not constexpr
// ill-formed: default argument
// ill-formed: non-matching return type
// deleted: exception speciﬁcation does not match

// OK: private copy constructor

// OK: deﬁnes copy constructor

103) Implementations are permitted to provide additional predeﬁned variables with names that are reserved to the implemen-
tation (2.10). If a predeﬁned variable is not odr-used (3.2), its string value need not be present in the program image.

§ 8.4.2

208

c(cid:13) ISO/IEC

— end example ]

N4296

5 Explicitly-defaulted functions and implicitly-declared functions are collectively called defaulted functions,
and the implementation shall provide implicit deﬁnitions for them (12.1 12.4, 12.8), which might mean
deﬁning them as deleted. A function is user-provided if it is user-declared and not explicitly defaulted or
deleted on its ﬁrst declaration. A user-provided explicitly-defaulted function (i.e., explicitly defaulted after its
ﬁrst declaration) is deﬁned at the point where it is explicitly defaulted; if such a function is implicitly deﬁned
as deleted, the program is ill-formed. [ Note: Declaring a function as defaulted after its ﬁrst declaration can
provide eﬃcient execution and concise deﬁnition while enabling a stable binary interface to an evolving code
base. — end note ]
[ Example:

6

struct trivial {

trivial() = default;
trivial(const trivial&) = default;
trivial(trivial&&) = default;
trivial& operator=(const trivial&) = default;
trivial& operator=(trivial&&) = default;
~trivial() = default;

};

struct nontrivial1 {

nontrivial1();

};
nontrivial1::nontrivial1() = default;

— end example ]
8.4.3 Deleted deﬁnitions
1 A function deﬁnition of the form:

// not ﬁrst declaration

[dcl.fct.def.delete]

attribute-speciﬁer-seqopt decl-speciﬁer-seqopt declarator virt-speciﬁer-seqopt = delete ;

is called a deleted deﬁnition. A function with a deleted deﬁnition is also called a deleted function.

2 A program that refers to a deleted function implicitly or explicitly, other than to declare it, is ill-formed.
[ Note: This includes calling the function implicitly or explicitly and forming a pointer or pointer-to-member
to the function. It applies even for references in expressions that are not potentially-evaluated. If a function
is overloaded, it is referenced only if the function is selected by overload resolution. — end note ]
[ Example: One can enforce non-default initialization and non-integral initialization with

3

struct onlydouble {

onlydouble() = delete;
onlydouble(std::intmax_t) = delete;
onlydouble(double);

};

// OK, but redundant

— end example ]
[ Example: One can prevent use of a class in certain new-expressions by using deleted deﬁnitions of a user-
declared operator new for that class.

struct sometype {

void* operator new(std::size_t) = delete;
void* operator new[](std::size_t) = delete;

};
sometype* p = new sometype;

// error, deleted class operator new

§ 8.4.3

209

c(cid:13) ISO/IEC

N4296

sometype* q = new sometype[3]; // error, deleted class operator new[]

— end example ]
[ Example: One can make a class uncopyable, i.e. move-only, by using deleted deﬁnitions of the copy
constructor and copy assignment operator, and then providing defaulted deﬁnitions of the move constructor
and move assignment operator.

struct moveonly {

moveonly() = default;
moveonly(const moveonly&) = delete;
moveonly(moveonly&&) = default;
moveonly& operator=(const moveonly&) = delete;
moveonly& operator=(moveonly&&) = default;
~moveonly() = default;

};
moveonly* p;
moveonly q(*p); // error, deleted copy constructor

— end example ]

4 A deleted function is implicitly inline.

[ Note: The one-deﬁnition rule (3.2) applies to deleted deﬁnitions.
— end note ] A deleted deﬁnition of a function shall be the ﬁrst declaration of the function or, for an explicit
specialization of a function template, the ﬁrst declaration of that specialization. [ Example:

struct sometype {

sometype();

};
sometype::sometype() = delete;

// ill-formed; not ﬁrst declaration

— end example ]
8.5 Initializers

[dcl.init]
1 A declarator can specify an initial value for the identiﬁer being declared. The identiﬁer designates a variable
being initialized. The process of initialization described in the remainder of 8.5 applies also to initializa-
tions speciﬁed by other syntactic contexts, such as the initialization of function parameters with argument
expressions (5.2.2) or the initialization of return values (6.6.3).

initializer:

brace-or-equal-initializer
( expression-list )
brace-or-equal-initializer:
= initializer-clause
braced-init-list

initializer-clause:

assignment-expression
braced-init-list

initializer-list:

initializer-clause ...opt
initializer-list , initializer-clause ...opt

braced-init-list:

{ initializer-list ,opt }
{ }

2 Except for objects declared with the constexpr speciﬁer, for which see 7.1.5, an initializer in the deﬁnition
of a variable can consist of arbitrary expressions involving literals and previously declared variables and
functions, regardless of the variable’s storage duration. [ Example:

§ 8.5

210

c(cid:13) ISO/IEC

int f(int);
int a = 2;
int b = f(a);
int c(b);

N4296

— end example ]
[ Note: Default arguments are more restricted; see 8.3.6.

3
4 The order of initialization of variables with static storage duration is described in 3.6 and 6.7. — end note ]
5 A declaration of a block-scope variable with external or internal linkage that has an initializer is ill-formed.
6 To zero-initialize an object or reference of type T means:

(6.1)

(6.2)

(6.3)

(6.4)

(6.5)

—

—

—

—
—

if T is a scalar type (3.9), the object is initialized to the value obtained by converting the integer literal
0 (zero) to T;104
if T is a (possibly cv-qualiﬁed) non-union class type, each non-static data member and each base-class
subobject is zero-initialized and padding is initialized to zero bits;
if T is a (possibly cv-qualiﬁed) union type, the object’s ﬁrst non-static named data member is zero-
initialized and padding is initialized to zero bits;
if T is an array type, each element is zero-initialized;
if T is a reference type, no initialization is performed.

7 To default-initialize an object of type T means:

(7.1)

—

(7.2)

(7.3)

—
—

If T is a (possibly cv-qualiﬁed) class type (Clause 9), constructors are considered. The applicable
constructors are enumerated (13.3.1.3), and the best one for the initializer () is chosen through
overload resolution (13.3). The constructor thus selected is called, with an empty argument list, to
initialize the object.
If T is an array type, each element is default-initialized.
Otherwise, no initialization is performed.

If a program calls for the default initialization of an object of a const-qualiﬁed type T, T shall be a class type
with a user-provided default constructor.

8 To value-initialize an object of type T means:

(8.1)

(8.2)

(8.3)

(8.4)

—

—

—
—

if T is a (possibly cv-qualiﬁed) class type (Clause 9) with either no default constructor (12.1) or a
default constructor that is user-provided or deleted, then the object is default-initialized;
if T is a (possibly cv-qualiﬁed) class type without a user-provided or deleted default constructor, then
the object is zero-initialized and the semantic constraints for default-initialization are checked, and if
T has a non-trivial default constructor, the object is default-initialized;
if T is an array type, then each element is value-initialized;
otherwise, the object is zero-initialized.

An object that is value-initialized is deemed to be constructed and thus subject to provisions of this Interna-
tional Standard applying to “constructed” objects, objects “for which the constructor has completed,” etc.,
even if no constructor is invoked for the object’s initialization.

9 A program that calls for default-initialization or value-initialization of an entity of reference type is ill-formed.

104) As speciﬁed in 4.10, converting an integer literal whose value is 0 to a pointer type results in a null pointer value.

§ 8.5

211

c(cid:13) ISO/IEC

N4296

10

[ Note: Every object of static storage duration is zero-initialized at program startup before any other initial-
ization takes place. In some cases, additional initialization is done later. — end note ]

11 An object whose initializer is an empty set of parentheses, i.e., (), shall be value-initialized.

[ Note: Since () is not permitted by the syntax for initializer,

X a();

12

is not the declaration of an object of class X, but the declaration of a function taking no argument and
returning an X. The form () is permitted in certain other initialization contexts (5.3.4, 5.2.3, 12.6.2). — end
note ]
If no initializer is speciﬁed for an object, the object is default-initialized. When storage for an object
with automatic or dynamic storage duration is obtained, the object has an indeterminate value, and if
no initialization is performed for the object, that object retains an indeterminate value until that value is
replaced (5.18).
[ Note: Objects with static or thread storage duration are zero-initialized, see 3.6.2. —
end note ] If an indeterminate value is produced by an evaluation, the behavior is undeﬁned except in the
following cases:

(12.1)

(12.1.1)

(12.1.2)

(12.1.3)

(12.1.4)

(12.2)

(12.3)

—

—

—

If an indeterminate value of unsigned narrow character type (3.9.1) is produced by the evaluation of:
—
—
—

the second or third operand of a conditional expression (5.16),
the right operand of a comma expression (5.19),
the operand of a cast or conversion to an unsigned narrow character type (4.7, 5.2.3, 5.2.9, 5.4),
or
a discarded-value expression (Clause 5),

—
then the result of the operation is an indeterminate value.
If an indeterminate value of unsigned narrow character type is produced by the evaluation of the right
operand of a simple assignment operator (5.18) whose ﬁrst operand is an lvalue of unsigned narrow
character type, an indeterminate value replaces the value of the object referred to by the left operand.
If an indeterminate value of unsigned narrow character type is produced by the evaluation of the
initialization expression when initializing an object of unsigned narrow character type, that object is
initialized to an indeterminate value.

[ Example:

int f(bool b) {

unsigned char c;
unsigned char d = c; // OK, d has an indeterminate value
int e = d;
return b ? d : 0;

// undeﬁned behavior
// undeﬁned behavior if b is true

}

— end example ]

13 An initializer for a static member is in the scope of the member’s class. [ Example:

int a;

struct X {

static int a;
static int b;

};

§ 8.5

212

c(cid:13) ISO/IEC

int X::a = 1;
int X::b = a;

// X::b = X::a

N4296

14

— end example ]
If the entity being initialized does not have class type, the expression-list in a parenthesized initializer shall
be a single expression.

15 The initialization that occurs in the = form of a brace-or-equal-initializer or condition (6.4), as well as
in argument passing, function return, throwing an exception (15.1), handling an exception (15.3), and
aggregate member initialization (8.5.1), is called copy-initialization. [ Note: Copy-initialization may invoke
a move (12.8). — end note ]

16 The initialization that occurs in the forms

T x(a);
T x{a};

as well as in new expressions (5.3.4), static_cast expressions (5.2.9), functional notation type conversions
(5.2.3), mem-initializers (12.6.2), and the braced-init-list form of a condition is called direct-initialization.
17 The semantics of initializers are as follows. The destination type is the type of the object or reference being
initialized and the source type is the type of the initializer expression. If the initializer is not a single (possibly
parenthesized) expression, the source type is not deﬁned.

(17.1)

(17.2)

(17.3)

(17.4)

(17.5)

(17.6)
(17.6.1)

—
—
—

—
—
—

(17.6.2)

—

If the initializer is a (non-parenthesized) braced-init-list, the object or reference is list-initialized (8.5.4).
If the destination type is a reference type, see 8.5.3.
If the destination type is an array of characters, an array of char16_t, an array of char32_t, or an
array of wchar_t, and the initializer is a string literal, see 8.5.2.
If the initializer is (), the object is value-initialized.
Otherwise, if the destination type is an array, the program is ill-formed.
If the destination type is a (possibly cv-qualiﬁed) class type:
—

If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualiﬁed
version of the source type is the same class as, or a derived class of, the class of the destination,
constructors are considered. The applicable constructors are enumerated (13.3.1.3), and the best
one is chosen through overload resolution (13.3). The constructor so selected is called to initialize
the object, with the initializer expression or expression-list as its argument(s). If no constructor
applies, or the overload resolution is ambiguous, the initialization is ill-formed.
Otherwise (i.e., for the remaining copy-initialization cases), user-deﬁned conversion sequences
that can convert from the source type to the destination type or (when a conversion function
is used) to a derived class thereof are enumerated as described in 13.3.1.4, and the best one is
chosen through overload resolution (13.3). If the conversion cannot be done or is ambiguous, the
initialization is ill-formed. The function selected is called with the initializer expression as its
argument; if the function is a constructor, the call initializes a temporary of the cv-unqualiﬁed
version of the destination type. The temporary is a prvalue. The result of the call (which is the
temporary for the constructor case) is then used to direct-initialize, according to the rules above,
the object that is the destination of the copy-initialization. In certain cases, an implementation
is permitted to eliminate the copying inherent in this direct-initialization by constructing the
intermediate result directly into the object being initialized; see 12.2, 12.8.

§ 8.5

213

c(cid:13) ISO/IEC

N4296

(17.7)

—

(17.8)

—

Otherwise, if the source type is a (possibly cv-qualiﬁed) class type, conversion functions are considered.
The applicable conversion functions are enumerated (13.3.1.5), and the best one is chosen through
overload resolution (13.3). The user-deﬁned conversion so selected is called to convert the initializer
expression into the object being initialized.
If the conversion cannot be done or is ambiguous, the
initialization is ill-formed.
Otherwise, the initial value of the object being initialized is the (possibly converted) value of the ini-
tializer expression. Standard conversions (Clause 4) will be used, if necessary, to convert the initializer
expression to the cv-unqualiﬁed version of the destination type; no user-deﬁned conversions are con-
sidered. If the conversion cannot be done, the initialization is ill-formed. When initializing a bit-ﬁeld
with a value that it cannot represent, the resulting value of the bit-ﬁeld is implementation-deﬁned.
[ Note: An expression of type “cv1 T” can initialize an object of type “cv2 T” independently of the
cv-qualiﬁers cv1 and cv2.

int a;
const int b = a;
int c = b;

— end note ]

18 An initializer-clause followed by an ellipsis is a pack expansion (14.5.3).

8.5.1 Aggregates

[dcl.init.aggr]
1 An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), no private or
protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).
2 When an aggregate is initialized by an initializer list, as speciﬁed in 8.5.4, the elements of the initializer list
are taken as initializers for the members of the aggregate, in increasing subscript or member order. Each
member is copy-initialized from the corresponding initializer-clause. If the initializer-clause is an expression
and a narrowing conversion (8.5.4) is required to convert the expression, the program is ill-formed. [ Note:
If an initializer-clause is itself an initializer list, the member is list-initialized, which will result in a recursive
application of the rules in this section if the member is an aggregate. — end note ] [ Example:

struct A {

int x;
struct B {

} a = { 1, { 2, 3 } };

int i;
int j;

} b;

initializes a.x with 1, a.b.i with 2, a.b.j with 3. — end example ]

3 An aggregate that is a class can also be initialized with a single expression not enclosed in braces, as described

in 8.5.

4 An array of unknown size initialized with a brace-enclosed initializer-list containing n initializer-clauses,

where n shall be greater than zero, is deﬁned as having n elements (8.3.4). [ Example:

int x[] = { 1, 3, 5 };

declares and initializes x as a one-dimensional array that has three elements since no size was speciﬁed and
there are three initializers. — end example ] An empty initializer list {} shall not be used as the initializer-
clause for an array of unknown bound.105
105) The syntax provides for empty initializer-lists, but nonetheless C++ does not have zero length arrays.

§ 8.5.1

214

c(cid:13) ISO/IEC

N4296

5 Static data members and anonymous bit-ﬁelds are not considered members of the class for purposes of

aggregate initialization. [ Example:

struct A {

int i;
static int s;
int j;
int :17;
int k;

} a = { 1, 2, 3 };

Here, the second initializer 2 initializes a.j and not the static data member A::s, and the third initializer
3 initializes a.k and not the anonymous bit-ﬁeld before it. — end example ]

6 An initializer-list is ill-formed if the number of initializer-clauses exceeds the number of members or elements

to initialize. [ Example:

char cv[4] = { ’a’, ’s’, ’d’, ’f’, 0 };

// error

7

is ill-formed. — end example ]
If there are fewer initializer-clauses in the list than there are members in the aggregate, then each member
not explicitly initialized shall be initialized from its brace-or-equal-initializer or, if there is no brace-or-equal-
initializer, from an empty initializer list (8.5.4). [ Example:

struct S { int a; const char* b; int c; int d = b[a]; };
S ss = { 1, "asdf" };

initializes ss.a with 1, ss.b with "asdf", ss.c with the value of an expression of the form int{} (that is,
0), and ss.d with the value of ss.b[ss.a] (that is, ’s’), and in

struct X { int i, j, k = 42; };
X a[] = { 1, 2, 3, 4, 5, 6 };
X b[2] = { { 1, 2, 3 }, { 4, 5, 6 } };

8

9

a and b have the same value — end example ]
If a reference member is initialized from its brace-or-equal-initializer and a potentially-evaluated subex-
pression thereof is an aggregate initialization that would use that brace-or-equal-initializer, the program is
ill-formed. [ Example:

struct A;
extern A a;
struct A {

};
A a{a,a};

const A& a1 { A{a,a} };
const A& a2 { A{} };

// OK
// error

// OK

— end example ]
If an aggregate class C contains a subaggregate member m that has no members for purposes of aggregate
initialization, the initializer-clause for m shall not be omitted from an initializer-list for an object of type C
unless the initializer-clauses for all members of C following m are also omitted. [ Example:

struct S { } s;
struct A {

S s1;
int i1;

§ 8.5.1

215

c(cid:13) ISO/IEC

S s2;
int i2;
S s3;
int i3;

} a = {
{ },
0,
s,
0
};

// Required initialization

// Required initialization

// Initialization not required for A::s3 because A::i3 is also not initialized

N4296

10

— end example ]
If an incomplete or empty initializer-list leaves a member of reference type uninitialized, the program is
ill-formed.

11 When initializing a multi-dimensional array, the initializer-clauses initialize the elements with the last (right-

most) index of the array varying the fastest (8.3.4). [ Example:

int x[2][2] = { 3, 1, 4, 2 };

initializes x[0][0] to 3, x[0][1] to 1, x[1][0] to 4, and x[1][1] to 2. On the other hand,

float y[4][3] = {

{ 1 }, { 2 }, { 3 }, { 4 }

};

initializes the ﬁrst column of y (regarded as a two-dimensional array) and leaves the rest zero. — end
example ]

12 Braces can be elided in an initializer-list as follows.

If the initializer-list begins with a left brace, then
the succeeding comma-separated list of initializer-clauses initializes the members of a subaggregate; it is
erroneous for there to be more initializer-clauses than members. If, however, the initializer-list for a sub-
aggregate does not begin with a left brace, then only enough initializer-clauses from the list are taken to
initialize the members of the subaggregate; any remaining initializer-clauses are left to initialize the next
member of the aggregate of which the current subaggregate is a member. [ Example:

float y[4][3] = {

{ 1, 3, 5 },
{ 2, 4, 6 },
{ 3, 5, 7 },

};

is a completely-braced initialization: 1, 3, and 5 initialize the ﬁrst row of the array y[0], namely y[0][0],
y[0][1], and y[0][2]. Likewise the next two lines initialize y[1] and y[2]. The initializer ends early and
therefore y[3]s elements are initialized as if explicitly initialized with an expression of the form float(),
that is, are initialized with 0.0. In the following example, braces in the initializer-list are elided; however
the initializer-list has the same eﬀect as the completely-braced initializer-list of the above example,

float y[4][3] = {

1, 3, 5, 2, 4, 6, 3, 5, 7

};

The initializer for y begins with a left brace, but the one for y[0] does not, therefore three elements from
the list are used. Likewise the next three are taken successively for y[1] and y[2]. — end example ]

13 All implicit type conversions (Clause 4) are considered when initializing the aggregate member with an
If the assignment-expression can initialize a member, the member is initialized.

assignment-expression.

§ 8.5.1

216

c(cid:13) ISO/IEC

N4296

Otherwise, if the member is itself a subaggregate, brace elision is assumed and the assignment-expression
is considered for the initialization of the ﬁrst member of the subaggregate.
[ Note: As speciﬁed above,
brace elision cannot apply to subaggregates with no members for purposes of aggregate initialization; an
initializer-clause for the entire subobject is required. — end note ]
[ Example:

struct A {

int i;
operator int();

};
struct B {
A a1, a2;
int z;

};
A a;
B b = { 4, a, a };

Braces are elided around the initializer-clause for b.a1.i. b.a1.i is initialized with 4, b.a2 is initialized
with a, b.z is initialized with whatever a.operator int() returns. — end example ]
[ Note: An aggregate array or an aggregate class may contain members of a class type with a user-provided
constructor (12.1). Initialization of these aggregate objects is described in 12.6.1. — end note ]
[ Note: Whether the initialization of aggregates with static storage duration is static or dynamic is speciﬁed
in 3.6.2 and 6.7. — end note ]

14

15

16 When a union is initialized with a brace-enclosed initializer, the braces shall only contain an initializer-clause

for the ﬁrst non-static data member of the union. [ Example:

union u { int a; const char* b; };
u a = { 1 };
u b = a;
u c = 1;
u d = { 0, "asdf" };
u e = { "asdf" };

// error
// error
// error

17

— end example ]
[ Note: As described above, the braces around the initializer-clause for a union member can be omitted if
the union is a member of another aggregate. — end note ]
8.5.2 Character arrays

[dcl.init.string]
1 An array of narrow character type (3.9.1), char16_t array, char32_t array, or wchar_t array can be ini-
tialized by a narrow string literal, char16_t string literal, char32_t string literal, or wide string literal,
respectively, or by an appropriately-typed string literal enclosed in braces (2.13.5). Successive characters of
the value of the string literal initialize the elements of the array. [ Example:

char msg[] = "Syntax error on line %s\n";

shows a character array whose members are initialized with a string-literal. Note that because ’\n’ is a
single character and because a trailing ’\0’ is appended, sizeof(msg) is 25. — end example ]

2 There shall not be more initializers than there are array elements. [ Example:

char cv[4] = "asdf";

// error

is ill-formed since there is no space for the implied trailing ’\0’. — end example ]

§ 8.5.2

217

c(cid:13) ISO/IEC

N4296

3

If there are fewer initializers than there are array elements, each element not explicitly initialized shall be
zero-initialized (8.5).
8.5.3 References

[dcl.init.ref]
1 A variable declared to be a T& or T&&, that is, “reference to type T” (8.3.2), shall be initialized by an object,

or function, of type T or by an object that can be converted into a T. [ Example:

int g(int);
void f() {

int i;
int& r = i;
r = 1;
int* p = &r;
int& rr = r;
int (&rg)(int) = g;
rg(i);
int a[3];
int (&ra)[3] = a;
ra[1] = i;

}

// r refers to i
// the value of i becomes 1
// p points to i
// rr refers to what r refers to, that is, to i
// rg refers to the function g
// calls function g

// ra refers to the array a
// modiﬁes a[1]

— end example ]

2 A reference cannot be changed to refer to another object after initialization. Note that initialization of a
reference is treated very diﬀerently from assignment to it. Argument passing (5.2.2) and function value
return (6.6.3) are initializations.

3 The initializer can be omitted for a reference only in a parameter declaration (8.3.5), in the declaration of
a function return type, in the declaration of a class member within its class deﬁnition (9.2), and where the
extern speciﬁer is explicitly used. [ Example:

int& r1;
extern int& r2;

— end example ]

// error: initializer missing
// OK

4 Given types “cv1 T1” and “cv2 T2,” “cv1 T1” is reference-related to “cv2 T2” if T1 is the same type as T2, or
T1 is a base class of T2. “cv1 T1” is reference-compatible with “cv2 T2” if T1 is reference-related to T2 and cv1
is the same cv-qualiﬁcation as, or greater cv-qualiﬁcation than, cv2. In all cases where the reference-related
or reference-compatible relationship of two types is used to establish the validity of a reference binding, and
T1 is a base class of T2, a program that necessitates such a binding is ill-formed if T1 is an inaccessible
(Clause 11) or ambiguous (10.2) base class of T2.

5 A reference to type “cv1 T1” is initialized by an expression of type “cv2 T2” as follows:

—

(5.1)
(5.1.1)

(5.1.2)

If the reference is an lvalue reference and the initializer expression
—
—

is an lvalue (but is not a bit-ﬁeld), and “cv1 T1” is reference-compatible with “cv2 T2,” or
has a class type (i.e., T2 is a class type), where T1 is not reference-related to T2, and can be
converted to an lvalue of type “cv3 T3,” where “cv1 T1” is reference-compatible with “cv3 T3”106
(this conversion is selected by enumerating the applicable conversion functions (13.3.1.6) and
choosing the best one through overload resolution (13.3)),

then the reference is bound to the initializer expression lvalue in the ﬁrst case and to the lvalue result
of the conversion in the second case (or, in either case, to the appropriate base class subobject of
the object).
[ Note: The usual lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer

106) This requires a conversion function (12.3.2) returning a reference type.

§ 8.5.3

218

c(cid:13) ISO/IEC

N4296

(4.3) standard conversions are not needed, and therefore are suppressed, when such direct bindings to
lvalues are done. — end note ]
[ Example:

double d = 2.0;
double& rd = d;
const double& rcd = d;

// rd refers to d
// rcd refers to d

struct A { };
struct B : A { operator int&(); } b;
A& ra = b;
const A& rca = b;
int& ir = B();
— end example ]
Otherwise, the reference shall be an lvalue reference to a non-volatile const type (i.e., cv1 shall be
const), or the reference shall be an rvalue reference. [ Example:

// ra refers to A subobject in b
// rca refers to A subobject in b
// ir refers to the result of B::operator int&

double& rd2 = 2.0;
int
double& rd3 = i;

i = 2;

// error: not an lvalue and reference not const

// error: type mismatch and reference not const

— end example ]
—

If the initializer expression
—

—

is an xvalue (but not a bit-ﬁeld), class prvalue, array prvalue or function lvalue and “cv1 T1”
is reference-compatible with “cv2 T2”, or
has a class type (i.e., T2 is a class type), where T1 is not reference-related to T2, and can be
converted to an xvalue, class prvalue, or function lvalue of type “cv3 T3”, where “cv1 T1” is
reference-compatible with “cv3 T3” (see 13.3.1.6),

then the reference is bound to the value of the initializer expression in the ﬁrst case and to
the result of the conversion in the second case (or, in either case, to an appropriate base class
subobject).
[ Example:

(5.2)

—

(5.2.1)

(5.2.1.1)

(5.2.1.2)

struct A { };
struct B : A { } b;
extern B f();
const A& rca2 = f();
A&& rra = f();
struct X {

operator B();
operator int&();

// bound to the A subobject of the B rvalue.
// same as above

} x;
const A& r = x;
int i2 = 42;
int&& rri = static_cast<int&&>(i2); // bound directly to i2
B&& rrb = x;
— end example ]
Otherwise:
—

// bound to the A subobject of the result of the conversion

// bound directly to the result of operator B

(5.2.2)

(5.2.2.1)

—

§ 8.5.3

If T1 or T2 is a class type and T1 is not reference-related to T2, user-deﬁned conversions
are considered using the rules for copy-initialization of an object of type “cv1 T1” by user-
deﬁned conversion (8.5, 13.3.1.4, 13.3.1.5); the program is ill-formed if the corresponding

219

c(cid:13) ISO/IEC

N4296

(5.2.2.2)

(5.2.2.3)
(5.2.2.4)

non-reference copy-initialization would be ill-formed. The result of the call to the conversion
function, as described for the non-reference copy-initialization, is then used to direct-initialize
the reference. For this direct-initialization, user-deﬁned conversions are not considered.
Otherwise, a temporary of type “cv1 T1” is created and copy-initialized (8.5) from the ini-
tializer expression. The reference is then bound to the temporary.

—

If T1 is reference-related to T2:
—
—
[ Example:

cv1 shall be the same cv-qualiﬁcation as, or greater cv-qualiﬁcation than, cv2; and
if the reference is an rvalue reference, the initializer expression shall not be an lvalue.

struct Banana { };
struct Enigma { operator const Banana(); };
struct Alaska { operator Banana&(); };
void enigmatic() {

typedef const Banana ConstBanana;
Banana &&banana1 = ConstBanana(); // ill-formed
// ill-formed
Banana &&banana2 = Enigma();
// ill-formed
Banana &&banana3 = Alaska();

}

const double& rcd2 = 2;
double&& rrd = 2;
const volatile int cvi = 1;
const int& r2 = cvi;
struct A { operator volatile int&(); } a;
const int& r3 = a;

// rcd2 refers to temporary with value 2.0
// rrd refers to temporary with value 2.0

// error: type qualiﬁers dropped

// error: type qualiﬁers dropped
// from result of conversion function

// error: initializer is lvalue of related type

// error: result of conversion function is lvalue of related type

// rrd3 refers to temporary with value 2.0

double d2 = 1.0;
double&& rrd2 = d2;
struct X { operator int&(); };
int&& rri2 = X();
int i3 = 2;
double&& rrd3 = i3;

— end example ]

6

In all cases except the last (i.e., creating and initializing a temporary from the initializer expression), the
reference is said to bind directly to the initializer expression.
[ Note: 12.2 describes the lifetime of temporaries bound to references. — end note ]
8.5.4 List-initialization

[dcl.init.list]
1 List-initialization is initialization of an object or reference from a braced-init-list. Such an initializer is
called an initializer list, and the comma-separated initializer-clauses of the list are called the elements of the
initializer list. An initializer list may be empty. List-initialization can occur in direct-initialization or copy-
initialization contexts; list-initialization in a direct-initialization context is called direct-list-initialization and
list-initialization in a copy-initialization context is called copy-list-initialization.
[ Note: List-initialization
can be used

(1.1)

(1.2)

(1.3)

—
—
—

as the initializer in a variable deﬁnition (8.5)
as the initializer in a new-expression (5.3.4)
in a return statement (6.6.3)

§ 8.5.4

220

c(cid:13) ISO/IEC

N4296

(1.4)

(1.5)

(1.6)

(1.7)

(1.8)

(1.9)

(1.10)

—
—
—
—
—
—
—

as a for-range-initializer (6.5)
as a function argument (5.2.2)
as a subscript (5.2.1)
as an argument to a constructor invocation (8.5, 5.2.3)
as an initializer for a non-static data member (9.2)
in a mem-initializer (12.6.2)
on the right-hand side of an assignment (5.18)

[ Example:

int a = {1};
std::complex<double> z{1,2};
new std::vector<std::string>{"once", "upon", "a", "time"}; // 4 string elements
f( {"Nicholas","Annemarie"} ); // pass list of two elements
// return list of one element
return { "Norah" };
// initialization to zero / null pointer
int* e {};
// explicitly construct a double
x = double{1};
std::map<std::string,int> anim = { {"bear",4}, {"cassowary",2}, {"tiger",7} };

— end example ] — end note ]

2 A constructor is an initializer-list constructor if its ﬁrst parameter is of type std::initializer_list<E>
or reference to possibly cv-qualiﬁed std::initializer_list<E> for some type E, and either there are
no other parameters or else all other parameters have default arguments (8.3.6).
Initializer-list
constructors are favored over other constructors in list-initialization (13.3.1.7). Passing an initializer list
as the argument to the constructor template template<class T> C(T) of a class C does not create an
initializer-list constructor, because an initializer list argument causes the corresponding parameter to be
a non-deduced context (14.8.2.1). — end note ] The template std::initializer_list is not predeﬁned;
if the header <initializer_list> is not included prior to a use of std::initializer_list — even an
implicit use in which the type is not named (7.1.6.4) — the program is ill-formed.

[ Note:

3 List-initialization of an object or reference of type T is deﬁned as follows:

(3.1)

(3.2)

(3.3)

—

—

—

If T is a class type and the initializer list has a single element of type cv U, where U is T or a class derived
from T, the object is initialized from that element (by copy-initialization for copy-list-initialization, or
by direct-initialization for direct-list-initialization).
Otherwise, if T is a character array and the initializer list has a single element that is an appropriately-
typed string literal (8.5.2), initialization is performed as described in that section.
Otherwise, if T is an aggregate, aggregate initialization is performed (8.5.1).
[ Example:

double ad[] = { 1, 2.0 };
int ai[] = { 1, 2.0 };

// OK
// error: narrowing

struct S2 {

int m1;
double m2, m3;

};
S2 s21 = { 1, 2, 3.0 };
S2 s22 { 1.0, 2, 3 };
S2 s23 { };

// OK
// error: narrowing
// OK: default to 0,0,0

§ 8.5.4

221

c(cid:13) ISO/IEC

N4296

(3.4)

(3.5)

(3.6)

—

—

—

— end example ]
Otherwise, if the initializer list has no elements and T is a class type with a default constructor, the
object is value-initialized.
Otherwise, if T is a specialization of std::initializer_list<E>, a prvalue initializer_list object
is constructed as described below and used to initialize the object according to the rules for initialization
of an object from a class of the same type (8.5).
Otherwise, if T is a class type, constructors are considered. The applicable constructors are enumerated
and the best one is chosen through overload resolution (13.3, 13.3.1.7). If a narrowing conversion (see
below) is required to convert any of the arguments, the program is ill-formed.
[ Example:

struct S {

S(std::initializer_list<double>); // #1
// #2
S(std::initializer_list<int>);
// #3
S();
// ...

};
S s1 = { 1.0, 2.0, 3.0 };
S s2 = { 1, 2, 3 };
S s3 = { };

// invoke #1
// invoke #2
// invoke #3

— end example ]
[ Example:

struct Map {

Map(std::initializer_list<std::pair<std::string,int>>);

};
Map ship = {{"Sophie",14}, {"Surprise",28}};

— end example ]
[ Example:

struct S {

// no initializer-list constructors
S(int, double, double);
S();
// ...

};
S s1 = { 1, 2, 3.0 };
S s2 { 1.0, 2, 3 };
S s3 { };

// #1
// #2

// OK: invoke #1
// error: narrowing
// OK: invoke #2

(3.7)

—

— end example ]
Otherwise, if the initializer list has a single element of type E and either T is not a reference type or
its referenced type is reference-related to E, the object or reference is initialized from that element (by
copy-initialization for copy-list-initialization, or by direct-initialization for direct-list-initialization); if
a narrowing conversion (see below) is required to convert the element to T, the program is ill-formed.
[ Example:

int x1 {2};
int x2 {2.0};

// OK
// error: narrowing

§ 8.5.4

222

c(cid:13) ISO/IEC

N4296

(3.8)

—

— end example ]
Otherwise, if T is a reference type, a prvalue temporary of the type referenced by T is copy-list-initialized
or direct-list-initialized, depending on the kind of initialization for the reference, and the reference is
bound to that temporary. [ Note: As usual, the binding will fail and the program is ill-formed if the
reference type is an lvalue reference to a non-const type. — end note ]
[ Example:

struct S {

S(std::initializer_list<double>); // #1
// #2
S(const std::string&);
// ...

};
const S& r1 = { 1, 2, 3.0 };
const S& r2 { "Spinach" };
S& r3 = { 1, 2, 3 };
const int& i1 = { 1 };
const int& i2 = { 1.1 };
const int (&iar)[2] = { 1, 2 };

// OK: invoke #1
// OK: invoke #2
// error: initializer is not an lvalue
// OK
// error: narrowing
// OK: iar is bound to temporary array

(3.9)

—

— end example ]
Otherwise, if the initializer list has no elements, the object is value-initialized.
[ Example:

int** pp {};

// initialized to null pointer

(3.10)

—

— end example ]
Otherwise, the program is ill-formed.
[ Example:

struct A { int i; int j; };
A a1 { 1, 2 };
A a2 { 1.2 };
struct B {

B(std::initializer_list<int>);

};
B b1 { 1, 2 };
B b2 { 1, 2.0 };
struct C {

C(int i, double j);

};
C c1 = { 1, 2.2 };
C c2 = { 1.1, 2 };

int j { 1 };
int k { };

— end example ]

// aggregate initialization
// error: narrowing

// creates initializer_list<int> and calls constructor
// error: narrowing

// calls constructor with arguments (1, 2.2)
// error: narrowing

// initialize to 1
// initialize to 0

4 Within the initializer-list of a braced-init-list, the initializer-clauses, including any that result from pack
expansions (14.5.3), are evaluated in the order in which they appear. That is, every value computation and
side eﬀect associated with a given initializer-clause is sequenced before every value computation and side
eﬀect associated with any initializer-clause that follows it in the comma-separated list of the initializer-list.

§ 8.5.4

223

c(cid:13) ISO/IEC

N4296

[ Note: This evaluation ordering holds regardless of the semantics of the initialization; for example, it applies
when the elements of the initializer-list are interpreted as arguments of a constructor call, even though
ordinarily there are no sequencing constraints on the arguments of a call. — end note ]

5 An object of type std::initializer_list<E> is constructed from an initializer list as if the implementation
allocated a temporary array of N elements of type const E, where N is the number of elements in the
initializer list. Each element of that array is copy-initialized with the corresponding element of the initializer
list, and the std::initializer_list<E> object is constructed to refer to that array. [ Note: A constructor
or conversion function selected for the copy shall be accessible (Clause 11) in the context of the initializer
list. — end note ] If a narrowing conversion is required to initialize any of the elements, the program is
ill-formed.[ Example:

X(std::initializer_list<double> v);

struct X {

};
X x{ 1,2,3 };

The initialization will be implemented in a way roughly equivalent to this:

const double __a[3] = {double{1}, double{2}, double{3}};
X x(std::initializer_list<double>(__a, __a+3));

assuming that the implementation can construct an initializer_list object with a pair of pointers. — end
example ]

6 The array has the same lifetime as any other temporary object (12.2), except that initializing an initializer_-

list object from the array extends the lifetime of the array exactly like binding a reference to a temporary.
[ Example:

typedef std::complex<double> cmplx;
std::vector<cmplx> v1 = { 1, 2, 3 };

void f() {

std::vector<cmplx> v2{ 1, 2, 3 };
std::initializer_list<int> i3 = { 1, 2, 3 };

struct A {

}

};

std::initializer_list<int> i4;
A() : i4{ 1, 2, 3 } {} // creates an A with a dangling reference

For v1 and v2, the initializer_list object is a parameter in a function call, so the array created for {
1, 2, 3 } has full-expression lifetime. For i3, the initializer_list object is a variable, so the array
persists for the lifetime of the variable. For i4, the initializer_list object is initialized in a constructor’s
ctor-initializer, so the array persists only until the constructor exits, and so any use of the elements of i4
after the constructor exits produces undeﬁned behavior. — end example ] [ Note: The implementation is free
to allocate the array in read-only memory if an explicit array with the same initializer could be so allocated.
— end note ]

7 A narrowing conversion is an implicit conversion

(7.1)

(7.2)

—
—

from a ﬂoating-point type to an integer type, or
from long double to double or float, or from double to float, except where the source is a constant
expression and the actual value after conversion is within the range of values that can be represented
(even if it cannot be represented exactly), or

§ 8.5.4

224

c(cid:13) ISO/IEC

N4296

(7.3)

(7.4)

—

—

from an integer type or unscoped enumeration type to a ﬂoating-point type, except where the source
is a constant expression and the actual value after conversion will ﬁt into the target type and will
produce the original value when converted back to the original type, or
from an integer type or unscoped enumeration type to an integer type that cannot represent all the
values of the original type, except where the source is a constant expression whose value after integral
promotions will ﬁt into the target type.

// x is not a constant expression

[ Note: As indicated above, such conversions are not allowed at the top level in list-initializations. — end
note ] [ Example:
int x = 999;
const int y = 999;
const int z = 99;
// OK, though it might narrow (in this case, it does narrow)
char c1 = x;
// error: might narrow
char c2{x};
// error: narrows (assuming char is 8 bits)
char c3{y};
// OK: no narrowing needed
char c4{z};
unsigned char uc1 = {5}; // OK: no narrowing needed
unsigned char uc2 = {-1}; // error: narrows
unsigned int ui1 = {-1}; // error: narrows
signed int si1 =

{ (unsigned int)-1 };

int ii = {2.0};
float f1 { x };
float f2 { 7 };
int f(int);
int a[] =

// error: narrows
// error: narrows
// error: might narrow
// OK: 7 can be exactly represented as a ﬂoat

{ 2, f(2), f(2.0) };

// OK: the double-to-int conversion is not at the top level

— end example ]

§ 8.5.4

225

c(cid:13) ISO/IEC

9 Classes

N4296

[class]

1 A class is a type. Its name becomes a class-name (9.1) within its scope.

class-name:

identiﬁer
simple-template-id

Class-speciﬁers and elaborated-type-speciﬁers (7.1.6.3) are used to make class-names. An object of a class
consists of a (possibly empty) sequence of members and base class objects.

class-speciﬁer:

class-head { member-speciﬁcationopt}

class-head:

class-key attribute-speciﬁer-seqopt class-head-name class-virt-speciﬁeropt base-clauseopt
class-key attribute-speciﬁer-seqopt base-clauseopt

class-head-name:

nested-name-speciﬁeropt class-name

class-virt-speciﬁer:

class-key:

final

class
struct
union

A class-speciﬁer whose class-head omits the class-head-name deﬁnes an unnamed class. [ Note: An unnamed
class thus can’t be final. — end note ]

2 A class-name is inserted into the scope in which it is declared immediately after the class-name is seen.
The class-name is also inserted into the scope of the class itself; this is known as the injected-class-name.
For purposes of access checking, the injected-class-name is treated as if it were a public member name. A
class-speciﬁer is commonly referred to as a class deﬁnition. A class is considered deﬁned after the closing
brace of its class-speciﬁer has been seen even though its member functions are in general not yet deﬁned.
The optional attribute-speciﬁer-seq appertains to the class; the attributes in the attribute-speciﬁer-seq are
thereafter considered attributes of the class whenever it is named.
If a class is marked with the class-virt-speciﬁer final and it appears as a base-type-speciﬁer in a base-clause
(Clause 10), the program is ill-formed. Whenever a class-key is followed by a class-head-name, the identiﬁer
final, and a colon or left brace, final is interpreted as a class-virt-speciﬁer. [ Example:

3

struct A;
struct A final {};

// OK: deﬁnition of struct A,
// not value-initialization of variable final

struct X {
struct C { constexpr operator int() { return 5; } };
struct B final : C{}; // OK: deﬁnition of nested class B,

// not declaration of a bit-ﬁeld member final

};

— end example ]

4 Complete objects and member subobjects of class type shall have nonzero size.107 [ Note: Class objects can

107) Base class subobjects are not so constrained.

Classes

226

c(cid:13) ISO/IEC

N4296

be assigned, passed as arguments to functions, and returned by functions (except objects of classes for which
copying or moving has been restricted; see 12.8). Other plausible operators, such as equality comparison,
can be deﬁned by the user; see 13.5. — end note ]

5 A union is a class deﬁned with the class-key union; it holds at most one data member at a time (9.5). [ Note:

Aggregates of class type are described in 8.5.1. — end note ]

6 A trivially copyable class is a class that:

(6.1)

(6.2)

(6.3)

(6.4)

(6.5)

—
—
—
—
—

has no non-trivial copy constructors (12.8),
has no non-trivial move constructors (12.8),
has no non-trivial copy assignment operators (13.5.3, 12.8),
has no non-trivial move assignment operators (13.5.3, 12.8), and
has a trivial destructor (12.4).

A trivial class is a class that has a default constructor (12.1), has no non-trivial default constructors, and is
trivially copyable. [ Note: In particular, a trivially copyable or trivial class does not have virtual functions
or virtual base classes. — end note ]

7 A class S is a standard-layout class if it:

(7.1)

(7.2)

(7.3)

(7.4)

(7.5)

(7.6)

(7.7)

(7.8)

(7.9)

(7.10)

—
—
—
—
—
—

—

has no non-static data members of type non-standard-layout class (or array of such types) or reference,
has no virtual functions (10.3) and no virtual base classes (10.1),
has the same access control (Clause 11) for all non-static data members,
has no non-standard-layout base classes,
has at most one base class subobject of any given type,
has all non-static data members and bit-ﬁelds in the class and its base classes ﬁrst declared in the
same class, and
has no element of the set M(S) of types (deﬁned below) as a base class.108

M(X) is deﬁned as follows:

—

—

—

If X is a non-union class type, the set M(X) is empty if X has no (possibly inherited (Clause 10))
non-static data members; otherwise, it consists of the type of the ﬁrst non-static data member of X
(where said member may be an anonymous union), X0, and the elements of M(X0).
If X is a union type, the set M(X) is the union of all M(Ui) and the set containing all Ui, where each
Ui is the type of the ith non-static data member of X.
If X is a non-class type, the set M(X) is empty.

[ Note: M(X) is the set of the types of all non-base-class subobjects that are guaranteed in a standard-layout
class to be at a zero oﬀset in X. — end note ]
[ Example:
108) This ensures that two subobjects that have the same class type and that belong to the same most derived object are not
allocated at the same address (5.10).

Classes

227

c(cid:13) ISO/IEC

N4296

struct B { int i; };
struct C : B { };
struct D : C { };
struct E : D { char : 4; }; // not a standard-layout class

// standard-layout class
// standard-layout class
// standard-layout class

struct Q {};
struct S : Q { };
struct T : Q { };
struct U : S, T { };

— end example ]

// not a standard-layout class

8 A standard-layout struct is a standard-layout class deﬁned with the class-key struct or the class-key class.

A standard-layout union is a standard-layout class deﬁned with the class-key union.
[ Note: Standard-layout classes are useful for communicating with code written in other programming lan-
guages. Their layout is speciﬁed in 9.2. — end note ]

9

10 A POD struct109 is a non-union class that is both a trivial class and a standard-layout class, and has no
non-static data members of type non-POD struct, non-POD union (or array of such types). Similarly, a
POD union is a union that is both a trivial class and a standard-layout class, and has no non-static data
members of type non-POD struct, non-POD union (or array of such types). A POD class is a class that is
either a POD struct or a POD union.
[ Example:

// neither trivial nor standard-layout

// trivial but not standard-layout

// standard-layout but not trivial

// both trivial and standard-layout

struct N {

int i;
int j;
virtual ~N();

};

struct T {

int i;
private:
int j;

};

struct SL {

int i;
int j;
~SL();

};

};

struct POD {

int i;
int j;

11

— end example ]
If a class-head-name contains a nested-name-speciﬁer, the class-speciﬁer shall refer to a class that was
previously declared directly in the class or namespace to which the nested-name-speciﬁer refers, or in an
element of the inline namespace set (7.3.1) of that namespace (i.e., not merely inherited or introduced by
a using-declaration), and the class-speciﬁer shall appear in a namespace enclosing the previous declaration.
109) The acronym POD stands for “plain old data”.

Classes

228

c(cid:13) ISO/IEC

N4296

In such cases, the nested-name-speciﬁer of the class-head-name of the deﬁnition shall not begin with a
decltype-speciﬁer.
9.1 Class names

[class.name]

1 A class deﬁnition introduces a new type. [ Example:

struct X { int a; };
struct Y { int a; };
X a1;
Y a2;
int a3;

declares three variables of three diﬀerent types. This implies that

a1 = a2;
a1 = a3;

// error: Y assigned to X
// error: int assigned to X

are type mismatches, and that

int f(X);
int f(Y);

declare an overloaded (Clause 13) function f() and not simply a single function f() twice. For the same
reason,

struct S { int a; };
struct S { int a; };

// error, double deﬁnition

is ill-formed because it deﬁnes S twice. — end example ]

2 A class declaration introduces the class name into the scope where it is declared and hides any class, variable,
function, or other declaration of that name in an enclosing scope (3.3). If a class name is declared in a scope
where a variable, function, or enumerator of the same name is also declared, then when both declarations
are in scope, the class can be referred to only using an elaborated-type-speciﬁer (3.4.4). [ Example:

struct stat {

// ...

};

stat gstat;

// use plain stat to
// deﬁne variable

int stat(struct stat*);

// redeclare stat as function

void f() {

struct stat* ps;

stat(ps);

}

// struct preﬁx needed
// to name struct stat
// call stat()

— end example ] A declaration consisting solely of class-key identiﬁer; is either a redeclaration of the name
in the current scope or a forward declaration of the identiﬁer as a class name. It introduces the class name
into the current scope. [ Example:

struct s { int a; };

void g() {
struct s;

§ 9.1

// hide global struct s

229

c(cid:13) ISO/IEC

N4296

s* p;
struct s { char* p; };
struct s;

}

// with a block-scope declaration
// refer to local struct s
// deﬁne local struct s
// redeclaration, has no eﬀect

— end example ] [ Note: Such declarations allow deﬁnition of classes that refer to each other. [ Example:

class Vector;

class Matrix {

// ...
friend Vector operator*(const Matrix&, const Vector&);

class Vector {

// ...
friend Vector operator*(const Matrix&, const Vector&);

};

};

}

3

Declaration of friends is described in 11.3, operator functions in 13.5. — end example ] — end note ]
[ Note: An elaborated-type-speciﬁer (7.1.6.3) can also be used as a type-speciﬁer as part of a declaration. It
diﬀers from a class declaration in that if a class of the elaborated name is in scope the elaborated name will
refer to it. — end note ] [ Example:

struct s { int a; };

void g(int s) {

struct s* p = new struct s;
p->a = s;

// global s
// parameter s

4

— end example ]
[ Note: The declaration of a class name takes eﬀect immediately after the identiﬁer is seen in the class
deﬁnition or elaborated-type-speciﬁer. For example,

class A * A;

ﬁrst speciﬁes A to be the name of a class and then redeﬁnes it as the name of a pointer to an object of that
class. This means that the elaborated form class A must be used to refer to the class. Such artistry with
names can be confusing and is best avoided. — end note ]

5 A typedef-name (7.1.3) that names a class type, or a cv-qualiﬁed version thereof, is also a class-name. If a
typedef-name that names a cv-qualiﬁed class type is used where a class-name is required, the cv-qualiﬁers
are ignored. A typedef-name shall not be used as the identiﬁer in a class-head.
9.2 Class members
member-speciﬁcation:

[class.mem]

member-declaration member-speciﬁcationopt
access-speciﬁer : member-speciﬁcationopt

§ 9.2

230

c(cid:13) ISO/IEC

N4296

member-declaration:

attribute-speciﬁer-seqopt decl-speciﬁer-seqopt member-declarator-listopt;
function-deﬁnition
using-declaration
static_assert-declaration
template-declaration
alias-declaration
empty-declaration
member-declarator-list:

member-declarator
member-declarator-list , member-declarator

member-declarator:

declarator virt-speciﬁer-seqopt pure-speciﬁeropt
declarator brace-or-equal-initializeropt
identiﬁeropt attribute-speciﬁer-seqopt: constant-expression

virt-speciﬁer-seq:

virt-speciﬁer
virt-speciﬁer-seq virt-speciﬁer

virt-speciﬁer:

override
final

pure-speciﬁer:

= 0

1 The member-speciﬁcation in a class deﬁnition declares the full set of members of the class; no member can
be added elsewhere. Members of a class are data members, member functions (9.3), nested types, and
enumerators. Data members and member functions are static or non-static; see 9.4. Nested types are
classes (9.1, 9.7) and enumerations (7.2) deﬁned in the class, and arbitrary types declared as members by
use of a typedef declaration (7.1.3). The enumerators of an unscoped enumeration (7.2) deﬁned in the class
are members of the class. Except when used to declare friends (11.3), to declare an unnamed bit-ﬁeld (9.6),
or to introduce the name of a member of a base class into a derived class (7.3.3), or when the declaration is
an empty-declaration, member-declarations declare members of the class, and each such member-declaration
shall declare at least one member name of the class. A member shall not be declared twice in the member-
speciﬁcation, except that a nested class or member class template can be declared and then later deﬁned,
and except that an enumeration can be introduced with an opaque-enum-declaration and later redeclared
with an enum-speciﬁer.

2 A class is considered a completely-deﬁned object type (3.9) (or complete type) at the closing } of the class-
speciﬁer. Within the class member-speciﬁcation, the class is regarded as complete within function bodies,
default arguments, using-declarations introducing inheriting constructors (12.9), exception-speciﬁcations, and
brace-or-equal-initializers for non-static data members (including such things in nested classes). Otherwise
it is regarded as incomplete within its own class member-speciﬁcation.
[ Note: A single name can denote several function members provided their types are suﬃciently diﬀerent
(Clause 13). — end note ]

3

4 A brace-or-equal-initializer shall appear only in the declaration of a data member. (For static data members,
see 9.4.2; for non-static data members, see 12.6.2). A brace-or-equal-initializer for a non-static data member
shall not directly or indirectly cause the implicit deﬁnition of a defaulted default constructor for the enclosing
class or the exception speciﬁcation of that constructor.

5 A member shall not be declared with the extern or register storage-class-speciﬁer. Within a class deﬁnition,

a member shall not be declared with the thread_local storage-class-speciﬁer unless also declared static.

6 The decl-speciﬁer-seq may be omitted in constructor, destructor, and conversion function declarations only;
when declaring another kind of member the decl-speciﬁer-seq shall contain a type-speciﬁer that is not a cv-

§ 9.2

231

c(cid:13) ISO/IEC

N4296

qualiﬁer. The member-declarator-list can be omitted only after a class-speciﬁer or an enum-speciﬁer or in a
friend declaration (11.3). A pure-speciﬁer shall be used only in the declaration of a virtual function (10.3).
7 The optional attribute-speciﬁer-seq in a member-declaration appertains to each of the entities declared by

the member-declarators; it shall not appear if the optional member-declarator-list is omitted.

8 A virt-speciﬁer-seq shall contain at most one of each virt-speciﬁer. A virt-speciﬁer-seq shall appear only in

the declaration of a virtual member function (10.3).

9 Non-static (9.4) data members shall not have incomplete types. In particular, a class C shall not contain

a non-static member of class C, but it can contain a pointer or reference to an object of class C.
[ Note: See 5.1 for restrictions on the use of non-static data members and non-static member functions.
— end note ]
[ Note: The type of a non-static member function is an ordinary function type, and the type of a non-static
data member is an ordinary object type. There are no special member function types or data member types.
— end note ]
[ Example: A simple example of a class deﬁnition is

10

11

12

struct tnode {

char tword[20];
int count;
tnode* left;
tnode* right;

};

which contains an array of twenty characters, an integer, and two pointers to objects of the same type. Once
this deﬁnition has been given, the declaration

tnode s, *sp;

declares s to be a tnode and sp to be a pointer to a tnode. With these declarations, sp->count refers to
the count member of the object to which sp points; s.left refers to the left subtree pointer of the object
s; and s.right->tword[0] refers to the initial character of the tword member of the right subtree of s.
— end example ]

13 Nonstatic data members of a (non-union) class with the same access control (Clause 11) are allocated so
that later members have higher addresses within a class object. The order of allocation of non-static data
members with diﬀerent access control is unspeciﬁed (Clause 11). Implementation alignment requirements
might cause two adjacent members not to be allocated immediately after each other; so might requirements
for space for managing virtual functions (10.3) and virtual base classes (10.1).
If T is the name of a class, then each of the following shall have a name diﬀerent from T:

14

(14.1)

(14.2)

(14.3)

(14.4)

(14.5)

(14.6)

15

—
—

—
—
—
—

every static data member of class T;
every member function of class T [ Note: This restriction does not apply to constructors, which do not
have names (12.1) — end note ];
every member of class T that is itself a type;
every member template of class T;
every enumerator of every member of class T that is an unscoped enumerated type; and
every member of every anonymous union that is a member of class T.

In addition, if class T has a user-declared constructor (12.1), every non-static data member of class T shall
have a name diﬀerent from T.

§ 9.2

232

c(cid:13) ISO/IEC

N4296

16 The common initial sequence of two standard-layout struct (Clause 9) types is the longest sequence of non-
static data members and bit-ﬁelds in declaration order, starting with the ﬁrst such entity in each of the
structs, such that corresponding entities have layout-compatible types and either neither entity is a bit-ﬁeld
or both are bit-ﬁelds with the same width. [ Example:

struct A { int a; char b; };
struct B { const int b1; volatile char b2; };
struct C { int c; unsigned : 0; char b; };
struct D { int d; char b : 4; };
struct E { unsigned int e; char b; };

The common initial sequence of A and B comprises all members of either class. The common initial sequence
of A and C and of A and D comprises the ﬁrst member in each case. The common initial sequence of A and
E is empty. — end example ]

17 Two standard-layout struct (Clause 9) types are layout-compatible if their common initial sequence comprises

all members and bit-ﬁelds of both classes (3.9).

19

20

18 Two standard-layout unions are layout-compatible if they have the same number of non-static data members

and corresponding non-static data members (in any order) have layout-compatible types (3.9).
In a standard-layout union with an active member (9.5) of struct type T1, it is permitted to read a non-static
data member m of another union member of struct type T2 provided m is part of the common initial sequence
of T1 and T2.
[ Note: Reading a volatile object through a non-volatile glvalue has undeﬁned behavior
(7.1.6.1). — end note ]
If a standard-layout class object has any non-static data members, its address is the same as the address
of its ﬁrst non-static data member. Otherwise, its address is the same as the address of its ﬁrst base class
subobject (if any).
[ Note: There might therefore be unnamed padding within a standard-layout struct
object, but not at its beginning, as necessary to achieve appropriate alignment. — end note ]
9.3 Member functions

[class.mfct]
1 Functions declared in the deﬁnition of a class, excluding those declared with a friend speciﬁer (11.3), are
called member functions of that class. A member function may be declared static in which case it is a static
member function of its class (9.4); otherwise it is a non-static member function of its class (9.3.1, 9.3.2).

2 A member function may be deﬁned (8.4) in its class deﬁnition, in which case it is an inline member func-
tion (7.1.2), or it may be deﬁned outside of its class deﬁnition if it has already been declared but not deﬁned
in its class deﬁnition. A member function deﬁnition that appears outside of the class deﬁnition shall appear
in a namespace scope enclosing the class deﬁnition. Except for member function deﬁnitions that appear
outside of a class deﬁnition, and except for explicit specializations of member functions of class templates
and member function templates (14.7) appearing outside of the class deﬁnition, a member function shall not
be redeclared.

3 An inline member function (whether static or non-static) may also be deﬁned outside of its class deﬁnition
provided either its declaration in the class deﬁnition or its deﬁnition outside of the class deﬁnition declares
the function as inline.
[ Note: Member functions of a class in namespace scope have the linkage of that
class. Member functions of a local class (9.8) have no linkage. See 3.5. — end note ]

5

4 There shall be at most one deﬁnition of a non-inline member function in a program; no diagnostic is required.

There may be more than one inline member function deﬁnition in a program. See 3.2 and 7.1.2.
If the deﬁnition of a member function is lexically outside its class deﬁnition, the member function name
shall be qualiﬁed by its class name using the :: operator.
[ Note: A name used in a member function
deﬁnition (that is, in the parameter-declaration-clause including the default arguments (8.3.6) or in the
member function body) is looked up as described in 3.4. — end note ] [ Example:

struct X {

§ 9.3

233

c(cid:13) ISO/IEC

typedef int T;
static T count;
void f(T);

};
void X::f(T t = count) { }

N4296

The member function f of class X is deﬁned in global scope; the notation X::f speciﬁes that the function f
is a member of class X and in the scope of class X. In the function deﬁnition, the parameter type T refers to
the typedef member T declared in class X and the default argument count refers to the static data member
count declared in class X. — end example ]

6 A static local variable in a member function always refers to the same object, whether or not the member

function is inline.

7 Previously declared member functions may be mentioned in friend declarations.
8 Member functions of a local class shall be deﬁned inline in their class deﬁnition, if they are deﬁned at all.
[ Note: A member function can be declared (but not deﬁned) using a typedef for a function type. The
9
resulting member function has exactly the same type as it would have if the function declarator were
provided explicitly, see 8.3.5. For example,

typedef void fv(void);
typedef void fvc(void) const;
struct S {

fv memfunc1;
void memfunc2();
fvc memfunc3;

};
fv
S::* pmfv1 = &S::memfunc1;
fv
S::* pmfv2 = &S::memfunc2;
fvc S::* pmfv3 = &S::memfunc3;

// equivalent to: void memfunc1(void);

// equivalent to: void memfunc3(void) const;

Also see 14.3. — end note ]
9.3.1 Nonstatic member functions

[class.mfct.non-static]
1 A non-static member function may be called for an object of its class type, or for an object of a class derived
(Clause 10) from its class type, using the class member access syntax (5.2.5, 13.3.1.1). A non-static member
function may also be called directly using the function call syntax (5.2.2, 13.3.1.1) from within the body of
a member function of its class or of a class derived from its class.
If a non-static member function of a class X is called for an object that is not of type X, or of a type derived
from X, the behavior is undeﬁned.

2

3 When an id-expression (5.1) that is not part of a class member access syntax (5.2.5) and not used to form
a pointer to member (5.3.1) is used in a member of class X in a context where this can be used (5.1.1),
if name lookup (3.4) resolves the name in the id-expression to a non-static non-type member of some class
C, and if either the id-expression is potentially evaluated or C is X or a base class of X, the id-expression is
transformed into a class member access expression (5.2.5) using (*this) (9.3.2) as the postﬁx-expression to
the left of the . operator. [ Note: If C is not X or a base class of X, the class member access expression is
ill-formed. — end note ] Similarly during name lookup, when an unqualiﬁed-id (5.1) used in the deﬁnition of
a member function for class X resolves to a static member, an enumerator or a nested type of class X or of a
base class of X, the unqualiﬁed-id is transformed into a qualiﬁed-id (5.1) in which the nested-name-speciﬁer
names the class of the member function. [ Example:

struct tnode {

char tword[20];

§ 9.3.1

234

c(cid:13) ISO/IEC

N4296

int count;
tnode* left;
tnode* right;
void set(const char*, tnode* l, tnode* r);

};

void tnode::set(const char* w, tnode* l, tnode* r) {

count = strlen(w)+1;
if (sizeof(tword)<=count)

perror("tnode string too long");

strcpy(tword,w);
left = l;
right = r;

}

}

void f(tnode n1, tnode n2) {

n1.set("abc",&n2,0);
n2.set("def",0,0);

In the body of the member function tnode::set, the member names tword, count, left, and right refer to
members of the object for which the function is called. Thus, in the call n1.set("abc",&n2,0), tword refers
to n1.tword, and in the call n2.set("def",0,0), it refers to n2.tword. The functions strlen, perror,
and strcpy are not members of the class tnode and should be declared elsewhere.110 — end example ]

4 A non-static member function may be declared const, volatile, or const volatile. These cv-qualiﬁers
aﬀect the type of the this pointer (9.3.2). They also aﬀect the function type (8.3.5) of the member function;
a member function declared const is a const member function, a member function declared volatile is
a volatile member function and a member function declared const volatile is a const volatile member
function. [ Example:

struct X {

void g() const;
void h() const volatile;

};

X::g is a const member function and X::h is a const volatile member function. — end example ]

5 A non-static member function may be declared with a ref-qualiﬁer (8.3.5); see 13.3.1.
6 A non-static member function may be declared virtual (10.3) or pure virtual (10.4).

1

[class.this]
9.3.2 The this pointer
In the body of a non-static (9.3) member function, the keyword this is a prvalue expression whose value
is the address of the object for which the function is called. The type of this in a member function of
a class X is X*. If the member function is declared const, the type of this is const X*, if the member
function is declared volatile, the type of this is volatile X*, and if the member function is declared
const volatile, the type of this is const volatile X*.
[ Note: thus in a const member function, the
object for which the function is called is accessed through a const access path. — end note ] [ Example:

struct s {

int a;
int f() const;
int g() { return a++; }

110) See, for example, <cstring> (21.8).

§ 9.3.2

235

c(cid:13) ISO/IEC

N4296

int h() const { return a++; } // error

};

int s::f() const { return a; }

The a++ in the body of s::h is ill-formed because it tries to modify (a part of) the object for which s::h()
is called. This is not allowed in a const member function because this is a pointer to const; that is, *this
has const type. — end example ]

2 Similarly, volatile semantics (7.1.6.1) apply in volatile member functions when accessing the object and

its non-static data members.

3 A cv-qualiﬁed member function can be called on an object-expression (5.2.5) only if the object-expression is

as cv-qualiﬁed or less-cv-qualiﬁed than the member function. [ Example:

void k(s& x, const s& y) {

x.f();
x.g();
y.f();
y.g();

}

// error

The call y.g() is ill-formed because y is const and s::g() is a non-const member function, that is, s::g()
is less-qualiﬁed than the object-expression y. — end example ]

4 Constructors (12.1) and destructors (12.4) shall not be declared const, volatile or const volatile. [ Note:
However, these functions can be invoked to create and destroy objects with cv-qualiﬁed types, see (12.1)
and (12.4). — end note ]
9.4 Static members

[class.static]
1 A data or function member of a class may be declared static in a class deﬁnition, in which case it is a

static member of the class.

2 A static member s of class X may be referred to using the qualiﬁed-id expression X::s; it is not necessary to
use the class member access syntax (5.2.5) to refer to a static member. A static member may be referred
to using the class member access syntax, in which case the object expression is evaluated. [ Example:

struct process {

static void reschedule();

};
process& g();

void f() {

process::reschedule();
g().reschedule();

}

// OK: no object necessary
// g() is called

— end example ]

3 A static member may be referred to directly in the scope of its class or in the scope of a class derived
(Clause 10) from its class; in this case, the static member is referred to as if a qualiﬁed-id expression was
used, with the nested-name-speciﬁer of the qualiﬁed-id naming the class scope from which the static member
is referenced. [ Example:

int g();
struct X {

static int g();

};

§ 9.4

236

c(cid:13) ISO/IEC

struct Y : X {
static int i;

};
int Y::i = g();

// equivalent to Y::g();

N4296

4

— end example ]
If an unqualiﬁed-id (5.1) is used in the deﬁnition of a static member following the member’s declarator-id,
and name lookup (3.4.1) ﬁnds that the unqualiﬁed-id refers to a static member, enumerator, or nested
type of the member’s class (or of a base class of the member’s class), the unqualiﬁed-id is transformed into
a qualiﬁed-id expression in which the nested-name-speciﬁer names the class scope from which the member
is referenced. [ Note: See 5.1 for restrictions on the use of non-static data members and non-static member
functions. — end note ]

1

2

5 Static members obey the usual class member access rules (Clause 11). When used in the declaration of
a class member, the static speciﬁer shall only be used in the member declarations that appear within
the member-speciﬁcation of the class deﬁnition. [ Note: It cannot be speciﬁed in member declarations that
appear in namespace scope. — end note ]
9.4.1 Static member functions
[ Note: The rules described in 9.3 apply to static member functions. — end note ]
[ Note: A static member function does not have a this pointer (9.3.2). — end note ] A static member
function shall not be virtual. There shall not be a static and a non-static member function with the
same name and the same parameter types (13.1). A static member function shall not be declared const,
volatile, or const volatile.
9.4.2 Static data members

[class.static.data]
1 A static data member is not part of the subobjects of a class. If a static data member is declared thread_-
local there is one copy of the member per thread. If a static data member is not declared thread_local
there is one copy of the data member that is shared by all the objects of the class.

[class.static.mfct]

2 The declaration of a static data member in its class deﬁnition is not a deﬁnition and may be of an incomplete
type other than cv-qualiﬁed void. The deﬁnition for a static data member shall appear in a namespace
scope enclosing the member’s class deﬁnition. In the deﬁnition at namespace scope, the name of the static
data member shall be qualiﬁed by its class name using the :: operator. The initializer expression in the
deﬁnition of a static data member is in the scope of its class (3.3.7). [ Example:

class process {

static process* run_chain;
static process* running;

};

process* process::running = get_main();
process* process::run_chain = running;

The static data member run_chain of class process is deﬁned in global scope; the notation process::
run_chain speciﬁes that the member run_chain is a member of class process and in the scope of class
process. In the static data member deﬁnition, the initializer expression refers to the static data member
running of class process. — end example ]
[ Note: Once the static data member has been deﬁned, it exists even if no objects of its class have been
created. [ Example: in the example above, run_chain and running exist even if no objects of class process
are created by the program. — end example ] — end note ]

§ 9.4.2

237

c(cid:13) ISO/IEC

N4296

3

4

If a non-volatile const static data member is of integral or enumeration type, its declaration in the class
deﬁnition can specify a brace-or-equal-initializer in which every initializer-clause that is an assignment-
expression is a constant expression (5.20). A static data member of literal type can be declared in the
class deﬁnition with the constexpr speciﬁer; if so, its declaration shall specify a brace-or-equal-initializer
in which every initializer-clause that is an assignment-expression is a constant expression. [ Note: In both
these cases, the member may appear in constant expressions. — end note ] The member shall still be deﬁned
in a namespace scope if it is odr-used (3.2) in the program and the namespace scope deﬁnition shall not
contain an initializer.
[ Note: There shall be exactly one deﬁnition of a static data member that is odr-used (3.2) in a program;
no diagnostic is required. — end note ] Unnamed classes and classes contained directly or indirectly within
unnamed classes shall not contain static data members.

5 Static data members of a class in namespace scope have the linkage of that class (3.5). A local class shall

not have static data members.

6 Static data members are initialized and destroyed exactly like non-local variables (3.6.2, 3.6.3).
7 A static data member shall not be mutable (7.1.1).

1

9.5 Unions
[class.union]
In a union, at most one of the non-static data members can be active at any time, that is, the value of at
most one of the non-static data members can be stored in a union at any time. [ Note: One special guarantee
is made in order to simplify the use of unions: If a standard-layout union contains several standard-layout
structs that share a common initial sequence (9.2), and if an object of this standard-layout union type
contains one of the standard-layout structs, it is permitted to inspect the common initial sequence of any of
standard-layout struct members; see 9.2. — end note ] The size of a union is suﬃcient to contain the largest
of its non-static data members. Each non-static data member is allocated as if it were the sole member of a
struct. All non-static data members of a union object have the same address.

2 A union can have member functions (including constructors and destructors), but not virtual (10.3) functions.
A union shall not have base classes. A union shall not be used as a base class. If a union contains a non-
static data member of reference type the program is ill-formed.
[ Note: If any non-static data member
of a union has a non-trivial default constructor (12.1), copy constructor (12.8), move constructor (12.8),
copy assignment operator (12.8), move assignment operator (12.8), or destructor (12.4), the corresponding
member function of the union must be user-provided or it will be implicitly deleted (8.4.3) for the union.
— end note ]
[ Example: Consider the following union:

3

union U {
int i;
float f;
std::string s;

};

4

Since std::string (21.3) declares non-trivial versions of all of the special member functions, U will have
an implicitly deleted default constructor, copy/move constructor, copy/move assignment operator, and de-
structor. To use U, some or all of these member functions must be user-provided. — end example ]
[ Note: In general, one must use explicit destructor calls and placement new operators to change the active
member of a union. — end note ] [ Example: Consider an object u of a union type U having non-static data
members m of type M and n of type N. If M has a non-trivial destructor and N has a non-trivial constructor
(for instance, if they declare or inherit virtual functions), the active member of u can be safely switched
from m to n using the destructor and placement new operator as follows:

u.m.~M();

§ 9.5

238

c(cid:13) ISO/IEC

new (&u.n) N;
— end example ]

5 A union of the form

N4296

union { member-speciﬁcation } ;

is called an anonymous union; it deﬁnes an unnamed object of unnamed type. Each member-declaration
in the member-speciﬁcation of an anonymous union shall either deﬁne a non-static data member or be a
static_assert-declaration. [ Note: Nested types, anonymous unions, and functions cannot be declared within
an anonymous union. — end note ] The names of the members of an anonymous union shall be distinct
from the names of any other entity in the scope in which the anonymous union is declared. For the purpose
of name lookup, after the anonymous union deﬁnition, the members of the anonymous union are considered
to have been deﬁned in the scope in which the anonymous union is declared. [ Example:

void f() {

union { int a; const char* p; };
a = 1;
p = "Jennifer";

}

}

Here a and p are used like ordinary (nonmember) variables, but since they are union members they have
the same address. — end example ]

6 Anonymous unions declared in a named namespace or in the global namespace shall be declared static.
Anonymous unions declared at block scope shall be declared with any storage class allowed for a block-scope
variable, or with no storage class. A storage class is not allowed in a declaration of an anonymous union
in a class scope. An anonymous union shall not have private or protected members (Clause 11). An
anonymous union shall not have function members.

7 A union for which objects, pointers, or references are declared is not an anonymous union. [ Example:

void f() {

union { int aa; char* p; } obj, *ptr = &obj;
aa = 1;
ptr->aa = 1;

// error
// OK

The assignment to plain aa is ill-formed since the member name is not visible outside the union, and even
if it were visible, it is not associated with any particular object. — end example ] [ Note: Initialization of
unions with no user-declared constructors is described in (8.5.1). — end note ]

8 A union-like class is a union or a class that has an anonymous union as a direct member. A union-like class X
has a set of variant members. If X is a union, a non-static data member of X that is not an anonymous union
is a variant member of X. In addition, a non-static data member of an anonymous union that is a member of
X is also a variant member of X. At most one variant member of a union may have a brace-or-equal-initializer.
[ Example:

int x = 0;
union { };
union {
int z;
int y = 1; // error: initialization for second variant member of U

union U {

};

};

— end example ]

§ 9.5

239

c(cid:13) ISO/IEC

9.6 Bit-ﬁelds

1 A member-declarator of the form

N4296

[class.bit]

identiﬁeropt attribute-speciﬁer-seqopt: constant-expression

speciﬁes a bit-ﬁeld; its length is set oﬀ from the bit-ﬁeld name by a colon. The optional attribute-speciﬁer-
seq appertains to the entity being declared. The bit-ﬁeld attribute is not part of the type of the class
member. The constant-expression shall be an integral constant expression with a value greater than or equal
to zero. The value of the integral constant expression may be larger than the number of bits in the object
representation (3.9) of the bit-ﬁeld’s type; in such cases the extra bits are used as padding bits and do not
participate in the value representation (3.9) of the bit-ﬁeld. Allocation of bit-ﬁelds within a class object is
implementation-deﬁned. Alignment of bit-ﬁelds is implementation-deﬁned. Bit-ﬁelds are packed into some
addressable allocation unit. [ Note: Bit-ﬁelds straddle allocation units on some machines and not on others.
Bit-ﬁelds are assigned right-to-left on some machines, left-to-right on others. — end note ]

2 A declaration for a bit-ﬁeld that omits the identiﬁer declares an unnamed bit-ﬁeld. Unnamed bit-ﬁelds
are not members and cannot be initialized. [ Note: An unnamed bit-ﬁeld is useful for padding to conform
to externally-imposed layouts. — end note ] As a special case, an unnamed bit-ﬁeld with a width of zero
speciﬁes alignment of the next bit-ﬁeld at an allocation unit boundary. Only when declaring an unnamed
bit-ﬁeld may the value of the constant-expression be equal to zero.

3 A bit-ﬁeld shall not be a static member. A bit-ﬁeld shall have integral or enumeration type (3.9.1). A bool
value can successfully be stored in a bit-ﬁeld of any nonzero size. The address-of operator & shall not be
applied to a bit-ﬁeld, so there are no pointers to bit-ﬁelds. A non-const reference shall not be bound to a
bit-ﬁeld (8.5.3). [ Note: If the initializer for a reference of type const T& is an lvalue that refers to a bit-ﬁeld,
the reference is bound to a temporary initialized to hold the value of the bit-ﬁeld; the reference is not bound
to the bit-ﬁeld directly. See 8.5.3. — end note ]
If the value true or false is stored into a bit-ﬁeld of type bool of any size (including a one bit bit-ﬁeld),
the original bool value and the value of the bit-ﬁeld shall compare equal. If the value of an enumerator is
stored into a bit-ﬁeld of the same enumeration type and the number of bits in the bit-ﬁeld is large enough
to hold all the values of that enumeration type (7.2), the original enumerator value and the value of the
bit-ﬁeld shall compare equal. [ Example:

4

enum BOOL { FALSE=0, TRUE=1 };
struct A {
BOOL b:1;

};
A a;
void f() {

}

a.b = TRUE;
if (a.b == TRUE)

{ /∗ ... ∗/ }

// yields true

— end example ]
9.7 Nested class declarations

[class.nest]
1 A class can be declared within another class. A class declared within another is called a nested class. The
name of a nested class is local to its enclosing class. The nested class is in the scope of its enclosing class.
[ Note: See 5.1 for restrictions on the use of non-static data members and non-static member functions.
— end note ]
[ Example:
int x;

§ 9.7

240

c(cid:13) ISO/IEC

int y;

struct enclose {

int x;
static int s;

N4296

struct inner {

void f(int i) {

int a = sizeof(x);
x = i;
s = i;
::x = i;
y = i;

}
void g(enclose* p, int i) {

p->x = i;

}

};

};

inner* p = 0;

— end example ]

// OK: operand of sizeof is an unevaluated operand
// error: assign to enclose::x
// OK: assign to enclose::s
// OK: assign to global x
// OK: assign to global y

// OK: assign to enclose::x

// error: inner not in scope

2 Member functions and static data members of a nested class can be deﬁned in a namespace scope enclosing

the deﬁnition of their class. [ Example:

struct enclose {
struct inner {
static int x;
void f(int i);

};

};

int enclose::inner::x = 1;
void enclose::inner::f(int i) { /∗ ... ∗/ }

3

— end example ]
If class X is deﬁned in a namespace scope, a nested class Y may be declared in class X and later deﬁned in the
deﬁnition of class X or be later deﬁned in a namespace scope enclosing the deﬁnition of class X. [ Example:

class E {

class I1;
class I2;
class I1 { };

};
class E::I2 { };

// forward declaration of nested class

// deﬁnition of nested class

// deﬁnition of nested class

— end example ]

4 Like a member function, a friend function (11.3) deﬁned within a nested class is in the lexical scope of that
class; it obeys the same rules for name binding as a static member function of that class (9.4), but it has no
special access rights to members of an enclosing class.

§ 9.7

241

c(cid:13) ISO/IEC

N4296

9.8 Local class declarations

[class.local]
1 A class can be declared within a function deﬁnition; such a class is called a local class. The name of a local
class is local to its enclosing scope. The local class is in the scope of the enclosing scope, and has the same
access to names outside the function as does the enclosing function. Declarations in a local class shall not
odr-use (3.2) a variable with automatic storage duration from an enclosing scope. [ Example:

int x;
void f() {

static int s ;
int x;
const int N = 5;
extern int q();

struct local {

int g() { return x; }
int h() { return s; }
int k() { return ::x; }
int l() { return q(); }
int m() { return N; }
int* n() { return &N; }

};

}

// error: odr-use of automatic variable x
// OK
// OK
// OK
// OK: not an odr-use
// error: odr-use of automatic variable N

local* p = 0;

— end example ]

// error: local not in scope

2 An enclosing function has no special access to members of the local class; it obeys the usual access rules
(Clause 11). Member functions of a local class shall be deﬁned within their class deﬁnition, if they are
deﬁned at all.
If class X is a local class a nested class Y may be declared in class X and later deﬁned in the deﬁnition of
class X or be later deﬁned in the same scope as the deﬁnition of class X. A class nested within a local class
is a local class.

3

4 A local class shall not have static data members.

9.9 Nested type names

[class.nested.type]
1 Type names obey exactly the same scope rules as other names. In particular, type names deﬁned within a

class deﬁnition cannot be used outside their class without qualiﬁcation. [ Example:

struct X {

typedef int I;
class Y { /∗ ... ∗/ };
I a;

};

// error
// error
// OK
// OK

I b;
Y c;
X::Y d;
X::I e;

— end example ]

§ 9.9

242

c(cid:13) ISO/IEC

N4296

10 Derived classes

[class.derived]

1 A list of base classes can be speciﬁed in a class deﬁnition using the notation:

base-clause:

: base-speciﬁer-list

base-speciﬁer-list:

base-speciﬁer ...opt
base-speciﬁer-list , base-speciﬁer ...opt

base-speciﬁer:

attribute-speciﬁer-seqopt base-type-speciﬁer
attribute-speciﬁer-seqoptvirtual access-speciﬁeropt base-type-speciﬁer
attribute-speciﬁer-seqopt access-speciﬁer virtualopt base-type-speciﬁer

class-or-decltype:

nested-name-speciﬁeropt class-name
decltype-speciﬁer

base-type-speciﬁer:

class-or-decltype

access-speciﬁer:
private
protected
public

The optional attribute-speciﬁer-seq appertains to the base-speciﬁer.

2 The type denoted by a base-type-speciﬁer shall be a class type that is not an incompletely deﬁned class
(Clause 9); this class is called a direct base class for the class being deﬁned. During the lookup for a base
class name, non-type names are ignored (3.3.10). If the name found is not a class-name, the program is
ill-formed. A class B is a base class of a class D if it is a direct base class of D or a direct base class of one of
D’s base classes. A class is an indirect base class of another if it is a base class but not a direct base class.
A class is said to be (directly or indirectly) derived from its (direct or indirect) base classes.
[ Note: See
Clause 11 for the meaning of access-speciﬁer. — end note ] Unless redeclared in the derived class, members
of a base class are also considered to be members of the derived class. The base class members are said to
be inherited by the derived class. Inherited members can be referred to in expressions in the same manner
as other members of the derived class, unless their names are hidden or ambiguous (10.2). [ Note: The scope
resolution operator :: (5.1) can be used to refer to a direct or indirect base member explicitly. This allows
access to a name that has been redeclared in the derived class. A derived class can itself serve as a base class
subject to access control; see 11.2. A pointer to a derived class can be implicitly converted to a pointer to
an accessible unambiguous base class (4.10). An lvalue of a derived class type can be bound to a reference
to an accessible unambiguous base class (8.5.3). — end note ]

3 The base-speciﬁer-list speciﬁes the type of the base class subobjects contained in an object of the derived

class type. [ Example:

struct Base {
int a, b, c;

};

struct Derived : Base {

int b;

};

Derived classes

243

c(cid:13) ISO/IEC

N4296

struct Derived2 : Derived {

int c;

};

Here, an object of class Derived2 will have a subobject of class Derived which in turn will have a subobject
of class Base. — end example ]

4 A base-speciﬁer followed by an ellipsis is a pack expansion (14.5.3).
5 The order in which the base class subobjects are allocated in the most derived object (1.8) is unspeciﬁed.
[ Note: a derived class and its base class subobjects can be represented by a directed acyclic graph (DAG)
where an arrow means “directly derived from.” A DAG of subobjects is often referred to as a “subobject
lattice.”

Figure 2 — Directed acyclic graph

8

6 The arrows need not have a physical representation in memory. — end note ]
7

[ Note: Initialization of objects representing base classes can be speciﬁed in constructors; see 12.6.2. — end
note ]
[ Note: A base class subobject might have a layout (3.7) diﬀerent from the layout of a most derived object
of the same type. A base class subobject might have a polymorphic behavior (12.7) diﬀerent from the
polymorphic behavior of a most derived object of the same type. A base class subobject may be of zero size
(Clause 9); however, two subobjects that have the same class type and that belong to the same most derived
object must not be allocated at the same address (5.10). — end note ]
10.1 Multiple base classes

[class.mi]
1 A class can be derived from any number of base classes. [ Note: The use of more than one direct base class

is often called multiple inheritance. — end note ] [ Example:

class A { /∗ ... ∗/ };
class B { /∗ ... ∗/ };
class C { /∗ ... ∗/ };
class D : public A, public B, public C { /∗ ... ∗/ };
— end example ]
[ Note: The order of derivation is not signiﬁcant except as speciﬁed by the semantics of initialization by
constructor (12.6.2), cleanup (12.4), and storage layout (9.2, 11.1). — end note ]

2

3 A class shall not be speciﬁed as a direct base class of a derived class more than once.

[ Note: A class can
be an indirect base class more than once and can be a direct and an indirect base class. There are limited
things that can be done with such a class. The non-static data members and member functions of the direct
base class cannot be referred to in the scope of the derived class. However, the static members, enumerations
and types can be unambiguously referred to. — end note ] [ Example:

class X { /∗ ... ∗/ };

§ 10.1

244

BaseDerived1Derived2c(cid:13) ISO/IEC

N4296

class Y : public X, public X { /∗ ... ∗/ };
class L { public: int next; /∗ ... ∗/ };
class A : public L { /∗ ... ∗/ };
class B : public L { /∗ ... ∗/ };
class C : public A, public B { void f(); /∗ ... ∗/ };
class D : public A, public L { void f(); /∗ ... ∗/ };

// ill-formed

// well-formed
// well-formed

— end example ]

4 A base class speciﬁer that does not contain the keyword virtual, speciﬁes a non-virtual base class. A base
class speciﬁer that contains the keyword virtual, speciﬁes a virtual base class. For each distinct occurrence
of a non-virtual base class in the class lattice of the most derived class, the most derived object (1.8) shall
contain a corresponding distinct base class subobject of that type. For each distinct base class that is
speciﬁed virtual, the most derived object shall contain a single base class subobject of that type. [ Example:
for an object of class type C, each distinct occurrence of a (non-virtual) base class L in the class lattice of
C corresponds one-to-one with a distinct L subobject within the object of type C. Given the class C deﬁned
above, an object of class C will have two subobjects of class L as shown below.

Figure 3 — Non-virtual base

5

In such lattices, explicit qualiﬁcation can be used to specify which subobject is meant. The body of function
C::f could refer to the member next of each L subobject:
// well-formed

void C::f() { A::next = B::next; }

Without the A:: or B:: qualiﬁers, the deﬁnition of C::f above would be ill-formed because of ambigu-
ity (10.2).

6 For another example,

class V { /∗ ... ∗/ };
class A : virtual public V { /∗ ... ∗/ };
class B : virtual public V { /∗ ... ∗/ };
class C : public A, public B { /∗ ... ∗/ };

for an object c of class type C, a single subobject of type V is shared by every base subobject of c that has
a virtual base class of type V. Given the class C deﬁned above, an object of class C will have one subobject
of class V, as shown below.

7 A class can have both virtual and non-virtual base classes of a given type.

class B { /∗ ... ∗/ };
class X : virtual public B { /∗ ... ∗/ };
class Y : virtual public B { /∗ ... ∗/ };
class Z : public B { /∗ ... ∗/ };
class AA : public X, public Y, public Z { /∗ ... ∗/ };

§ 10.1

245

LLABCc(cid:13) ISO/IEC

N4296

Figure 4 — Virtual base

For an object of class AA, all virtual occurrences of base class B in the class lattice of AA correspond to a
single B subobject within the object of type AA, and every other occurrence of a (non-virtual) base class B
in the class lattice of AA corresponds one-to-one with a distinct B subobject within the object of type AA.
Given the class AA deﬁned above, class AA has two subobjects of class B: Z’s B and the virtual B shared by X
and Y, as shown below.

Figure 5 — Virtual and non-virtual base

— end example ]
10.2 Member name lookup

[class.member.lookup]
1 Member name lookup determines the meaning of a name (id-expression) in a class scope (3.3.7). Name
lookup can result in an ambiguity, in which case the program is ill-formed. For an id-expression, name
lookup begins in the class scope of this; for a qualiﬁed-id, name lookup begins in the scope of the nested-
name-speciﬁer. Name lookup takes place before access control (3.4, Clause 11).

2 The following steps deﬁne the result of name lookup for a member name f in a class scope C.
3 The lookup set for f in C, called S(f, C), consists of two component sets: the declaration set, a set of
members named f; and the subobject set, a set of subobjects where declarations of these members (possibly
including using-declarations) were found. In the declaration set, using-declarations are replaced by the set
of designated members that are not hidden or overridden by members of the derived class (7.3.3), and type
declarations (including injected-class-names) are replaced by the types they designate. S(f, C) is calculated
as follows:
If C contains a declaration of the name f, the declaration set contains every declaration of f declared in
C that satisﬁes the requirements of the language construct in which the lookup occurs.
[ Note: Looking
up a name in an elaborated-type-speciﬁer (3.4.4) or base-speciﬁer (Clause 10), for instance, ignores all non-
type declarations, while looking up a name in a nested-name-speciﬁer (3.4.3) ignores function, variable, and
enumerator declarations. As another example, looking up a name in a using-declaration (7.3.3) includes the
declaration of a class or enumeration that would ordinarily be hidden by another declaration of that name

4

§ 10.2

246

VABCBBAAXYZc(cid:13) ISO/IEC

N4296

in the same scope. — end note ] If the resulting declaration set is not empty, the subobject set contains C
itself, and calculation is complete.

5 Otherwise (i.e., C does not contain a declaration of f or the resulting declaration set is empty), S(f, C) is
initially empty. If C has base classes, calculate the lookup set for f in each direct base class subobject Bi,
and merge each such lookup set S(f, Bi) in turn into S(f, C).

6 The following steps deﬁne the result of merging lookup set S(f, Bi) into the intermediate S(f, C):

(6.1)

—

(6.2)

(6.3)

—

—

If each of the subobject members of S(f, Bi) is a base class subobject of at least one of the subobject
members of S(f, C), or if S(f, Bi) is empty, S(f, C) is unchanged and the merge is complete. Con-
versely, if each of the subobject members of S(f, C) is a base class subobject of at least one of the
subobject members of S(f, Bi), or if S(f, C) is empty, the new S(f, C) is a copy of S(f, Bi).
Otherwise, if the declaration sets of S(f, Bi) and S(f, C) diﬀer, the merge is ambiguous: the new
S(f, C) is a lookup set with an invalid declaration set and the union of the subobject sets. In subsequent
merges, an invalid declaration set is considered diﬀerent from any other.
Otherwise, the new S(f, C) is a lookup set with the shared set of declarations and the union of the
subobject sets.

7 The result of name lookup for f in C is the declaration set of S(f, C). If it is an invalid set, the program is

ill-formed. [ Example:

struct A { int x; };
struct B { float x; };
struct C: public A, public B { };
struct D: public virtual C { };
struct E: public virtual C { char x; }; // S(x,E) = { { E::x }, { E } }
struct F: public D, public E { };
int main() {

// S(x,A) = { { A::x }, { A } }
// S(x,B) = { { B::x }, { B } }
// S(x,C) = { invalid, { A in C, B in C } }
// S(x,D) = S(x,C)

// S(x,F) = S(x,E)

// OK, lookup ﬁnds E::x

F f;
f.x = 0;

}

8

S(x, F) is unambiguous because the A and B base subobjects of D are also base subobjects of E, so S(x, D)
is discarded in the ﬁrst merge step. — end example ]
If the name of an overloaded function is unambiguously found, overloading resolution (13.3) also takes
place before access control. Ambiguities can often be resolved by qualifying a name with its class name.
[ Example:

struct A {
int f();

};

struct B {
int f();

};

struct C : A, B {

int f() { return A::f() + B::f(); }

};

9

— end example ]
[ Note: A static member, a nested type or an enumerator deﬁned in a base class T can unambiguously be
found even if an object has more than one base class subobject of type T. Two base class subobjects share
the non-static member subobjects of their common virtual base classes. — end note ] [ Example:

§ 10.2

247

c(cid:13) ISO/IEC

N4296

struct V {

int v;

};
struct A {

int a;
static int
enum { e };

s;

};
struct B : A, virtual V { };
struct C : A, virtual V { };
struct D : B, C { };

void f(D* pd) {

pd->v++;
pd->s++;
int i = pd->e;
pd->a++;

}

// OK: only one v (virtual)
// OK: only one s (static)
// OK: only one e (enumerator)
// error, ambiguous: two as in D

10

— end example ]
[ Note: When virtual base classes are used, a hidden declaration can be reached along a path through the
subobject lattice that does not pass through the hiding declaration. This is not an ambiguity. The identical
use with non-virtual base classes is an ambiguity; in that case there is no unique instance of the name that
hides all the others. — end note ] [ Example:

struct V { int f();
struct W { int g();
struct B : virtual V, W {

int x; };
int y; };

int f();
int g();

int x;
int y;

};
struct C : virtual V, W { };

struct D : B, C { void glorp(); };

Figure 6 — Name lookup

11

[ Note: The names declared in V and the left-hand instance of W are hidden by those in B, but the names
declared in the right-hand instance of W are not hidden at all. — end note ]

void D::glorp() {

x++;
f();
y++;
g();

// OK: B::x hides V::x
// OK: B::f() hides V::f()
// error: B::y and C’s W::y
// error: B::g() and C’s W::g()

§ 10.2

248

WVWBCDc(cid:13) ISO/IEC

}

— end example ]

N4296

12 An explicit or implicit conversion from a pointer to or an expression designating an object of a derived class
to a pointer or reference to one of its base classes shall unambiguously refer to a unique object representing
the base class. [ Example:

struct V { };
struct A { };
struct B : A, virtual V { };
struct C : A, virtual V { };
struct D : B, C { };

void g() {

D d;
B* pb = &d;
A* pa = &d;
V* pv = &d;

}

// error, ambiguous: C’s A or B’s A?
// OK: only one V subobject

13

— end example ]
[ Note: Even if the result of name lookup is unambiguous, use of a name found in multiple subobjects might
still be ambiguous (4.11, 5.2.5, 11.2). — end note ] [ Example:

struct B1 {
void f();
static void f(int);
int i;

};
struct B2 {

void f(double);

};
struct I1: B1 { };
struct I2: B1 { };

struct D: I1, I2, B2 {

using B1::f;
using B2::f;
void g() {

f();
f(0);
f(0.0);
int B1::* mpB1 = &D::i;
int D::* mpD = &D::i;

// Ambiguous conversion of this
// Unambiguous (static)
// Unambiguous (only one B2)
// Unambiguous
// Ambiguous conversion

}
};

— end example ]
10.3 Virtual functions

[class.virtual]
1 Virtual functions support dynamic binding and object-oriented programming. A class that declares or

inherits a virtual function is called a polymorphic class.
If a virtual member function vf is declared in a class Base and in a class Derived, derived directly or indirectly
from Base, a member function vf with the same name, parameter-type-list (8.3.5), cv-qualiﬁcation, and ref-

2

§ 10.3

249

c(cid:13) ISO/IEC

N4296

qualiﬁer (or absence of same) as Base::vf is declared, then Derived::vf is also virtual (whether or not it is
so declared) and it overrides111 Base::vf. For convenience we say that any virtual function overrides itself.
A virtual member function C::vf of a class object S is a ﬁnal overrider unless the most derived class (1.8)
of which S is a base class subobject (if any) declares or inherits another member function that overrides vf.
In a derived class, if a virtual member function of a base class subobject has more than one ﬁnal overrider
the program is ill-formed. [ Example:

struct A {

virtual void f();

};
struct B : virtual A {

virtual void f();

};
struct C : B , virtual A {

using A::f;

};

void foo() {

C c;
c.f();
c.C::f();

}

// calls B::f, the ﬁnal overrider
// calls A::f because of the using-declaration

— end example ]
[ Example:

struct A { virtual void f(); };
struct B : A { };
struct C : A { void f(); };
struct D : B, C { }; // OK: A::f and C::f are the ﬁnal overriders

// for the B and C subobjects, respectively

— end example ]
[ Note: A virtual member function does not have to be visible to be overridden, for example,

3

struct B {

virtual void f();

};
struct D : B {
void f(int);

};
struct D2 : D {

void f();

};

4

the function f(int) in class D hides the virtual function f() in its base class B; D::f(int) is not a virtual
function. However, f() declared in class D2 has the same name and the same parameter list as B::f(), and
therefore is a virtual function that overrides the function B::f() even though B::f() is not visible in class
D2. — end note ]
If a virtual function f in some class B is marked with the virt-speciﬁer final and in a class D derived from
B a function D::f overrides B::f, the program is ill-formed. [ Example:
111) A function with the same name but a diﬀerent parameter list (Clause 13) as a virtual function is not necessarily virtual
and does not override. The use of the virtual speciﬁer in the declaration of an overriding function is legal but redundant (has
empty semantics). Access control (Clause 11) is not considered in determining overriding.

§ 10.3

250

c(cid:13) ISO/IEC

N4296

struct B {

};

virtual void f() const final;

struct D : B {

void f() const;

};

// error: D::f attempts to override final B::f

5

— end example ]
If a virtual function is marked with the virt-speciﬁer override and does not override a member function of
a base class, the program is ill-formed. [ Example:

struct B {

virtual void f(int);

struct D : B {

};

};

virtual void f(long) override; // error: wrong signature overriding B::f
virtual void f(int) override;

// OK

— end example ]

6 Even though destructors are not inherited, a destructor in a derived class overrides a base class destructor

declared virtual; see 12.4 and 12.5.

7 The return type of an overriding function shall be either identical to the return type of the overridden
function or covariant with the classes of the functions. If a function D::f overrides a function B::f, the
return types of the functions are covariant if they satisfy the following criteria:

(7.1)

(7.2)

(7.3)

8

—

—

—

both are pointers to classes, both are lvalue references to classes, or both are rvalue references to
classes112
the class in the return type of B::f is the same class as the class in the return type of D::f, or is an
unambiguous and accessible direct or indirect base class of the class in the return type of D::f
both pointers or references have the same cv-qualiﬁcation and the class type in the return type of D::f
has the same cv-qualiﬁcation as or less cv-qualiﬁcation than the class type in the return type of B::f.

If the class type in the covariant return type of D::f diﬀers from that of B::f, the class type in the return
type of D::f shall be complete at the point of declaration of D::f or shall be the class type D. When the
overriding function is called as the ﬁnal overrider of the overridden function, its result is converted to the
type returned by the (statically chosen) overridden function (5.2.2). [ Example:

class B { };
class D : private B { friend class Derived; };
struct Base {

virtual void vf1();
virtual void vf2();
virtual void vf3();
vf4();
virtual B*
virtual B*
vf5();
void f();

};

112) Multi-level pointers to classes or references to multi-level pointers to classes are not allowed.

§ 10.3

251

c(cid:13) ISO/IEC

N4296

struct No_good : public Base {

D*

vf4();

// error: B (base class of D) inaccessible

};

};

class A;
struct Derived : public Base {

// virtual and overrides Base::vf1()

void vf1();
void vf2(int); // not virtual, hides Base::vf2()
char vf3();
vf4();
D*
A*
vf5();
void f();

// error: invalid diﬀerence in return type only
// OK: returns pointer to derived class
// error: returns pointer to incomplete class

void g() {

Derived d;
Base* bp = &d;

bp->vf1();
bp->vf2();
bp->f();
B*

p = bp->vf4();

Derived* dp = &d;
D*
q = dp->vf4();

dp->vf2();

}

// standard conversion:
// Derived* to Base*
// calls Derived::vf1()
// calls Base::vf2()
// calls Base::f() (not virtual)
// calls Derived::pf() and converts the
// result to B*

// calls Derived::pf() and does not
// convert the result to B*
// ill-formed: argument mismatch

9

10

— end example ]
[ Note: The interpretation of the call of a virtual function depends on the type of the object for which it is
called (the dynamic type), whereas the interpretation of a call of a non-virtual member function depends
only on the type of the pointer or reference denoting that object (the static type) (5.2.2). — end note ]
[ Note: The virtual speciﬁer implies membership, so a virtual function cannot be a nonmember (7.1.2)
function. Nor can a virtual function be a static member, since a virtual function call relies on a speciﬁc
object for determining which function to invoke. A virtual function declared in one class can be declared a
friend in another class. — end note ]

11 A virtual function declared in a class shall be deﬁned, or declared pure (10.4) in that class, or both; but no

diagnostic is required (3.2).
[ Example: here are some uses of virtual functions with multiple base classes:

12

struct A {

virtual void f();

};

struct B1 : A {

void f();

};

// note non-virtual derivation

struct B2 : A {

void f();

};

§ 10.3

252

c(cid:13) ISO/IEC

N4296

struct D : B1, B2 {
};

// D has two separate A subobjects

// A* ap = &d; // would be ill-formed: ambiguous

// calls D::B1::f
// ill-formed: ambiguous

In class D above there are two occurrences of class A and hence two occurrences of the virtual member
function A::f. The ﬁnal overrider of B1::A::f is B1::f and the ﬁnal overrider of B2::A::f is B2::f.

13 The following example shows a function that does not have a unique ﬁnal overrider:

void foo() {

D

d;

b1p = &d;
ap = b1p;
dp = &d;

B1*
A*
D*
ap->f();
dp->f();

struct A {

virtual void f();

}

};

};

};

struct VB1 : virtual A {

// note virtual derivation

void f();

struct VB2 : virtual A {

void f();

struct Error : VB1, VB2 {
};

// ill-formed

struct Okay : VB1, VB2 {

void f();

};

Both VB1::f and VB2::f override A::f but there is no overrider of both of them in class Error. This
example is therefore ill-formed. Class Okay is well formed, however, because Okay::f is a ﬁnal overrider.

14 The following example uses the well-formed classes from above.

struct VB1a : virtual A {
};

struct Da : VB1a, VB2 {
};

// does not declare f

void foe() {

VB1a*
vb1ap->f();

}

vb1ap = new Da;

// calls VB2::f

— end example ]

15 Explicit qualiﬁcation with the scope operator (5.1) suppresses the virtual call mechanism. [ Example:

§ 10.3

253

c(cid:13) ISO/IEC

N4296

class B { public: virtual void f(); };
class D : public B { public: void f(); };
void D::f() { /∗ ... ∗/ B::f(); }

Here, the function call in D::f really does call B::f and not D::f. — end example ]

16 A function with a deleted deﬁnition (8.4) shall not override a function that does not have a deleted deﬁnition.
Likewise, a function that does not have a deleted deﬁnition shall not override a function with a deleted
deﬁnition.
10.4 Abstract classes

[class.abstract]
1 The abstract class mechanism supports the notion of a general concept, such as a shape, of which only more
concrete variants, such as circle and square, can actually be used. An abstract class can also be used to
deﬁne an interface for which derived classes provide a variety of implementations.

2 An abstract class is a class that can be used only as a base class of some other class; no objects of an abstract
class can be created except as subobjects of a class derived from it. A class is abstract if it has at least
one pure virtual function.
[ Note: Such a function might be inherited: see below. — end note ] A virtual
function is speciﬁed pure by using a pure-speciﬁer (9.2) in the function declaration in the class deﬁnition. A
pure virtual function need be deﬁned only if called with, or as if with (12.4), the qualiﬁed-id syntax (5.1).
[ Example:

class point { /∗ ... ∗/ };
class shape {

point center;

public:

// abstract class

point where() { return center; }
void move(point p) { center=p; draw(); }
virtual void rotate(int) = 0; // pure virtual
// pure virtual
virtual void draw() = 0;

};

};

— end example ] [ Note: A function declaration cannot provide both a pure-speciﬁer and a deﬁnition — end
note ] [ Example:

struct C {

virtual void f() = 0 { };

// ill-formed

— end example ]

3 An abstract class shall not be used as a parameter type, as a function return type, or as the type of an

explicit conversion. Pointers and references to an abstract class can be declared. [ Example:

shape x;
shape* p;
shape f();
void g(shape);
shape& h(shape&);

— end example ]

// error: object of abstract class
// OK
// error
// error
// OK

4 A class is abstract if it contains or inherits at least one pure virtual function for which the ﬁnal overrider is

pure virtual. [ Example:

class ab_circle : public shape {

int radius;

§ 10.4

254

c(cid:13) ISO/IEC

N4296

public:

void rotate(int) { }
// ab_circle::draw() is a pure virtual

Since shape::draw() is a pure virtual function ab_circle::draw() is a pure virtual by default. The
alternative declaration,

};

};

class circle : public shape {

int radius;

public:

void rotate(int) { }
void draw();

// a deﬁnition is required somewhere

would make class circle nonabstract and a deﬁnition of circle::draw() must be provided. — end exam-
ple ]
[ Note: An abstract class can be derived from a class that is not abstract, and a pure virtual function may
override a virtual function which is not pure. — end note ]

5

6 Member functions can be called from a constructor (or destructor) of an abstract class; the eﬀect of making a
virtual call (10.3) to a pure virtual function directly or indirectly for the object being created (or destroyed)
from such a constructor (or destructor) is undeﬁned.

§ 10.4

255

c(cid:13) ISO/IEC

N4296

11 Member access control

[class.access]

1 A member of a class can be

(1.1)

(1.2)

(1.3)

—
—

—

private; that is, its name can be used only by members and friends of the class in which it is declared.
protected; that is, its name can be used only by members and friends of the class in which it is
declared, by classes derived from that class, and by their friends (see 11.4).
public; that is, its name can be used anywhere without access restriction.

2 A member of a class can also access all the names to which the class has access. A local class of a member

function may access the same names that the member function itself may access.113

3 Members of a class deﬁned with the keyword class are private by default. Members of a class deﬁned

with the keywords struct or union are public by default. [ Example:

class X {
int a;

};

struct S {

int a;

};

// X::a is private by default

// S::a is public by default

— end example ]

4 Access control is applied uniformly to all names, whether the names are referred to from declarations or
expressions.
[ Note: Access control applies to names nominated by friend declarations (11.3) and using-
declarations (7.3.3). — end note ] In the case of overloaded function names, access control is applied to the
function selected by overload resolution. [ Note: Because access control applies to names, if access control is
applied to a typedef name, only the accessibility of the typedef name itself is considered. The accessibility
of the entity referred to by the typedef is not considered. For example,

class A {

class B { };

};

public:

typedef B BB;

void f() {
A::BB x;
A::B y;

}

// OK, typedef name A::BB is public
// access error, A::B is private

5

— end note ]
It should be noted that it is access to members and base classes that is controlled, not their visibility. Names
of members are still visible, and implicit conversions to base classes are still considered, when those members
and base classes are inaccessible. The interpretation of a given construct is established without regard to
113) Access permissions are thus transitive and cumulative to nested and local classes.

Member access control

256

c(cid:13) ISO/IEC

N4296

access control. If the interpretation established makes use of inaccessible member names or base classes, the
construct is ill-formed.

6 All access controls in Clause 11 aﬀect the ability to access a class member name from the declaration of a
particular entity, including parts of the declaration preceding the name of the entity being declared and, if the
entity is a class, the deﬁnitions of members of the class appearing outside the class’s member-speciﬁcation.
[ Note: this access also applies to implicit references to constructors, conversion functions, and destructors.
— end note ] [ Example:

class A {

// private member

typedef int I;
I f();
friend I g(I);
static I x;
template<int> struct Q;
template<int> friend struct R;

protected:

struct B { };

};

A::I A::f() { return 0; }
A::I g(A::I p = A::x);
A::I g(A::I p) { return 0; }
A::I A::x = 0;
template<A::I> struct A::Q { };
template<A::I> struct R { };

struct D: A::B, A { };

7 Here, all the uses of A::I are well-formed because A::f, A::x, and A::Q are members of class A and g and
R are friends of class A. This implies, for example, that access checking on the ﬁrst use of A::I must be
deferred until it is determined that this use of A::I is as the return type of a member of class A. Similarly,
the use of A::B as a base-speciﬁer is well-formed because D is derived from A, so checking of base-speciﬁers
must be deferred until the entire base-speciﬁer-list has been seen. — end example ]

8 The names in a default argument (8.3.6) are bound at the point of declaration, and access is checked at that
point rather than at any points of use of the default argument. Access checking for default arguments in
function templates and in member functions of class templates is performed as described in 14.7.1.

9 The names in a default template-argument (14.1) have their access checked in the context in which they

appear rather than at any points of use of the default template-argument. [ Example:

class B { };
template <class T> class C {
protected:

typedef T TT;

};

template <class U, class V = typename U::TT>
class D : public U { };

// access error, C::TT is protected

D <C<B> >* d;
— end example ]
11.1 Access speciﬁers

1 Member declarations can be labeled by an access-speciﬁer (Clause 10):

§ 11.1

[class.access.spec]

257

c(cid:13) ISO/IEC

N4296

access-speciﬁer : member-speciﬁcationopt

An access-speciﬁer speciﬁes the access rules for members following it until the end of the class or until
another access-speciﬁer is encountered. [ Example:

class X {
int a;
public:
int b;
int c;

};

— end example ]

// X::a is private by default: class used

// X::b is public
// X::c is public

2 Any number of access speciﬁers is allowed and no particular order is required. [ Example:

struct S {

int a;

protected:

int b;
private:
int c;
public:
int d;

};

// S::a is public by default: struct used

// S::b is protected

// S::c is private

// S::d is public

3

— end example ]
[ Note: The eﬀect of access control on the order of allocation of data members is described in 9.2. — end
note ]

4 When a member is redeclared within its class deﬁnition, the access speciﬁed at its redeclaration shall be the

same as at its initial declaration. [ Example:

struct S {
class A;
enum E : int;

private:

};

// error: cannot change access
class A { };
enum E: int { e0 }; // error: cannot change access

5

— end example ]
[ Note: In a derived class, the lookup of a base class name will ﬁnd the injected-class-name instead of the
name of the base class in the scope in which it was declared. The injected-class-name might be less accessible
than the name of the base class in the scope in which it was declared. — end note ]
[ Example:

class A { };
class B : private A { };
class C : public B {

A* p;
::A* q;

};

// error: injected-class-name A is inaccessible
// OK

— end example ]

§ 11.1

258

c(cid:13) ISO/IEC

N4296

[class.access.base]
11.2 Accessibility of base classes and base class members
If a class is declared to be a base class (Clause 10) for another class using the public access speciﬁer, the
public members of the base class are accessible as public members of the derived class and protected
members of the base class are accessible as protected members of the derived class. If a class is declared to
be a base class for another class using the protected access speciﬁer, the public and protected members
of the base class are accessible as protected members of the derived class. If a class is declared to be a base
class for another class using the private access speciﬁer, the public and protected members of the base
class are accessible as private members of the derived class114.
In the absence of an access-speciﬁer for a base class, public is assumed when the derived class is deﬁned with
the class-key struct and private is assumed when the class is deﬁned with the class-key class. [ Example:

class B { /∗ ... ∗/ };
class D1 : private B { /∗ ... ∗/ };
class D2 : public B { /∗ ... ∗/ };
class D3 : B { /∗ ... ∗/ };
struct D4 : public B { /∗ ... ∗/ };
struct D5 : private B { /∗ ... ∗/ };
struct D6 : B { /∗ ... ∗/ };
class D7 : protected B { /∗ ... ∗/ };
struct D8 : protected B { /∗ ... ∗/ };

// B private by default

// B public by default

Here B is a public base of D2, D4, and D6, a private base of D1, D3, and D5, and a protected base of D7 and
D8. — end example ]
[ Note: A member of a private base class might be inaccessible as an inherited member name, but accessible
directly. Because of the rules on pointer conversions (4.10) and explicit casts (5.4), a conversion from
a pointer to a derived class to a pointer to an inaccessible base class might be ill-formed if an implicit
conversion is used, but well-formed if an explicit cast is used. For example,

1

2

3

class B {
public:

int mi;
static int si;

};
class D : private B {
};
class DD : public D {

void f();

};

void DD::f() {

mi = 3;
si = 3;
::B
b;
b.mi = 3;
b.si = 3;
::B::si = 3;
::B* bp1 = this;
::B* bp2 = (::B*)this;
bp2->mi = 3;

}

// non-static member
// static member

// error: mi is private in D
// error: si is private in D

// OK (b.mi is diﬀerent from this->mi)
// OK (b.si is diﬀerent from this->si)
// OK
// error: B is a private base class
// OK with cast
// OK: access through a pointer to B.

114) As speciﬁed previously in Clause 11, private members of a base class remain inaccessible even to derived classes unless
friend declarations within the base class deﬁnition are used to grant access explicitly.

§ 11.2

259

c(cid:13) ISO/IEC

— end note ]

4 A base class B of N is accessible at R, if

N4296

(4.1)

(4.2)

(4.3)

(4.4)

—
—

—

—

an invented public member of B would be a public member of N, or
R occurs in a member or friend of class N, and an invented public member of B would be a private or
protected member of N, or
R occurs in a member or friend of a class P derived from N, and an invented public member of B would
be a private or protected member of P, or
there exists a class S such that B is a base class of S accessible at R and S is a base class of N accessible
at R.

[ Example:

class B {
public:
int m;

};

class S: private B {

friend class N;

};

void f() {

B* p = this;

// OK because class S satisﬁes the fourth condition
// above: B is a base class of N accessible in f() because
// B is an accessible base class of S and S is an accessible
// base class of N.

class N: private S {

}
};

5

— end example ]
If a base class is accessible, one can implicitly convert a pointer to a derived class to a pointer to that base
class (4.10, 4.11). [ Note: It follows that members and friends of a class X can implicitly convert an X* to a
pointer to a private or protected immediate base class of X. — end note ] The access to a member is aﬀected
by the class in which the member is named. This naming class is the class in which the member name was
looked up and found.
[ Note: This class can be explicit, e.g., when a qualiﬁed-id is used, or implicit, e.g.,
when a class member access operator (5.2.5) is used (including cases where an implicit “this->” is added).
If both a class member access operator and a qualiﬁed-id are used to name the member (as in p->T::m), the
class naming the member is the class denoted by the nested-name-speciﬁer of the qualiﬁed-id (that is, T).
— end note ] A member m is accessible at the point R when named in class N if

(5.1)

(5.2)

(5.3)

(5.4)

—
—
—

—

m as a member of N is public, or
m as a member of N is private, and R occurs in a member or friend of class N, or
m as a member of N is protected, and R occurs in a member or friend of class N, or in a member or
friend of a class P derived from N, where m as a member of P is public, private, or protected, or
there exists a base class B of N that is accessible at R, and m is accessible at R when named in class B.
[ Example:

§ 11.2

260

c(cid:13) ISO/IEC

N4296

class B;
class A {
private:
int i;
friend void f(B*);

};
class B : public A { };
void f(B* p) {

p->i = 1;

}

— end example ]

// OK: B* can be implicitly converted to A*,
// and f has access to i in A

6

If a class member access operator, including an implicit “this->,” is used to access a non-static data member
or non-static member function, the reference is ill-formed if the left operand (considered as a pointer in the
“.” operator case) cannot be implicitly converted to a pointer to the naming class of the right operand.
[ Note: This requirement is in addition to the requirement that the member be accessible as named. — end
note ]
11.3 Friends

[class.friend]
1 A friend of a class is a function or class that is given permission to use the private and protected member
names from the class. A class speciﬁes its friends, if any, by way of friend declarations. Such declarations give
special access rights to the friends, but they do not make the nominated friends members of the befriending
class. [ Example: the following example illustrates the diﬀerences between members and friends:

class X {
int a;
friend void friend_set(X*, int);

public:

};

void member_set(int);

void friend_set(X* p, int i) { p->a = i; }
void X::member_set(int i) { a = i; }

void f() {

X obj;
friend_set(&obj,10);
obj.member_set(10);

}

— end example ]

2 Declaring a class to be a friend implies that the names of private and protected members from the class
granting friendship can be accessed in the base-speciﬁers and member declarations of the befriended class.
[ Example:

class A {

class B { };
friend class X;

};

struct X : A::B {

A::B mx;

// OK: A::B accessible to friend
// OK: A::B accessible to member of friend

§ 11.3

261

c(cid:13) ISO/IEC

N4296

class Y {
A::B my;

};

};

// OK: A::B accessible to nested member of friend

— end example ] [ Example:

class X {

enum { a=100 };
friend class Y;

class Y {

int v[X::a];

class Z {

int v[X::a];

// OK, Y is a friend of X

// error: X::a is private

};

};

};

};

};

};

— end example ]
A class shall not be deﬁned in a friend declaration. [ Example:

class A {

friend class B { }; // error: cannot deﬁne class in friend declaration

— end example ]

3 A friend declaration that does not declare a function shall have one of the following forms:

friend elaborated-type-speciﬁer ;
friend simple-type-speciﬁer ;
friend typename-speciﬁer ;

[ Note: A friend declaration may be the declaration in a template-declaration (Clause 14, 14.5.4). — end
note ] If the type speciﬁer in a friend declaration designates a (possibly cv-qualiﬁed) class type, that class
is declared as a friend; otherwise, the friend declaration is ignored. [ Example:

class C;
typedef C Ct;

class X1 {
friend C;

};

class X2 {

friend Ct;
friend D;
friend class D;

// OK: class C is a friend

// OK: class C is a friend
// error: no type-name D in scope
// OK: elaborated-type-speciﬁer declares new class

template <typename T> class R {

friend T;

R<C> rc;
R<int> Ri;

// class C is a friend of R<C>
// OK: "friend int;" is ignored

§ 11.3

262

c(cid:13) ISO/IEC

— end example ]

N4296

4 A function ﬁrst declared in a friend declaration has the linkage of the namespace of which it is a member (3.5).

Otherwise, the function retains its previous linkage (7.1.1).

5 When a friend declaration refers to an overloaded name or operator, only the function speciﬁed by the
parameter types becomes a friend. A member function of a class X can be a friend of a class Y. [ Example:

class Y {

friend char* X::foo(int);
friend X::X(char);
friend X::~X();

};

// constructors can be friends
// destructors can be friends

— end example ]

6 A function can be deﬁned in a friend declaration of a class if and only if the class is a non-local class (9.8),

the function name is unqualiﬁed, and the function has namespace scope. [ Example:

class M {

friend void f() { }

};

— end example ]

// deﬁnition of global f, a friend of M,
// not the deﬁnition of a member function

7 Such a function is implicitly inline. A friend function deﬁned in a class is in the (lexical) scope of the

class in which it is deﬁned. A friend function deﬁned outside the class is not (3.4.1).
8 No storage-class-speciﬁer shall appear in the decl-speciﬁer-seq of a friend declaration.
9 A name nominated by a friend declaration shall be accessible in the scope of the class containing the friend
declaration. The meaning of the friend declaration is the same whether the friend declaration appears in
the private, protected or public (9.2) portion of the class member-speciﬁcation.

10 Friendship is neither inherited nor transitive. [ Example:

class A {

friend class B;
int a;

class B {

friend class C;

};

};

class C

{

void f(A* p) {

p->a++;

}
};

class D : public B

void f(A* p) {

p->a++;

}
};

§ 11.3

// error: C is not a friend of A
// despite being a friend of a friend

{

// error: D is not a friend of A
// despite being derived from a friend

263

c(cid:13) ISO/IEC

N4296

11

— end example ]
If a friend declaration appears in a local class (9.8) and the name speciﬁed is an unqualiﬁed name, a prior
declaration is looked up without considering scopes that are outside the innermost enclosing non-class scope.
For a friend function declaration, if there is no prior declaration, the program is ill-formed. For a friend class
declaration, if there is no prior declaration, the class that is speciﬁed belongs to the innermost enclosing
non-class scope, but if it is subsequently referenced, its name is not found by name lookup until a matching
declaration is provided in the innermost enclosing non-class scope. [ Example:

class X;
void a();
void f() {
class Y;
extern void b();
class A {
// OK, but X is a local class, not ::X
friend class X;
// OK
friend class Y;
// OK, introduces local class Z
friend class Z;
friend void a(); // error, ::a is not considered
friend void b(); // OK
friend void c(); // error
};
X* px;
Z* pz;

// OK, but ::X is found
// error, no Z is found

}

— end example ]
11.4 Protected member access

[class.protected]
1 An additional access check beyond those described earlier in Clause 11 is applied when a non-static data
member or non-static member function is a protected member of its naming class (11.2)115 As described
earlier, access to a protected member is granted because the reference occurs in a friend or member of some
class C. If the access is to form a pointer to member (5.3.1), the nested-name-speciﬁer shall denote C or a
class derived from C. All other accesses involve a (possibly implicit) object expression (5.2.5). In this case,
the class of the object expression shall be C or a class derived from C. [ Example:

class B {
protected:

int i;
static int j;

};

class D1 : public B {
};

class D2 : public B {

friend void fr(B*,D1*,D2*);
void mem(B*,D1*);

};

void fr(B* pb, D1* p1, D2* p2) {

pb->i = 1;
p1->i = 2;
p2->i = 3;

// ill-formed
// ill-formed
// OK (access through a D2)

115) This additional check does not apply to other members, e.g., static data members or enumerator member constants.

§ 11.4

264

c(cid:13) ISO/IEC

N4296

p2->B::i = 4;

int B::* pmi_B = &B::i;
int B::* pmi_B2 = &D2::i;
B::j = 5;
D2::j = 6;

}

// OK (access through a D2, even though
// naming class is B)
// ill-formed
// OK (type of &D2::i is int B::*)
// OK (because refers to static member)
// OK (because refers to static member)

void D2::mem(B* pb, D1* p1) {

pb->i = 1;
p1->i = 2;
i = 3;
B::i = 4;
int B::* pmi_B = &B::i;
int B::* pmi_B2 = &D2::i;
j = 5;
B::j = 6;

void g(B* pb, D1* p1, D2* p2) {

pb->i = 1;
p1->i = 2;
p2->i = 3;

// ill-formed
// ill-formed
// OK (access through this)
// OK (access through this, qualiﬁcation ignored)
// ill-formed
// OK
// OK (because j refers to static member)
// OK (because B::j refers to static member)

// ill-formed
// ill-formed
// ill-formed

}

}

};

};

class B {
public:

virtual int f();

class D : public B {
private:

int f();

— end example ]
11.5 Access to virtual functions

[class.access.virt]
1 The access rules (Clause 11) for a virtual function are determined by its declaration and are not aﬀected by

the rules for a function that later overrides it. [ Example:

void f() {

D d;
B* pb = &d;
D* pd = &d;

pb->f();

pd->f();

}

— end example ]

// OK: B::f() is public,
// D::f() is invoked
// error: D::f() is private

2 Access is checked at the call point using the type of the expression used to denote the object for which the
member function is called (B* in the example above). The access of the member function in the class in
which it was deﬁned (D in the example above) is in general not known.

§ 11.5

265

c(cid:13) ISO/IEC

N4296

1

[class.paths]
11.6 Multiple access
If a name can be reached by several paths through a multiple inheritance graph, the access is that of the
path that gives most access. [ Example:

class W { public: void f(); };
class A : private virtual W { };
class B : public virtual W { };
class C : public A, public B {

void f() { W::f(); }

// OK

};

2 Since W::f() is available to C::f() along the public path through B, access is allowed. — end example ]

11.7 Nested classes

[class.access.nest]
1 A nested class is a member and as such has the same access rights as any other member. The members of
an enclosing class have no special access to members of a nested class; the usual access rules (Clause 11)
shall be obeyed. [ Example:

class E {
int x;
class B { };

class I {

B b;
int y;
void f(E* p, int i) {

p->x = i;

}

};

int g(I* p) {
return p->y;

}
};

— end example ]

// OK: E::I can access E::B

// OK: E::I can access E::x

// error: I::y is private

§ 11.7

266

c(cid:13) ISO/IEC

N4296

12 Special member functions

[special]

1 The default constructor (12.1), copy constructor and copy assignment operator (12.8), move constructor
and move assignment operator (12.8), and destructor (12.4) are special member functions.
[ Note: The
implementation will implicitly declare these member functions for some class types when the program does
not explicitly declare them. The implementation will implicitly deﬁne them if they are odr-used (3.2).
See 12.1, 12.4 and 12.8. — end note ] An implicitly-declared special member function is declared at the
closing } of the class-speciﬁer. Programs shall not deﬁne implicitly-declared special member functions.

2 Programs may explicitly refer to implicitly-declared special member functions. [ Example: a program may
explicitly call, take the address of or form a pointer to member to an implicitly-declared special member
function.

struct A { };
struct B : A {

B& operator=(const B &);

};
B& B::operator=(const B& s) {

this->A::operator=(s);
return *this;

}

// implicitly declared A::operator=

// well formed

3

— end example ]
[ Note: The special member functions aﬀect the way objects of class type are created, copied, moved, and
destroyed, and how values can be converted to values of other types. Often such special member functions
are called implicitly. — end note ]

4 Special member functions obey the usual access rules (Clause 11).

[ Example: declaring a constructor

protected ensures that only derived classes and friends can create objects using it. — end example ]

5 For a class, its non-static data members, its non-virtual direct base classes, and, if the class is not ab-

stract (10.4), its virtual base classes are called its potentially constructed subobjects.
12.1 Constructors

[class.ctor]
1 Constructors do not have names. In a declaration of a constructor, the declarator is a function declara-

tor (8.3.5) of the form

ptr-declarator ( parameter-declaration-clause ) exception-speciﬁcationopt attribute-speciﬁer-seqopt

where the ptr-declarator consists solely of an id-expression, an optional attribute-speciﬁer-seq, and optional
surrounding parentheses, and the id-expression has one of the following forms:

(1.1)

(1.2)

(1.3)

—

—

—

in a member-declaration that belongs to the member-speciﬁcation of a class but is not a friend dec-
laration (11.3), the id-expression is the injected-class-name (Clause 9) of the immediately-enclosing
class;
in a member-declaration that belongs to the member-speciﬁcation of a class template but is not a friend
declaration, the id-expression is a class-name that names the current instantiation (14.6.2.1) of the
immediately-enclosing class template; or
in a declaration at namespace scope or in a friend declaration, the id-expression is a qualiﬁed-id that
names a constructor (3.4.3.1).

§ 12.1

267

c(cid:13) ISO/IEC

N4296

The class-name shall not be a typedef-name. In a constructor declaration, each decl-speciﬁer in the optional
decl-speciﬁer-seq shall be friend, inline, explicit, or constexpr. [ Example:

struct S {

S();

};

// declares the constructor

S::S() { }

// deﬁnes the constructor

— end example ]

2 A constructor is used to initialize objects of its class type. Because constructors do not have names, they are
never found during name lookup; however an explicit type conversion using the functional notation (5.2.3)
will cause a constructor to be called to initialize an object. [ Note: For initialization of objects of class type
see 12.6. — end note ]

3 A constructor can be invoked for a const, volatile or const volatile object. const and volatile seman-
tics (7.1.6.1) are not applied on an object under construction. They come into eﬀect when the constructor
for the most derived object (1.8) ends.

4 A default constructor for a class X is a constructor of class X that either has no parameters or else each param-
eter that is not a function parameter pack has a default argument. If there is no user-declared constructor for
class X, a constructor having no parameters is implicitly declared as defaulted (8.4). An implicitly-declared
default constructor is an inline public member of its class. A defaulted default constructor for class X is
deﬁned as deleted if:

(4.1)

(4.2)

(4.3)

(4.4)

(4.5)

(4.6)

—
—
—

—
—

—

(4.7)

—

X is a union-like class that has a variant member with a non-trivial default constructor,
any non-static data member with no brace-or-equal-initializer is of reference type,
any non-variant non-static data member of const-qualiﬁed type (or array thereof) with no brace-or-
equal-initializer does not have a user-provided default constructor,
X is a union and all of its variant members are of const-qualiﬁed type (or array thereof),
X is a non-union class and all members of any anonymous union member are of const-qualiﬁed type
(or array thereof),
any potentially constructed subobject, except for a non-static data member with a brace-or-equal-
initializer, has class type M (or array thereof) and either M has no default constructor or overload
resolution (13.3) as applied to M’s default constructor results in an ambiguity or in a function that is
deleted or inaccessible from the defaulted default constructor, or
any potentially constructed subobject has a type with a destructor that is deleted or inaccessible from
the defaulted default constructor.

A default constructor is trivial if it is not user-provided and if:

(4.8)

(4.9)

(4.10)

(4.11)

—
—
—
—

its class has no virtual functions (10.3) and no virtual base classes (10.1), and
no non-static data member of its class has a brace-or-equal-initializer, and
all the direct base classes of its class have trivial default constructors, and
for all the non-static data members of its class that are of class type (or array thereof), each such class
has a trivial default constructor.

§ 12.1

268

c(cid:13) ISO/IEC

N4296

Otherwise, the default constructor is non-trivial.

5 A default constructor that is defaulted and not deﬁned as deleted is implicitly deﬁned when it is odr-
used (3.2) to create an object of its class type (1.8) or when it is explicitly defaulted after its ﬁrst declaration.
The implicitly-deﬁned default constructor performs the set of initializations of the class that would be
performed by a user-written default constructor for that class with no ctor-initializer (12.6.2) and an empty
compound-statement. If that user-written default constructor would be ill-formed, the program is ill-formed.
If that user-written default constructor would satisfy the requirements of a constexpr constructor (7.1.5),
the implicitly-deﬁned default constructor is constexpr. Before the defaulted default constructor for a
class is implicitly deﬁned, all the non-user-provided default constructors for its base classes and its non-
static data members shall have been implicitly deﬁned.
[ Note: An implicitly-declared default constructor
has an exception speciﬁcation (15.4). An explicitly-defaulted deﬁnition might have an implicit exception
speciﬁcation, see 8.4. — end note ]

6 Default constructors are called implicitly to create class objects of static, thread, or automatic storage
duration (3.7.1, 3.7.2, 3.7.3) deﬁned without an initializer (8.5), are called to create class objects of dynamic
storage duration (3.7.4) created by a new-expression in which the new-initializer is omitted (5.3.4), or
are called when the explicit type conversion syntax (5.2.3) is used. A program is ill-formed if the default
constructor for an object is implicitly used and the constructor is not accessible (Clause 11).
[ Note: 12.6.2 describes the order in which constructors for base classes and non-static data members are
called and describes how arguments can be speciﬁed for the calls to these constructors. — end note ]

7

8 A return statement in the body of a constructor shall not specify a return value. The address of a constructor

shall not be taken.

9 A functional notation type conversion (5.2.3) can be used to create new objects of its type.

syntax looks like an explicit call of the constructor. — end note ] [ Example:

[ Note: The

complex zz = complex(1,2.3);
cprint( complex(7.8,1.2) );

— end example ]

10 An object created in this way is unnamed. [ Note: 12.2 describes the lifetime of temporary objects. — end

note ] [ Note: Explicit constructor calls do not yield lvalues, see 3.10. — end note ]
[ Note: some language constructs have special semantics when used during construction; see 12.6.2 and 12.7.
— end note ]

11

12 During the construction of a const object, if the value of the object or any of its subobjects is accessed
through a glvalue that is not obtained, directly or indirectly, from the constructor’s this pointer, the value
of the object or subobject thus obtained is unspeciﬁed. [ Example:

struct C;
void no_opt(C*);

struct C {

int c;
C() : c(0) { no_opt(this); }

};

const C cobj;

void no_opt(C* cptr) {
int i = cobj.c * 100;
cptr->c = 1;
cout << cobj.c * 100

<< ’\n’;

§ 12.1

// value of cobj.c is unspeciﬁed

// value of cobj.c is unspeciﬁed

269

c(cid:13) ISO/IEC

}

N4296

— end example ]
12.2 Temporary objects

[class.temporary]
1 Temporaries of class type are created in various contexts: binding a reference to a prvalue (8.5.3), returning
a prvalue (6.6.3), a conversion that creates a prvalue (4.1, 5.2.9, 5.2.11, 5.4), throwing an exception (15.1),
and in some initializations (8.5). [ Note: The lifetime of exception objects is described in 15.1. — end note ]
Even when the creation of the temporary object is unevaluated (Clause 5) or otherwise avoided (12.8), all
the semantic restrictions shall be respected as if the temporary object had been created and later destroyed.
[ Note: This includes accessibility (11) and whether it is deleted, for the constructor selected and for the
destructor. However, in the special case of a function call used as the operand of a decltype-speciﬁer (5.2.2),
no temporary is introduced, so the foregoing does not apply to the prvalue of any such function call. — end
note ]
[ Example: Consider the following code:

2

class X {
public:

X(int);
X(const X&);
X& operator=(const X&);
~X();

};

class Y {
public:

Y(int);
Y(Y&&);
~Y();

};

X f(X);
Y g(Y);

void h() {
X a(1);
X b = f(X(2));
Y c = g(Y(3));
a = f(a);

}

An implementation might use a temporary in which to construct X(2) before passing it to f() using X’s copy
constructor; alternatively, X(2) might be constructed in the space used to hold the argument. Likewise, an
implementation might use a temporary in which to construct Y(3) before passing it to g() using Y’s move
constructor; alternatively, Y(3) might be constructed in the space used to hold the argument. Also, a
temporary might be used to hold the result of f(X(2)) before copying it to b using X’s copy constructor;
alternatively, f()’s result might be constructed in b. Likewise, a temporary might be used to hold the result
of g(Y(3)) before moving it to c using Y’s move constructor; alternatively, g()’s result might be constructed
in c. On the other hand, the expression a=f(a) requires a temporary for the result of f(a), which is then
assigned to a. — end example ]

3 When an implementation introduces a temporary object of a class that has a non-trivial constructor (12.1,
12.8), it shall ensure that a constructor is called for the temporary object. Similarly, the destructor shall be
called for a temporary with a non-trivial destructor (12.4). Temporary objects are destroyed as the last step

§ 12.2

270

c(cid:13) ISO/IEC

N4296

in evaluating the full-expression (1.9) that (lexically) contains the point where they were created. This is true
even if that evaluation ends in throwing an exception. The value computations and side eﬀects of destroying
a temporary object are associated only with the full-expression, not with any speciﬁc subexpression.

4 There are two contexts in which temporaries are destroyed at a diﬀerent point than the end of the full-
expression. The ﬁrst context is when a default constructor is called to initialize an element of an array. If
the constructor has one or more default arguments, the destruction of every temporary created in a default
argument is sequenced before the construction of the next array element, if any.

5 The second context is when a reference is bound to a temporary.116 The temporary to which the reference is
bound or the temporary that is the complete object of a subobject to which the reference is bound persists
for the lifetime of the reference except:

(5.1)

(5.2)

(5.3)

—

—

—

A temporary object bound to a reference parameter in a function call (5.2.2) persists until the com-
pletion of the full-expression containing the call.
The lifetime of a temporary bound to the returned value in a function return statement (6.6.3) is not
extended; the temporary is destroyed at the end of the full-expression in the return statement.
A temporary bound to a reference in a new-initializer (5.3.4) persists until the completion of the
full-expression containing the new-initializer. [ Example:
struct S { int mi; const std::pair<int,int>& mp; };
S a { 1, {2,3} };
S* p = new S{ 1, {2,3} };

// Creates dangling reference

— end example ] [ Note: This may introduce a dangling reference, and implementations are encouraged
to issue a warning in such a case. — end note ]

The destruction of a temporary whose lifetime is not extended by being bound to a reference is sequenced
before the destruction of every temporary which is constructed earlier in the same full-expression. If the
lifetime of two or more temporaries to which references are bound ends at the same point, these temporaries
are destroyed at that point in the reverse order of the completion of their construction. In addition, the
destruction of temporaries bound to references shall take into account the ordering of destruction of objects
with static, thread, or automatic storage duration (3.7.1, 3.7.2, 3.7.3); that is, if obj1 is an object with the
same storage duration as the temporary and created before the temporary is created the temporary shall be
destroyed before obj1 is destroyed; if obj2 is an object with the same storage duration as the temporary and
created after the temporary is created the temporary shall be destroyed after obj2 is destroyed. [ Example:

struct S {

S();
S(int);
friend S operator+(const S&, const S&);
~S();

};
S obj1;
const S& cr = S(16)+S(23);
S obj2;

the expression S(16) + S(23) creates three temporaries: a ﬁrst temporary T1 to hold the result of the
expression S(16), a second temporary T2 to hold the result of the expression S(23), and a third temporary
T3 to hold the result of the addition of these two expressions. The temporary T3 is then bound to the reference
cr. It is unspeciﬁed whether T1 or T2 is created ﬁrst. On an implementation where T1 is created before
T2, T2 shall be destroyed before T1. The temporaries T1 and T2 are bound to the reference parameters of
116) The same rules apply to initialization of an initializer_list object (8.5.4) with its underlying temporary array

§ 12.2

271

c(cid:13) ISO/IEC

N4296

operator+; these temporaries are destroyed at the end of the full-expression containing the call to operator+.
The temporary T3 bound to the reference cr is destroyed at the end of cr’s lifetime, that is, at the end of the
program. In addition, the order in which T3 is destroyed takes into account the destruction order of other
objects with static storage duration. That is, because obj1 is constructed before T3, and T3 is constructed
before obj2, obj2 shall be destroyed before T3, and T3 shall be destroyed before obj1. — end example ]
12.3 Conversions

[class.conv]
1 Type conversions of class objects can be speciﬁed by constructors and by conversion functions. These
conversions are called user-deﬁned conversions and are used for implicit type conversions (Clause 4), for
initialization (8.5), and for explicit type conversions (5.4, 5.2.9).

2 User-deﬁned conversions are applied only where they are unambiguous (10.2, 12.3.2). Conversions obey the

access control rules (Clause 11). Access control is applied after ambiguity resolution (3.4).
[ Note: See 13.3 for a discussion of the use of conversions in function calls as well as examples below. — end
note ]

3

4 At most one user-deﬁned conversion (constructor or conversion function) is implicitly applied to a single

value.
[ Example:

struct X {

operator int();

struct Y {

operator X();

};

};

};

};

Y a;
int b = a;

int c = X(a);

— end example ]

// error
// a.operator X().operator int() not tried
// OK: a.operator X().operator int()

5 User-deﬁned conversions are used implicitly only if they are unambiguous. A conversion function in a
derived class does not hide a conversion function in a base class unless the two functions convert to the same
type. Function overload resolution (13.3.3) selects the best conversion function to perform the conversion.
[ Example:

struct X {

operator int();

struct Y : X {

operator char();

// ill-formed:
// X::operator int() or Y::operator char()

void f(Y& a) {

if (a) {

}

}

— end example ]

§ 12.3

272

c(cid:13) ISO/IEC

N4296

12.3.1 Conversion by constructor

[class.conv.ctor]
1 A constructor declared without the function-speciﬁer explicit speciﬁes a conversion from the types of its

parameters to the type of its class. Such a constructor is called a converting constructor. [ Example:

struct X {
X(int);
X(const char*, int =0);
X(int, int);

};

void f(X arg) {

X a = 1;
X b = "Jessie";
a = 2;
f(3);
f({1, 2});

}

// a = X(1)
// b = X("Jessie",0)
// a = X(2)
// f(X(3))
// f(X(1,2))

— end example ]

2 An explicit constructor constructs objects just like non-explicit constructors, but does so only where the
direct-initialization syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used. A default constructor
may be an explicit constructor; such a constructor will be used to perform default-initialization or value-
initialization (8.5). [ Example:

struct Z {

explicit Z();
explicit Z(int);
explicit Z(int, int);

};

Z a;
Z a1 = 1;
Z a3 = Z(1);
Z a2(1);
Z* p = new Z(1);
Z a4 = (Z)1;
Z a5 = static_cast<Z>(1);
Z a6 = { 3, 4 };

— end example ]

// OK: default-initialization performed
// error: no implicit conversion
// OK: direct initialization syntax used
// OK: direct initialization syntax used
// OK: direct initialization syntax used
// OK: explicit cast used
// OK: explicit cast used
// error: no implicit conversion

3 A non-explicit copy/move constructor (12.8) is a converting constructor. An implicitly-declared copy/move

constructor is not an explicit constructor; it may be called for implicit type conversions.
12.3.2 Conversion functions

[class.conv.fct]

1 A member function of a class X having no parameters with a name of the form

conversion-function-id:

operator conversion-type-id

conversion-type-id:

type-speciﬁer-seq conversion-declaratoropt

conversion-declarator:

ptr-operator conversion-declaratoropt

speciﬁes a conversion from X to the type speciﬁed by the conversion-type-id. Such functions are called
conversion functions. No return type can be speciﬁed. If a conversion function is a member function, the

§ 12.3.2

273

c(cid:13) ISO/IEC

N4296

type of the conversion function (8.3.5) is “function taking no parameter returning conversion-type-id”. A
conversion function is never used to convert a (possibly cv-qualiﬁed) object to the (possibly cv-qualiﬁed)
same object type (or a reference to it), to a (possibly cv-qualiﬁed) base class of that type (or a reference to
it), or to (possibly cv-qualiﬁed) void.117
[ Example:

struct X {

operator int();

};

void f(X a) {

int i = int(a);
i = (int)a;
i = a;

}

In all three cases the value assigned will be converted by X::operator int(). — end example ]

2 A conversion function may be explicit (7.1.2), in which case it is only considered as a user-deﬁned conversion
for direct-initialization (8.5). Otherwise, user-deﬁned conversions are not restricted to use in assignments
and initializations. [ Example:

class Y { };
struct Z {

explicit operator Y() const;

void h(Z z) {

Y y1(z);
Y y2 = z;
Y y3 = (Y)z;

// OK: direct-initialization
// ill-formed: copy-initialization
// OK: cast notation

};

}

}

void g(X a, X b) {

int i = (a) ? 1+a : 0;
int j = (a&&b) ? a+b : i;
if (a) {
}

— end example ]

3 The conversion-type-id shall not represent a function type nor an array type. The conversion-type-id in
[ Note: This prevents

a conversion-function-id is the longest possible sequence of conversion-declarators.
ambiguities between the declarator operator * and its expression counterparts. [ Example:

&ac.operator int*i; // syntax error:

// parsed as: &(ac.operator int *)i
// not as: &(ac.operator int)*i

The * is the pointer declarator and not the multiplication operator. — end example ] — end note ]

4 Conversion functions are inherited.

117) These conversions are considered as standard conversions for the purposes of overload resolution (13.3.3.1, 13.3.3.1.4) and
therefore initialization (8.5) and explicit casts (5.2.9). A conversion to void does not invoke any conversion function (5.2.9).
Even though never directly called to perform a conversion, such conversion functions can be declared and can potentially be
reached through a call to a virtual conversion function in a base class.

§ 12.3.2

274

c(cid:13) ISO/IEC

N4296

5 Conversion functions can be virtual.
6 Conversion functions cannot be declared static.
7 A conversion function template shall not have a deduced return type (7.1.6.4).

12.4 Destructors
In a declaration of a destructor, the declarator is a function declarator (8.3.5) of the form

1

[class.dtor]

ptr-declarator ( parameter-declaration-clause ) exception-speciﬁcationopt attribute-speciﬁer-seqopt

where the ptr-declarator consists solely of an id-expression, an optional attribute-speciﬁer-seq, and optional
surrounding parentheses, and the id-expression has one of the following forms:

(1.1)

(1.2)

(1.3)

—

—

—

in a member-declaration that belongs to the member-speciﬁcation of a class but is not a friend declara-
tion (11.3), the id-expression is ~class-name and the class-name is the injected-class-name (Clause 9)
of the immediately-enclosing class;
in a member-declaration that belongs to the member-speciﬁcation of a class template but is not a
friend declaration, the id-expression is ~class-name and the class-name names the current instantia-
tion (14.6.2.1) of the immediately-enclosing class template; or
in a declaration at namespace scope or in a friend declaration, the id-expression is nested-name-speciﬁer
~class-name and the class-name names the same class as the nested-name-speciﬁer.

The class-name shall not be a typedef-name. A destructor shall take no arguments (8.3.5). In a destructor
declaration, each decl-speciﬁer of the optional decl-speciﬁer-seq shall be friend, inline, or virtual.

2 A destructor is used to destroy objects of its class type. The address of a destructor shall not be taken.
A destructor can be invoked for a const, volatile or const volatile object. const and volatile
semantics (7.1.6.1) are not applied on an object under destruction. They stop being in eﬀect when the
destructor for the most derived object (1.8) starts.

3 A declaration of a destructor that does not have an exception-speciﬁcation has the same exception speciﬁ-

cation as if had been implicitly declared (15.4).
If a class has no user-declared destructor, a destructor is implicitly declared as defaulted (8.4). An implicitly-
declared destructor is an inline public member of its class.

4

5 A defaulted destructor for a class X is deﬁned as deleted if:

(5.1)

(5.2)

(5.3)

(5.4)

(5.5)

(5.6)

—
—

—

X is a union-like class that has a variant member with a non-trivial destructor,
any potentially constructed subobject has class type M (or array thereof) and M has a deleted destructor
or a destructor that is inaccessible from the defaulted destructor,
or, for a virtual destructor, lookup of the non-array deallocation function results in an ambiguity or in
a function that is deleted or inaccessible from the defaulted destructor.

A destructor is trivial if it is not user-provided and if:

—
—
—

the destructor is not virtual,
all of the direct base classes of its class have trivial destructors, and
for all of the non-static data members of its class that are of class type (or array thereof), each such
class has a trivial destructor.

§ 12.4

275

c(cid:13) ISO/IEC

N4296

Otherwise, the destructor is non-trivial.

6 A destructor that is defaulted and not deﬁned as deleted is implicitly deﬁned when it is odr-used (3.2) to

destroy an object of its class type (3.7) or when it is explicitly defaulted after its ﬁrst declaration.

7 Before the defaulted destructor for a class is implicitly deﬁned, all the non-user-provided destructors for its

base classes and its non-static data members shall have been implicitly deﬁned.

8 After executing the body of the destructor and destroying any automatic objects allocated within the body, a
destructor for class X calls the destructors for X’s direct non-variant non-static data members, the destructors
for X’s direct base classes and, if X is the type of the most derived class (12.6.2), its destructor calls the
destructors for X’s virtual base classes. All destructors are called as if they were referenced with a qualiﬁed
name, that is, ignoring any possible virtual overriding destructors in more derived classes. Bases and
members are destroyed in the reverse order of the completion of their constructor (see 12.6.2). A return
statement (6.6.3) in a destructor might not directly return to the caller; before transferring control to the
caller, the destructors for the members and bases are called. Destructors for elements of an array are called
in reverse order of their construction (see 12.6).

9 A destructor can be declared virtual (10.3) or pure virtual (10.4); if any objects of that class or any
derived class are created in the program, the destructor shall be deﬁned. If a class has a base class with a
virtual destructor, its destructor (whether user- or implicitly-declared) is virtual.
[ Note: some language constructs have special semantics when used during destruction; see 12.7. — end
note ]

10

11 A destructor is invoked implicitly

(11.1)

(11.2)

(11.3)

(11.4)

—
—
—

—

for a constructed object with static storage duration (3.7.1) at program termination (3.6.3),
for a constructed object with thread storage duration (3.7.2) at thread exit,
for a constructed object with automatic storage duration (3.7.3) when the block in which an object is
created exits (6.7),
for a constructed temporary object when its lifetime ends (12.2).

In each case, the context of the invocation is the context of the construction of the object. A destructor
is also invoked implicitly through use of a delete-expression (5.3.5) for a constructed object allocated by a
new-expression (5.3.4); the context of the invocation is the delete-expression. [ Note: An array of class type
contains several subobjects for each of which the destructor is invoked. — end note ] A destructor can also
be invoked explicitly. A destructor is potentially invoked if it is invoked or as speciﬁed in 5.3.4 and 12.6.2. A
program is ill-formed if a destructor that is potentially invoked is deleted or not accessible from the context
of the invocation.

12 At the point of deﬁnition of a virtual destructor (including an implicit deﬁnition (12.8)), the non-array deal-
location function is determined as if for the expression delete this appearing in a non-virtual destructor
of the destructor’s class (see 5.3.5). If the lookup fails or if the deallocation function has a deleted deﬁni-
tion (8.4), the program is ill-formed. [ Note: This assures that a deallocation function corresponding to the
dynamic type of an object is available for the delete-expression (12.5). — end note ]
In an explicit destructor call, the destructor name appears as a ~ followed by a type-name or decltype-
speciﬁer that denotes the destructor’s class type. The invocation of a destructor is subject to the usual
rules for member functions (9.3); that is, if the object is not of the destructor’s class type and not of a class
derived from the destructor’s class type (including when the destructor is invoked via a null pointer value),
the program has undeﬁned behavior. [ Note: invoking delete on a null pointer does not call the destructor;
see 5.3.5. — end note ] [ Example:

13

struct B {

virtual ~B() { }

§ 12.4

276

c(cid:13) ISO/IEC

N4296

};
struct D : B {

~D() { }

};

D D_object;
typedef B B_alias;
B* B_ptr = &D_object;

void f() {

D_object.B::~B();
B_ptr->~B();
B_ptr->~B_alias();
B_ptr->B_alias::~B();
B_ptr->B_alias::~B_alias();

// calls B’s destructor
// calls D’s destructor
// calls D’s destructor
// calls B’s destructor
// calls B’s destructor

}

}

14

— end example ] [ Note: An explicit destructor call must always be written using a member access opera-
tor (5.2.5) or a qualiﬁed-id (5.1); in particular, the unary-expression ~X() in a member function is not an
explicit destructor call (5.3.1). — end note ]
[ Note: explicit calls of destructors are rarely needed. One use of such calls is for objects placed at speciﬁc
addresses using a placement new-expression. Such use of explicit placement and destruction of objects can
be necessary to cope with dedicated hardware resources and for writing memory management facilities. For
example,

void* operator new(std::size_t, void* p) { return p; }
struct X {
X(int);
~X();

};
void f(X* p);

void g() {

char* buf = new char[sizeof(X)];
X* p = new(buf) X(222);
f(p);
p->X::~X();

// cleanup

// rare, specialized use:

// use buf[] and initialize

— end note ]

15 Once a destructor is invoked for an object, the object no longer exists; the behavior is undeﬁned if the
destructor is invoked for an object whose lifetime has ended (3.8).
if the destructor for an
automatic object is explicitly invoked, and the block is subsequently left in a manner that would ordinarily
invoke implicit destruction of the object, the behavior is undeﬁned. — end example ]
[ Note: the notation for explicit call of a destructor can be used for any scalar type name (5.2.4). Allowing
this makes it possible to write code without having to know if a destructor exists for a given type. For
example,

[ Example:

16

typedef int I;
I* p;
p->I::~I();
— end note ]

§ 12.4

277

c(cid:13) ISO/IEC

12.5 Free store

N4296

[class.free]

1 Any allocation function for a class T is a static member (even if not explicitly declared static).
2

[ Example:

void* operator new(std::size_t, Arena*);

class Arena;
struct B {

};
struct D1 : B {
};

Arena*
void foo(int i) {

ap;

new (ap) D1;
new D1[i];
new D1;

}

// calls B::operator new(std::size_t, Arena*)
// calls ::operator new[](std::size_t)
// ill-formed: ::operator new(std::size_t) hidden

— end example ]

3 When an object is deleted with a delete-expression (5.3.5), a deallocation function (operator delete() for
non-array objects or operator delete[]() for arrays) is (implicitly) called to reclaim the storage occupied
by the object (3.7.4.2).

4 Class-speciﬁc deallocation function lookup is a part of general deallocation function lookup (5.3.5) and
occurs as follows. If the delete-expression is used to deallocate a class object whose static type has a virtual
destructor, the deallocation function is the one selected at the point of deﬁnition of the dynamic type’s
virtual destructor (12.4).118 Otherwise, if the delete-expression is used to deallocate an object of class T or
array thereof, the static and dynamic types of the object shall be identical and the deallocation function’s
name is looked up in the scope of T. If this lookup fails to ﬁnd the name, general deallocation function
lookup (5.3.5) continues. If the result of the lookup is ambiguous or inaccessible, or if the lookup selects a
placement deallocation function, the program is ill-formed.

5 Any deallocation function for a class X is a static member (even if not explicitly declared static). [ Example:

class X {

void operator delete(void*);
void operator delete[](void*, std::size_t);

class Y {

};

};

void operator delete(void*, std::size_t);
void operator delete[](void*);

— end example ]

6 Since member allocation and deallocation functions are static they cannot be virtual.

[ Note: however,
when the cast-expression of a delete-expression refers to an object of class type, because the deallocation
function actually called is looked up in the scope of the class that is the dynamic type of the object, if the
destructor is virtual, the eﬀect is the same. For example,

struct B {

virtual ~B();

118) A similar provision is not needed for the array version of operator delete because 5.3.5 requires that in this situation,
the static type of the object to be deleted be the same as its dynamic type.

§ 12.5

278

c(cid:13) ISO/IEC

N4296

void operator delete(void*, std::size_t);

};

struct D : B {

void operator delete(void*);

void f() {

B* bp = new D;
delete bp;

//1: uses D::operator delete(void*)

};

}

};

};

Here, storage for the non-array object of class D is deallocated by D::operator delete(), due to the
virtual destructor. — end note ] [ Note: Virtual destructors have no eﬀect on the deallocation function
actually called when the cast-expression of a delete-expression refers to an array of objects of class type. For
example,

struct B {

virtual ~B();
void operator delete[](void*, std::size_t);

struct D : B {

void operator delete[](void*, std::size_t);

void f(int i) {

D* dp = new D[i];
delete [] dp;
B* bp = new D[i];
delete[] bp;

}

// uses D::operator delete[](void*, std::size_t)

// undeﬁned behavior

— end note ]

7 Access to the deallocation function is checked statically. Hence, even though a diﬀerent one might actually
be executed, the statically visible deallocation function is required to be accessible. [ Example: for the call
on line //1 above, if B::operator delete() had been private, the delete expression would have been
ill-formed. — end example ]
[ Note: If a deallocation function has no explicit exception-speciﬁcation, it has a non-throwing exception
speciﬁcation (15.4). — end note ]
12.6 Initialization

[class.init]
1 When no initializer is speciﬁed for an object of (possibly cv-qualiﬁed) class type (or array thereof), or the

8

initializer has the form (), the object is initialized as speciﬁed in 8.5.

2 An object of class type (or array thereof) can be explicitly initialized; see 12.6.1 and 12.6.2.
3 When an array of class objects is initialized (either explicitly or implicitly) and the elements are initialized
by constructor, the constructor shall be called for each element of the array, following the subscript order;
see 8.3.4. [ Note: Destructors for the array elements are called in reverse order of their construction. — end
note ]

§ 12.6

279

c(cid:13) ISO/IEC

N4296

12.6.1 Explicit initialization

[class.expl.init]
1 An object of class type can be initialized with a parenthesized expression-list, where the expression-list
is construed as an argument list for a constructor that is called to initialize the object. Alternatively, a
single assignment-expression can be speciﬁed as an initializer using the = form of initialization. Either
direct-initialization semantics or copy-initialization semantics apply; see 8.5. [ Example:

struct complex {

complex();
complex(double);
complex(double,double);

};

complex sqrt(complex,complex);

complex a(1);

complex b = a;
complex c = complex(1,2);

complex d = sqrt(b,c);

complex e;

complex f = 3;

complex g = { 1, 2 };

// initialize by a call of
// complex(double)
// initialize by a copy of a
// construct complex(1,2)
// using complex(double,double)
// copy/move it into c
// call sqrt(complex,complex)
// and copy/move the result into d
// initialize by a call of
// complex()
// construct complex(3) using
// complex(double)
// copy/move it into f
// initialize by a call of
// complex(double, double)

— end example ] [ Note: overloading of the assignment operator (13.5.3) has no eﬀect on initialization. — end
note ]

2 An object of class type can also be initialized by a braced-init-list. List-initialization semantics apply; see 8.5

and 8.5.4. [ Example:

complex v[6] = { 1, complex(1,2), complex(), 2 };

Here, complex::complex(double) is called for the initialization of v[0] and v[3], complex::complex(
double, double) is called for the initialization of v[1], complex::complex() is called for the initialization
v[2], v[4], and v[5]. For another example,

struct X {

int i;
float f;
complex c;

} x = { 99, 88.8, 77.7 };

Here, x.i is initialized with 99, x.f is initialized with 88.8, and complex::complex(double) is called for the
initialization of x.c. — end example ] [ Note: Braces can be elided in the initializer-list for any aggregate,
even if the aggregate has members of a class type with user-deﬁned type conversions; see 8.5.1. — end note ]
[ Note: If T is a class type with no default constructor, any declaration of an object of type T (or array
thereof) is ill-formed if no initializer is explicitly speciﬁed (see 12.6 and 8.5). — end note ]
[ Note: the order in which objects with static or thread storage duration are initialized is described in 3.6.2
and 6.7. — end note ]

3

4

§ 12.6.1

280

c(cid:13) ISO/IEC

N4296

1

Initializing bases and members

[class.base.init]
12.6.2
In the deﬁnition of a constructor for a class, initializers for direct and virtual base subobjects and non-static
data members can be speciﬁed by a ctor-initializer, which has the form

ctor-initializer:

: mem-initializer-list

mem-initializer-list:

mem-initializer ...opt
mem-initializer-list , mem-initializer ...opt

mem-initializer:

mem-initializer-id ( expression-listopt)
mem-initializer-id braced-init-list

mem-initializer-id:

class-or-decltype
identiﬁer

2

In a mem-initializer-id an initial unqualiﬁed identiﬁer is looked up in the scope of the constructor’s class
and, if not found in that scope, it is looked up in the scope containing the constructor’s deﬁnition. [ Note:
If the constructor’s class contains a member with the same name as a direct or virtual base class of the
class, a mem-initializer-id naming the member or base class and composed of a single identiﬁer refers to
the class member. A mem-initializer-id for the hidden base class may be speciﬁed using a qualiﬁed name.
— end note ] Unless the mem-initializer-id names the constructor’s class, a non-static data member of the
constructor’s class, or a direct or virtual base of that class, the mem-initializer is ill-formed.

3 A mem-initializer-list can initialize a base class using any class-or-decltype that denotes that base class type.

[ Example:

struct A { A(); };

typedef A global_A;
struct B { };
struct C: public A, public B { C(); };
C::C(): global_A() { }

// mem-initializer for base A

4

— end example ]
If a mem-initializer-id is ambiguous because it designates both a direct non-virtual base class and an inherited
virtual base class, the mem-initializer is ill-formed. [ Example:

struct A { A(); };
struct B: public virtual A { };
struct C: public A, public B { C(); };
C::C(): A() { }

// ill-formed: which A?

— end example ]

5 A ctor-initializer may initialize a variant member of the constructor’s class. If a ctor-initializer speciﬁes more
than one mem-initializer for the same member or for the same base class, the ctor-initializer is ill-formed.
6 A mem-initializer-list can delegate to another constructor of the constructor’s class using any class-or-
decltype that denotes the constructor’s class itself. If a mem-initializer-id designates the constructor’s class,
it shall be the only mem-initializer; the constructor is a delegating constructor, and the constructor selected
by the mem-initializer is the target constructor. The principal constructor is the ﬁrst constructor invoked
in the construction of an object (that is, not a target constructor for that object’s construction). The
target constructor is selected by overload resolution. Once the target constructor returns, the body of the
delegating constructor is executed. If a constructor delegates to itself directly or indirectly, the program is
ill-formed; no diagnostic is required. [ Example:

struct C {

§ 12.6.2

281

c(cid:13) ISO/IEC

C( int ) { }
C(): C(42) { }
C( char c ) : C(42.0) { }
C( double d ) : C(’a’) { }

};

— end example ]

// #1: non-delegating constructor
// #2: delegates to #1
// #3: ill-formed due to recursion with #4
// #4: ill-formed due to recursion with #3

N4296

7 The expression-list or braced-init-list in a mem-initializer is used to initialize the designated subobject (or,
in the case of a delegating constructor, the complete class object) according to the initialization rules of 8.5
for direct-initialization.
[ Example:

struct B1 { B1(int); /∗ ... ∗/ };
struct B2 { B2(int); /∗ ... ∗/ };
struct D : B1, B2 {

D(int);
B1 b;
const int c;

};

D::D(int a) : B2(a+1), B1(a+2), c(a+3), b(a+4)

{ /∗ ... ∗/ }

D d(10);

— end example ] The initialization performed by each mem-initializer constitutes a full-expression. Any
expression in a mem-initializer is evaluated as part of the full-expression that performs the initialization.
A mem-initializer where the mem-initializer-id denotes a virtual base class is ignored during execution of a
constructor of any class that is not the most derived class.

8 A temporary expression bound to a reference member in a mem-initializer is ill-formed. [ Example:

struct A {
A() : v(42) { } // error

const int& v;

};

9

— end example ]
In a non-delegating constructor, if a given potentially constructed subobject is not designated by a mem-
initializer-id (including the case where there is no mem-initializer-list because the constructor has no ctor-
initializer), then

—

(9.1)
(9.1.1)

(9.1.2)

(9.2)

(9.3)

—
—

—

if the entity is a non-static data member that has a brace-or-equal-initializer and either
—

the constructor’s class is a union (9.5), and no other variant member of that union is designated
by a mem-initializer-id or
the constructor’s class is not a union, and, if the entity is a member of an anonymous union, no
other member of that union is designated by a mem-initializer-id,

the entity is initialized as speciﬁed in 8.5;
otherwise, if the entity is an anonymous union or a variant member (9.5), no initialization is performed;
otherwise, the entity is default-initialized (8.5).

[ Note: An abstract class (10.4) is never a most derived class, thus its constructors never initialize virtual
base classes, therefore the corresponding mem-initializers may be omitted. — end note ] An attempt to
initialize more than one non-static data member of a union renders the program ill-formed. [ Note: After the

§ 12.6.2

282

c(cid:13) ISO/IEC

N4296

call to a constructor for class X for an object with automatic or dynamic storage duration has completed, if
the constructor was not invoked as part of value-initialization and a member of X is neither initialized nor
given a value during execution of the compound-statement of the body of the constructor, the member has
an indeterminate value. — end note ] [ Example:

struct A {

A();

};

struct B {
B(int);

};

struct C {
C() { }
A a;
const B b;
int i;
int j = 5;

};

// initializes members as follows:

// OK: calls A::A()
// error: B has no default constructor
// OK: i has indeterminate value
// OK: j has the value 5

10

— end example ]
If a given non-static data member has both a brace-or-equal-initializer and a mem-initializer, the initializa-
tion speciﬁed by the mem-initializer is performed, and the non-static data member’s brace-or-equal-initializer
is ignored. [ Example: Given

struct A {

int i = /∗ some integer expression with side eﬀects ∗/ ;
A(int arg) : i(arg) { }
// ...

};

the A(int) constructor will simply initialize i to the value of arg, and the side eﬀects in i’s brace-or-equal-
initializer will not take place. — end example ]

11 A temporary expression bound to a reference member from a brace-or-equal-initializer is ill-formed. [ Example:

Given

struct A {

A() = default;
A(int v) : v(v) { }
const int& v = 42;

};
A a1;
A a2(1);

// OK
// OK
// OK

// error: ill-formed binding of temporary to reference
// OK, unfortunately

— end example ]
In a non-delegating constructor, the destructor for each potentially constructed subobject of class type is
potentially invoked (12.4). [ Note: This provision ensures that destructors can be called for fully-constructed
sub-objects in case an exception is thrown (15.2). — end note ]
In a non-delegating constructor, initialization proceeds in the following order:

12

13

(13.1)

—

First, and only for the constructor of the most derived class (1.8), virtual base classes are initialized in
the order they appear on a depth-ﬁrst left-to-right traversal of the directed acyclic graph of base classes,
where “left-to-right” is the order of appearance of the base classes in the derived class base-speciﬁer-list.

§ 12.6.2

283

c(cid:13) ISO/IEC

N4296

(13.2)

(13.3)

(13.4)

—

—

—

Then, direct base classes are initialized in declaration order as they appear in the base-speciﬁer-list
(regardless of the order of the mem-initializers).
Then, non-static data members are initialized in the order they were declared in the class deﬁnition
(again regardless of the order of the mem-initializers).
Finally, the compound-statement of the constructor body is executed.

[ Note: The declaration order is mandated to ensure that base and member subobjects are destroyed in the
reverse order of initialization. — end note ]
[ Example:

14

struct V {

V();
V(int);

};

struct A : virtual V {

A();
A(int);

B();
B(int);

};

};

struct B : virtual V {

struct C : A, B, virtual V {

C();
C(int);

};
A::A(int i) : V(i) { /∗ ... ∗/ }
B::B(int i) { /∗ ... ∗/ }
C::C(int i) { /∗ ... ∗/ }

V v(1);
A a(2);
B b(3);
C c(4);

— end example ]

// use V(int)
// use V(int)
// use V()
// use V()

15 Names in the expression-list or braced-init-list of a mem-initializer are evaluated in the scope of the con-

structor for which the mem-initializer is speciﬁed. [ Example:

class X {
int a;
int b;
int i;
int j;
public:

};

const int& r;
X(int i): r(a), b(i), i(i), j(this->i) { }

§ 12.6.2

284

c(cid:13) ISO/IEC

N4296

initializes X::r to refer to X::a, initializes X::b with the value of the constructor parameter i, initializes X::i
with the value of the constructor parameter i, and initializes X::j with the value of X::i; this takes place
each time an object of class X is created. — end example ] [ Note: Because the mem-initializer are evaluated
in the scope of the constructor, the this pointer can be used in the expression-list of a mem-initializer to
refer to the object being initialized. — end note ]

16 Member functions (including virtual member functions, 10.3) can be called for an object under construction.
Similarly, an object under construction can be the operand of the typeid operator (5.2.8) or of a dynamic_-
cast (5.2.7). However, if these operations are performed in a ctor-initializer (or in a function called directly
or indirectly from a ctor-initializer) before all the mem-initializers for base classes have completed, the result
of the operation is undeﬁned. [ Example:

class A {
public:

A(int);

};

class B : public A {

int j;
public:

int f();
B() : A(f()),

j(f()) { }

};

class C {
public:

C(int);

};

// undeﬁned: calls member function
// but base A not yet initialized
// well-deﬁned: bases are all initialized

class D : public B, C {

int i;
public:

D() : C(f()),

i(f()) { }

};

// undeﬁned: calls member function
// but base C not yet initialized
// well-deﬁned: bases are all initialized

17

— end example ]
[ Note: 12.7 describes the result of virtual function calls, typeid and dynamic_casts during construction for
the well-deﬁned cases; that is, describes the polymorphic behavior of an object under construction. — end
note ]

18 A mem-initializer followed by an ellipsis is a pack expansion (14.5.3) that initializes the base classes speciﬁed

by a pack expansion in the base-speciﬁer-list for the class. [ Example:

template<class... Mixins>
class X : public Mixins... {
public:

X(const Mixins&... mixins) : Mixins(mixins)... { }

};

— end example ]

§ 12.6.2

285

c(cid:13) ISO/IEC

N4296

12.7 Construction and destruction

[class.cdtor]
1 For an object with a non-trivial constructor, referring to any non-static member or base class of the object
before the constructor begins execution results in undeﬁned behavior. For an object with a non-trivial
destructor, referring to any non-static member or base class of the object after the destructor ﬁnishes
execution results in undeﬁned behavior. [ Example:

struct X { int i; };
struct Y : X { Y(); };
struct A { int a; };
struct B : public A { int j; Y y; };

// non-trivial

// non-trivial

extern B bobj;
B* pb = &bobj;
int* p1 = &bobj.a;
int* p2 = &bobj.y.i;

A* pa = &bobj;
B bobj;

extern X xobj;
int* p3 = &xobj.i;
X xobj;

2 For another example,

// OK
// undeﬁned, refers to base class member
// undeﬁned, refers to member’s member

// undeﬁned, upcast to a base class type
// deﬁnition of bobj

//OK, X is a trivial class

struct W { int j; };
struct X : public virtual W { };
struct Y {
int* p;
X x;
Y() : p(&x.j) {

// undeﬁned, x is not yet constructed

}

};

— end example ]

3 To explicitly or implicitly convert a pointer (a glvalue) referring to an object of class X to a pointer (reference)
to a direct or indirect base class B of X, the construction of X and the construction of all of its direct or
indirect bases that directly or indirectly derive from B shall have started and the destruction of these classes
shall not have completed, otherwise the conversion results in undeﬁned behavior. To form a pointer to (or
access the value of) a direct non-static member of an object obj, the construction of obj shall have started
and its destruction shall not have completed, otherwise the computation of the pointer value (or accessing
the member value) results in undeﬁned behavior. [ Example:

struct A { };
struct B : virtual A { };
struct C : B { };
struct D : virtual A { D(A*); };
struct X { X(A*); };

struct E : C, D, X {

E() : D(this),

// undeﬁned: upcast from E* to A*
// might use path E* → D* → A*
// but D is not constructed
// D((C*)this), // deﬁned:
// E* → C* deﬁned because E() has started

§ 12.7

286

c(cid:13) ISO/IEC

X(this) {

}
};

— end example ]

// and C* → A* deﬁned because
// C fully constructed
// deﬁned: upon construction of X,
// C/B/D/A sublattice is fully constructed

N4296

4 Member functions, including virtual functions (10.3), can be called during construction or destruction (12.6.2).
When a virtual function is called directly or indirectly from a constructor or from a destructor, including
during the construction or destruction of the class’s non-static data members, and the object to which the
call applies is the object (call it x) under construction or destruction, the function called is the ﬁnal overrider
in the constructor’s or destructor’s class and not one overriding it in a more-derived class. If the virtual
function call uses an explicit class member access (5.2.5) and the object expression refers to the complete
object of x or one of that object’s base class subobjects but not x or one of its base class subobjects, the
behavior is undeﬁned. [ Example:

struct V {

virtual void f();
virtual void g();

};

struct A : virtual V {

virtual void f();

};

struct B : virtual V {

virtual void g();
B(V*, A*);

};

struct D : A, B {

virtual void f();
virtual void g();
D() : B((A*)this, this) { }

B::B(V* v, A* a) {

};

}

f();
g();
v->g();
a->f();

// calls V::f, not A::f
// calls B::g, not D::g
// v is base of B, the call is well-deﬁned, calls B::g
// undeﬁned behavior, a’s type not a base of B

— end example ]

5 The typeid operator (5.2.8) can be used during construction or destruction (12.6.2). When typeid is used
in a constructor (including the mem-initializer or brace-or-equal-initializer for a non-static data member) or
in a destructor, or used in a function called (directly or indirectly) from a constructor or destructor, if the
operand of typeid refers to the object under construction or destruction, typeid yields the std::type_info
object representing the constructor or destructor’s class. If the operand of typeid refers to the object under
construction or destruction and the static type of the operand is neither the constructor or destructor’s class
nor one of its bases, the result of typeid is undeﬁned.

§ 12.7

287

c(cid:13) ISO/IEC

N4296

6 dynamic_casts (5.2.7) can be used during construction or destruction (12.6.2). When a dynamic_cast
is used in a constructor (including the mem-initializer or brace-or-equal-initializer for a non-static data
member) or in a destructor, or used in a function called (directly or indirectly) from a constructor or
destructor, if the operand of the dynamic_cast refers to the object under construction or destruction, this
object is considered to be a most derived object that has the type of the constructor or destructor’s class. If
the operand of the dynamic_cast refers to the object under construction or destruction and the static type
of the operand is not a pointer to or object of the constructor or destructor’s own class or one of its bases,
the dynamic_cast results in undeﬁned behavior.
[ Example:

struct V {

virtual void f();

};

struct A : virtual V { };

struct B : virtual V {

B(V*, A*);

struct D : A, B {

D() : B((A*)this, this) { }

};

};

B::B(V* v, A* a) {

typeid(*this);
typeid(*v);

typeid(*a);
dynamic_cast<B*>(v);

dynamic_cast<B*>(a);

}

// type_info for B
// well-deﬁned: *v has type V, a base of B
// yields type_info for B
// undeﬁned behavior: type A not a base of B
// well-deﬁned: v of type V*, V base of B
// results in B*
// undeﬁned behavior,
// a has type A*, A not a base of B

— end example ]
12.8 Copying and moving class objects

[class.copy]
1 A class object can be copied or moved in two ways: by initialization (12.1, 8.5), including for function argu-
ment passing (5.2.2) and for function value return (6.6.3); and by assignment (5.18). Conceptually, these two
operations are implemented by a copy/move constructor (12.1) and copy/move assignment operator (13.5.3).
2 A non-template constructor for class X is a copy constructor if its ﬁrst parameter is of type X&, const X&,
volatile X& or const volatile X&, and either there are no other parameters or else all other parameters
have default arguments (8.3.6). [ Example: X::X(const X&) and X::X(X&,int=1) are copy constructors.

struct X {
X(int);
X(const X&, int = 1);

};
X a(1);
X b(a, 0);
X c = b;

// calls X(int);
// calls X(const X&, int);
// calls X(const X&, int);

— end example ]

§ 12.8

288

c(cid:13) ISO/IEC

N4296

3 A non-template constructor for class X is a move constructor if its ﬁrst parameter is of type X&&, const
X&&, volatile X&&, or const volatile X&&, and either there are no other parameters or else all other
parameters have default arguments (8.3.6). [ Example: Y::Y(Y&&) is a move constructor.

struct Y {

Y(const Y&);
Y(Y&&);

};
extern Y f(int);
Y d(f(1));
Y e = d;

// calls Y(Y&&)
// calls Y(const Y&)

— end example ]
[ Note: All forms of copy/move constructor may be declared for a class. [ Example:

4

struct X {

X(const X&);
X(X&);
X(X&&);
X(const X&&);

};

// OK

// OK, but possibly not sensible

5

— end example ] — end note ]
[ Note: If a class X only has a copy constructor with a parameter of type X&, an initializer of type const X
or volatile X cannot initialize an object of type (possibly cv-qualiﬁed) X. [ Example:

struct X {

X();
X(X&);

};
const X cx;
X x = cx;

// default constructor
// copy constructor with a nonconst parameter

// error: X::X(X&) cannot copy cx into x

— end example ] — end note ]

6 A declaration of a constructor for a class X is ill-formed if its ﬁrst parameter is of type (optionally cv-qualiﬁed)
X and either there are no other parameters or else all other parameters have default arguments. A member
function template is never instantiated to produce such a constructor signature. [ Example:

struct S {

template<typename T> S(T);
S();

};

S g;

void h() {
S a(g);

}

// does not instantiate the member template to produce S::S<S>(S);
// uses the implicitly declared copy constructor

7

— end example ]
If the class deﬁnition does not explicitly declare a copy constructor, one is declared implicitly. If the class
deﬁnition declares a move constructor or move assignment operator, the implicitly declared copy constructor
is deﬁned as deleted; otherwise, it is deﬁned as defaulted (8.4). The latter case is deprecated if the class has
a user-declared copy assignment operator or a user-declared destructor.

§ 12.8

289

c(cid:13) ISO/IEC

N4296

8 The implicitly-declared copy constructor for a class X will have the form

X::X(const X&)

if each potentially constructed subobject of a class type M (or array thereof) has a copy constructor whose ﬁrst
parameter is of type const M& or const volatile M&.119 Otherwise, the implicitly-declared copy constructor
will have the form

X::X(X&)

9

If the deﬁnition of a class X does not explicitly declare a move constructor, one will be implicitly declared
as defaulted if and only if

(9.1)

(9.2)

(9.3)

(9.4)

—
—
—
—

X does not have a user-declared copy constructor,
X does not have a user-declared copy assignment operator,
X does not have a user-declared move assignment operator, and
X does not have a user-declared destructor.

[ Note: When the move constructor is not implicitly declared or explicitly supplied, expressions that otherwise
would have invoked the move constructor may instead invoke a copy constructor. — end note ]

10 The implicitly-declared move constructor for class X will have the form

X::X(X&&)

11 An implicitly-declared copy/move constructor is an inline public member of its class. A defaulted copy/

move constructor for a class X is deﬁned as deleted (8.4.3) if X has:

(11.1)

(11.2)

(11.3)

(11.4)

—
—

—

—

a variant member with a non-trivial corresponding constructor and X is a union-like class,
a potentially constructed subobject type M (or array thereof) that cannot be copied/moved because
overload resolution (13.3), as applied to M’s corresponding constructor, results in an ambiguity or a
function that is deleted or inaccessible from the defaulted constructor,
any potentially constructed subobject of a type with a destructor that is deleted or inaccessible from
the defaulted constructor, or,
for the copy constructor, a non-static data member of rvalue reference type.

A defaulted move constructor that is deﬁned as deleted is ignored by overload resolution (13.3, 13.4). [ Note:
A deleted move constructor would otherwise interfere with initialization from an rvalue which can use the
copy constructor instead. — end note ]

12 A copy/move constructor for class X is trivial if it is not user-provided, its parameter-type-list is equivalent

to the parameter-type-list of an implicit declaration, and if

(12.1)

(12.2)

(12.3)

(12.4)

—
—
—
—

class X has no virtual functions (10.3) and no virtual base classes (10.1), and
class X has no non-static data members of volatile-qualiﬁed type, and
the constructor selected to copy/move each direct base class subobject is trivial, and
for each non-static data member of X that is of class type (or array thereof), the constructor selected
to copy/move that member is trivial;

119) This implies that the reference parameter of the implicitly-declared copy constructor cannot bind to a volatile lvalue;
see C.1.9.

§ 12.8

290

c(cid:13) ISO/IEC

N4296

otherwise the copy/move constructor is non-trivial.

13 A copy/move constructor that is defaulted and not deﬁned as deleted is implicitly deﬁned if it is odr-
used (3.2) or when it is explicitly defaulted after its ﬁrst declaration. [ Note: The copy/move constructor is
implicitly deﬁned even if the implementation elided its odr-use (3.2, 12.2). — end note ] If the implicitly-
deﬁned constructor would satisfy the requirements of a constexpr constructor (7.1.5), the implicitly-deﬁned
constructor is constexpr.

14 Before the defaulted copy/move constructor for a class is implicitly deﬁned, all non-user-provided copy/-
move constructors for its potentially constructed subobjects shall have been implicitly deﬁned. [ Note: An
implicitly-declared copy/move constructor has an implied exception speciﬁcation (15.4). — end note ]

15 The implicitly-deﬁned copy/move constructor for a non-union class X performs a memberwise copy/move
of its bases and members.
[ Note: brace-or-equal-initializers of non-static data members are ignored. See
also the example in 12.6.2. — end note ] The order of initialization is the same as the order of initialization
of bases and members in a user-deﬁned constructor (see 12.6.2). Let x be either the parameter of the
constructor or, for the move constructor, an xvalue referring to the parameter. Each base or non-static data
member is copied/moved in the manner appropriate to its type:

(15.1)

(15.2)

(15.3)

—
—
—

if the member is an array, each element is direct-initialized with the corresponding subobject of x;
if a member m has rvalue reference type T&&, it is direct-initialized with static_cast<T&&>(x.m);
otherwise, the base or member is direct-initialized with the corresponding base or member of x.

Virtual base class subobjects shall be initialized only once by the implicitly-deﬁned copy/move constructor
(see 12.6.2).

16 The implicitly-deﬁned copy/move constructor for a union X copies the object representation (3.9) of X.
17 A user-declared copy assignment operator X::operator= is a non-static non-template member function of
class X with exactly one parameter of type X, X&, const X&, volatile X& or const volatile X&.120 [ Note:
An overloaded assignment operator must be declared to have only one parameter; see 13.5.3. — end note ]
[ Note: More than one form of copy assignment operator may be declared for a class. — end note ] [ Note:
If a class X only has a copy assignment operator with a parameter of type X&, an expression of type const X
cannot be assigned to an object of type X. [ Example:

struct X {

X();
X& operator=(X&);

};
const X cx;
X x;
void f() {
x = cx;

}

// error: X::operator=(X&) cannot assign cx into x

18

— end example ] — end note ]
If the class deﬁnition does not explicitly declare a copy assignment operator, one is declared implicitly. If
the class deﬁnition declares a move constructor or move assignment operator, the implicitly declared copy
assignment operator is deﬁned as deleted; otherwise, it is deﬁned as defaulted (8.4). The latter case is
deprecated if the class has a user-declared copy constructor or a user-declared destructor. The implicitly-
declared copy assignment operator for a class X will have the form
120) Because a template assignment operator or an assignment operator taking an rvalue reference parameter is never a
copy assignment operator, the presence of such an assignment operator does not suppress the implicit declaration of a copy
assignment operator. Such assignment operators participate in overload resolution with other assignment operators, including
copy assignment operators, and, if selected, will be used to assign an object.

§ 12.8

291

c(cid:13) ISO/IEC

X& X::operator=(const X&)

N4296

if

(18.1)

(18.2)

—

—

each direct base class B of X has a copy assignment operator whose parameter is of type const B&,
const volatile B& or B, and
for all the non-static data members of X that are of a class type M (or array thereof), each such class
type has a copy assignment operator whose parameter is of type const M&, const volatile M& or M.121

Otherwise, the implicitly-declared copy assignment operator will have the form

X& X::operator=(X&)

19 A user-declared move assignment operator X::operator= is a non-static non-template member function of
class X with exactly one parameter of type X&&, const X&&, volatile X&&, or const volatile X&&. [ Note:
An overloaded assignment operator must be declared to have only one parameter; see 13.5.3. — end note ]
[ Note: More than one form of move assignment operator may be declared for a class. — end note ]
If the deﬁnition of a class X does not explicitly declare a move assignment operator, one will be implicitly
declared as defaulted if and only if

20

(20.1)

(20.2)

(20.3)

(20.4)

—
—
—
—

X does not have a user-declared copy constructor,
X does not have a user-declared move constructor,
X does not have a user-declared copy assignment operator, and
X does not have a user-declared destructor.

[ Example: The class deﬁnition

struct S {

int a;
S& operator=(const S&) = default;

will not have a default move assignment operator implicitly declared because the copy assignment operator
has been user-declared. The move assignment operator may be explicitly defaulted.

};

};

struct S {

int a;
S& operator=(const S&) = default;
S& operator=(S&&) = default;

— end example ]

21 The implicitly-declared move assignment operator for a class X will have the form

X& X::operator=(X&&);

22 The implicitly-declared copy/move assignment operator for class X has the return type X&; it returns the
object for which the assignment operator is invoked, that is, the object assigned to. An implicitly-declared
copy/move assignment operator is an inline public member of its class.

23 A defaulted copy/move assignment operator for class X is deﬁned as deleted if X has:

121) This implies that the reference parameter of the implicitly-declared copy assignment operator cannot bind to a volatile
lvalue; see C.1.9.

§ 12.8

292

c(cid:13) ISO/IEC

N4296

(23.1)

(23.2)

(23.3)

(23.4)

—
—
—
—

a variant member with a non-trivial corresponding assignment operator and X is a union-like class, or
a non-static data member of const non-class type (or array thereof), or
a non-static data member of reference type, or
a potentially constructed subobject of class type M (or array thereof) that cannot be copied/moved
because overload resolution (13.3), as applied to M’s corresponding assignment operator, results in an
ambiguity or a function that is deleted or inaccessible from the defaulted assignment operator.

A defaulted move assignment operator that is deﬁned as deleted is ignored by overload resolution (13.3,
13.4).

24 Because a copy/move assignment operator is implicitly declared for a class if not declared by the user, a
base class copy/move assignment operator is always hidden by the corresponding assignment operator of a
derived class (13.5.3). A using-declaration (7.3.3) that brings in from a base class an assignment operator
with a parameter type that could be that of a copy/move assignment operator for the derived class is not
considered an explicit declaration of such an operator and does not suppress the implicit declaration of the
derived class operator; the operator introduced by the using-declaration is hidden by the implicitly-declared
operator in the derived class.

25 A copy/move assignment operator for class X is trivial if it is not user-provided, its parameter-type-list is

equivalent to the parameter-type-list of an implicit declaration, and if

(25.1)

(25.2)

(25.3)

(25.4)

—
—
—
—

class X has no virtual functions (10.3) and no virtual base classes (10.1), and
class X has no non-static data members of volatile-qualiﬁed type, and
the assignment operator selected to copy/move each direct base class subobject is trivial, and
for each non-static data member of X that is of class type (or array thereof), the assignment operator
selected to copy/move that member is trivial;

otherwise the copy/move assignment operator is non-trivial.

26 A copy/move assignment operator for a class X that is defaulted and not deﬁned as deleted is implicitly
deﬁned when it is odr-used (3.2) (e.g., when it is selected by overload resolution to assign to an object of
its class type) or when it is explicitly defaulted after its ﬁrst declaration. The implicitly-deﬁned copy/move
assignment operator is constexpr if

(26.1)

(26.2)

(26.3)

—
—

—

X is a literal type, and
the assignment operator selected to copy/move each direct base class subobject is a constexpr function,
and
for each non-static data member of X that is of class type (or array thereof), the assignment operator
selected to copy/move that member is a constexpr function.

27 Before the defaulted copy/move assignment operator for a class is implicitly deﬁned, all non-user-provided
copy/move assignment operators for its direct base classes and its non-static data members shall have been
implicitly deﬁned. [ Note: An implicitly-declared copy/move assignment operator has an implied exception
speciﬁcation (15.4). — end note ]

28 The implicitly-deﬁned copy/move assignment operator for a non-union class X performs memberwise copy-
/move assignment of its subobjects. The direct base classes of X are assigned ﬁrst, in the order of their
declaration in the base-speciﬁer-list, and then the immediate non-static data members of X are assigned, in
the order in which they were declared in the class deﬁnition. Let x be either the parameter of the function
or, for the move operator, an xvalue referring to the parameter. Each subobject is assigned in the manner
appropriate to its type:

§ 12.8

293

c(cid:13) ISO/IEC

N4296

(28.1)

(28.2)

(28.3)

—

—
—

if the subobject is of class type, as if by a call to operator= with the subobject as the object expression
and the corresponding subobject of x as a single function argument (as if by explicit qualiﬁcation; that
is, ignoring any possible virtual overriding functions in more derived classes);
if the subobject is an array, each element is assigned, in the manner appropriate to the element type;
if the subobject is of scalar type, the built-in assignment operator is used.

It is unspeciﬁed whether subobjects representing virtual base classes are assigned more than once by the
implicitly-deﬁned copy/move assignment operator. [ Example:

struct V { };
struct A : virtual V { };
struct B : virtual V { };
struct C : B, A { };

It is unspeciﬁed whether the virtual base class subobject V is assigned twice by the implicitly-deﬁned copy-
/move assignment operator for C. — end example ]

29 The implicitly-deﬁned copy assignment operator for a union X copies the object representation (3.9) of X.
30 A program is ill-formed if the copy/move constructor or the copy/move assignment operator for an object is
implicitly odr-used and the special member function is not accessible (Clause 11). [ Note: Copying/moving
one object into another using the copy/move constructor or the copy/move assignment operator does not
change the layout or size of either object. — end note ]

31 When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class
object, even if the constructor selected for the copy/move operation and/or the destructor for the object
have side eﬀects. In such cases, the implementation treats the source and target of the omitted copy/move
operation as simply two diﬀerent ways of referring to the same object, and the destruction of that object
occurs at the later of the times when the two objects would have been destroyed without the optimization.122
This elision of copy/move operations, called copy elision, is permitted in the following circumstances (which
may be combined to eliminate multiple copies):

(31.1)

—

(31.2)

—

(31.3)

(31.4)

—

—

in a return statement in a function with a class return type, when the expression is the name of a
non-volatile automatic object (other than a function or catch-clause parameter) with the same cv-
unqualiﬁed type as the function return type, the copy/move operation can be omitted by constructing
the automatic object directly into the function’s return value
in a throw-expression (5.17), when the operand is the name of a non-volatile automatic object (other than
a function or catch-clause parameter) whose scope does not extend beyond the end of the innermost
enclosing try-block (if there is one), the copy/move operation from the operand to the exception
object (15.1) can be omitted by constructing the automatic object directly into the exception object
when a temporary class object that has not been bound to a reference (12.2) would be copied/moved
to a class object with the same cv-unqualiﬁed type, the copy/move operation can be omitted by
constructing the temporary object directly into the target of the omitted copy/move
when the exception-declaration of an exception handler (Clause 15) declares an object of the same type
(except for cv-qualiﬁcation) as the exception object (15.1), the copy operation can be omitted by
treating the exception-declaration as an alias for the exception object if the meaning of the program will
be unchanged except for the execution of constructors and destructors for the object declared by the
exception-declaration. [ Note: There cannot be a move from the exception object because it is always an
lvalue. — end note ]

122) Because only one object is destroyed instead of two, and one copy/move constructor is not executed, there is still one
object destroyed for each one constructed.

§ 12.8

294

c(cid:13) ISO/IEC

[ Example:

N4296

class Thing {
public:

Thing();
~Thing();
Thing(const Thing&);

};

Thing f() {
Thing t;
return t;

}

Thing t2 = f();

Here the criteria for elision can be combined to eliminate two calls to the copy constructor of class Thing:
the copying of the local automatic object t into the temporary object for the return value of function f()
and the copying of that temporary object into object t2. Eﬀectively, the construction of the local object t
can be viewed as directly initializing the global object t2, and that object’s destruction will occur at program
exit. Adding a move constructor to Thing has the same eﬀect, but it is the move construction from the
temporary object to t2 that is elided. — end example ]

32 When the criteria for elision of a copy/move operation are met, but not for an exception-declaration, and the
object to be copied is designated by an lvalue, or when the expression in a return statement is a (possibly
parenthesized) id-expression that names an object with automatic storage duration declared in the body or
parameter-declaration-clause of the innermost enclosing function or lambda-expression, overload resolution
to select the constructor for the copy is ﬁrst performed as if the object were designated by an rvalue. If
the ﬁrst overload resolution fails or was not performed, or if the type of the ﬁrst parameter of the selected
constructor is not an rvalue reference to the object’s type (possibly cv-qualiﬁed), overload resolution is
performed again, considering the object as an lvalue.
[ Note: This two-stage overload resolution must be
performed regardless of whether copy elision will occur. It determines the constructor to be called if elision
is not performed, and the selected constructor must be accessible even if the call is elided. — end note ]
[ Example:

class Thing {
public:

Thing();
~Thing();
Thing(Thing&&);

private:

Thing(const Thing&);

};

}

Thing f(bool b) {

Thing t;
if (b)

throw t;
return t;

// OK: Thing(Thing&&) used (or elided) to throw t
// OK: Thing(Thing&&) used (or elided) to return t

Thing t2 = f(false);

// OK: Thing(Thing&&) used (or elided) to construct t2

— end example ]

§ 12.8

295

c(cid:13) ISO/IEC

N4296

12.9 Inheriting constructors

[class.inhctor]
1 A using-declaration (7.3.3) that names a constructor implicitly declares a set of inheriting constructors. The
candidate set of inherited constructors from the class X named in the using-declaration consists of actual
constructors and notional constructors that result from the transformation of defaulted parameters and
ellipsis parameter speciﬁcations as follows:

(1.1)

(1.2)

(1.3)

(1.4)

—

—

—

—

for each non-template constructor of X, the constructor that results from omitting any ellipsis parameter
speciﬁcation, and
for each non-template constructor of X that has at least one parameter with a default argument, the set
of constructors that results from omitting any ellipsis parameter speciﬁcation and successively omitting
parameters with a default argument from the end of the parameter-type-list, and
for each constructor template of X, the constructor template that results from omitting any ellipsis
parameter speciﬁcation, and
for each constructor template of X that has at least one parameter with a default argument, the set of
constructor templates that results from omitting any ellipsis parameter speciﬁcation and successively
omitting parameters with a default argument from the end of the parameter-type-list.

2 The constructor characteristics of a constructor or constructor template are

(2.1)

(2.2)

(2.3)

—
—
—

the template parameter list (14.1), if any,
the parameter-type-list (8.3.5), and
absence or presence of explicit (12.3.1).

3 For each non-template constructor in the candidate set of inherited constructors other than a constructor
having no parameters or a copy/move constructor having a single parameter, a constructor is implicitly
declared with the same constructor characteristics unless there is a user-declared constructor with the same
signature in the complete class where the using-declaration appears or the constructor would be a default,
copy, or move constructor for that class. Similarly, for each constructor template in the candidate set of
inherited constructors, a constructor template is implicitly declared with the same constructor characteristics
unless there is an equivalent user-declared constructor template (14.5.6.1) in the complete class where the
using-declaration appears. [ Note: Default arguments are not inherited. An exception speciﬁcation is implied
as speciﬁed in 15.4. — end note ]

4 A constructor so declared has the same access as the corresponding constructor in X. It is constexpr if the
user-written constructor (see below) would satisfy the requirements of a constexpr constructor (7.1.5). It
is deleted if the corresponding constructor in X is deleted (8.4.3) or if a defaulted default constructor (12.1)
would be deleted, except that the construction of the direct base class X is not considered in the determination.
An inheriting constructor shall not be explicitly instantiated (14.7.2) or explicitly specialized (14.7.3).
[ Note: Default and copy/move constructors may be implicitly declared as speciﬁed in 12.1 and 12.8. — end
note ]
[ Example:

6

5

struct B1 {
B1(int);

};

struct B2 {

B2(int = 13, int = 42);

};

§ 12.9

296

N4296

c(cid:13) ISO/IEC

struct D1 : B1 {
using B1::B1;

};

struct D2 : B2 {
using B2::B2;

};

The candidate set of inherited constructors in D1 for B1 is

—
—
—

B1(const B1&)

B1(B1&&)

B1(int)

The set of constructors present in D1 is

—
—
—
—

D1(), implicitly-declared default constructor, ill-formed if odr-used
D1(const D1&), implicitly-declared copy constructor, not inherited
D1(D1&&), implicitly-declared move constructor, not inherited
D1(int), implicitly-declared inheriting constructor
The candidate set of inherited constructors in D2 for B2 is

—
—
—
—
—

B2(const B2&)

B2(B2&&)

B2(int = 13, int = 42)

B2(int = 13)

B2()

The set of constructors present in D2 is

—
—
—
—
—

D2(), implicitly-declared default constructor, not inherited
D2(const D2&), implicitly-declared copy constructor, not inherited
D2(D2&&), implicitly-declared move constructor, not inherited
D2(int, int), implicitly-declared inheriting constructor
D2(int), implicitly-declared inheriting constructor

— end example ]
[ Note: If two using-declarations declare inheriting constructors with the same signatures, the program is
ill-formed (9.2, 13.1), because an implicitly-declared constructor introduced by the ﬁrst using-declaration is
not a user-declared constructor and thus does not preclude another declaration of a constructor with the
same signature by a subsequent using-declaration. [ Example:

§ 12.9

297

(6.1)

(6.2)

(6.3)

(6.4)

(6.5)

(6.6)

(6.7)

(6.8)

(6.9)

(6.10)

(6.11)

(6.12)

(6.13)

(6.14)

(6.15)

(6.16)

(6.17)

7

c(cid:13) ISO/IEC

struct B1 {
B1(int);

};

struct B2 {
B2(int);

};

N4296

// ill-formed: attempts to declare D1(int) twice

struct D1 : B1, B2 {

using B1::B1;
using B2::B2;

};

};

struct D2 : B1, B2 {

using B1::B1;
using B2::B2;
D2(int);

// OK: user declaration supersedes both implicit declarations

— end example ] — end note ]

8 An inheriting constructor for a class is implicitly deﬁned when it is odr-used (3.2) to create an object of its
class type (1.8). An implicitly-deﬁned inheriting constructor performs the set of initializations of the class
that would be performed by a user-written inline constructor for that class with a mem-initializer-list whose
only mem-initializer has a mem-initializer-id that names the base class denoted in the nested-name-speciﬁer
of the using-declaration and an expression-list as speciﬁed below, and where the compound-statement in
its function body is empty (12.6.2). If that user-written constructor would be ill-formed, the program is
ill-formed. Each expression in the expression-list is of the form static_cast<T&&>(p), where p is the name
of the corresponding constructor parameter and T is the declared type of p.
[ Example:

9

struct B1 {

B1(int) { }

};

struct B2 {

B2(double) { }

};

struct D1 : B1 {
using B1::B1;
int x;

};

// implicitly declares D1(int)

void test() {

D1 d(6);
D1 e;

}

struct D2 : B2 {
using B2::B2;
B1 b;

};

// OK: d.x is not initialized
// error: D1 has no default constructor

// OK: implicitly declares D2(double)

D2 f(1.0);

// error: B1 has no default constructor

§ 12.9

298

c(cid:13) ISO/IEC

N4296

template< class T >
struct D : T {
using T::T;
~D() { std::clog << "Destroying wrapper" << std::endl; }

// declares all constructors from class T

};

Class template D wraps any class and forwards all of its constructors, while writing a message to the standard
log whenever an object of class D is destroyed. — end example ]

§ 12.9

299

c(cid:13) ISO/IEC

13 Overloading

N4296

[over]

1 When two or more diﬀerent declarations are speciﬁed for a single name in the same scope, that name is said
to be overloaded. By extension, two declarations in the same scope that declare the same name but with
diﬀerent types are called overloaded declarations. Only function and function template declarations can be
overloaded; variable and type declarations cannot be overloaded.

2 When an overloaded function name is used in a call, which overloaded function declaration is being referenced
is determined by comparing the types of the arguments at the point of use with the types of the parameters
in the overloaded declarations that are visible at the point of use. This function selection process is called
overload resolution and is deﬁned in 13.3. [ Example:

double abs(double);
int abs(int);

abs(1);
abs(1.0);

// calls abs(int);
// calls abs(double);

— end example ]
13.1 Overloadable declarations

[over.load]
1 Not all function declarations can be overloaded. Those that cannot be overloaded are speciﬁed here. A
program is ill-formed if it contains two such non-overloadable declarations in the same scope. [ Note: This
restriction applies to explicit declarations in a scope, and between such declarations and declarations made
through a using-declaration (7.3.3). It does not apply to sets of functions fabricated as a result of name
lookup (e.g., because of using-directives) or overload resolution (e.g., for operator functions). — end note ]

2 Certain function declarations cannot be overloaded:

(2.1)

(2.2)

—
—

Function declarations that diﬀer only in the return type cannot be overloaded.
Member function declarations with the same name and the same parameter-type-list cannot be over-
loaded if any of them is a static member function declaration (9.4). Likewise, member function
template declarations with the same name, the same parameter-type-list, and the same template pa-
rameter lists cannot be overloaded if any of them is a static member function template declaration.
The types of the implicit object parameters constructed for the member functions for the purpose of
overload resolution (13.3.1) are not considered when comparing parameter-type-lists for enforcement of
this rule. In contrast, if there is no static member function declaration among a set of member func-
tion declarations with the same name and the same parameter-type-list, then these member function
declarations can be overloaded if they diﬀer in the type of their implicit object parameter. [ Example:
the following illustrates this distinction:

class X {

static void f();
void f();
void f() const;
void f() const volatile;
void g();
void g() const;
void g() const volatile;

};

§ 13.1

// ill-formed
// ill-formed
// ill-formed

// OK: no static g
// OK: no static g

300

c(cid:13) ISO/IEC

N4296

(2.3)

—

— end example ]
Member function declarations with the same name and the same parameter-type-list as well as mem-
ber function template declarations with the same name, the same parameter-type-list, and the same
template parameter lists cannot be overloaded if any of them, but not all, have a ref-qualiﬁer (8.3.5).
[ Example:

class Y {

void h() &;
void h() const &;
void h() &&;
void i() &;
void i() const;

};

— end example ]

// OK
// OK, all declarations have a ref-qualiﬁer

// ill-formed, prior declaration of i
// has a ref-qualiﬁer

3

[ Note: As speciﬁed in 8.3.5, function declarations that have equivalent parameter declarations declare the
same function and therefore cannot be overloaded:

(3.1)

—

Parameter declarations that diﬀer only in the use of equivalent typedef “types” are equivalent. A
typedef is not a separate type, but only a synonym for another type (7.1.3). [ Example:

typedef int Int;

void f(int i);
void f(Int i);
void f(int i) { /* ...
void f(Int i) { /* ...

*/ }
*/ }

// OK: redeclaration of f(int)

// error: redeﬁnition of f(int)

— end example ]
Enumerations, on the other hand, are distinct types and can be used to distinguish overloaded function
declarations. [ Example:

enum E { a };

void f(int i) { /* ...
void f(E i)
{ /* ...

*/ }
*/ }

(3.2)

—

— end example ]
Parameter declarations that diﬀer only in a pointer * versus an array [] are equivalent. That is, the
array declaration is adjusted to become a pointer declaration (8.3.5). Only the second and subsequent
array dimensions are signiﬁcant in parameter types (8.3.4). [ Example:

int f(char*);
int f(char[]);
int f(char[7]);
int f(char[9]);

int g(char(*)[10]);
int g(char[5][10]);
int g(char[7][10]);
int g(char(*)[20]);

— end example ]

// same as f(char*);
// same as f(char*);
// same as f(char*);

// same as g(char(*)[10]);
// same as g(char(*)[10]);
// diﬀerent from g(char(*)[10]);

§ 13.1

301

c(cid:13) ISO/IEC

N4296

(3.3)

—

Parameter declarations that diﬀer only in that one is a function type and the other is a pointer to
the same function type are equivalent. That is, the function type is adjusted to become a pointer to
function type (8.3.5). [ Example:

void h(int());
void h(int (*)());
void h(int x()) { }
void h(int (*x)()) { }

// redeclaration of h(int())
// deﬁnition of h(int())
// ill-formed: redeﬁnition of h(int())

(3.4)

—

— end example ]
Parameter declarations that diﬀer only in the presence or absence of const and/or volatile are
equivalent. That is, the const and volatile type-speciﬁers for each parameter type are ignored when
determining which function is being declared, deﬁned, or called. [ Example:

typedef const int cInt;

int f (int);
int f (const int);
int f (int) { /* ...
int f (cInt) { /* ...

*/ }
*/ }

// redeclaration of f(int)
// deﬁnition of f(int)
// error: redeﬁnition of f(int)

— end example ]
Only the const and volatile type-speciﬁers at the outermost level of the parameter type speciﬁca-
tion are ignored in this fashion; const and volatile type-speciﬁers buried within a parameter type
speciﬁcation are signiﬁcant and can be used to distinguish overloaded function declarations.123
In
particular, for any type T, “pointer to T,” “pointer to const T,” and “pointer to volatile T” are
considered distinct parameter types, as are “reference to T,” “reference to const T,” and “reference to
volatile T.”
Two parameter declarations that diﬀer only in their default arguments are equivalent.
consider the following:

[ Example:

(3.5)

—

void f (int i, int j);
void f (int i, int j = 99);
void f (int i = 88, int j);
void f ();

// OK: redeclaration of f(int, int)
// OK: redeclaration of f(int, int)
// OK: overloaded declaration of f

void prog () {
f (1, 2);
f (1);
f ();

}

// OK: call f(int, int)
// OK: call f(int, int)
// Error: f(int, int) or f()?

— end example ] — end note ]
13.2 Declaration matching

[over.dcl]
1 Two function declarations of the same name refer to the same function if they are in the same scope and
have equivalent parameter declarations (13.1). A function member of a derived class is not in the same scope
as a function member of the same name in a base class. [ Example:
123) When a parameter type includes a function type, such as in the case of a parameter type that is a pointer to function, the
const and volatile type-speciﬁers at the outermost level of the parameter type speciﬁcations for the inner function type are
also ignored.

§ 13.2

302

c(cid:13) ISO/IEC

N4296

struct B {

int f(int);

};

struct D : B {

int f(const char*);

};

Here D::f(const char*) hides B::f(int) rather than overloading it.

void h(D* pd) {

pd->f(1);

pd->B::f(1);
pd->f("Ben");

}

— end example ]

// error:
// D::f(const char*) hides B::f(int)
// OK
// OK, calls D::f

2 A locally declared function is not in the same scope as a function in a containing scope. [ Example:

void f(const char*);
void g() {

extern void f(int);
f("asdf");

}

void caller () {

extern void callee(int, int);
{

extern void callee(int);
callee(88, 99);

}

}

// error: f(int) hides f(const char*)
// so there is no f(const char*) in this scope

// hides callee(int, int)
// error: only callee(int) in scope

— end example ]

3 Diﬀerent versions of an overloaded member function can be given diﬀerent access rules. [ Example:

class buffer {
private:

char* p;
int size;

protected:

public:

};

buffer(int s, char* store) { size = s; p = store; }

buffer(int s) { p = new char[size = s]; }

— end example ]
13.3 Overload resolution

[over.match]
1 Overload resolution is a mechanism for selecting the best function to call given a list of expressions that are
to be the arguments of the call and a set of candidate functions that can be called based on the context of
the call. The selection criteria for the best function are the number of arguments, how well the arguments
match the parameter-type-list of the candidate function, how well (for non-static member functions) the

§ 13.3

303

c(cid:13) ISO/IEC

N4296

object matches the implicit object parameter, and certain other properties of the candidate function. [ Note:
The function selected by overload resolution is not guaranteed to be appropriate for the context. Other
restrictions, such as the accessibility of the function, can make its use in the calling context ill-formed.
— end note ]

2 Overload resolution selects the function to call in seven distinct contexts within the language:

—
—

—
—
—
—

—

invocation of a function named in the function call syntax (13.3.1.1.1);
invocation of a function call operator, a pointer-to-function conversion function, a reference-to-pointer-
to-function conversion function, or a reference-to-function conversion function on a class object named
in the function call syntax (13.3.1.1.2);
invocation of the operator referenced in an expression (13.3.1.2);
invocation of a constructor for default- or direct-initialization (8.5) of a class object (13.3.1.3);
invocation of a user-deﬁned conversion for copy-initialization (8.5) of a class object (13.3.1.4);
invocation of a conversion function for initialization of an object of a nonclass type from an expression
of class type (13.3.1.5); and
invocation of a conversion function for conversion to a glvalue or class prvalue to which a refer-
ence (8.5.3) will be directly bound (13.3.1.6).

Each of these contexts deﬁnes the set of candidate functions and the list of arguments in its own unique way.
But, once the candidate functions and argument lists have been identiﬁed, the selection of the best function
is the same in all cases:

—

—

First, a subset of the candidate functions (those that have the proper number of arguments and meet
certain other conditions) is selected to form a set of viable functions (13.3.2).
Then the best viable function is selected based on the implicit conversion sequences (13.3.3.1) needed
to match each argument to the corresponding parameter of each viable function.

(2.1)

(2.2)

(2.3)

(2.4)

(2.5)

(2.6)

(2.7)

(2.8)

(2.9)

3

If a best viable function exists and is unique, overload resolution succeeds and produces it as the result.
Otherwise overload resolution fails and the invocation is ill-formed. When overload resolution succeeds, and
the best viable function is not accessible (Clause 11) in the context in which it is used, the program is
ill-formed.
13.3.1 Candidate functions and argument lists

[over.match.funcs]
1 The subclauses of 13.3.1 describe the set of candidate functions and the argument list submitted to overload
resolution in each of the seven contexts in which overload resolution is used. The source transformations
and constructions deﬁned in these subclauses are only for the purpose of describing the overload resolution
process. An implementation is not required to use such transformations and constructions.

2 The set of candidate functions can contain both member and non-member functions to be resolved against
the same argument list. So that argument and parameter lists are comparable within this heterogeneous
set, a member function is considered to have an extra parameter, called the implicit object parameter, which
represents the object for which the member function has been called. For the purposes of overload resolution,
both static and non-static member functions have an implicit object parameter, but constructors do not.

3 Similarly, when appropriate, the context can construct an argument list that contains an implied object
argument to denote the object to be operated on. Since arguments and parameters are associated by
position within their respective lists, the convention is that the implicit object parameter, if present, is
always the ﬁrst parameter and the implied object argument, if present, is always the ﬁrst argument.

4 For non-static member functions, the type of the implicit object parameter is

§ 13.3.1

304

c(cid:13) ISO/IEC

N4296

(4.1)

(4.2)

—
—

“lvalue reference to cv X” for functions declared without a ref-qualiﬁer or with the & ref-qualiﬁer
“rvalue reference to cv X” for functions declared with the && ref-qualiﬁer

[ Example:

where X is the class of which the function is a member and cv is the cv-qualiﬁcation on the member function
declaration.
for a const member function of class X, the extra parameter is assumed to have
type “reference to const X”. — end example ] For conversion functions, the function is considered to be a
member of the class of the implied object argument for the purpose of deﬁning the type of the implicit
object parameter. For non-conversion functions introduced by a using-declaration into a derived class, the
function is considered to be a member of the derived class for the purpose of deﬁning the type of the implicit
object parameter. For static member functions, the implicit object parameter is considered to match any
object (since if the function is selected, the object is discarded).
[ Note: No actual type is established for
the implicit object parameter of a static member function, and no attempt will be made to determine a
conversion sequence for that parameter (13.3.3). — end note ]

5 During overload resolution, the implied object argument is indistinguishable from other arguments. The
implicit object parameter, however, retains its identity since conversions on the corresponding argument
shall obey these additional rules:

(5.1)

(5.2)

—
—

no temporary object can be introduced to hold the argument for the implicit object parameter; and
no user-deﬁned conversions can be applied to achieve a type match with it.

For non-static member functions declared without a ref-qualiﬁer, an additional rule applies:

(5.3)

—

even if the implicit object parameter is not const-qualiﬁed, an rvalue can be bound to the parameter as
long as in all other respects the argument can be converted to the type of the implicit object parameter.
[ Note: The fact that such an argument is an rvalue does not aﬀect the ranking of implicit conversion
sequences (13.3.3.2). — end note ]

6 Because other than in list-initialization only one user-deﬁned conversion is allowed in an implicit conversion
sequence, special rules apply when selecting the best user-deﬁned conversion (13.3.3, 13.3.3.1). [ Example:

class T {
public:
T();

};

class C : T {
public:

C(int);

};
T a = 1;

// ill-formed: T(C(1)) not tried

7

— end example ]
In each case where a candidate is a function template, candidate function template specializations are gen-
erated using template argument deduction (14.8.3, 14.8.2). Those candidates are then handled as candidate
functions in the usual way.124 A given name can refer to one or more function templates and also to a set
of overloaded non-template functions. In such a case, the candidate functions generated from each function
template are combined with the set of non-template candidate functions.

8 A defaulted move constructor or assignment operator (12.8) that is deﬁned as deleted is excluded from the

set of candidate functions in all contexts.
124) The process of argument deduction fully determines the parameter types of the function template specializations, i.e.,
the parameters of function template specializations contain no template parameter types. Therefore, except where speciﬁed
otherwise, function template specializations and non-template functions (8.3.5) are treated equivalently for the remainder of
overload resolution.

§ 13.3.1

305

c(cid:13) ISO/IEC

13.3.1.1 Function call syntax
In a function call (5.2.2)

postﬁx-expression ( expression-listopt)

N4296

[over.match.call]

if the postﬁx-expression denotes a set of overloaded functions and/or function templates, overload resolution is
applied as speciﬁed in 13.3.1.1.1. If the postﬁx-expression denotes an object of class type, overload resolution
is applied as speciﬁed in 13.3.1.1.2.
If the postﬁx-expression denotes the address of a set of overloaded functions and/or function templates,
overload resolution is applied using that set as described above. If the function selected by overload resolution
is a non-static member function, the program is ill-formed.
[ Note: The resolution of the address of an
overload set in other contexts is described in 13.4. — end note ]
13.3.1.1.1 Call to named function

[over.call.func]
1 Of interest in 13.3.1.1.1 are only those function calls in which the postﬁx-expression ultimately contains a
name that denotes one or more functions that might be called. Such a postﬁx-expression, perhaps nested
arbitrarily deep in parentheses, has one of the following forms:

1

2

2

3

postﬁx-expression:

postﬁx-expression . id-expression
postﬁx-expression -> id-expression
primary-expression

These represent two syntactic subcategories of function calls: qualiﬁed function calls and unqualiﬁed function
calls.
In qualiﬁed function calls, the name to be resolved is an id-expression and is preceded by an -> or . operator.
Since the construct A->B is generally equivalent to (*A).B, the rest of Clause 13 assumes, without loss of
generality, that all member function calls have been normalized to the form that uses an object and the
. operator. Furthermore, Clause 13 assumes that the postﬁx-expression that is the left operand of the .
operator has type “cv T” where T denotes a class125. Under this assumption, the id-expression in the call
is looked up as a member function of T following the rules for looking up names in classes (10.2). The
function declarations found by that lookup constitute the set of candidate functions. The argument list
is the expression-list in the call augmented by the addition of the left operand of the . operator in the
normalized member function call as the implied object argument (13.3.1).
In unqualiﬁed function calls, the name is not qualiﬁed by an -> or . operator and has the more general form
of a primary-expression. The name is looked up in the context of the function call following the normal rules
for name lookup in function calls (3.4). The function declarations found by that lookup constitute the set of
candidate functions. Because of the rules for name lookup, the set of candidate functions consists (1) entirely
of non-member functions or (2) entirely of member functions of some class T. In case (1), the argument list
is the same as the expression-list in the call. In case (2), the argument list is the expression-list in the call
augmented by the addition of an implied object argument as in a qualiﬁed function call. If the keyword
this (9.3.2) is in scope and refers to class T, or a derived class of T, then the implied object argument is
(*this). If the keyword this is not in scope or refers to another class, then a contrived object of type
T becomes the implied object argument126. If the argument list is augmented by a contrived object and
overload resolution selects one of the non-static member functions of T, the call is ill-formed.
125) Note that cv-qualiﬁers on the type of objects are signiﬁcant in overload resolution for both glvalue and class prvalue
objects.
126) An implied object argument must be contrived to correspond to the implicit object parameter attributed to member
functions during overload resolution. It is not used in the call to the selected function. Since the member functions all have
the same implicit object parameter, the contrived object will not be the cause to select or reject a function.

§ 13.3.1.1.1

306

c(cid:13) ISO/IEC

N4296

1

2

3

[over.call.object]
13.3.1.1.2 Call to object of class type
If the primary-expression E in the function call syntax evaluates to a class object of type “cv T”, then the
set of candidate functions includes at least the function call operators of T. The function call operators of T
are obtained by ordinary lookup of the name operator() in the context of (E).operator().
In addition, for each non-explicit conversion function declared in T of the form

operator conversion-type-id ( ) cv-qualiﬁer ref-qualiﬁeropt exception-speciﬁcationopt attribute-
speciﬁer-seqopt;

where cv-qualiﬁer is the same cv-qualiﬁcation as, or a greater cv-qualiﬁcation than, cv, and where conversion-
type-id denotes the type “pointer to function of (P1,...,Pn) returning R”, or the type “reference to pointer to
function of (P1,...,Pn) returning R”, or the type “reference to function of (P1,...,Pn) returning R”, a surrogate
call function with the unique name call-function and having the form

R call-function ( conversion-type-id F, P1 a1, ... ,Pn an) { return F (a1,... ,an); }

is also considered as a candidate function. Similarly, surrogate call functions are added to the set of candidate
functions for each non-explicit conversion function declared in a base class of T provided the function is not
hidden within T by another intervening declaration127.
If such a surrogate call function is selected by overload resolution, the corresponding conversion function will
be called to convert E to the appropriate function pointer or reference, and the function will then be invoked
with the arguments of the call. If the conversion function cannot be called (e.g., because of an ambiguity),
the program is ill-formed.

4 The argument list submitted to overload resolution consists of the argument expressions present in the
function call syntax preceded by the implied object argument (E). [ Note: When comparing the call against
the function call operators, the implied object argument is compared against the implicit object parameter
of the function call operator. When comparing the call against a surrogate call function, the implied object
argument is compared against the ﬁrst parameter of the surrogate call function. The conversion function
from which the surrogate call function was derived will be used in the conversion sequence for that parameter
since it converts the implied object argument to the appropriate function pointer or reference required by
that ﬁrst parameter. — end note ] [ Example:

int f1(int);
int f2(float);
typedef int (*fp1)(int);
typedef int (*fp2)(float);
struct A {

operator fp1() { return f1; }
operator fp2() { return f2; }

} a;
int i = a(1);

// calls f1 via pointer returned from
// conversion function

1

— end example ]
[over.match.oper]
13.3.1.2 Operators in expressions
If no operand of an operator in an expression has a type that is a class or an enumeration, the operator
is assumed to be a built-in operator and interpreted according to Clause 5. [ Note: Because ., .*, and ::
cannot be overloaded, these operators are always built-in operators interpreted according to Clause 5. ?:
cannot be overloaded, but the rules in this subclause are used to determine the conversions to be applied to
the second and third operands when they have class or enumeration type (5.16). — end note ] [ Example:
127) Note that this construction can yield candidate call functions that cannot be diﬀerentiated one from the other by overload
resolution because they have identical declarations or diﬀer only in their return type. The call will be ambiguous if overload
resolution cannot select a match to the call that is uniquely better than such undiﬀerentiable functions.

§ 13.3.1.2

307

c(cid:13) ISO/IEC

N4296

struct String {

String (const String&);
String (const char*);
operator const char* ();

};
String operator + (const String&, const String&);

void f(void) {
const char* p= "one" + "two"; // ill-formed because neither

int I = 1 + 1;

}

// operand has class or enumeration type
// Always evaluates to 2 even if
// class or enumeration types exist that
// would perform the operation.

2

— end example ]
If either operand has a type that is a class or an enumeration, a user-deﬁned operator function might be
declared that implements this operator or a user-deﬁned conversion can be necessary to convert the operand
to a type that is appropriate for a built-in operator. In this case, overload resolution is used to determine
which operator function or built-in operator is to be invoked to implement the operator. Therefore, the
operator notation is ﬁrst transformed to the equivalent function-call notation as summarized in Table 10
(where @ denotes one of the operators covered in the speciﬁed subclause).

Table 10 — Relationship between operator and function call notation

Subclause Expression As member function As non-member function
13.5.1
13.5.2
13.5.3
13.5.5
13.5.6
13.5.7

(a).operator@ ( )
(a).operator@ (b)
(a).operator= (b)
(a).operator[](b)
(a).operator-> ( )
(a).operator@ (0)

operator@ (a)
operator@ (a, b)

@a
a@b
a=b
a[b]
a->
a@

operator@ (a, 0)

3 For a unary operator @ with an operand of a type whose cv-unqualiﬁed version is T1, and for a binary
operator @ with a left operand of a type whose cv-unqualiﬁed version is T1 and a right operand of a type
whose cv-unqualiﬁed version is T2, three sets of candidate functions, designated member candidates, non-
member candidates and built-in candidates, are constructed as follows:

(3.1)

(3.2)

—

—

(3.3)

—

If T1 is a complete class type or a class currently being deﬁned, the set of member candidates is the
result of the qualiﬁed lookup of T1::operator@ (13.3.1.1.1); otherwise, the set of member candidates
is empty.
The set of non-member candidates is the result of the unqualiﬁed lookup of operator@ in the context
of the expression according to the usual rules for name lookup in unqualiﬁed function calls (3.4.2)
except that all member functions are ignored. However, if no operand has a class type, only those
non-member functions in the lookup set that have a ﬁrst parameter of type T1 or “reference to (possibly
cv-qualiﬁed) T1”, when T1 is an enumeration type, or (if there is a right operand) a second parameter
of type T2 or “reference to (possibly cv-qualiﬁed) T2”, when T2 is an enumeration type, are candidate
functions.
For the operator ,, the unary operator &, or the operator ->, the built-in candidates set is empty.
For all other operators, the built-in candidates include all of the candidate operator functions deﬁned
in 13.6 that, compared to the given operator,

§ 13.3.1.2

308

c(cid:13) ISO/IEC

N4296

(3.3.1)

(3.3.2)

(3.3.3)

(3.3.4)

—
—
—

—

have the same operator name, and
accept the same number of operands, and
accept operand types to which the given operand or operands can be converted according to
13.3.3.1, and
do not have the same parameter-type-list as any non-member candidate that is not a function
template specialization.

4 For the built-in assignment operators, conversions of the left operand are restricted as follows:

(4.1)

(4.2)

—
—

no temporaries are introduced to hold the left operand, and
no user-deﬁned conversions are applied to the left operand to achieve a type match with the left-most
parameter of a built-in candidate.

5 For all other operators, no such restrictions apply.
6 The set of candidate functions for overload resolution is the union of the member candidates, the non-member
candidates, and the built-in candidates. The argument list contains all of the operands of the operator. The
best function from the set of candidate functions is selected according to 13.3.2 and 13.3.3.128 [ Example:

struct A {

operator int();

};
A operator+(const A&, const A&);
void m() {
A a, b;
a + b;

// operator+(a,b) chosen over int(a) + int(b)

7

— end example ]
If a built-in candidate is selected by overload resolution, the operands of class type are converted to the
types of the corresponding parameters of the selected operation function, except that the second standard
conversion sequence of a user-deﬁned conversion sequence (13.3.3.1.2) is not applied. Then the operator is
treated as the corresponding built-in operator and interpreted according to Clause 5. [ Example:

}

};

};

struct X {

operator double();

struct Y {

operator int*();

int *a = Y() + 100.0;
int *b = Y() + X();

// error: pointer arithmetic requires integral operand
// error: pointer arithmetic requires integral operand

— end example ]

8 The second operand of operator -> is ignored in selecting an operator-> function, and is not an argument
when the operator-> function is called. When operator-> returns, the operator -> is applied to the value
returned, with the original second operand.129
128) If the set of candidate functions is empty, overload resolution is unsuccessful.
129) If the value returned by the operator-> function has class type, this may result in selecting and calling another operator->
function. The process repeats until an operator-> function returns a value of non-class type.

§ 13.3.1.2

309

c(cid:13) ISO/IEC

N4296

9

10

If the operator is the operator ,, the unary operator &, or the operator ->, and there are no viable functions,
then the operator is assumed to be the built-in operator and interpreted according to Clause 5.
[ Note: The lookup rules for operators in expressions are diﬀerent than the lookup rules for operator function
names in a function call, as shown in the following example:

struct A { };
void operator + (A, A);

struct B {

void operator + (B);
void f ();

};

A a;

void B::f() {

operator+ (a,a);
a + a;

}

// error: global operator hidden by member
// OK: calls global operator+

— end note ]
13.3.1.3

Initialization by constructor

[over.match.ctor]
1 When objects of class type are direct-initialized (8.5), copy-initialized from an expression of the same or a
derived class type (8.5), or default-initialized (8.5), overload resolution selects the constructor. For direct-
initialization or default-initialization, the candidate functions are all the constructors of the class of the object
being initialized. For copy-initialization, the candidate functions are all the converting constructors (12.3.1)
of that class. The argument list is the expression-list or assignment-expression of the initializer.
13.3.1.4 Copy-initialization of class by user-deﬁned conversion

[over.match.copy]
1 Under the conditions speciﬁed in 8.5, as part of a copy-initialization of an object of class type, a user-deﬁned
conversion can be invoked to convert an initializer expression to the type of the object being initialized.
Overload resolution is used to select the user-deﬁned conversion to be invoked.
[ Note: The conversion
performed for indirect binding to a reference to a possibly cv-qualiﬁed class type is determined in terms of
a corresponding non-reference copy-initialization. — end note ] Assuming that “cv1 T” is the type of the
object being initialized, with T a class type, the candidate functions are selected as follows:

(1.1)

(1.2)

—
—

The converting constructors (12.3.1) of T are candidate functions.
When the type of the initializer expression is a class type “cv S”, the non-explicit conversion functions
of S and its base classes are considered. When initializing a temporary to be bound to the ﬁrst
parameter of a constructor where the parameter is of type “reference to possibly cv-qualiﬁed T” and
the constructor is called with a single argument in the context of direct-initialization of an object
of type “cv2 T”, explicit conversion functions are also considered. Those that are not hidden within
S and yield a type whose cv-unqualiﬁed version is the same type as T or is a derived class thereof
are candidate functions. Conversion functions that return “reference to X” return lvalues or xvalues,
depending on the type of reference, of type X and are therefore considered to yield X for this process
of selecting candidate functions.

2

In both cases, the argument list has one argument, which is the initializer expression. [ Note: This argument
will be compared against the ﬁrst parameter of the constructors and against the implicit object parameter
of the conversion functions. — end note ]

§ 13.3.1.4

310

c(cid:13) ISO/IEC

N4296

13.3.1.5

Initialization by conversion function

[over.match.conv]
1 Under the conditions speciﬁed in 8.5, as part of an initialization of an object of nonclass type, a conversion
function can be invoked to convert an initializer expression of class type to the type of the object being
initialized. Overload resolution is used to select the conversion function to be invoked. Assuming that “cv1
T” is the type of the object being initialized, and “cv S” is the type of the initializer expression, with S a
class type, the candidate functions are selected as follows:

(1.1)

—

The conversion functions of S and its base classes are considered. Those non-explicit conversion
functions that are not hidden within S and yield type T or a type that can be converted to type T
via a standard conversion sequence (13.3.3.1.1) are candidate functions. For direct-initialization, those
explicit conversion functions that are not hidden within S and yield type T or a type that can be
converted to type T with a qualiﬁcation conversion (4.4) are also candidate functions. Conversion
functions that return a cv-qualiﬁed type are considered to yield the cv-unqualiﬁed version of that type
for this process of selecting candidate functions. Conversion functions that return “reference to cv2
X” return lvalues or xvalues, depending on the type of reference, of type “cv2 X” and are therefore
considered to yield X for this process of selecting candidate functions.
2 The argument list has one argument, which is the initializer expression.

[ Note: This argument will be

compared against the implicit object parameter of the conversion functions. — end note ]
13.3.1.6

Initialization by conversion function for direct reference binding

[over.match.ref]
1 Under the conditions speciﬁed in 8.5.3, a reference can be bound directly to a glvalue or class prvalue that is
the result of applying a conversion function to an initializer expression. Overload resolution is used to select
the conversion function to be invoked. Assuming that “cv1 T” is the underlying type of the reference being
initialized, and “cv S” is the type of the initializer expression, with S a class type, the candidate functions
are selected as follows:

(1.1)

—

The conversion functions of S and its base classes are considered. Those non-explicit conversion
functions that are not hidden within S and yield type “lvalue reference to cv2 T2” (when initializing
an lvalue reference or an rvalue reference to function) or “cv2 T2” or “rvalue reference to cv2 T2”
(when initializing an rvalue reference or an lvalue reference to function), where “cv1 T” is reference-
compatible (8.5.3) with “cv2 T2”, are candidate functions. For direct-initialization, those explicit
conversion functions that are not hidden within S and yield type “lvalue reference to cv2 T2” or “cv2
T2” or “rvalue reference to cv2 T2,” respectively, where T2 is the same type as T or can be converted
to type T with a qualiﬁcation conversion (4.4), are also candidate functions.

2 The argument list has one argument, which is the initializer expression.

[ Note: This argument will be

Initialization by list-initialization

compared against the implicit object parameter of the conversion functions. — end note ]
13.3.1.7

[over.match.list]
1 When objects of non-aggregate class type T are list-initialized such that 8.5.4 speciﬁes that overload resolution
is performed according to the rules in this section, overload resolution selects the constructor in two phases:
Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class T and the
argument list consists of the initializer list as a single argument.
If no viable initializer-list constructor is found, overload resolution is performed again, where the
candidate functions are all the constructors of the class T and the argument list consists of the elements
of the initializer list.

—

—

(1.1)

(1.2)

If the initializer list has no elements and T has a default constructor, the ﬁrst phase is omitted. In copy-list-
initialization, if an explicit constructor is chosen, the initialization is ill-formed. [ Note: This diﬀers from
other situations (13.3.1.3, 13.3.1.4), where only converting constructors are considered for copy-initialization.
This restriction only applies if this initialization is part of the ﬁnal result of overload resolution. — end note ]

§ 13.3.1.7

311

c(cid:13) ISO/IEC

N4296

13.3.2 Viable functions

[over.match.viable]
1 From the set of candidate functions constructed for a given context (13.3.1), a set of viable functions is
chosen, from which the best function will be selected by comparing argument conversion sequences for the
best ﬁt (13.3.3). The selection of viable functions considers relationships between arguments and function
parameters other than the ranking of conversion sequences.

2 First, to be a viable function, a candidate function shall have enough parameters to agree in number with

the arguments in the list.

(2.1)

(2.2)

(2.3)

—
—

—

If there are m arguments in the list, all candidate functions having exactly m parameters are viable.
A candidate function having fewer than m parameters is viable only if it has an ellipsis in its parameter
list (8.3.5). For the purposes of overload resolution, any argument for which there is no corresponding
parameter is considered to “match the ellipsis” (13.3.3.1.3) .
A candidate function having more than m parameters is viable only if the (m+1)-st parameter has a
default argument (8.3.6).130 For the purposes of overload resolution, the parameter list is truncated
on the right, so that there are exactly m parameters.

3 Second, for F to be a viable function, there shall exist for each argument an implicit conversion se-
quence (13.3.3.1) that converts that argument to the corresponding parameter of F. If the parameter has
reference type, the implicit conversion sequence includes the operation of binding the reference, and the fact
that an lvalue reference to non-const cannot be bound to an rvalue and that an rvalue reference cannot be
bound to an lvalue can aﬀect the viability of the function (see 13.3.3.1.4).
13.3.3 Best viable function

[over.match.best]

1 Deﬁne ICSi(F) as follows:

(1.1)

(1.2)

—

—

if F is a static member function, ICS1(F) is deﬁned such that ICS1(F) is neither better nor worse than
ICS1(G) for any function G, and, symmetrically, ICS1(G) is neither better nor worse than ICS1(F)131;
otherwise,
let ICSi(F) denote the implicit conversion sequence that converts the i-th argument in the list to the
type of the i-th parameter of viable function F. 13.3.3.1 deﬁnes the implicit conversion sequences and
13.3.3.2 deﬁnes what it means for one implicit conversion sequence to be a better conversion sequence
or worse conversion sequence than another.

Given these deﬁnitions, a viable function F1 is deﬁned to be a better function than another viable function
F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then

(1.3)

(1.4)

—
—

for some argument j, ICSj(F1) is a better conversion sequence than ICSj(F2), or, if not that,
the context is an initialization by user-deﬁned conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the
standard conversion sequence from the return type of F1 to the destination type (i.e., the type of the
entity being initialized) is a better conversion sequence than the standard conversion sequence from
the return type of F2 to the destination type. [ Example:

struct A {

A();
operator int();
operator double();

} a;

130) According to 8.3.6, parameters following the (m+1)-st parameter must also have default arguments.
131) If a function is a static member function, this deﬁnition means that the ﬁrst argument, the implied object argument, has
no eﬀect in the determination of whether the function is better or worse than any other function.

§ 13.3.3

312

c(cid:13) ISO/IEC

int i = a;

float x = a;

N4296

// a.operator int() followed by no conversion
// is better than a.operator double() followed by
// a conversion to int
// ambiguous: both possibilities require conversions,
// and neither is better than the other

(1.5)

—

— end example ] or, if not that,
the context is an initialization by conversion function for direct reference binding (13.3.1.6) of a refer-
ence to function type, the return type of F1 is the same kind of reference (i.e. lvalue or rvalue) as the
reference being initialized, and the return type of F2 is not [ Example:

template <class T> struct A {
// #1
// #2

operator T&();
operator T&&();

};
typedef int Fn();
A<Fn> a;
Fn& lf = a;
Fn&& rf = a;

// calls #1
// calls #2

(1.6)

(1.7)

— end example ] or, if not that,
F1 is not a function template specialization and F2 is a function template specialization, or, if not that,
F1 and F2 are function template specializations, and the function template for F1 is more specialized
than the template for F2 according to the partial ordering rules described in 14.5.6.2.

—
—

2

If there is exactly one viable function that is a better function than all other viable functions, then it is the
one selected by overload resolution; otherwise the call is ill-formed132.
[ Example:

void Fcn(const int*,
void Fcn(int*, int);

short);

int i;
short s = 0;

void f() {

Fcn(&i, s);

Fcn(&i, 1L);

Fcn(&i,’c’);

}

// is ambiguous because
// &i → int* is better than &i → const int*
// but s → short is also better than s → int

// calls Fcn(int*, int), because
// &i → int* is better than &i → const int*
// and 1L → short and 1L → int are indistinguishable

// calls Fcn(int*, int), because
// &i → int* is better than &i → const int*
// and c → int is better than c → short

132) The algorithm for selecting the best viable function is linear in the number of viable functions. Run a simple tournament
to ﬁnd a function W that is not worse than any opponent it faced. Although another function F that W did not face might be
at least as good as W, F cannot be the best function because at some point in the tournament F encountered another function
G such that F was not better than G. Hence, W is either the best function or there is no best function. So, make a second pass
over the viable functions to verify that W is better than all other functions.

§ 13.3.3

313

c(cid:13) ISO/IEC

N4296

3

— end example ]
If the best viable function resolves to a function for which multiple declarations were found, and if at least
two of these declarations — or the declarations they refer to in the case of using-declarations — specify a
default argument that made the function viable, the program is ill-formed. [ Example:

extern "C" void f(int = 5);

namespace A {

}
namespace B {

extern "C" void f(int = 5);

}

}

using A::f;
using B::f;

void use() {

f(3);
f();

// OK, default argument was not used for viability
// Error: found default argument twice

— end example ]
13.3.3.1

Implicit conversion sequences

[over.best.ics]
1 An implicit conversion sequence is a sequence of conversions used to convert an argument in a function call
to the type of the corresponding parameter of the function being called. The sequence of conversions is an
implicit conversion as deﬁned in Clause 4, which means it is governed by the rules for initialization of an
object or reference by a single expression (8.5, 8.5.3).
Implicit conversion sequences are concerned only with the type, cv-qualiﬁcation, and value category of
the argument and how these are converted to match the corresponding properties of the parameter. Other
properties, such as the lifetime, storage class, alignment, accessibility of the argument, whether the argument
is a bit-ﬁeld, and whether a function is deleted (8.4.3), are ignored. So, although an implicit conversion
sequence can be deﬁned for a given argument-parameter pair, the conversion from the argument to the
parameter might still be ill-formed in the ﬁnal analysis.

2

3 A well-formed implicit conversion sequence is one of the following forms:

(3.1)

(3.2)

(3.3)

—
—
—

a standard conversion sequence (13.3.3.1.1),
a user-deﬁned conversion sequence (13.3.3.1.2), or
an ellipsis conversion sequence (13.3.3.1.3).

4 However, if the target is

(4.1)

(4.2)

(4.3)

(4.4)

—
—

the ﬁrst parameter of a constructor or
the implicit object parameter of a user-deﬁned conversion function

and the constructor or user-deﬁned conversion function is a candidate by

—
—

13.3.1.3, when the argument is the temporary in the second step of a class copy-initialization, or
13.3.1.4, 13.3.1.5, or 13.3.1.6 (in all cases),

§ 13.3.3.1

314

c(cid:13) ISO/IEC

N4296

user-deﬁned conversion sequences are not considered. [ Note: These rules prevent more than one user-deﬁned
conversion from being applied during overload resolution, thereby avoiding inﬁnite recursion. — end note ]
[ Example:

struct Y { Y(int); };
struct A { operator int(); };
Y y1 = A();

// error: A::operator int() is not a candidate

struct X { };
struct B { operator X(); };
B b;
X x({b});

// error: B::operator X() is not a candidate

— end example ]

7

5 For the case where the parameter type is a reference, see 13.3.3.1.4.
6 When the parameter type is not a reference, the implicit conversion sequence models a copy-initialization of
the parameter from the argument expression. The implicit conversion sequence is the one required to convert
the argument expression to a prvalue of the type of the parameter. [ Note: When the parameter has a class
type, this is a conceptual conversion deﬁned for the purposes of Clause 13; the actual initialization is deﬁned
in terms of constructors and is not a conversion. — end note ] Any diﬀerence in top-level cv-qualiﬁcation is
subsumed by the initialization itself and does not constitute a conversion. [ Example: a parameter of type A
can be initialized from an argument of type const A. The implicit conversion sequence for that case is the
identity sequence; it contains no “conversion” from const A to A. — end example ] When the parameter has
a class type and the argument expression has the same type, the implicit conversion sequence is an identity
conversion. When the parameter has a class type and the argument expression has a derived class type,
the implicit conversion sequence is a derived-to-base Conversion from the derived class to the base class.
[ Note: There is no such standard conversion; this derived-to-base Conversion exists only in the description of
implicit conversion sequences. — end note ] A derived-to-base Conversion has Conversion rank (13.3.3.1.1).
In all contexts, when converting to the implicit object parameter or when converting to the left operand of
an assignment operation only standard conversion sequences that create no temporary object for the result
are allowed.
If no conversions are required to match an argument to a parameter type, the implicit conversion sequence
is the standard conversion sequence consisting of the identity conversion (13.3.3.1.1).
If no sequence of conversions can be found to convert an argument to a parameter type, an implicit conversion
sequence cannot be formed.
If several diﬀerent sequences of conversions exist that each convert the argument to the parameter type, the
implicit conversion sequence associated with the parameter is deﬁned to be the unique conversion sequence
designated the ambiguous conversion sequence. For the purpose of ranking implicit conversion sequences
as described in 13.3.3.2, the ambiguous conversion sequence is treated as a user-deﬁned sequence that is
indistinguishable from any other user-deﬁned conversion sequence133. If a function that uses the ambiguous
133) The ambiguous conversion sequence is ranked with user-deﬁned conversion sequences because multiple conversion sequences
for an argument can exist only if they involve diﬀerent user-deﬁned conversions. The ambiguous conversion sequence is indistin-
guishable from any other user-deﬁned conversion sequence because it represents at least two user-deﬁned conversion sequences,
each with a diﬀerent user-deﬁned conversion, and any other user-deﬁned conversion sequence must be indistinguishable from
at least one of them.

This rule prevents a function from becoming non-viable because of an ambiguous conversion sequence for one of its parameters.

8

9

10

Consider this example,

class B;
class A { A (B&);};
class B { operator A (); };
class C { C (B&); };

§ 13.3.3.1

315

c(cid:13) ISO/IEC

N4296

conversion sequence is selected as the best viable function, the call will be ill-formed because the conversion
of one of the arguments in the call is ambiguous.

13.3.3.1.1 Standard conversion sequences

11 The three forms of implicit conversion sequences mentioned above are deﬁned in the following subclauses.
[over.ics.scs]
1 Table 11 summarizes the conversions deﬁned in Clause 4 and partitions them into four disjoint categories:
Lvalue Transformation, Qualiﬁcation Adjustment, Promotion, and Conversion. [ Note: These categories are
orthogonal with respect to value category, cv-qualiﬁcation, and data representation: the Lvalue Transforma-
tions do not change the cv-qualiﬁcation or data representation of the type; the Qualiﬁcation Adjustments
do not change the value category or data representation of the type; and the Promotions and Conversions
do not change the value category or cv-qualiﬁcation of the type. — end note ]
[ Note: As described in Clause 4, a standard conversion sequence is either the Identity conversion by itself
(that is, no conversion) or consists of one to three conversions from the other four categories. At most one
conversion from each category is allowed in a single standard conversion sequence. If there are two or more
conversions in the sequence, the conversions are applied in the canonical order: Lvalue Transformation,
Promotion or Conversion, Qualiﬁcation Adjustment. — end note ]

2

3 Each conversion in Table 11 also has an associated rank (Exact Match, Promotion, or Conversion). These are
used to rank standard conversion sequences (13.3.3.2). The rank of a conversion sequence is determined by
considering the rank of each conversion in the sequence and the rank of any reference binding (13.3.3.1.4). If
any of those has Conversion rank, the sequence has Conversion rank; otherwise, if any of those has Promotion
rank, the sequence has Promotion rank; otherwise, the sequence has Exact Match rank.

Conversion
No conversions required
Lvalue-to-rvalue conversion
Array-to-pointer conversion
Function-to-pointer conversion
Qualiﬁcation conversions
Integral promotions
Floating point promotion
Integral conversions
Floating point conversions
Floating-integral conversions
Pointer conversions
Pointer to member conversions
Boolean conversions

Table 11 — Conversions

Category
Identity

Rank

Subclause

Lvalue Transformation

Exact Match

Qualiﬁcation Adjustment

Promotion

Promotion

Conversion

Conversion

4.1
4.2
4.3
4.4
4.5
4.6
4.7
4.8
4.9
4.10
4.11
4.12

void f(A) { }
void f(C) { }
B b;
f(b);

// ambiguous because b → C via constructor and
// b → A via constructor or conversion function.

If it were not for this rule, f(A) would be eliminated as a viable function for the call f(b) causing overload resolution to
select f(C) as the function to call even though it is not clearly the best choice. On the other hand, if an f(B) were to be
declared then f(b) would resolve to that f(B) because the exact match with f(B) is better than any of the sequences required
to match f(A).

§ 13.3.3.1.1

316

c(cid:13) ISO/IEC

N4296

13.3.3.1.2 User-deﬁned conversion sequences

[over.ics.user]
1 A user-deﬁned conversion sequence consists of an initial standard conversion sequence followed by a user-
deﬁned conversion (12.3) followed by a second standard conversion sequence. If the user-deﬁned conversion
is speciﬁed by a constructor (12.3.1), the initial standard conversion sequence converts the source type to the
type required by the argument of the constructor. If the user-deﬁned conversion is speciﬁed by a conversion
function (12.3.2), the initial standard conversion sequence converts the source type to the implicit object
parameter of the conversion function.

2 The second standard conversion sequence converts the result of the user-deﬁned conversion to the target type
for the sequence. Since an implicit conversion sequence is an initialization, the special rules for initialization
by user-deﬁned conversion apply when selecting the best user-deﬁned conversion for a user-deﬁned conversion
sequence (see 13.3.3 and 13.3.3.1).
If the user-deﬁned conversion is speciﬁed by a specialization of a conversion function template, the second
standard conversion sequence shall have exact match rank.

3

4 A conversion of an expression of class type to the same class type is given Exact Match rank, and a conversion
of an expression of class type to a base class of that type is given Conversion rank, in spite of the fact that
a constructor (i.e., a user-deﬁned conversion function) is called for those cases.
13.3.3.1.3 Ellipsis conversion sequences

[over.ics.ellipsis]
1 An ellipsis conversion sequence occurs when an argument in a function call is matched with the ellipsis

parameter speciﬁcation of the function called (see 5.2.2).
13.3.3.1.4 Reference binding

[over.ics.ref]
1 When a parameter of reference type binds directly (8.5.3) to an argument expression, the implicit conversion
sequence is the identity conversion, unless the argument expression has a type that is a derived class of the
parameter type, in which case the implicit conversion sequence is a derived-to-base Conversion (13.3.3.1).
[ Example:

struct A {};
struct B : public A {} b;
int f(A&);
int f(B&);
int i = f(b);

// calls f(B&), an exact match, rather than
// f(A&), a conversion

— end example ] If the parameter binds directly to the result of applying a conversion function to the
argument expression, the implicit conversion sequence is a user-deﬁned conversion sequence (13.3.3.1.2),
with the second standard conversion sequence either an identity conversion or, if the conversion function
returns an entity of a type that is a derived class of the parameter type, a derived-to-base Conversion.

2 When a parameter of reference type is not bound directly to an argument expression, the conversion sequence
is the one required to convert the argument expression to the underlying type of the reference according
to 13.3.3.1. Conceptually, this conversion sequence corresponds to copy-initializing a temporary of the
underlying type with the argument expression. Any diﬀerence in top-level cv-qualiﬁcation is subsumed by
the initialization itself and does not constitute a conversion.

3 Except for an implicit object parameter, for which see 13.3.1, a standard conversion sequence cannot be
formed if it requires binding an lvalue reference other than a reference to a non-volatile const type to
an rvalue or binding an rvalue reference to an lvalue other than a function lvalue.
[ Note: This means,
for example, that a candidate function cannot be a viable function if it has a non-const lvalue reference
parameter (other than the implicit object parameter) and the corresponding argument is a temporary or
would require one to be created to initialize the lvalue reference (see 8.5.3). — end note ]

§ 13.3.3.1.4

317

c(cid:13) ISO/IEC

N4296

4 Other restrictions on binding a reference to a particular argument that are not based on the types of
the reference and the argument do not aﬀect the formation of a standard conversion sequence, however.
[ Example: a function with an “lvalue reference to int” parameter can be a viable candidate even if the
corresponding argument is an int bit-ﬁeld. The formation of implicit conversion sequences treats the int
bit-ﬁeld as an int lvalue and ﬁnds an exact match with the parameter. If the function is selected by overload
resolution, the call will nonetheless be ill-formed because of the prohibition on binding a non-const lvalue
reference to a bit-ﬁeld (8.5.3). — end example ]
13.3.3.1.5 List-initialization sequence

[over.ics.list]
1 When an argument is an initializer list (8.5.4), it is not an expression and special rules apply for converting

2

it to a parameter type.
If the parameter type is a class X and the initializer list has a single element of type cv U, where U is X or
a class derived from X, the implicit conversion sequence is the one required to convert the element to the
parameter type.

3 Otherwise, if the parameter type is a character array134 and the initializer list has a single element that is

an appropriately-typed string literal (8.5.2), the implicit conversion sequence is the identity conversion.

4 Otherwise, if the parameter type is std::initializer_list<X> and all the elements of the initializer list can
be implicitly converted to X, the implicit conversion sequence is the worst conversion necessary to convert an
element of the list to X, or if the initializer list has no elements, the identity conversion. This conversion can
be a user-deﬁned conversion even in the context of a call to an initializer-list constructor. [ Example:

void f(std::initializer_list<int>);
f( {} );
f( {1,2,3} );
f( {’a’,’b’} );
f( {1.0} );

// OK: f(initializer_list<int>) identity conversion
// OK: f(initializer_list<int>) identity conversion
// OK: f(initializer_list<int>) integral promotion
// error: narrowing

struct A {

// #1
A(std::initializer_list<double>);
A(std::initializer_list<complex<double>>); // #2
// #3
A(std::initializer_list<std::string>);

};
A a{ 1.0,2.0 };

void g(A);
g({ "foo", "bar" });

typedef int IA[3];
void h(const IA&);
h({ 1, 2, 3 });

— end example ]

// OK, uses #1

// OK, uses #3

// OK: identity conversion

5 Otherwise, if the parameter type is “array of N X”, if the initializer list has exactly N elements or if it has
fewer than N elements and X is default-constructible, and if all the elements of the initializer list can be
implicitly converted to X, the implicit conversion sequence is the worst conversion necessary to convert an
element of the list to X.

6 Otherwise, if the parameter is a non-aggregate class X and overload resolution per 13.3.1.7 chooses a single
best constructor of X to perform the initialization of an object of type X from the argument initializer list,
the implicit conversion sequence is a user-deﬁned conversion sequence with the second standard conversion
sequence an identity conversion. If multiple constructors are viable but none is better than the others, the
134) Since there are no parameters of array type, this will only occur as the underlying type of a reference parameter.

§ 13.3.3.1.5

318

c(cid:13) ISO/IEC

N4296

implicit conversion sequence is the ambiguous conversion sequence. User-deﬁned conversions are allowed
for conversion of the initializer list elements to the constructor parameter types except as noted in 13.3.3.1.
[ Example:

struct A {

A(std::initializer_list<int>);

};
void f(A);
f( {’a’, ’b’} );

struct B {

B(int, double);

};
void g(B);
g( {’a’, ’b’} );
g( {1.0, 1.0} );

// OK: f(A(std::initializer_list<int>)) user-deﬁned conversion

// OK: g(B(int,double)) user-deﬁned conversion
// error: narrowing

void f(B);
f( {’a’, ’b’} );

// error: ambiguous f(A) or f(B)

struct C {

C(std::string);

};
void h(C);
h({"foo"});

struct D {
D(A, C);

};
void i(D);
i({ {1,2}, {"bar"} });

— end example ]

// OK: h(C(std::string("foo")))

// OK: i(D(A(std::initializer_list<int>{1,2}),C(std::string("bar"))))

7 Otherwise, if the parameter has an aggregate type which can be initialized from the initializer list according
to the rules for aggregate initialization (8.5.1), the implicit conversion sequence is a user-deﬁned conversion
sequence with the second standard conversion sequence an identity conversion. [ Example:

struct A {
int m1;
double m2;

};

void f(A);
f( {’a’, ’b’} );
f( {1.0} );

— end example ]

// OK: f(A(int,double)) user-deﬁned conversion
// error: narrowing

8 Otherwise, if the parameter is a reference, see 13.3.3.1.4.

[ Note: The rules in this section will apply for

initializing the underlying temporary for the reference. — end note ] [ Example:

struct A {
int m1;
double m2;

};

§ 13.3.3.1.5

319

c(cid:13) ISO/IEC

void f(const A&);
f( {’a’, ’b’} );
f( {1.0} );

void g(const double &);
g({1});

— end example ]

// OK: f(A(int,double)) user-deﬁned conversion
// error: narrowing

// same conversion as int to double

N4296

9 Otherwise, if the parameter type is not a class:

(9.1)

—

if the initializer list has one element that is not itself an initializer list, the implicit conversion sequence
is the one required to convert the element to the parameter type; [ Example:

void f(int);
f( {’a’} );
f( {1.0} );

// OK: same conversion as char to int
// error: narrowing

(9.2)

—

— end example ]
if the initializer list has no elements, the implicit conversion sequence is the identity conversion.
[ Example:

void f(int);
f( { } );

— end example ]

// OK: identity conversion

10

In all cases other than those enumerated above, no conversion is possible.
13.3.3.2 Ranking implicit conversion sequences

[over.ics.rank]
1 13.3.3.2 deﬁnes a partial ordering of implicit conversion sequences based on the relationships better conversion
sequence and better conversion. If an implicit conversion sequence S1 is deﬁned by these rules to be a better
conversion sequence than S2, then it is also the case that S2 is a worse conversion sequence than S1. If
conversion sequence S1 is neither better than nor worse than conversion sequence S2, S1 and S2 are said to
be indistinguishable conversion sequences.

2 When comparing the basic forms of implicit conversion sequences (as deﬁned in 13.3.3.1)

(2.1)

(2.2)

—

—

a standard conversion sequence (13.3.3.1.1) is a better conversion sequence than a user-deﬁned con-
version sequence or an ellipsis conversion sequence, and
a user-deﬁned conversion sequence (13.3.3.1.2) is a better conversion sequence than an ellipsis conver-
sion sequence (13.3.3.1.3).

3 Two implicit conversion sequences of the same form are indistinguishable conversion sequences unless one of

the following rules applies:

(3.1)
(3.1.1)

(3.1.2)

—

List-initialization sequence L1 is a better conversion sequence than list-initialization sequence L2 if
—
—

L1 converts to std::initializer_list<X> for some X and L2 does not, or, if not that,
L1 converts to type “array of N1 T”, L2 converts to type “array of N2 T”, and N1 is smaller than
N2, even if one of the other rules in this paragraph would otherwise apply. [ Example:

void f1(int);
void f1(std::initializer_list<long>);
void g1() { f1({42}); }

// #1
// #2
// chooses #2

void f2(std::pair<const char*, const char*>); // #3
void f2(std::initializer_list<std::string>); // #4
void g2() { f2({"foo","bar"}); }

// chooses #4

§ 13.3.3.2

320

c(cid:13) ISO/IEC

— end example ]

N4296

(3.2)

—

(3.2.1)

(3.2.2)

(3.2.3)

—

—

Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence
S2 if
—

S1 is a proper subsequence of S2 (comparing the conversion sequences in the canonical form
deﬁned by 13.3.3.1.1, excluding any Lvalue Transformation; the identity conversion sequence is
considered to be a subsequence of any non-identity conversion sequence) or, if not that,
the rank of S1 is better than the rank of S2, or S1 and S2 have the same rank and are distin-
guishable by the rules in the paragraph below, or, if not that,
S1 and S2 are reference bindings (8.5.3) and neither refers to an implicit object parameter of a
non-static member function declared without a ref-qualiﬁer, and S1 binds an rvalue reference to
an rvalue and S2 binds an lvalue reference.
[ Example:
int i;
int f1();
int&& f2();
int g(const int&);
int g(const int&&);
int j = g(i);
int k = g(f1());
int l = g(f2());

// calls g(const int&)
// calls g(const int&&)
// calls g(const int&&)

struct A {

A& operator<<(int);
void p() &;
void p() &&;

};
A& operator<<(A&&, char);
A() << 1;
A() << ’c’;
A a;
a << 1;
a << ’c’;
A().p();
a.p();

// calls A::operator<<(int)
// calls operator<<(A&&, char)

// calls A::operator<<(int)
// calls A::operator<<(int)
// calls A::p()&&
// calls A::p()&

(3.2.4)

—

— end example ] or, if not that,
S1 and S2 are reference bindings (8.5.3) and S1 binds an lvalue reference to a function lvalue and
S2 binds an rvalue reference to a function lvalue. [ Example:

int f(void(&)());
int f(void(&&)());
void g();
int i1 = f(g);

// #1
// #2

// calls #1

(3.2.5)

—

— end example ] or, if not that,
S1 and S2 diﬀer only in their qualiﬁcation conversion and yield similar types T1 and T2 (4.4),
respectively, and the cv-qualiﬁcation signature of type T1 is a proper subset of the cv-qualiﬁcation
signature of type T2. [ Example:
int f(const volatile int *);
int f(const int *);
int i;
int j = f(&i);

// calls f(const int*)

§ 13.3.3.2

321

c(cid:13) ISO/IEC

N4296

(3.2.6)

—

— end example ] or, if not that,
S1 and S2 are reference bindings (8.5.3), and the types to which the references refer are the same
type except for top-level cv-qualiﬁers, and the type to which the reference initialized by S2 refers
is more cv-qualiﬁed than the type to which the reference initialized by S1 refers. [ Example:

int f(const int &);
int f(int &);
int g(const int &);
int g(int);

int i;
int j = f(i);
int k = g(i);

struct X {

void f() const;
void f();

};
void g(const X& a, X b) {

a.f();
b.f();

}

// calls f(int &)
// ambiguous

// calls X::f() const
// calls X::f()

— end example ]

(3.3)

—

User-deﬁned conversion sequence U1 is a better conversion sequence than another user-deﬁned con-
version sequence U2 if they contain the same user-deﬁned conversion function or constructor or they
initialize the same class in an aggregate initialization and in either case the second standard conversion
sequence of U1 is better than the second standard conversion sequence of U2. [ Example:

struct A {

operator short();

} a;
int f(int);
int f(float);
int i = f(a);

// calls f(int), because short → int is
// better than short → float.

— end example ]

4 Standard conversion sequences are ordered by their ranks: an Exact Match is a better conversion than a
Promotion, which is a better conversion than a Conversion. Two conversion sequences with the same rank
are indistinguishable unless one of the following rules applies:

(4.1)

(4.2)

(4.3)

(4.4)

(4.4.1)

—

—

—

—

A conversion that does not convert a pointer, a pointer to member, or std::nullptr_t to bool is
better than one that does.
A conversion that promotes an enumeration whose underlying type is ﬁxed to its underlying type is
better than one that promotes to the promoted underlying type, if the two are diﬀerent.
If class B is derived directly or indirectly from class A, conversion of B* to A* is better than conversion
of B* to void*, and conversion of A* to void* is better than conversion of B* to void*.
If class B is derived directly or indirectly from class A and class C is derived directly or indirectly from
B,
—

conversion of C* to B* is better than conversion of C* to A*, [ Example:

§ 13.3.3.2

322

c(cid:13) ISO/IEC

N4296

// calls f(B*)

struct A {};
struct B : public A {};
struct C : public B {};
C* pc;
int f(A*);
int f(B*);
int i = f(pc);
— end example ]
binding of an expression of type C to a reference to type B is better than binding an expression
of type C to a reference to type A,
conversion of A::* to B::* is better than conversion of A::* to C::*,
conversion of C to B is better than conversion of C to A,
conversion of B* to A* is better than conversion of C* to A*,
binding of an expression of type B to a reference to type A is better than binding an expression
of type C to a reference to type A,
conversion of B::* to C::* is better than conversion of A::* to C::*, and
conversion of B to A is better than conversion of C to A.

—
—
[ Note: Compared conversion sequences will have diﬀerent source types only in the context of comparing
the second standard conversion sequence of an initialization by user-deﬁned conversion (see 13.3.3);
in all other contexts, the source types will be the same and the target types will be diﬀerent. — end
note ]

—

—
—
—
—

(4.4.2)

(4.4.3)

(4.4.4)

(4.4.5)

(4.4.6)

(4.4.7)

(4.4.8)

13.4 Address of overloaded function

[over.over]
1 A use of an overloaded function name without arguments is resolved in certain contexts to a function, a
pointer to function or a pointer to member function for a speciﬁc function from the overload set. A function
template name is considered to name a set of overloaded functions in such contexts. The function selected
is the one whose type is identical to the function type of the target type required in the context.
[ Note:
That is, the class of which the function is a member is ignored when matching a pointer-to-member-function
type. — end note ] The target can be

(1.1)

(1.2)

(1.3)

(1.4)

(1.5)

(1.6)

(1.7)

2

—
—
—
—
—
—
—

an object or reference being initialized (8.5, 8.5.3, 8.5.4),
the left side of an assignment (5.18),
a parameter of a function (5.2.2),
a parameter of a user-deﬁned operator (13.5),
the return value of a function, operator function, or conversion (6.6.3),
an explicit type conversion (5.2.3, 5.2.9, 5.4), or
a non-type template-parameter (14.3.2).

The overloaded function name can be preceded by the & operator. An overloaded function name shall not
be used without arguments in contexts other than those listed.
[ Note: Any redundant set of parentheses
surrounding the overloaded function name is ignored (5.1). — end note ]
If the name is a function template, template argument deduction is done (14.8.2.2), and if the argument
deduction succeeds, the resulting template argument list is used to generate a single function template
specialization, which is added to the set of overloaded functions considered. [ Note: As described in 14.8.1,
if deduction fails and the function template name is followed by an explicit template argument list, the

§ 13.4

323

c(cid:13) ISO/IEC

N4296

template-id is then examined to see whether it identiﬁes a single function template specialization. If it does,
the template-id is considered to be an lvalue for that function template specialization. The target type is
not used in that determination. — end note ]

4

3 Non-member functions and static member functions match targets of type “pointer-to-function” or “reference-
to-function.” Nonstatic member functions match targets of type “pointer-to-member-function”. If a non-
static member function is selected, the reference to the overloaded function name is required to have the
form of a pointer to member as described in 5.3.1.
If more than one function is selected, any function template specializations in the set are eliminated if
the set also contains a function that is not a function template specialization, and any given function
template specialization F1 is eliminated if the set contains a second function template specialization whose
function template is more specialized than the function template of F1 according to the partial ordering
rules of 14.5.6.2. After such eliminations, if any, there shall remain exactly one selected function.
[ Example:

5

int f(double);
int f(int);
int (*pfd)(double) = &f;
int (*pfi)(int) = &f;
int (*pfe)(...) = &f;
int (&rfi)(int) = f;
int (&rfd)(double) = f;
void g() {

(int (*)(int))&f;

}

// selects f(double)
// selects f(int)
// error: type mismatch
// selects f(int)
// selects f(double)

// cast expression as selector

The initialization of pfe is ill-formed because no f() with type int(...) has been declared, and not because
of any ambiguity. For another example,

struct X {

int f(int);
static int f(long);

};

= &X::f;
int (X::*p1)(int)
(*p2)(int)
int
= &X::f;
int
(*p3)(long) = &X::f;
int (X::*p4)(long) = &X::f;
int (X::*p5)(int)

= &(X::f);

int

(*p6)(long) = &(X::f);

// OK
// error: mismatch
// OK
// error: mismatch
// error: wrong syntax for
// pointer to member
// OK

6

7

— end example ]
[ Note: If f() and g() are both overloaded functions, the cross product of possibilities must be considered
to resolve f(&g), or the equivalent expression f(g). — end note ]
[ Note: There are no standard conversions (Clause 4) of one pointer-to-function type into another.
particular, even if B is a public base of D, we have

In

D* f();
B* (*p1)() = &f;

void g(D*);
void (*p2)(B*) = &g;

— end note ]

§ 13.4

// error

// error

324

c(cid:13) ISO/IEC

N4296

13.5 Overloaded operators

[over.oper]
1 A function declaration having one of the following operator-function-ids as its name declares an operator
function. A function template declaration having one of the following operator-function-ids as its name
declares an operator function template. A specialization of an operator function template is also an operator
function. An operator function is said to implement the operator named in its operator-function-id.

operator-function-id:

operator operator

operator: one of

new
+
!
ˆ=
<=
( )

delete
-
=
&=
>=
[ ]

new[]
*
<
|=
&&

delete[]
/
>
<<
||

%
+=
>>
++

ˆ
-=
>>=
--

&
*=
<<=
,

|
/=
==
->*

~
%=
!=
->

[ Note: The last two operators are function call (5.2.2) and subscripting (5.2.1). The operators new[],
delete[], (), and [] are formed from more than one token. — end note ]

2 Both the unary and binary forms of

+

-

*

&

can be overloaded.

3 The following operators cannot be overloaded:

.

.*

::

?:

nor can the preprocessing symbols # and ## (Clause 16).

4 Operator functions are usually not called directly; instead they are invoked to evaluate the operators they
implement (13.5.1 – 13.5.7). They can be explicitly called, however, using the operator-function-id as the
name of the function in the function call syntax (5.2.2). [ Example:

complex z = a.operator+(b);
void* p = operator new(sizeof(int)*n);

// complex z = a+b;

— end example ]

5 The allocation and deallocation functions, operator new, operator new[], operator delete and operator
delete[], are described completely in 3.7.4. The attributes and restrictions found in the rest of this
subclause do not apply to them unless explicitly stated in 3.7.4.

6 An operator function shall either be a non-static member function or be a non-member function that has
at least one parameter whose type is a class, a reference to a class, an enumeration, or a reference to an
enumeration. It is not possible to change the precedence, grouping, or number of operands of operators.
The meaning of the operators =, (unary) &, and , (comma), predeﬁned for each type, can be changed for
speciﬁc class and enumeration types by deﬁning operator functions that implement these operators. Operator
functions are inherited in the same manner as other base class functions.

7 The identities among certain predeﬁned operators applied to basic types (for example, ++a ≡ a+=1) need
not hold for operator functions. Some predeﬁned operators, such as +=, require an operand to be an lvalue
when applied to basic types; this is not required by operator functions.

8 An operator function cannot have default arguments (8.3.6), except where explicitly stated below. Operator
functions cannot have more or fewer parameters than the number required for the corresponding operator,
as described in the rest of this subclause.

9 Operators not mentioned explicitly in subclauses 13.5.3 through 13.5.7 act as ordinary unary and binary

operators obeying the rules of 13.5.1 or 13.5.2.

§ 13.5

325

c(cid:13) ISO/IEC

N4296

13.5.1 Unary operators

[over.unary]
1 A preﬁx unary operator shall be implemented by a non-static member function (9.3) with no parameters or
a non-member function with one parameter. Thus, for any preﬁx unary operator @, @x can be interpreted
as either x.operator@() or operator@(x). If both forms of the operator function have been declared, the
rules in 13.3.1.2 determine which, if any, interpretation is used. See 13.5.7 for an explanation of the postﬁx
unary operators ++ and --.

2 The unary and binary forms of the same operator are considered to have the same name.

[ Note: Con-
sequently, a unary operator can hide a binary operator from an enclosing scope, and vice versa. — end
note ]
13.5.2 Binary operators

[over.binary]
1 A binary operator shall be implemented either by a non-static member function (9.3) with one parameter
or by a non-member function with two parameters. Thus, for any binary operator @, x@y can be interpreted
as either x.operator@(y) or operator@(x,y). If both forms of the operator function have been declared,
the rules in 13.3.1.2 determine which, if any, interpretation is used.
13.5.3 Assignment

[over.ass]
1 An assignment operator shall be implemented by a non-static member function with exactly one parameter.
Because a copy assignment operator operator= is implicitly declared for a class if not declared by the
user (12.8), a base class assignment operator is always hidden by the copy assignment operator of the
derived class.

2 Any assignment operator, even the copy and move assignment operators, can be virtual. [ Note: For a derived
class D with a base class B for which a virtual copy/move assignment has been declared, the copy/move
assignment operator in D does not override B’s virtual copy/move assignment operator. [ Example:

struct B {

virtual int operator= (int);
virtual B& operator= (const B&);

};
struct D : B {

virtual int operator= (int);
virtual D& operator= (const B&);

};

D dobj1;
D dobj2;
B* bptr = &dobj1;
void f() {

bptr->operator=(99);
*bptr = 99;
bptr->operator=(dobj2);
*bptr = dobj2;
dobj1 = dobj2;

}

// calls D::operator=(int)
// ditto
// calls D::operator=(const B&)
// ditto
// calls implicitly-declared
// D::operator=(const D&)

— end example ] — end note ]
13.5.4 Function call

[over.call]
1 operator() shall be a non-static member function with an arbitrary number of parameters. It can have

default arguments. It implements the function call syntax

§ 13.5.4

326

c(cid:13) ISO/IEC

N4296

postﬁx-expression ( expression-listopt)

where the postﬁx-expression evaluates to a class object and the possibly empty expression-list matches the
parameter list of an operator() member function of the class. Thus, a call x(arg1,...) is interpreted as
x.operator()(arg1, ...) for a class object x of type T if T::operator()(T1, T2, T3) exists and if the
operator is selected as the best match function by the overload resolution mechanism (13.3.3).
13.5.5 Subscripting

[over.sub]
1 operator[] shall be a non-static member function with exactly one parameter. It implements the subscript-

ing syntax

postﬁx-expression [ expression ]

or

postﬁx-expression [ braced-init-list ]

Thus, a subscripting expression x[y] is interpreted as x.operator[](y) for a class object x of type T
if T::operator[](T1) exists and if the operator is selected as the best match function by the overload
resolution mechanism (13.3.3). [ Example:

Z operator[](std::initializer_list<int>);

struct X {

};
X x;
x[{1,2,3}] = 7;
int a[10];
a[{1,2,3}] = 7;

// OK: meaning x.operator[]({1,2,3})

// error: built-in subscript operator

— end example ]
13.5.6 Class member access

access syntax that uses ->.

[over.ref]
1 operator-> shall be a non-static member function taking no parameters. It implements the class member

postﬁx-expression -> templateopt id-expression
postﬁx-expression -> pseudo-destructor-name

Increment and decrement

An expression x->m is interpreted as (x.operator->())->m for a class object x of type T if T::operator->()
exists and if the operator is selected as the best match function by the overload resolution mechanism (13.3).
[over.inc]
13.5.7
1 The user-deﬁned function called operator++ implements the preﬁx and postﬁx ++ operator. If this function
is a non-static member function with no parameters, or a non-member function with one parameter, it
deﬁnes the preﬁx increment operator ++ for objects of that type. If the function is a non-static member
function with one parameter (which shall be of type int) or a non-member function with two parameters
(the second of which shall be of type int), it deﬁnes the postﬁx increment operator ++ for objects of that
type. When the postﬁx increment is called as a result of using the ++ operator, the int argument will have
value zero.135 [ Example:

struct X {

X&
X
};

operator++();
operator++(int);

// preﬁx ++a
// postﬁx a++

135) Calling operator++ explicitly, as in expressions like a.operator++(2), has no special properties: The argument to
operator++ is 2.

§ 13.5.7

327

c(cid:13) ISO/IEC

N4296

struct Y { };
Y&
Y

operator++(Y&);
operator++(Y&, int);

// preﬁx ++b
// postﬁx b++

void f(X a, Y b) {

++a;
a++;
++b;
b++;

a.operator++();
a.operator++(0);
operator++(b);
operator++(b, 0);

}

— end example ]

// a.operator++();
// a.operator++(0);
// operator++(b);
// operator++(b, 0);

// explicit call: like ++a;
// explicit call: like a++;
// explicit call: like ++b;
// explicit call: like b++;

2 The preﬁx and postﬁx decrement operators -- are handled analogously.

13.5.8 User-deﬁned literals

[over.literal]

literal-operator-id:

operator string-literal identiﬁer
operator user-deﬁned-string-literal

1 The string-literal or user-deﬁned-string-literal in a literal-operator-id shall have no encoding-preﬁx and shall
contain no characters other than the implicit terminating ’\0’. The ud-suﬃx of the user-deﬁned-string-
literal or the identiﬁer in a literal-operator-id is called a literal suﬃx identiﬁer. Some literal suﬃx identiﬁers
are reserved for future standardization; see 17.6.4.3.4. A declaration whose literal-operator-id uses such a
literal suﬃx identiﬁer is ill-formed; no diagnostic required.

2 A declaration whose declarator-id is a literal-operator-id shall be a declaration of a namespace-scope function
or function template (it could be a friend function (11.3)), an explicit instantiation or specialization of a
function template, or a using-declaration (7.3.3). A function declared with a literal-operator-id is a literal
operator. A function template declared with a literal-operator-id is a literal operator template.

3 The declaration of a literal operator shall have a parameter-declaration-clause equivalent to one of the

following:

const char*
unsigned long long int
long double
char
wchar_t
char16_t
char32_t
const char*, std::size_t
const wchar_t*, std::size_t
const char16_t*, std::size_t
const char32_t*, std::size_t

If a parameter has a default argument (8.3.6), the program is ill-formed.

4 A raw literal operator is a literal operator with a single parameter whose type is const char*.
5 The declaration of a literal operator template shall have an empty parameter-declaration-clause and its
template-parameter-list shall have a single template-parameter that is a non-type template parameter pack
(14.5.3) with element type char.

§ 13.5.8

328

c(cid:13) ISO/IEC

N4296

6 Literal operators and literal operator templates shall not have C language linkage.
7

[ Note: Literal operators and literal operator templates are usually invoked implicitly through user-deﬁned
literals (2.13.8). However, except for the constraints described above, they are ordinary namespace-scope
functions and function templates. In particular, they are looked up like ordinary functions and function tem-
plates and they follow the same overload resolution rules. Also, they can be declared inline or constexpr,
they may have internal or external linkage, they can be called explicitly, their addresses can be taken, etc.
— end note ]
[ Example:

8

// OK
void operator "" _km(long double);
string operator "" _i18n(const char*, std::size_t); // OK
// OK: UCN for lowercase pi
template <char...> double operator "" _\u03C0();
// OK
float operator ""_e(const char*);
// error: reserved literal suﬃx (17.6.4.3.4, 2.13.8)
float operator ""E(const char*);
// OK: does not use the reserved identiﬁer _Bq (2.10)
double operator""_Bq(long double);
// uses the reserved identiﬁer _Bq (2.10)
double operator"" _Bq(long double);
// error: non-empty string-literal
float operator " " B(const char*);
// error: invalid literal suﬃx identiﬁer
string operator "" 5X(const char*, std::size_t);
// error: invalid parameter-declaration-clause
double operator "" _miles(double);
template <char...> int operator "" _j(const char*); // error: invalid parameter-declaration-clause
extern "C" void operator "" _m(long double);

// error: C language linkage

— end example ]
13.6 Built-in operators

[over.built]
1 The candidate operator functions that represent the built-in operators deﬁned in Clause 5 are speciﬁed in
this subclause. These candidate functions participate in the operator overload resolution process as described
in 13.3.1.2 and are used for no other purpose.
[ Note: Because built-in operators take only operands with
non-class type, and operator overload resolution occurs only when an operand expression originally has class
or enumeration type, operator overload resolution can resolve to a built-in operator only when an operand
has a class type that has a user-deﬁned conversion to a non-class type appropriate for the operator, or when
an operand has an enumeration type that can be converted to a type appropriate for the operator. Also note
that some of the candidate operator functions given in this subclause are more permissive than the built-in
operators themselves. As described in 13.3.1.2, after a built-in operator is selected by overload resolution
the expression is subject to the requirements for the built-in operator given in Clause 5, and therefore to
any additional semantic constraints given there. If there is a user-written candidate with the same name
and parameter types as a built-in candidate operator function, the built-in operator function is hidden and
is not included in the set of candidate functions. — end note ]
In this subclause, the term promoted integral type is used to refer to those integral types which are preserved
by integral promotion (including e.g. int and long but excluding e.g. char). Similarly, the term promoted
arithmetic type refers to ﬂoating types plus promoted integral types. [ Note: In all cases where a promoted
integral type or promoted arithmetic type is required, an operand of enumeration type will be acceptable
by way of the integral promotions. — end note ]

2

3 For every pair (T, VQ), where T is an arithmetic type, and VQ is either volatile or empty, there exist

candidate operator functions of the form

VQ T & operator++(VQ T &);
T operator++(VQ T &, int);

4 For every pair (T, VQ), where T is an arithmetic type other than bool, and VQ is either volatile or empty,

there exist candidate operator functions of the form

§ 13.6

329

c(cid:13) ISO/IEC

VQ T & operator--(VQ T &);
T operator--(VQ T &, int);

N4296

5 For every pair (T, VQ), where T is a cv-qualiﬁed or cv-unqualiﬁed object type, and VQ is either volatile

or empty, there exist candidate operator functions of the form

T *VQ & operator++(T *VQ &);
T *VQ & operator--(T *VQ &);
T *
T *

operator++(T *VQ &, int);
operator--(T *VQ &, int);

6 For every cv-qualiﬁed or cv-unqualiﬁed object type T, there exist candidate operator functions of the form

T &

operator*(T *);

7 For every function type T that does not have cv-qualiﬁers or a ref-qualiﬁer, there exist candidate operator

functions of the form

T &

operator*(T *);

8 For every type T there exist candidate operator functions of the form

T *

operator+(T *);

9 For every promoted arithmetic type T, there exist candidate operator functions of the form

T operator+(T );
T operator-(T );

10 For every promoted integral type T, there exist candidate operator functions of the form

T operator~(T );

11 For every quintuple (C1, C2, T, CV1, CV2), where C2 is a class type, C1 is the same type as C2 or is a
derived class of C2, T is an object type or a function type, and CV1 and CV2 are cv-qualiﬁer-seqs, there
exist candidate operator functions of the form

CV12 T & operator->*(CV1 C1*, CV2 T C2::*);

where CV12 is the union of CV1 and CV2. The return type is shown for exposition only; see 5.5 for the
determination of the operator’s result type.

12 For every pair of promoted arithmetic types L and R, there exist candidate operator functions of the form

LR
LR
LR
LR
bool
bool
bool
bool
bool
bool

operator*(L , R );
operator/(L , R );
operator+(L , R );
operator-(L , R );
operator<(L , R );
operator>(L , R );
operator<=(L , R );
operator>=(L , R );
operator==(L , R );
operator!=(L , R );

where LR is the result of the usual arithmetic conversions between types L and R.

13 For every cv-qualiﬁed or cv-unqualiﬁed object type T there exist candidate operator functions of the form

§ 13.6

330

c(cid:13) ISO/IEC

N4296

T *
T &
T *
T *
T &

operator+(T *, std::ptrdiff_t);
operator[](T *, std::ptrdiff_t);
operator-(T *, std::ptrdiff_t);
operator+(std::ptrdiff_t, T *);
operator[](std::ptrdiff_t, T *);

14 For every T, where T is a pointer to object type, there exist candidate operator functions of the form

std::ptrdiff_t

operator-(T , T );

15 For every T, where T is an enumeration type or a pointer type, there exist candidate operator functions of

the form

bool
bool
bool
bool
bool
bool

operator<(T , T );
operator>(T , T );
operator<=(T , T );
operator>=(T , T );
operator==(T , T );
operator!=(T , T );

16 For every pointer to member type T or type std::nullptr_t there exist candidate operator functions of

the form

bool
bool

operator==(T , T );
operator!=(T , T );

17 For every pair of promoted integral types L and R, there exist candidate operator functions of the form

LR
LR
LR
LR
L
L

operator%(L , R );
operator&(L , R );
operator^(L , R );
operator|(L , R );
operator<<(L , R );
operator>>(L , R );

where LR is the result of the usual arithmetic conversions between types L and R.

18 For every triple (L, VQ, R), where L is an arithmetic type, VQ is either volatile or empty, and R is a

promoted arithmetic type, there exist candidate operator functions of the form

VQ L &
VQ L &
VQ L &
VQ L &
VQ L &

operator=(VQ L &, R );
operator*=(VQ L &, R );
operator/=(VQ L &, R );
operator+=(VQ L &, R );
operator-=(VQ L &, R );

19 For every pair (T, VQ), where T is any type and VQ is either volatile or empty, there exist candidate

operator functions of the form

T *VQ &

operator=(T *VQ &, T *);

20 For every pair (T, VQ), where T is an enumeration or pointer to member type and VQ is either volatile

or empty, there exist candidate operator functions of the form

VQ T &

operator=(VQ T &, T );

21 For every pair (T, VQ), where T is a cv-qualiﬁed or cv-unqualiﬁed object type and VQ is either volatile

or empty, there exist candidate operator functions of the form

§ 13.6

331

c(cid:13) ISO/IEC

N4296

T *VQ &
T *VQ &

operator+=(T *VQ &, std::ptrdiff_t);
operator-=(T *VQ &, std::ptrdiff_t);

22 For every triple (L, VQ, R), where L is an integral type, VQ is either volatile or empty, and R is a

promoted integral type, there exist candidate operator functions of the form

VQ L &
VQ L &
VQ L &
VQ L &
VQ L &
VQ L &

operator%=(VQ L &, R );
operator<<=(VQ L &, R );
operator>>=(VQ L &, R );
operator&=(VQ L &, R );
operator^=(VQ L &, R );
operator|=(VQ L &, R );

23 There also exist candidate operator functions of the form

bool
bool
bool

operator!(bool);
operator&&(bool, bool);
operator||(bool, bool);

24 For every pair of promoted arithmetic types L and R, there exist candidate operator functions of the form

LR

operator?:(bool, L , R );

where LR is the result of the usual arithmetic conversions between types L and R. [ Note: As with all these
descriptions of candidate functions, this declaration serves only to describe the built-in operator for purposes
of overload resolution. The operator “?:” cannot be overloaded. — end note ]

25 For every type T, where T is a pointer, pointer-to-member, or scoped enumeration type, there exist candidate

operator functions of the form

T

operator?:(bool, T , T );

§ 13.6

332

c(cid:13) ISO/IEC

14 Templates

N4296

[temp]

1 A template deﬁnes a family of classes or functions or an alias for a family of types.

template-declaration:

template < template-parameter-list > declaration

template-parameter-list:

template-parameter
template-parameter-list , template-parameter

[ Note: The > token following the template-parameter-list of a template-declaration may be the product of
replacing a >> token by two consecutive > tokens (14.2). — end note ]
The declaration in a template-declaration shall

(1.1)

(1.2)

(1.3)

(1.4)

—
—

—
—

declare or deﬁne a function, a class, or a variable, or
deﬁne a member function, a member class, a member enumeration, or a static data member of a class
template or of a class nested within a class template, or
deﬁne a member template of a class or class template, or
be an alias-declaration.

A template-declaration is a declaration. A template-declaration is also a deﬁnition if its declaration deﬁnes
a function, a class, a variable, or a static data member. A declaration introduced by a template declaration
of a variable is a variable template. A variable template at class scope is a static data member template.
[ Example:

template<class T>

constexpr T pi = T(3.1415926535897932385L);

template<class T>
T circular_area(T r) {
return pi<T> * r * r;

}
struct matrix_constants {

template<class T>
using pauli = hermitian_matrix<T, 2>;
template<class T>
constexpr pauli<T> sigma1 = { { 0, 1 }, { 1, 0 } };
template<class T>
constexpr pauli<T> sigma2 = { { 0, -1i }, { 1i, 0 } };
template<class T>
constexpr pauli<T> sigma3 = { { 1, 0 }, { 0, -1 } };

};

— end example ]

2 A template-declaration can appear only as a namespace scope or class scope declaration.

In a function
template declaration, the last component of the declarator-id shall not be a template-id. [ Note: That last
component may be an identiﬁer, an operator-function-id, a conversion-function-id, or a literal-operator-id.
In a class template declaration, if the class name is a simple-template-id, the declaration declares a class
template partial specialization (14.5.5). — end note ]

Templates

333

c(cid:13) ISO/IEC

N4296

3

In a template-declaration, explicit specialization, or explicit instantiation the init-declarator-list in the dec-
laration shall contain at most one declarator. When such a declaration is used to declare a class template,
no declarator is permitted.

4 A template name has linkage (3.5). Specializations (explicit or implicit) of a template that has internal link-
age are distinct from all specializations in other translation units. A template, a template explicit specializa-
tion (14.7.3), and a class template partial specialization shall not have C linkage. Use of a linkage speciﬁcation
other than C or C++ with any of these constructs is conditionally-supported, with implementation-deﬁned
semantics. Template deﬁnitions shall obey the one deﬁnition rule (3.2).
[ Note: Default arguments for
function templates and for member functions of class templates are considered deﬁnitions for the purpose of
template instantiation (14.5) and must also obey the one deﬁnition rule. — end note ]

5 A class template shall not have the same name as any other template, class, function, variable, enumeration,
enumerator, namespace, or type in the same scope (3.3), except as speciﬁed in (14.5.5). Except that a
function template can be overloaded either by non-template functions (8.3.5) with the same name or by
other function templates with the same name (14.8.3), a template name declared in namespace scope or in
class scope shall be unique in that scope.

6 A function template, member function of a class template, variable template, or static data member of a
class template shall be deﬁned in every translation unit in which it is implicitly instantiated (14.7.1) unless
the corresponding specialization is explicitly instantiated (14.7.2) in some translation unit; no diagnostic is
required.
14.1 Template parameters

[temp.param]

1 The syntax for template-parameters is:

template-parameter:
type-parameter
parameter-declaration

type-parameter:

type-parameter-key ...opt identiﬁeropt
type-parameter-key identiﬁeropt= type-id
template < template-parameter-list > type-parameter-key ...opt identiﬁeropt
template < template-parameter-list > type-parameter-key identiﬁeropt= id-expression

type-parameter-key:

class
typename

[ Note: The > token following the template-parameter-list of a type-parameter may be the product of replacing
a >> token by two consecutive > tokens (14.2). — end note ]

2 There is no semantic diﬀerence between class and typename in a type-parameter-key. typename followed by
an unqualiﬁed-id names a template type parameter. typename followed by a qualiﬁed-id denotes the type in
a non-type136 parameter-declaration. A template-parameter of the form class identiﬁer is a type-parameter.
[ Example:

class T { /∗ ... ∗/ };
int i;

template<class T, T i> void f(T t) {

T t1 = i;
::T t2 = ::i; // global namespace members T and i

// template-parameters T and i

}

136) Since template template-parameters and template template-arguments are treated as types for descriptive purposes, the
terms non-type parameter and non-type argument are used to refer to non-type, non-template parameters and arguments.

§ 14.1

334

c(cid:13) ISO/IEC

N4296

Here, the template f has a type-parameter called T, rather than an unnamed non-type template-parameter
of class T. — end example ] A storage class shall not be speciﬁed in a template-parameter declaration. Types
shall not be deﬁned in a template-parameter declaration.

3 A type-parameter whose identiﬁer does not follow an ellipsis deﬁnes its identiﬁer to be a typedef-name (if
declared without template) or template-name (if declared with template) in the scope of the template
declaration. [ Note: A template argument may be a class template or alias template. For example,

template<class T> class myarray { /∗ ... ∗/ };

template<class K, class V, template<class T> class C = myarray>
class Map {
C<K> key;
C<V> value;

};

— end note ]

4 A non-type template-parameter shall have one of the following (optionally cv-qualiﬁed) types:

(4.1)

(4.2)

(4.3)

(4.4)

(4.5)

5

—
—
—
—
—

integral or enumeration type,
pointer to object or pointer to function,
lvalue reference to object or lvalue reference to function,
pointer to member,
std::nullptr_t.

[ Note: Other types are disallowed either explicitly below or implicitly by the rules governing the form of
template-arguments (14.3). — end note ] The top-level cv-qualiﬁers on the template-parameter are ignored
when determining its type.

6 A non-type non-reference template-parameter is a prvalue. It shall not be assigned to or in any other way
have its value changed. A non-type non-reference template-parameter cannot have its address taken. When
a non-type non-reference template-parameter is used as an initializer for a reference, a temporary is always
used. [ Example:

template<const X& x, int i> void f() {

i++;

// error: change of template-parameter value

&x;
&i;

int& ri = i;
const int& cri = i;

}

— end example ]

// OK
// error: address of non-reference template-parameter

// error: non-const reference bound to temporary
// OK: const reference bound to temporary

7 A non-type template-parameter shall not be declared to have ﬂoating point, class, or void type. [ Example:

template<double d> class X;
template<double* pd> class Y;
template<double& rd> class Z;

// error
// OK
// OK

— end example ]

8 A non-type template-parameter of type “array of T” or “function returning T” is adjusted to be of type

“pointer to T” or “pointer to function returning T”, respectively. [ Example:

§ 14.1

335

c(cid:13) ISO/IEC

N4296

struct R { /∗ ... ∗/ };
template<int* a>
template<int b[5]> struct S { /∗ ... ∗/ };
int p;
R<&p> w;
S<&p> x;
int v[5];
R<v> y;
S<v> z;

// OK
// OK due to parameter adjustment

// OK due to implicit argument conversion
// OK due to both adjustment and conversion

— end example ]

9 A default template-argument is a template-argument (14.3) speciﬁed after = in a template-parameter. A de-
fault template-argument may be speciﬁed for any kind of template-parameter (type, non-type, template) that
is not a template parameter pack (14.5.3). A default template-argument may be speciﬁed in a template dec-
laration. A default template-argument shall not be speciﬁed in the template-parameter-lists of the deﬁnition
of a member of a class template that appears outside of the member’s class. A default template-argument
shall not be speciﬁed in a friend class template declaration. If a friend function template declaration speciﬁes
a default template-argument, that declaration shall be a deﬁnition and shall be the only declaration of the
function template in the translation unit.

10 The set of default template-arguments available for use with a template declaration or deﬁnition is obtained
by merging the default arguments from the deﬁnition (if in scope) and all declarations in scope in the same
way default function arguments are (8.3.6). [ Example:

template<class T1, class T2 = int> class A;
template<class T1 = int, class T2> class A;

is equivalent to

template<class T1 = int, class T2 = int> class A;

11

— end example ]
If a template-parameter of a class template or alias template has a default template-argument, each subse-
quent template-parameter shall either have a default template-argument supplied or be a template parameter
pack. If a template-parameter of a primary class template or alias template is a template parameter pack, it
shall be the last template-parameter. A template parameter pack of a function template shall not be followed
by another template parameter unless that template parameter can be deduced from the parameter-type-list
of the function template or has a default argument (14.8.2). [ Example:

template<class T1 = int, class T2> class B;

// error

// U can be neither deduced from the parameter-type-list nor speciﬁed
template<class... T, class... U> void f() { } // error
// error
template<class... T, class U> void g() { }

— end example ]

12 A template-parameter shall not be given default arguments by two diﬀerent declarations in the same scope.

[ Example:

template<class T = int> class X;
template<class T = int> class X { /∗... ∗/ }; // error

— end example ]

13 When parsing a default template-argument for a non-type template-parameter, the ﬁrst non-nested > is taken

as the end of the template-parameter-list rather than a greater-than operator. [ Example:

§ 14.1

336

c(cid:13) ISO/IEC

N4296

template<int i = 3 > 4 >
class X { /∗ ... ∗/ };

// syntax error

template<int i = (3 > 4) >
class Y { /∗ ... ∗/ };

// OK

— end example ]

14 A template-parameter of a template template-parameter is permitted to have a default template-argument.
When such default arguments are speciﬁed, they apply to the template template-parameter in the scope of
the template template-parameter. [ Example:
template <class T = float> struct B {};
template <template <class TT = float> class T> struct A {

inline void f();
inline void g();

};
template <template <class TT> class T> void A<T>::f() {

T<> t;

// error - TT has no default template argument

}
template <template <class TT = char> class T> void A<T>::g() {

T<> t;

// OK - T<char>

}

15

— end example ]
If a template-parameter is a type-parameter with an ellipsis prior to its optional identiﬁer or is a parameter-
declaration that declares a parameter pack (8.3.5), then the template-parameter is a template parameter
pack (14.5.3). A template parameter pack that is a parameter-declaration whose type contains one or more
unexpanded parameter packs is a pack expansion. Similarly, a template parameter pack that is a type-
parameter with a template-parameter-list containing one or more unexpanded parameter packs is a pack
expansion. A template parameter pack that is a pack expansion shall not expand a parameter pack declared
in the same template-parameter-list. [ Example:

template <class... Types> class Tuple;

template <class T, int... Dims> struct multi_array;

template<class... T> struct value_holder {
template<T... Values> struct apply { };

// Types is a template type parameter pack
// but not a pack expansion
// Dims is a non-type template parameter pack
// but not a pack expansion

// Values is a non-type template parameter pack
// and a pack expansion

};
template<class... T, T... Values> struct static_array;// error: Values expands template type parameter
// pack T within the same template parameter list

— end example ]
14.2 Names of template specializations

1 A template specialization (14.7) can be referred to by a template-id:

simple-template-id:

template-name < template-argument-listopt>

template-id:

simple-template-id
operator-function-id < template-argument-listopt>
literal-operator-id < template-argument-listopt>

[temp.names]

§ 14.2

337

c(cid:13) ISO/IEC

template-name:
identiﬁer

template-argument-list:

template-argument ...opt
template-argument-list , template-argument ...opt

template-argument:

constant-expression
type-id
id-expression

N4296

[ Note: The name lookup rules (3.4) are used to associate the use of a name with a template declaration;
that is, to identify a name as a template-name. — end note ]

2 For a template-name to be explicitly qualiﬁed by the template arguments, the name must be known to refer

to a template.

3 After name lookup (3.4) ﬁnds that a name is a template-name or that an operator-function-id or a literal-
operator-id refers to a set of overloaded functions any member of which is a function template, if this is
followed by a <, the < is always taken as the delimiter of a template-argument-list and never as the less-than
operator. When parsing a template-argument-list, the ﬁrst non-nested >137 is taken as the ending delimiter
rather than a greater-than operator. Similarly, the ﬁrst non-nested >> is treated as two consecutive but
distinct > tokens, the ﬁrst of which is taken as the end of the template-argument-list and completes the
template-id.
[ Note: The second > token produced by this replacement rule may terminate an enclosing
template-id construct or it may be part of a diﬀerent construct (e.g. a cast). — end note ] [ Example:

template<int i> class X { /* ...

*/ };

X< 1>2 > x1;
X<(1>2)> x2;

// syntax error
// OK

template<class T> class Y { /* ...
Y<X<1>> x3;
Y<X<6>>1>> x4;
Y<X<(6>>1)>> x5;

*/ };
// OK, same as Y<X<1> > x3;
// syntax error
// OK

— end example ]

4 When the name of a member template specialization appears after . or -> in a postﬁx-expression or after a
nested-name-speciﬁer in a qualiﬁed-id, and the object expression of the postﬁx-expression is type-dependent
or the nested-name-speciﬁer in the qualiﬁed-id refers to a dependent type, but the name is not a member of
the current instantiation (14.6.2.1), the member template name must be preﬁxed by the keyword template.
Otherwise the name is assumed to name a non-template. [ Example:

struct X {

template<std::size_t> X* alloc();
template<std::size_t> static X* adjust();

};
template<class T> void f(T* p) {

T* p1 = p->alloc<200>();
T* p2 = p->template alloc<200>(); // OK: < starts template argument list
T::adjust<100>();
T::template adjust<100>();

// ill-formed: < means less than
// OK: < starts template argument list

// ill-formed: < means less than

}

— end example ]
137) A > that encloses the type-id of a dynamic_cast, static_cast, reinterpret_cast or const_cast, or which encloses the
template-arguments of a subsequent template-id, is considered nested for the purpose of this description.

§ 14.2

338

c(cid:13) ISO/IEC

N4296

5 A name preﬁxed by the keyword template shall be a template-id or the name shall refer to a class template.
[ Note: The keyword template may not be applied to non-template members of class templates. — end
note ] [ Note: As is the case with the typename preﬁx, the template preﬁx is allowed in cases where it is
not strictly necessary; i.e., when the nested-name-speciﬁer or the expression on the left of the -> or . is not
dependent on a template-parameter, or the use does not appear in the scope of a template. — end note ]
[ Example:

template <class T> struct A {

void f(int);
template <class U> void f(U);

};

template <class T> void f(T t) {

A<T> a;
a.template f<>(t);
a.template f(t);

}

// OK: calls template
// error: not a template-id

template <class T> struct B {

template <class T2> struct C { };

};

// OK: T::template C names a class template:
template <class T, template <class X> class TT = T::template C> struct D { };
D<B<int> > db;

— end example ]

6 A simple-template-id that names a class template specialization is a class-name (Clause 9).
7 A template-id that names an alias template specialization is a type-name.

14.3 Template arguments

[temp.arg]
1 There are three forms of template-argument, corresponding to the three forms of template-parameter: type,
non-type and template. The type and form of each template-argument speciﬁed in a template-id shall
match the type and form speciﬁed for the corresponding parameter declared by the template in its template-
parameter-list. When the parameter declared by the template is a template parameter pack (14.5.3), it will
correspond to zero or more template-arguments. [ Example:

template<class T> class Array {

T* v;
int sz;

public:

};

explicit Array(int);
T& operator[](int);
T& elem(int i) { return v[i]; }

Array<int> v1(20);
typedef std::complex<double> dcomplex; // std::complex is a standard

// library template

Array<dcomplex> v2(30);
Array<dcomplex> v3(40);

void bar() {
v1[3] = 7;

§ 14.3

339

c(cid:13) ISO/IEC

N4296

v2[3] = v3.elem(4) = dcomplex(7,8);

}

2

— end example ]
In a template-argument, an ambiguity between a type-id and an expression is resolved to a type-id, regardless
of the form of the corresponding template-parameter.138 [ Example:

template<class T> void f();
template<int I> void f();

void g() {

f<int()>();

}

// int() is a type-id: call the ﬁrst f()

— end example ]

3 The name of a template-argument shall be accessible at the point where it is used as a template-argument.
[ Note:
If the name of the template-argument is accessible at the point where it is used as a template-
argument, there is no further access restriction in the resulting instantiation where the corresponding
template-parameter name is used. — end note ] [ Example:

template<class T> class X {

static T t;

};

class Y {
private:

struct S { /∗ ... ∗/ };
X<S> x;

// OK: S is accessible
// X<Y::S> has a static member of type Y::S
// OK: even though Y::S is private

};

};

X<Y::S> y;

// error: S not accessible

— end example ] For a template-argument that is a class type or a class template, the template deﬁnition
has no special access rights to the members of the template-argument. [ Example:

template <template <class TT> class T> class A {

typename T<int>::S s;

template <class U> class B {
private:

struct S { /∗ ... ∗/ };

};

A<B> b;

// ill-formed: A has no access to B::S

— end example ]

4 When template argument packs or default template-arguments are used, a template-argument list can be

empty. In that case the empty <> brackets shall still be used as the template-argument-list. [ Example:
138) There is no such ambiguity in a default template-argument because the form of the template-parameter determines the
allowable forms of the template-argument.

§ 14.3

340

c(cid:13) ISO/IEC

N4296

template<class T = char> class String;
String<>* p;
String* q;
template<class ... Elements> class Tuple;
Tuple<>* t;
Tuple* u;

// OK: String<char>
// syntax error

// OK: Elements is empty
// syntax error

— end example ]

5 An explicit destructor call (12.4) for an object that has a type that is a class template specialization may

explicitly specify the template-arguments. [ Example:

template<class T> struct A {

~A();

};
void f(A<int>* p, A<int>* q) {

p->A<int>::~A();
q->A<int>::~A<int>();

}

// OK: destructor call
// OK: destructor call

6

— end example ]
If the use of a template-argument gives rise to an ill-formed construct in the instantiation of a template
specialization, the program is ill-formed.

7 When the template in a template-id is an overloaded function template, both non-template functions in the
overload set and function templates in the overload set for which the template-arguments do not match the
template-parameters are ignored. If none of the function templates have matching template-parameters, the
program is ill-formed.

8 A template-argument followed by an ellipsis is a pack expansion (14.5.3).

14.3.1 Template type arguments

1 A template-argument for a template-parameter which is a type shall be a type-id.
2

[ Example:

[temp.arg.type]

template <class T> class X { };
template <class T> void f(T t) { }
struct { } unnamed_obj;

void f() {

struct A { };
enum { e1 };
typedef struct { } B;
B b;
X<A> x1;
X<A*> x2;
X<B> x3;
f(e1);
f(unnamed_obj);
f(b);

// OK
// OK
// OK
// OK
// OK
// OK

}

3

— end example ] [ Note: A template type argument may be an incomplete type (3.9). — end note ]
If a declaration acquires a function type through a type dependent on a template-parameter and this causes a
declaration that does not use the syntactic form of a function declarator to have function type, the program
is ill-formed. [ Example:

§ 14.3.1

341

c(cid:13) ISO/IEC

N4296

template<class T> struct A {

static T t;

};
typedef int function();
A<function> a;

// ill-formed: would declare A<function>::t
// as a static member function

— end example ]
14.3.2 Template non-type arguments

[temp.arg.nontype]
1 A template-argument for a non-type template-parameter shall be a converted constant expression (5.20) of
the type of the template-parameter. For a non-type template-parameter of reference or pointer type, the
value of the constant expression shall not refer to (or for a pointer type, shall not be the address of):

(1.1)

(1.2)

(1.3)

(1.4)

(1.5)

—
—
—
—
—

a subobject (1.8),
a temporary object (12.2),
a string literal (2.13.5),
the result of a typeid expression (5.2.8), or
a predeﬁned __func__ variable (8.4.1).

[ Note: If the template-argument represents a set of overloaded functions (or a pointer or member pointer to
such), the matching function is selected from the set (13.4). — end note ]
[ Example:

2

template<const int* pci> struct X { /∗ ... ∗/ };
int ai[10];
X<ai> xi;
struct Y { /∗ ... ∗/ };
template<const Y& b> struct Z { /∗ ... ∗/ };
Y y;
Z<y> z;
template<int (&pa)[5]> struct W { /∗ ... ∗/ };
int b[5];
W<b> w;

// no conversion

// array to pointer and qualiﬁcation conversions

// no conversion, but note extra cv-qualiﬁcation

void f(char);
void f(int);
template<void (*pf)(int)> struct A { /∗ ... ∗/ };

A<&f> a;

// selects f(int)

— end example ]
[ Note: A string literal (2.13.5) is not an acceptable template-argument. [ Example:

3

template<class T, const char* p> class X {

/∗ ... ∗/

};

X<int, "Studebaker"> x1;

// error: string literal as template-argument

§ 14.3.2

342

c(cid:13) ISO/IEC

N4296

const char p[] = "Vivisectionist";
X<int,p> x2;

// OK

4

— end example ] — end note ]
[ Note: The address of an array element or non-static data member is not an acceptable template-argument.
[ Example:

template<int* p> class X { };

int a[10];
struct S { int m; static int s; } s;

X<&a[2]> x3;
X<&s.m> x4;
X<&s.s> x5;
X<&S::s> x6;

// error: address of array element
// error: address of non-static member
// OK: address of static member
// OK: address of static member

5

— end example ] — end note ]
[ Note: A temporary object is not an acceptable template-argument when the corresponding template-
parameter has reference type. [ Example:

template<const int& CRI> struct B { /∗ ... ∗/ };

B<1> b2;

int c = 1;
B<c> b1;

// error: temporary would be required for template argument

// OK

— end example ] — end note ]
14.3.3 Template template arguments

[temp.arg.template]
1 A template-argument for a template template-parameter shall be the name of a class template or an alias
template, expressed as id-expression. When the template-argument names a class template, only primary
class templates are considered when matching the template template argument with the corresponding
parameter; partial specializations are not considered even if their parameter lists match that of the template
template parameter.

2 Any partial specializations (14.5.5) associated with the primary class template or primary variable template
are considered when a specialization based on the template template-parameter is instantiated. If a special-
ization is not visible at the point of instantiation, and it would have been selected had it been visible, the
program is ill-formed; no diagnostic is required. [ Example:

template<class T> class A {

// primary template

};
template<class T> class A<T*> { // partial specialization

};
template<template<class U> class V> class C {

int x;

long x;

V<int>
y;
V<int*> z;

};
C<A> c;

// V<int> within C<A> uses the primary template,
// so c.y.x has type int

§ 14.3.3

343

c(cid:13) ISO/IEC

— end example ]

// V<int*> within C<A> uses the partial specialization,
// so c.z.x has type long

N4296

3 A template-argument matches a template template-parameter P when each of the template parameters in the
template-parameter-list of the template-argument’s corresponding class template or alias template A matches
the corresponding template parameter in the template-parameter-list of P. Two template parameters match
if they are of the same kind (type, non-type, template), for non-type template-parameters, their types are
equivalent (14.5.6.1), and for template template-parameters, each of their corresponding template-parameters
matches, recursively. When P’s template-parameter-list contains a template parameter pack (14.5.3), the
template parameter pack will match zero or more template parameters or template parameter packs in the
template-parameter-list of A with the same type and form as the template parameter pack in P (ignoring
whether those template parameters are template parameter packs).
[ Example:

template<class T> class A { /∗ ... ∗/ };
template<class T, class U = T> class B { /∗ ... ∗/ };
template <class ... Types> class C { /∗ ... ∗/ };
template<template<class> class P> class X { /∗ ... ∗/ };
template<template<class ...> class Q> class Y { /∗ ... ∗/ };

// OK
// ill-formed: default arguments for the parameters of a template argument are ignored
// ill-formed: a template parameter pack does not match a template parameter

// OK
// OK
// OK

X<A> xa;
X<B> xb;
X<C> xc;

Y<A> ya;
Y<B> yb;
Y<C> yc;

— end example ]
[ Example:

template <class T> struct eval;

template <template <class, class...> class TT, class T1, class... Rest>
struct eval<TT<T1, Rest...>> { };

template <class T1> struct A;
template <class T1, class T2> struct B;
template <int N> struct C;
template <class T1, int N> struct D;
template <class T1, class T2, int N = 17> struct E;

eval<A<int>> eA;
eval<B<int, float>> eB;
eval<C<17>> eC;
eval<D<int, 17>> eD;
eval<E<int, float>> eE;

— end example ]
14.4 Type equivalence

// OK: matches partial specialization of eval
// OK: matches partial specialization of eval
// error: C does not match TT in partial specialization
// error: D does not match TT in partial specialization
// error: E does not match TT in partial specialization

1 Two template-ids refer to the same class, function, or variable if

§ 14.4

[temp.type]

344

c(cid:13) ISO/IEC

N4296

(1.1)

(1.2)

(1.3)

(1.4)

(1.5)

(1.6)

(1.7)

—
—
—

—

—

—

—

their template-names, operator-function-ids, or literal-operator-ids refer to the same template and
their corresponding type template-arguments are the same type and
their corresponding non-type template arguments of integral or enumeration type have identical values
and
their corresponding non-type template-arguments of pointer type refer to the same object or function
or are both the null pointer value and
their corresponding non-type template-arguments of pointer-to-member type refer to the same class
member or are both the null member pointer value and
their corresponding non-type template-arguments of reference type refer to the same object or function
and
their corresponding template template-arguments refer to the same template.

[ Example:

template<class E, int size> class buffer { /∗ ... ∗/ };
buffer<char,2*512> x;
buffer<char,1024> y;

declares x and y to be of the same type, and

template<class T, void(*err_fct)()> class list { /∗ ... ∗/ };
list<int,&error_handler1> x1;
list<int,&error_handler2> x2;
list<int,&error_handler2> x3;
list<char,&error_handler2> x4;

declares x2 and x3 to be of the same type. Their type diﬀers from the types of x1 and x4.

template<class T> struct X { };
template<class> struct Y { };
template<class T> using Z = Y<T>;
X<Y<int> > y;
X<Z<int> > z;

2

declares y and z to be of the same type. — end example ]
If an expression e involves a template parameter, decltype(e) denotes a unique dependent type. Two such
decltype-speciﬁers refer to the same type only if their expressions are equivalent (14.5.6.1). [ Note: however,
it may be aliased, e.g., by a typedef-name. — end note ]
14.5 Template declarations

[temp.decls]
1 A template-id, that is, the template-name followed by a template-argument-list shall not be speciﬁed in the

declaration of a primary template declaration. [ Example:

template<class T1, class T2, int I> class A<T1, T2, I> { };
template<class T1, int I> void sort<T1, I>(T1 data[I]);

// error
// error

— end example ] [ Note: However, this syntax is allowed in class template partial specializations (14.5.5).
— end note ]

2 For purposes of name lookup and instantiation, default arguments and exception-speciﬁcations of function
templates and default arguments and exception-speciﬁcations of member functions of class templates are

§ 14.5

345

c(cid:13) ISO/IEC

N4296

considered deﬁnitions; each default argument or exception-speciﬁcation is a separate deﬁnition which is
unrelated to the function template deﬁnition or to any other default arguments or exception-speciﬁcations.
3 Because an alias-declaration cannot declare a template-id, it is not possible to partially or explicitly specialize

an alias template.
14.5.1 Class templates

[temp.class]
1 A class template deﬁnes the layout and operations for an unbounded set of related types. [ Example: a single
class template List might provide a common deﬁnition for list of int, list of float, and list of pointers to
Shapes. — end example ]
[ Example: An array class template might be declared like this:

template<class T> class Array {

T* v;
int sz;

public:

};

explicit Array(int);
T& operator[](int);
T& elem(int i) { return v[i]; }

2 The preﬁx template <class T> speciﬁes that a template is being declared and that a type-name T will be
used in the declaration. In other words, Array is a parameterized type with T as its parameter. — end
example ]

3 When a member function, a member class, a member enumeration, a static data member or a member
template of a class template is deﬁned outside of the class template deﬁnition, the member deﬁnition is
deﬁned as a template deﬁnition in which the template-parameters are those of the class template. The
names of the template parameters used in the deﬁnition of the member may be diﬀerent from the template
parameter names used in the class template deﬁnition. The template argument list following the class
template name in the member deﬁnition shall name the parameters in the same order as the one used in the
template parameter list of the member. Each template parameter pack shall be expanded with an ellipsis
in the template argument list. [ Example:

template<class T1, class T2> struct A {

void f1();
void f2();

};

};

template<class T2, class T1> void A<T2,T1>::f1() { }
template<class T2, class T1> void A<T1,T2>::f2() { }

// OK
// error

template<class ... Types> struct B {

void f3();
void f4();

template<class ... Types> void B<Types ...>::f3() { }
template<class ... Types> void B<Types>::f4() { }

// OK
// error

4

— end example ]
In a redeclaration, partial specialization, explicit specialization or explicit instantiation of a class template,
the class-key shall agree in kind with the original class template declaration (7.1.6.3).

§ 14.5.1

346

c(cid:13) ISO/IEC

N4296

14.5.1.1 Member functions of class templates

[temp.mem.func]
1 A member function of a class template may be deﬁned outside of the class template deﬁnition in which it is

declared. [ Example:

template<class T> class Array {

T* v;
int sz;

public:

};

explicit Array(int);
T& operator[](int);
T& elem(int i) { return v[i]; }

declares three function templates. The subscript function might be deﬁned like this:

template<class T> T& Array<T>::operator[](int i) {

if (i<0 || sz<=i) error("Array: range error");
return v[i];

}

— end example ]

2 The template-arguments for a member function of a class template are determined by the template-arguments
of the type of the object for which the member function is called.
[ Example: the template-argument for
Array<T> :: operator [] () will be determined by the Array to which the subscripting operation is applied.

Array<int> v1(20);
Array<dcomplex> v2(30);

v1[3] = 7;
v2[3] = dcomplex(7,8);

// Array<int>::operator[]()
// Array<dcomplex>::operator[]()

— end example ]
14.5.1.2 Member classes of class templates

[temp.mem.class]
1 A member class of a class template may be deﬁned outside the class template deﬁnition in which it is declared.
[ Note: The member class must be deﬁned before its ﬁrst use that requires an instantiation (14.7.1). For
example,

template<class T> struct A {

class B;

};
A<int>::B* b1;
template<class T> class A<T>::B { };
A<int>::B

b2;

// OK: requires A to be deﬁned but not A::B

// OK: requires A::B to be deﬁned

— end note ]
14.5.1.3 Static data members of class templates

[temp.static]
1 A deﬁnition for a static data member or static data member template may be provided in a namespace scope

enclosing the deﬁnition of the static member’s class template. [ Example:

template<class T> class X {

static T s;

};
template<class T> T X<T>::s = 0;

§ 14.5.1.3

347

c(cid:13) ISO/IEC

N4296

struct limits {

template<class T>

static const T min;

};

// declaration

template<class T>

const T limits::min = { };

// deﬁnition

— end example ]

2 An explicit specialization of a static data member declared as an array of unknown bound can have a diﬀerent

bound from its deﬁnition, if any. [ Example:

template <class T> struct A {

static int i[];

};
template <class T> int A<T>::i[4];
template <> int A<int>::i[] = { 1 }; // OK: 1 element

// 4 elements

— end example ]
14.5.1.4 Enumeration members of class templates

[temp.mem.enum]
1 An enumeration member of a class template may be deﬁned outside the class template deﬁnition. [ Example:

template<class T> struct A {

enum E : T;

};
A<int> a;
template<class T> enum A<T>::E : T { e1, e2 };
A<int>::E e = A<int>::e1;

— end example ]
14.5.2 Member templates

[temp.mem]
1 A template can be declared within a class or class template; such a template is called a member template. A
member template can be deﬁned within or outside its class deﬁnition or class template deﬁnition. A member
template of a class template that is deﬁned outside of its class template deﬁnition shall be speciﬁed with
the template-parameters of the class template followed by the template-parameters of the member template.
[ Example:

template<class T> struct string {

template<class T2> int compare(const T2&);
template<class T2> string(const string<T2>& s) { /∗ ... ∗/ }

};

template<class T> template<class T2> int string<T>::compare(const T2& s) {
}

— end example ]

2 A local class of non-closure type shall not have member templates. Access control rules (Clause 11) apply
to member template names. A destructor shall not be a member template. A non-template member
function (8.3.5) with a given name and type and a member function template of the same name, which could
be used to generate a specialization of the same type, can both be declared in a class. When both exist, a
use of that name and type refers to the non-template member unless an explicit template argument list is
supplied. [ Example:

§ 14.5.2

348

c(cid:13) ISO/IEC

N4296

template <class T> struct A {

void f(int);
template <class T2> void f(T2);

};

template <> void A<int>::f(int) { }
template <> template <> void A<int>::f<>(int) { }

// non-template member function
// member function template specialization

int main() {
A<char> ac;
ac.f(1);
ac.f(’c’);
ac.f<>(1);

}

— end example ]

// non-template
// template
// template

3 A member function template shall not be virtual. [ Example:

template <class T> struct AA {

template <class C> virtual void g(C);
virtual void f();

// error
// OK

— end example ]

4 A specialization of a member function template does not override a virtual function from a base class.

[ Example:

};

};

};

class B {

virtual void f(int);

class D : public B {

template <class T> void f(T); // does not override B::f(int)
// overriding function that calls
void f(int i) { f<>(i); }
// the template instantiation

— end example ]

5 A specialization of a conversion function template is referenced in the same way as a non-template conversion

function that converts to the same type. [ Example:

struct A {

template <class T> operator T*();

};
template <class T> A::operator T*(){ return 0; }
template <> A::operator char*(){ return 0; }
template A::operator void*();

// specialization
// explicit instantiation

int main() {

A a;
int* ip;
ip = a.operator int*();

}

§ 14.5.2

// explicit call to template operator
// A::operator int*()

349

c(cid:13) ISO/IEC

N4296

— end example ] [ Note: Because the explicit template argument list follows the function template name,
and because conversion member function templates and constructor member function templates are called
without using a function name, there is no way to provide an explicit template argument list for these
function templates. — end note ]

6 A specialization of a conversion function template is not found by name lookup. Instead, any conversion
function templates visible in the context of the use are considered. For each such operator, if argument
deduction succeeds (14.8.2.3), the resulting specialization is used as if found by name lookup.

7 A using-declaration in a derived class cannot refer to a specialization of a conversion function template in a

base class.

8 Overload resolution (13.3.3.2) and partial ordering (14.5.6.2) are used to select the best conversion function
among multiple specializations of conversion function templates and/or non-template conversion functions.
14.5.3 Variadic templates
[temp.variadic]
1 A template parameter pack is a template parameter that accepts zero or more template arguments. [ Example:

template<class ... Types> struct Tuple { };

Tuple<> t0;
Tuple<int> t1;
Tuple<int, float> t2;
Tuple<0> error;

— end example ]

// Types contains no arguments
// Types contains one argument: int
// Types contains two arguments: int and float
// error: 0 is not a type

2 A function parameter pack is a function parameter that accepts zero or more function arguments. [ Example:

template<class ... Types> void f(Types ... args);

f();
f(1);
f(2, 1.0);

— end example ]

// OK: args contains no arguments
// OK: args contains one argument: int
// OK: args contains two arguments: int and double

3 A parameter pack is either a template parameter pack or a function parameter pack.
4 A pack expansion consists of a pattern and an ellipsis, the instantiation of which produces zero or more
instantiations of the pattern in a list (described below). The form of the pattern depends on the context in
which the expansion occurs. Pack expansions can occur in the following contexts:

(4.1)

(4.2)
(4.2.1)

(4.2.2)

(4.3)

(4.4)

(4.5)

(4.6)

—
—

In a function parameter pack (8.3.5); the pattern is the parameter-declaration without the ellipsis.
In a template parameter pack that is a pack expansion (14.1):
—

if the template parameter pack is a parameter-declaration; the pattern is the parameter-declaration
without the ellipsis;
if the template parameter pack is a type-parameter with a template-parameter-list; the pattern is
the corresponding type-parameter without the ellipsis.

—

—
—
—

—

In an initializer-list (8.5); the pattern is an initializer-clause.
In a base-speciﬁer-list (Clause 10); the pattern is a base-speciﬁer.
In a mem-initializer-list (12.6.2) for a mem-initializer whose mem-initializer-id denotes a base class;
the pattern is the mem-initializer.
In a template-argument-list (14.3); the pattern is a template-argument.

§ 14.5.3

350

c(cid:13) ISO/IEC

N4296

(4.7)

(4.8)

(4.9)

(4.10)

(4.11)

(4.12)

—
—
—
—
—
—

In a dynamic-exception-speciﬁcation (15.4); the pattern is a type-id.
In an attribute-list (7.6.1); the pattern is an attribute.
In an alignment-speciﬁer (7.6.2); the pattern is the alignment-speciﬁer without the ellipsis.
In a capture-list (5.1.2); the pattern is a capture.
In a sizeof... expression (5.3.3); the pattern is an identiﬁer.
In a fold-expression (5.1.3); the pattern is the cast-expression that contains an unexpanded parameter
pack.

5 For the purpose of determining whether a parameter pack satisﬁes a rule regarding entities other than
parameter packs, the parameter pack is considered to be the entity that would result from an instantiation
of the pattern in which it appears.
[ Example:

template<class ... Types> void f(Types ... rest);
template<class ... Types> void g(Types ... rest) {

f(&rest ...);

// “&rest ...” is a pack expansion; “&rest” is its pattern

}

— end example ]

6 A parameter pack whose name appears within the pattern of a pack expansion is expanded by that pack
expansion. An appearance of the name of a parameter pack is only expanded by the innermost enclosing
pack expansion. The pattern of a pack expansion shall name one or more parameter packs that are not
expanded by a nested pack expansion; such parameter packs are called unexpanded parameter packs in the
pattern. All of the parameter packs expanded by a pack expansion shall have the same number of arguments
speciﬁed. An appearance of a name of a parameter pack that is not expanded is ill-formed. [ Example:

template<typename...> struct Tuple {};
template<typename T1, typename T2> struct Pair {};

template<class ... Args1> struct zip {

template<class ... Args2> struct with {

typedef Tuple<Pair<Args1, Args2> ... > type;

};

};

typedef zip<short, int>::with<unsigned short, unsigned>::type T1;

// T1 is Tuple<Pair<short, unsigned short>, Pair<int, unsigned>>

typedef zip<short>::with<unsigned short, unsigned>::type T2;

// error: diﬀerent number of arguments speciﬁed for Args1 and Args2

// OK: Args is expanded by the function parameter pack args

f(const_cast<const Args*>(&args)...); // OK: “Args” and “args” are expanded
f(5 ...);
f(args);
f(h(args ...) + args ...);

// error: pattern does not contain any parameter packs
// error: parameter pack “args” is not expanded
// OK: ﬁrst “args” expanded within h, second
// “args” expanded within f

template<class ... Args>
void g(Args ... args) {

}

— end example ]

§ 14.5.3

351

c(cid:13) ISO/IEC

N4296

7 The instantiation of a pack expansion that is neither a sizeof... expression nor a fold-expression produces a
list E1, E2, ..., EN, where N is the number of elements in the pack expansion parameters. Each Ei is generated
by instantiating the pattern and replacing each pack expansion parameter with its ith element. Such an
element, in the context of the instantiation, is interpreted as follows:

(7.1)

(7.2)

—

—

if the pack is a template parameter pack, the element is a template parameter (14.1) of the correspond-
ing kind (type or non-type) designating the type or value from the template argument; otherwise,
if the pack is a function parameter pack, the element is an id-expression designating the function
parameter that resulted from the instantiation of the pattern where the pack is declared.

All of the Ei become elements in the enclosing list.
[ Note: The variety of list varies with the context:
expression-list, base-speciﬁer-list, template-argument-list, etc. — end note ] When N is zero, the instantiation
of the expansion produces an empty list. Such an instantiation does not alter the syntactic interpretation
of the enclosing construct, even in cases where omitting the list entirely would otherwise be ill-formed or
would result in an ambiguity in the grammar. [ Example:

template<class... T> struct X : T... { };
template<class... T> void f(T... values) {

X<T...> x(values...);

}

template void f<>(); // OK: X<> has no base classes

// x is a variable of type X<> that is value-initialized

— end example ]

8 The instantiation of a sizeof... expression (5.3.3) produces an integral constant containing the number

of elements in the parameter pack it expands.

9 The instantiation of a fold-expression produces:

(9.1)

(9.2)

(9.3)

(9.4)

—
—
—
—

((E1 op E2) op ··· ) op EN for a unary left fold,
E1 op (··· op (EN−1 op EN)) for a unary right fold,
(((E op E1) op E2) op ··· ) op EN for a binary left fold, and
E1 op (··· op (EN−1 op (EN op E))) for a binary right fold.

In each case, op is the fold-operator, N is the number of elements in the pack expansion parameters, and
each Ei is generated by instantiating the pattern and replacing each pack expansion parameter with its
ith element. For a binary fold-expression, E is generated by instantiating the cast-expression that did not
contain an unexpanded parameter pack. [ Example:

template<typename ...Args>

bool all(Args ...args) { return (... && args); }

bool b = all(true, true, true, false);

Within the instantiation of all, the returned expression expands to ((true && true) && true) && false,
which evalutes to false. — end example ] If N is zero for a unary fold-expression, the value of the expression
is shown in Table 12; if the operator is not listed in Table 12, the instantiation is ill-formed.
14.5.4 Friends

[temp.friend]
1 A friend of a class or class template can be a function template or class template, a specialization of a
function template or class template, or a non-template function or class. For a friend function declaration
that is not a template declaration:

§ 14.5.4

352

c(cid:13) ISO/IEC

N4296

Table 12 — Value of folding empty sequences

Operator Value when parameter pack is empty
*
+
&
|
&&
||
,

1
int()
-1
int()
true
false
void()

(1.1)

(1.2)

(1.3)

(1.4)

—

—

—

—

if the name of the friend is a qualiﬁed or unqualiﬁed template-id, the friend declaration refers to a
specialization of a function template, otherwise,
if the name of the friend is a qualiﬁed-id and a matching non-template function is found in the speciﬁed
class or namespace, the friend declaration refers to that function, otherwise,
if the name of the friend is a qualiﬁed-id and a matching function template is found in the speci-
ﬁed class or namespace, the friend declaration refers to the deduced specialization of that function
template (14.8.2.6), otherwise,
the name shall be an unqualiﬁed-id that declares (or redeclares) a non-template function.

[ Example:

template<class T> class task;
template<class T> task<T>* preempt(task<T>*);

template<class T> class task {

friend void next_time();
friend void process(task<T>*);
friend task<T>* preempt<T>(task<T>*);
template<class C> friend int func(C);

friend class task<int>;
template<class P> friend class frd;

};

Here, each specialization of the task class template has the function next_time as a friend; because process
does not have explicit template-arguments, each specialization of the task class template has an appropriately
typed function process as a friend, and this friend is not a function template specialization; because the
friend preempt has an explicit template-argument T, each specialization of the task class template has the
appropriate specialization of the function template preempt as a friend; and each specialization of the task
class template has all specializations of the function template func as friends. Similarly, each specialization of
the task class template has the class template specialization task<int> as a friend, and has all specializations
of the class template frd as friends. — end example ]

2 A friend template may be declared within a class or class template. A friend function template may be
deﬁned within a class or class template, but a friend class template may not be deﬁned in a class or class
template. In these cases, all specializations of the friend class or friend function template are friends of the
class or class template granting friendship. [ Example:

class A {

template<class T> friend class B;
template<class T> friend void f(T){ /* ...

// OK
*/ } // OK

§ 14.5.4

353

c(cid:13) ISO/IEC

};

— end example ]

N4296

3 A template friend declaration speciﬁes that all specializations of that template, whether they are implicitly
instantiated (14.7.1), partially specialized (14.5.5) or explicitly specialized (14.7.3), are friends of the class
containing the template friend declaration. [ Example:

class X {

};

template<class T> friend struct A;
class Y { };

template<class T> struct A { X::Y ab; };
template<class T> struct A<T*> { X::Y ab; };

// OK
// OK

— end example ]

4 When a function is deﬁned in a friend function declaration in a class template, the function is instantiated
when the function is odr-used (3.2). The same restrictions on multiple declarations and deﬁnitions that
apply to non-template function declarations and deﬁnitions also apply to these implicit deﬁnitions.

5 A member of a class template may be declared to be a friend of a non-template class. In this case, the
corresponding member of every specialization of the primary class template and class template partial spe-
cializations thereof is a friend of the class granting friendship. For explicit specializations and specializations
of partial specializations, the corresponding member is the member (if any) that has the same name, kind
(type, function, class template, or function template), template parameters, and signature as the member
of the class template instantiation that would otherwise have been generated. [ Example:

template<class T> struct A {

struct B { };
void f();
struct D {
void g();

};

struct B { };
int f();
struct D {
void g();

};
template<> struct A<int> {

};

};

};

class C {

template<class T> friend struct A<T>::B;

template<class T> friend void A<T>::f();

// grants friendship to A<int>::B even though
// it is not a specialization of A<T>::B
// does not grant friendship to A<int>::f()
// because its return type does not match

template<class T> friend void A<T>::D::g(); // does not grant friendship to A<int>::D::g()

// because A<int>::D is not a specialization of A<T>::D

6

— end example ]
[ Note: A friend declaration may ﬁrst declare a member of an enclosing namespace scope (14.6.5). — end
note ]

§ 14.5.4

354

c(cid:13) ISO/IEC

N4296

7 A friend template shall not be declared in a local class.
8 Friend declarations shall not declare partial specializations. [ Example:

template<class T> class A { };
class X {

template<class T> friend class A<T*>; // error

};

— end example ]

9 When a friend declaration refers to a specialization of a function template, the function parameter declara-

tions shall not include default arguments, nor shall the inline speciﬁer be used in such a declaration.
14.5.5 Class template partial specializations

[temp.class.spec]
1 A primary class template declaration is one in which the class template name is an identiﬁer. A template
declaration in which the class template name is a simple-template-id is a partial specialization of the class
template named in the simple-template-id. A partial specialization of a class template provides an alternative
deﬁnition of the template that is used instead of the primary deﬁnition when the arguments in a specialization
match those given in the partial specialization (14.5.5.1). The primary template shall be declared before
any specializations of that template. A partial specialization shall be declared before the ﬁrst use of a class
template specialization that would make use of the partial specialization as the result of an implicit or
explicit instantiation in every translation unit in which such a use occurs; no diagnostic is required.

2 Each class template partial specialization is a distinct template and deﬁnitions shall be provided for the

members of a template partial specialization (14.5.5.3).
[ Example:

3

{ };
template<class T1, class T2, int I> class A
template<class T, int I>
{ };
template<class T1, class T2, int I> class A<T1*, T2, I> { };
template<class T>
class A<int, T*, 5> { };
template<class T1, class T2, int I> class A<T1, T2*, I> { };

class A<T, T*, I>

// #1
// #2
// #3
// #4
// #5

The ﬁrst declaration declares the primary (unspecialized) class template. The second and subsequent dec-
larations declare partial specializations of the primary template. — end example ]

4 The template parameters are speciﬁed in the angle bracket enclosed list that immediately follows the keyword
template. For partial specializations, the template argument list is explicitly written immediately following
the class template name. For primary templates, this list is implicitly described by the template parameter
list. Speciﬁcally, the order of the template arguments is the sequence in which they appear in the template
parameter list. [ Example: the template argument list for the primary template in the example above is <T1,
T2, I>. — end example ] [ Note: The template argument list shall not be speciﬁed in the primary template
declaration. For example,

template<class T1, class T2, int I> class A<T1, T2, I>

{ };

// error

— end note ]

5 A class template partial specialization may be declared or redeclared in any namespace scope in which the

corresponding primary template may be deﬁned (7.3.1.2 and 14.5.2). [ Example:

template<class T> struct A {

struct C {

template<class T2> struct B { };

};

};

§ 14.5.5

355

c(cid:13) ISO/IEC

N4296

// partial specialization of A<T>::C::B<T2>
template<class T> template<class T2>

struct A<T>::C::B<T2*> { };

A<short>::C::B<int*> absip;

// uses partial specialization

— end example ]

6 Partial specialization declarations themselves are not found by name lookup. Rather, when the primary
template name is used, any previously-declared partial specializations of the primary template are also
considered. One consequence is that a using-declaration which refers to a class template does not restrict
the set of partial specializations which may be found through the using-declaration. [ Example:

namespace N {

template<class T1, class T2> class A { };

// primary template

}

}

using N::A;

// refers to the primary template

namespace N {

template<class T> class A<T, T*> { }; // partial specialization

A<int,int*> a;

— end example ]

// uses the partial specialization, which is found through
// the using declaration which refers to the primary template

7 A non-type argument is non-specialized if it is the name of a non-type parameter. All other non-type

arguments are specialized.

8 Within the argument list of a class template partial specialization, the following restrictions apply:

(8.1)

—

A partially specialized non-type argument expression shall not involve a template parameter of the
partial specialization except when the argument expression is a simple identiﬁer. [ Example:

template <int I, int J> struct A {};
template <int I> struct A<I+5, I*2> {}; // error

template <int I, int J> struct B {};
template <int I> struct B<I, I> {};

// OK

(8.2)

—

— end example ]
The type of a template parameter corresponding to a specialized non-type argument shall not be
dependent on a parameter of the specialization. [ Example:

template <class T, T t> struct C {};
template <class T> struct C<T, 1>;

// error

template< int X, int (*array_ptr)[X] > class A {};
int array[5];
template< int X > class A<X,&array> { };

// error

(8.3)

—

— end example ]
The argument list of the specialization shall not be identical to the implicit argument list of the primary
template.

§ 14.5.5

356

c(cid:13) ISO/IEC

N4296

(8.4)

(8.5)

(8.6)

—
—
—

The specialization shall be more specialized than the primary template (14.5.5.2).
The template parameter list of a specialization shall not contain default template argument values.139
An argument shall not contain an unexpanded parameter pack.
If an argument is a pack expan-
sion (14.5.3), it shall be the last argument in the template argument list.

14.5.5.1 Matching of class template partial specializations

[temp.class.spec.match]
1 When a class template is used in a context that requires an instantiation of the class, it is necessary to
determine whether the instantiation is to be generated using the primary template or one of the partial
specializations. This is done by matching the template arguments of the class template specialization with
the template argument lists of the partial specializations.

(1.1)

(1.2)

—
—

(1.3)

—

If exactly one matching specialization is found, the instantiation is generated from that specialization.
If more than one matching specialization is found, the partial order rules (14.5.5.2) are used to deter-
mine whether one of the specializations is more specialized than the others. If none of the specializations
is more specialized than all of the other matching specializations, then the use of the class template is
ambiguous and the program is ill-formed.
If no matches are found, the instantiation is generated from the primary template.

2 A partial specialization matches a given actual template argument list if the template arguments of the

partial specialization can be deduced from the actual template argument list (14.8.2). [ Example:

a1;
A<int, int, 1>
A<int, int*, 1>
a2;
A<int, char*, 5> a3;
A<int, char*, 1> a4;
A<int*, int*, 2> a5;

— end example ]

// uses #1
// uses #2, T is int, I is 1
// uses #4, T is char
// uses #5, T1 is int, T2 is char, I is 1
// ambiguous: matches #3 and #5

3 A non-type template argument can also be deduced from the value of an actual template argument of a

4

non-type parameter of the primary template. [ Example: the declaration of a2 above. — end example ]
In a type name that refers to a class template specialization, (e.g., A<int, int, 1>) the argument list shall
match the template parameter list of the primary template. The template arguments of a specialization are
deduced from the arguments of the primary template.
14.5.5.2 Partial ordering of class template specializations

[temp.class.order]
1 For two class template partial specializations, the ﬁrst is more specialized than the second if, given the
following rewrite to two function templates, the ﬁrst function template is more specialized than the second
according to the ordering rules for function templates (14.5.6.2):

(1.1)

(1.2)

—

—

the ﬁrst function template has the same template parameters as the ﬁrst partial specialization and has
a single function parameter whose type is a class template specialization with the template arguments
of the ﬁrst partial specialization, and
the second function template has the same template parameters as the second partial specialization
and has a single function parameter whose type is a class template specialization with the template
arguments of the second partial specialization.

2

[ Example:
139) There is no way in which they could be used.

§ 14.5.5.2

357

c(cid:13) ISO/IEC

N4296

template<int I, int J, class T> class X { };
template<int I, int J>
template<int I>

class X<I, J, int> { }; // #1
class X<I, I, int> { }; // #2

template<int I, int J> void f(X<I, J, int>);
template<int I>
void f(X<I, I, int>);

// A
// B

The partial specialization #2 is more specialized than the partial specialization #1 because the function
template B is more specialized than the function template A according to the ordering rules for function
templates. — end example ]
14.5.5.3 Members of class template specializations

[temp.class.spec.mfunc]
1 The template parameter list of a member of a class template partial specialization shall match the template
parameter list of the class template partial specialization. The template argument list of a member of a class
template partial specialization shall match the template argument list of the class template partial special-
ization. A class template specialization is a distinct template. The members of the class template partial
specialization are unrelated to the members of the primary template. Class template partial specialization
members that are used in a way that requires a deﬁnition shall be deﬁned; the deﬁnitions of members of the
primary template are never used as deﬁnitions for members of a class template partial specialization. An
explicit specialization of a member of a class template partial specialization is declared in the same way as
an explicit specialization of the primary template. [ Example:

// primary template
template<class T, int I> struct A {

void f();

};

template<class T, int I> void A<T,I>::f() { }

// class template partial specialization
template<class T> struct A<T,2> {

void f();
void g();
void h();

};

// member of class template partial specialization
template<class T> void A<T,2>::g() { }

// explicit specialization
template<> void A<char,2>::h() { }

int main() {

A<char,0> a0;
A<char,2> a2;
a0.f();
a2.g();

a2.h();

a2.f();

}

— end example ]

§ 14.5.5.3

// OK, uses deﬁnition of primary template’s member
// OK, uses deﬁnition of
// partial specialization’s member
// OK, uses deﬁnition of
// explicit specialization’s member
// ill-formed, no deﬁnition of f for A<T,2>
// the primary template is not used here

358

c(cid:13) ISO/IEC

N4296

2

If a member template of a class template is partially specialized, the member template partial specializations
are member templates of the enclosing class template; if the enclosing class template is instantiated (14.7.1,
14.7.2), a declaration for every member template partial specialization is also instantiated as part of creating
the members of the class template specialization. If the primary member template is explicitly specialized
for a given (implicit) specialization of the enclosing class template, the partial specializations of the member
template are ignored for this specialization of the enclosing class template. If a partial specialization of the
member template is explicitly specialized for a given (implicit) specialization of the enclosing class template,
the primary member template and its other partial specializations are still considered for this specialization
of the enclosing class template. [ Example:

template<class T> struct A {

template<class T2> struct B {};
template<class T2> struct B<T2*> {};

};

// #1
// #2

template<> template<class T2> struct A<short>::B {}; // #3

abcip; // uses #2
A<char>::B<int*>
A<short>::B<int*> absip; // uses #3
// uses #1
A<char>::B<int>

abci;

— end example ]
14.5.6 Function templates

1 A function template deﬁnes an unbounded set of related functions.

might be declared like this:

template<class T> class Array { };
template<class T> void sort(Array<T>&);

— end example ]

[temp.fct]
[ Example: a family of sort functions

2 A function template can be overloaded with other function templates and with non-template functions (8.3.5).
A non-template function is not related to a function template (i.e., it is never considered to be a specializa-
tion), even if it has the same name and type as a potentially generated function template specialization.140
14.5.6.1 Function template overloading
[temp.over.link]
It is possible to overload function templates so that two diﬀerent function template specializations have the
same type. [ Example:

1

// ﬁle1.c
template<class T>

void f(T*);

void g(int* p) {

}

// ﬁle2.c
template<class T>

void f(T);

void h(int* p) {

}

f(p); // calls f<int>(int*)

f(p); // calls f<int*>(int*)

— end example ]

2 Such specializations are distinct functions and do not violate the one deﬁnition rule (3.2).
3 The signature of a function template is deﬁned in 1.3. The names of the template parameters are signiﬁcant
only for establishing the relationship between the template parameters and the rest of the signature. [ Note:
140) That is, declarations of non-template functions do not merely guide overload resolution of function template specializations
with the same name. If such a non-template function is odr-used (3.2) in a program, it must be deﬁned; it will not be implicitly
instantiated using the function template deﬁnition.

§ 14.5.6.1

359

c(cid:13) ISO/IEC

N4296

Two distinct function templates may have identical function return types and function parameter lists, even
if overload resolution alone cannot distinguish them.

template<class T> void f();
template<int I> void f();

— end note ]

// OK: overloads the ﬁrst template
// distinguishable with an explicit template argument list

4 When an expression that references a template parameter is used in the function parameter list or the return
type in the declaration of a function template, the expression that references the template parameter is part
of the signature of the function template. This is necessary to permit a declaration of a function template
in one translation unit to be linked with another declaration of the function template in another translation
unit and, conversely, to ensure that function templates that are intended to be distinct are not linked with
one another. [ Example:

template <int I, int J> A<I+J> f(A<I>, A<J>);
template <int K, int L> A<K+L> f(A<K>, A<L>);
template <int I, int J> A<I-J> f(A<I>, A<J>);

// #1
// same as #1
// diﬀerent from #1

— end example ] [ Note: Most expressions that use template parameters use non-type template parameters,
but it is possible for an expression to reference a type parameter. For example, a template type parameter
can be used in the sizeof operator. — end note ]

5 Two expressions involving template parameters are considered equivalent if two function deﬁnitions con-
taining the expressions would satisfy the one deﬁnition rule (3.2), except that the tokens used to name the
template parameters may diﬀer as long as a token used to name a template parameter in one expression is
replaced by another token that names the same template parameter in the other expression. For determining
whether two dependent names (14.6.2) are equivalent, only the name itself is considered, not the result of
name lookup in the context of the template. If multiple declarations of the same function template diﬀer in
the result of this name lookup, the result for the ﬁrst declaration is used. [ Example:

template <int I, int J> void f(A<I+J>);
template <int K, int L> void f(A<K+L>);

// #1
// same as #1

template <class T> decltype(g(T())) h();
int g(int);
template <class T> decltype(g(T())) h()

{ return g(T()); }

int i = h<int>();

// redeclaration of h() uses the earlier lookup
// ...although the lookup here does ﬁnd g(int)
// template argument substitution fails; g(int)
// was not in scope at the ﬁrst declaration of h()

— end example ] Two expressions involving template parameters that are not equivalent are functionally
equivalent if, for any given set of template arguments, the evaluation of the expression results in the same
value.

6 Two function templates are equivalent if they are declared in the same scope, have the same name, have
identical template parameter lists, and have return types and parameter lists that are equivalent using the
rules described above to compare expressions involving template parameters. Two function templates are
functionally equivalent if they are equivalent except that one or more expressions that involve template
parameters in the return types and parameter lists are functionally equivalent using the rules described
above to compare expressions involving template parameters. If a program contains declarations of function
templates that are functionally equivalent but not equivalent, the program is ill-formed; no diagnostic is
required.
[ Note: This rule guarantees that equivalent declarations will be linked with one another, while not requiring
implementations to use heroic eﬀorts to guarantee that functionally equivalent declarations will be treated

7

§ 14.5.6.1

360

c(cid:13) ISO/IEC

N4296

as distinct. For example, the last two declarations are functionally equivalent and would cause a program
to be ill-formed:

// Guaranteed to be the same
template <int I> void f(A<I>, A<I+10>);
template <int I> void f(A<I>, A<I+10>);

// Guaranteed to be diﬀerent
template <int I> void f(A<I>, A<I+10>);
template <int I> void f(A<I>, A<I+11>);

// Ill-formed, no diagnostic required
template <int I> void f(A<I>, A<I+10>);
template <int I> void f(A<I>, A<I+1+2+3+4>);

1

(1.1)

(1.2)

(1.3)

— end note ]
14.5.6.2 Partial ordering of function templates
[temp.func.order]
If a function template is overloaded, the use of a function template specialization might be ambiguous
because template argument deduction (14.8.2) may associate the function template specialization with more
than one function template declaration. Partial ordering of overloaded function template declarations is
used in the following contexts to select the function template to which a function template specialization
refers:
—
—
—

during overload resolution for a call to a function template specialization (13.3.3);
when the address of a function template specialization is taken;
when a placement operator delete that is a function template specialization is selected to match a
placement operator new (3.7.4.2, 5.3.4);
when a friend function declaration (14.5.4), an explicit instantiation (14.7.2) or an explicit specializa-
tion (14.7.3) refers to a function template specialization.

(1.4)

—

2 Partial ordering selects which of two function templates is more specialized than the other by transforming
each template in turn (see next paragraph) and performing template argument deduction using the function
type. The deduction process determines whether one of the templates is more specialized than the other. If
so, the more specialized template is the one chosen by the partial ordering process.

3 To produce the transformed template, for each type, non-type, or template template parameter (including
template parameter packs (14.5.3) thereof) synthesize a unique type, value, or class template respectively
and substitute it for each occurrence of that parameter in the function type of the template. If only one of the
function templates M is a non-static member of some class A, M is considered to have a new ﬁrst parameter
inserted in its function parameter list. Given cv as the cv-qualiﬁers of M (if any), the new parameter is of
type “rvalue reference to cv A” if the optional ref-qualiﬁer of M is && or if M has no ref-qualiﬁer and the ﬁrst
parameter of the other template has rvalue reference type. Otherwise, the new parameter is of type “lvalue
reference to cv A”. [ Note: This allows a non-static member to be ordered with respect to a nonmember
function and for the results to be equivalent to the ordering of two equivalent nonmembers. — end note ]
[ Example:

struct A { };
template<class T> struct B {

template<class R> int operator*(R&);

};

// #1

template<class T, class R> int operator*(T&, R&);

// #2

§ 14.5.6.2

361

c(cid:13) ISO/IEC

N4296

// The declaration of B::operator* is transformed into the equivalent of
// template<class R> int operator*(B<A>&, R&);

// #1a

int main() {

A a;
B<A> b;
b * a;

}

// calls #1a

— end example ]

4 Using the transformed function template’s function type, perform type deduction against the other template

as described in 14.8.2.4.
[ Example:

template<class T> struct A { A(); };

template<class T> void f(T);
template<class T> void f(T*);
template<class T> void f(const T*);

template<class T> void g(T);
template<class T> void g(T&);

template<class T> void h(const T&);
template<class T> void h(A<T>&);

void m() {

const int* p;
f(p);
float x;
g(x);
A<int> z;
h(z);
const A<int> z2;
h(z2);

}

// f(const T*) is more specialized than f(T) or f(T*)

// Ambiguous: g(T) or g(T&)

// overload resolution selects h(A<T>&)

// h(const T&) is called because h(A<T>&) is not callable

5

— end example ]
[ Note: Since partial ordering in a call context considers only parameters for which there are explicit call argu-
ments, some parameters are ignored (namely, function parameter packs, parameters with default arguments,
and ellipsis parameters). [ Example:

template<class T> void f(T);
template<class T> void f(T*, int=1);
template<class T> void g(T);
template<class T> void g(T*, ...);

// #1
// #2
// #3
// #4

int main() {

int* ip;
f(ip);
g(ip);

}

// calls #2
// calls #4

— end example ] [ Example:

§ 14.5.6.2

362

c(cid:13) ISO/IEC

N4296

template<class T, class U> struct A { };

template<class T, class U> void f(U, A<U, T>* p = 0); // #1
class U> void f(U, A<U, U>* p = 0); // #2
template<
// #3
template<class T
> void g(T, T = T());
// #4
template<class T, class... U> void g(T, U ...);

void h() {

f<int>(42, (A<int, int>*)0);
f<int>(42);
g(42);

— end example ] [ Example:

template<class T, class... U> void f(T, U...);
template<class T
template<class T, class... U> void g(T*, U...);
template<class T

> void f(T);

> void g(T);

}

}

void h(int i) {

f(&i);
g(&i);

// calls #2
// error: ambiguous
// error: ambiguous

// #1
// #2
// #3
// #4

// error: ambiguous
// OK: calls #3

— end example ] — end note ]
14.5.7 Alias templates

[temp.alias]
1 A template-declaration in which the declaration is an alias-declaration (Clause 7) declares the identiﬁer to
be a alias template. An alias template is a name for a family of types. The name of the alias template is a
template-name.

2 When a template-id refers to the specialization of an alias template, it is equivalent to the associated type
obtained by substitution of its template-arguments for the template-parameters in the type-id of the alias
template. [ Note: An alias template name is never deduced. — end note ] [ Example:

template<class T> struct Alloc { /∗ ... ∗/ };
template<class T> using Vec = vector<T, Alloc<T>>;
Vec<int> v;

// same as vector<int, Alloc<int>> v;

template<class T>

void process(Vec<T>& v)
{ /∗ ... ∗/ }

template<class T>

void process(vector<T, Alloc<T>>& w)
{ /∗ ... ∗/ }
// error: redeﬁnition

template<template<class> class TT>

void f(TT<int>);

f(v);

// error: Vec not deduced

template<template<class,class> class TT>

void g(TT<int, Alloc<int>>);

g(v);

// OK: TT = vector

§ 14.5.7

363

c(cid:13) ISO/IEC

— end example ]

N4296

3 However, if the template-id is dependent, subsequent template argument substitution still applies to the

template-id. [ Example:

template<typename...> using void_t = void;
template<typename T> void_t<typename T::foo> f();
f<int>(); // error, int does not have a nested type foo

— end example ]

4 The type-id in an alias template declaration shall not refer to the alias template being declared. The type
produced by an alias template specialization shall not directly or indirectly make use of that specialization.
[ Example:

template <class T> struct A;
template <class T> using B = typename A<T>::U;
template <class T> struct A {

typedef B<T> U;

};
B<short> b;

// error: instantiation of B<short> uses own type via A<short>::U

— end example ]
14.6 Name resolution

[temp.res]

1 Three kinds of names can be used within a template deﬁnition:

(1.1)

(1.2)

(1.3)

—
—
—

The name of the template itself, and names declared within the template itself.
Names dependent on a template-parameter (14.6.2).
Names from scopes which are visible within the template deﬁnition.

2 A name used in a template declaration or deﬁnition and that is dependent on a template-parameter is
assumed not to name a type unless the applicable name lookup ﬁnds a type name or the name is qualiﬁed
by the keyword typename. [ Example:

// no B declared here

class X;

template<class T> class Y {

class Z;

// forward declaration of member class

void f() {

X* a1;
T* a2;
Y* a3;
Z* a4;
typedef typename T::A TA;
TA* a5;
typename T::A* a6;
T::A* a7;

B* a8;

§ 14.6

// declare pointer to X
// declare pointer to T
// declare pointer to Y<T>
// declare pointer to Z

// declare pointer to T’s A
// declare pointer to T’s A
// T::A is not a type name:
// multiply T::A by a7; ill-formed,
// no visible declaration of a7
// B is not a type name:
// multiply B by a8; ill-formed,
// no visible declarations of B and a8

364

c(cid:13) ISO/IEC

}
};

— end example ]

N4296

3 When a qualiﬁed-id is intended to refer to a type that is not a member of the current instantiation (14.6.2.1)
and its nested-name-speciﬁer refers to a dependent type, it shall be preﬁxed by the keyword typename, forming
a typename-speciﬁer. If the qualiﬁed-id in a typename-speciﬁer does not denote a type, the program is ill-
formed.

typename-speciﬁer:

typename nested-name-speciﬁer identiﬁer
typename nested-name-speciﬁer templateopt simple-template-id

4

If a specialization of a template is instantiated for a set of template-arguments such that the qualiﬁed-id
preﬁxed by typename does not denote a type, the specialization is ill-formed. The usual qualiﬁed name
lookup (3.4.3) is used to ﬁnd the qualiﬁed-id even in the presence of typename. [ Example:

struct A {

struct X { };
int X;

};
struct B {

struct X { };

};
template<class T> void f(T t) {

typename T::X x;

}
void foo() {

A a;
B b;
f(b);
f(a);

}

// OK: T::X refers to B::X
// error: T::X refers to the data member A::X not the struct A::X

— end example ]

5 A qualiﬁed name used as the name in a mem-initializer-id, a base-speciﬁer, or an elaborated-type-speciﬁer
is implicitly assumed to name a type, without the use of the typename keyword. In a nested-name-speciﬁer
that immediately contains a nested-name-speciﬁer that depends on a template parameter, the identiﬁer or
simple-template-id is implicitly assumed to name a type, without the use of the typename keyword. [ Note:
The typename keyword is not permitted by the syntax of these constructs. — end note ]
If, for a given set of template arguments, a specialization of a template is instantiated that refers to a
qualiﬁed-id that denotes a type, and the qualiﬁed-id refers to a member of an unknown specialization, the
qualiﬁed-id shall either be preﬁxed by typename or shall be used in a context in which it implicitly names a
type as described above. [ Example:

6

template <class T> void f(int i) {

T::x * i;

// T::x must not be a type

}

struct Foo {

typedef int x;

};

struct Bar {

static int const x = 5;

};

§ 14.6

365

c(cid:13) ISO/IEC

int main() {
f<Bar>(1);
f<Foo>(1);

}

— end example ]

// OK
// error: Foo::x is a type

N4296

7 Within the deﬁnition of a class template or within the deﬁnition of a member of a class template following
the declarator-id, the keyword typename is not required when referring to the name of a previously declared
member of the class template that declares a type. [ Note: such names can be found using unqualiﬁed name
lookup (3.4.1), class member lookup (3.4.3.1) into the current instantiation (14.6.2.1), or class member access
expression lookup (3.4.5) when the type of the object expression is the current instantiation (14.6.2.2). — end
note ] [ Example:

template<class T> struct A {

// OK, no typename required

typedef int B;
B b;

};

— end example ]

8 Knowing which names are type names allows the syntax of every template to be checked. No diagnostic
shall be issued for a template for which a valid specialization can be generated. If no valid specialization can
be generated for a template, and that template is not instantiated, the template is ill-formed, no diagnostic
required. If every valid specialization of a variadic template requires an empty template parameter pack,
the template is ill-formed, no diagnostic required. If a hypothetical instantiation of a template immediately
following its deﬁnition would be ill-formed due to a construct that does not depend on a template param-
eter, the program is ill-formed; no diagnostic is required. If the interpretation of such a construct in the
hypothetical instantiation is diﬀerent from the interpretation of the corresponding construct in any actual
instantiation of the template, the program is ill-formed; no diagnostic is required. [ Note: This can happen
in situations including the following:

—

—

—

(8.1)

(8.2)

(8.3)

(8.3.1)
(8.3.2)
(8.3.3)
(8.3.4)

(8.4)

—

a type used in a non-dependent name is incomplete at the point at which a template is deﬁned but is
complete at the point at which an instantiation is performed, or
an instantiation uses a default argument or default template argument that had not been deﬁned at
the point at which the template was deﬁned, or
constant expression evaluation (5.20) within the template instantiation uses
the value of a const object of integral or unscoped enumeration type or
—
—
the value of a constexpr object or
the value of a reference or
—
—
the deﬁnition of a constexpr function,
and that entity was not deﬁned when the template was deﬁned, or
a class template specialization or variable template specialization that is speciﬁed by a non-dependent
simple-template-id is used by the template, and either it is instantiated from a partial specialization
that was not deﬁned when the template was deﬁned or it names an explicit specialization that was not
declared when the template was deﬁned.

— end note ] [ Note: If a template is instantiated, errors will be diagnosed according to the other rules in
this Standard. Exactly when these errors are diagnosed is a quality of implementation issue. — end note ]
[ Example:

§ 14.6

366

c(cid:13) ISO/IEC

N4296

int j;
template<class T> class X {

void f(T t, int i, char* p) {

t = i;

p = i;

p = j;

}
void g(T t) {

+;

}
};

// diagnosed if X::f is instantiated
// and the assignment to t is an error
// may be diagnosed even if X::f is
// not instantiated
// may be diagnosed even if X::f is
// not instantiated

// may be diagnosed even if X::g is
// not instantiated

template<class... T> struct A {
void operator++(int, T... t);

};
template<class... T> union X : T... { };
template<class... T> struct A : T...,

// error: too many parameters

// error: union with base class

T... { };// error: duplicate base class

— end example ]

9 When looking for the declaration of a name used in a template deﬁnition, the usual lookup rules (3.4.1,
3.4.2) are used for non-dependent names. The lookup of names dependent on the template parameters is
postponed until the actual template argument is known (14.6.2). [ Example:

#include <iostream>
using namespace std;

template<class T> class Set {

T* p;
int cnt;

public:
Set();
Set<T>(const Set<T>&);
void printall() {

for (int i = 0; i<cnt; i++)

cout << p[i] << ’\n’;

}
};

in the example, i is the local variable i declared in printall, cnt is the member cnt declared in Set, and
cout is the standard output stream declared in iostream. However, not every declaration can be found this
way; the resolution of some names must be postponed until the actual template-arguments are known. For
example, even though the name operator<< is known within the deﬁnition of printall() and a declaration
of it can be found in <iostream>, the actual declaration of operator<< needed to print p[i] cannot be
known until it is known what type T is (14.6.2). — end example ]
If a name does not depend on a template-parameter (as deﬁned in 14.6.2), a declaration (or set of declarations)
for that name shall be in scope at the point where the name appears in the template deﬁnition; the name is
bound to the declaration (or declarations) found at that point and this binding is not aﬀected by declarations
that are visible at the point of instantiation. [ Example:

10

void f(char);

§ 14.6

367

c(cid:13) ISO/IEC

N4296

template<class T> void g(T t) {
// f(char)
// dependent
// dependent
// not dependent
// error: declaration for dd not found

f(1);
f(T(1));
f(t);
dd++;

}

enum E { e };
void f(E);

double dd;
void h() {

g(e);

g(’a’);

}

// will cause one call of f(char) followed
// by two calls of f(E)
// will cause three calls of f(char)

11

— end example ]
[ Note: For purposes of name lookup, default arguments and exception-speciﬁcations of function templates
and default arguments and exception-speciﬁcations of member functions of class templates are considered
deﬁnitions (14.5). — end note ]
14.6.1 Locally declared names

[temp.local]
1 Like normal (non-template) classes, class templates have an injected-class-name (Clause 9). The injected-
class-name can be used as a template-name or a type-name. When it is used with a template-argument-list,
as a template-argument for a template template-parameter, or as the ﬁnal identiﬁer in the elaborated-type-
speciﬁer of a friend class template declaration, it refers to the class template itself. Otherwise, it is equivalent
to the template-name followed by the template-parameters of the class template enclosed in <>.

2 Within the scope of a class template specialization or partial specialization, when the injected-class-name is
used as a type-name, it is equivalent to the template-name followed by the template-arguments of the class
template specialization or partial specialization enclosed in <>. [ Example:

template<template<class> class T> class A { };
template<class T> class Y;
template<> class Y<int> {

// meaning Y<int>
// meaning Y<char>
// meaning A<::Y>

Y* p;
Y<char>* q;
A<Y>* a;
class B {

};

};

template<class> friend class Y;

// meaning ::Y

— end example ]

3 The injected-class-name of a class template or class template specialization can be used either as a template-

name or a type-name wherever it is in scope. [ Example:

template <class T> struct Base {

Base* p;

};

template <class T> struct Derived: public Base<T> {

typename Derived::Base* p;

// meaning Derived::Base<T>

§ 14.6.1

368

c(cid:13) ISO/IEC

};

N4296

template<class T, template<class> class U = T::template Base> struct Third { };
Third<Base<int> > t;

// OK: default argument uses injected-class-name as a template

— end example ]

4 A lookup that ﬁnds an injected-class-name (10.2) can result in an ambiguity in certain cases (for example, if it
is found in more than one base class). If all of the injected-class-names that are found refer to specializations
of the same class template, and if the name is used as a template-name, the reference refers to the class
template itself and not a specialization thereof, and is not ambiguous. [ Example:

template <class T> struct Base { };
template <class T> struct Derived: Base<int>, Base<char> {
// error: ambiguous
// OK

typename Derived::Base b;
typename Derived::Base<double> d;

};

— end example ]

5 When the normal name of the template (i.e., the name from the enclosing scope, not the injected-class-name)

is used, it always refers to the class template itself and not a specialization of the template. [ Example:

template<class T> class X {

// meaning X<T>

X* p;
X<T>* p2;
X<int>* p3;
::X* p4;

};

— end example ]

// error: missing template argument list
// ::X does not refer to the injected-class-name

6 A template-parameter shall not be redeclared within its scope (including nested scopes). A template-

parameter shall not have the same name as the template name. [ Example:

template<class T, int i> class Y {

// error: template-parameter redeclared

// error: template-parameter redeclared

int T;
void f() {
char T;

}
};

template<class X> class X;

// error: template-parameter redeclared

7

— end example ]
In the deﬁnition of a member of a class template that appears outside of the class template deﬁnition, the
name of a member of the class template hides the name of a template-parameter of any enclosing class
templates (but not a template-parameter of the member if the member is a class or function template).
[ Example:

template<class T> struct A {

*/ };

struct B { /* ...
typedef void C;
void f();
template<class U> void g(U);

};

§ 14.6.1

369

c(cid:13) ISO/IEC

N4296

template<class B> void A<B>::f() {

// A’s B, not the template parameter

template<class B> template<class C> void A<B>::g(C) {

// A’s B, not the template parameter
// the template parameter C, not A’s C

B b;

B b;
C c;

}

}

8

— end example ]
In the deﬁnition of a member of a class template that appears outside of the namespace containing the
class template deﬁnition, the name of a template-parameter hides the name of a member of this namespace.
[ Example:

namespace N {
class C { };
template<class T> class B {

void f(T);

};

}
template<class C> void N::B<C>::f(C) {

C b;

}

// C is the template parameter, not N::C

9

— end example ]
In the deﬁnition of a class template or in the deﬁnition of a member of such a template that appears outside
of the template deﬁnition, for each non-dependent base class (14.6.2.1), if the name of the base class or the
name of a member of the base class is the same as the name of a template-parameter, the base class name
or member name hides the template-parameter name (3.3.10). [ Example:

struct A {

struct B { /∗ ... ∗/ };
int a;
int Y;

};

};

B b;
a b;

template<class B, class a> struct X : A {

// A’s B
// error: A’s a isn’t a type name

1

— end example ]
14.6.2 Dependent names
[temp.dep]
Inside a template, some constructs have semantics which may diﬀer from one instantiation to another. Such a
construct depends on the template parameters. In particular, types and expressions may depend on the type
and/or value of template parameters (as determined by the template arguments) and this determines the
context for name lookup for certain names. Expressions may be type-dependent (on the type of a template
parameter) or value-dependent (on the value of a non-type template parameter). In an expression of the
form:

postﬁx-expression ( expression-listopt)

where the postﬁx-expression is an unqualiﬁed-id, the unqualiﬁed-id denotes a dependent name if

(1.1)

—

any of the expressions in the expression-list is a pack expansion (14.5.3),

§ 14.6.2

370

c(cid:13) ISO/IEC

N4296

(1.2)

(1.3)

—
—

any of the expressions or braced-init-lists in the expression-list is type-dependent (14.6.2.2), or
if the unqualiﬁed-id is a template-id in which any of the template arguments depends on a template
parameter.

2

3

If an operand of an operator is a type-dependent expression, the operator also denotes a dependent name.
Such names are unbound and are looked up at the point of the template instantiation (14.6.4.1) in both the
context of the template deﬁnition and the context of the point of instantiation.
[ Example:

template<class T> struct X : B<T> {

typename T::A* pa;
void f(B<T>* pb) {

static int i = B<T>::i;
pb->j++;

}
};

the base class name B<T>, the type name T::A, the names B<T>::i and pb->j explicitly depend on the
template-parameter. — end example ]
In the deﬁnition of a class or class template, the scope of a dependent base class (14.6.2.1) is not examined
during unqualiﬁed name lookup either at the point of deﬁnition of the class template or member or during
an instantiation of the class template or member. [ Example:

typedef double A;
template<class T> class B {

typedef int A;

};
template<class T> struct X : B<T> {

// a has type double

A a;

};

The type name A in the deﬁnition of X<T> binds to the typedef name deﬁned in the global namespace scope,
not to the typedef name deﬁned in the base class B<T>. — end example ] [ Example:

struct A {

struct B { /∗ ... ∗/ };
int a;
int Y;

};

int a;

template<class T> struct Y : T {

struct B { /∗ ... ∗/ };
B b;
void f(int i) { a = i; }
Y* p;

};

// The B deﬁned in Y
// ::a
// Y<T>

Y<A> ya;

The members A::B, A::a, and A::Y of the template argument A do not aﬀect the binding of names in Y<A>.
— end example ]

§ 14.6.2

371

c(cid:13) ISO/IEC

14.6.2.1 Dependent types

1 A name refers to the current instantiation if it is

N4296

[temp.dep.type]

(1.1)

(1.2)

(1.3)

(1.4)

—

—

in the deﬁnition of a class template, a nested class of a class template, a member of a class template, or
a member of a nested class of a class template, the injected-class-name (Clause 9) of the class template
or nested class,
in the deﬁnition of a primary class template or a member of a primary class template, the name of the
class template followed by the template argument list of the primary template (as described below)
enclosed in <> (or an equivalent template alias specialization),
in the deﬁnition of a nested class of a class template, the name of the nested class referenced as a
member of the current instantiation, or
in the deﬁnition of a partial specialization or a member of a partial specialization, the name of the
class template followed by the template argument list of the partial specialization enclosed in <> (or
an equivalent template alias specialization). If the nth template parameter is a parameter pack, the
nth template argument is a pack expansion (14.5.3) whose pattern is the name of the parameter pack.
2 The template argument list of a primary template is a template argument list in which the nth template
argument has the value of the nth template parameter of the class template. If the nth template parameter
is a template parameter pack (14.5.3), the nth template argument is a pack expansion (14.5.3) whose pattern
is the name of the template parameter pack.

—

—

3 A template argument that is equivalent to a template parameter (i.e., has the same constant value or the
same type as the template parameter) can be used in place of that template parameter in a reference to
the current instantiation. In the case of a non-type template argument, the argument must have been given
the value of the template parameter and not an expression in which the template parameter appears as a
subexpression. [ Example:

template <class T> class A {

A* p1;
A<T>* p2;
A<T*> p3;
::A<T>* p4;
class B {
B* p1;
A<T>::B* p2;
typename A<T*>::B* p3;

};

};

// A is the current instantiation
// A<T> is the current instantiation
// A<T*> is not the current instantiation
// ::A<T> is the current instantiation

// B is the current instantiation
// A<T>::B is the current instantiation
// A<T*>::B is not the
// current instantiation

template <class T> class A<T*> {

A<T*>* p1;
A<T>* p2;

};

// A<T*> is the current instantiation
// A<T> is not the current instantiation

template <class T1, class T2, int I> struct B {

// refers to the current instantiation
// not the current instantiation

B<T1, T2, I>* b1;
B<T2, T1, I>* b2;
typedef T1 my_T1;
static const int my_I = I;
static const int my_I2 = I+0;
static const int my_I3 = my_I;
B<my_T1, T2, my_I>* b3;

§ 14.6.2.1

372

// refers to the current instantiation

c(cid:13) ISO/IEC

B<my_T1, T2, my_I2>* b4;
B<my_T1, T2, my_I3>* b5;

};

— end example ]

// not the current instantiation
// refers to the current instantiation

N4296

4 A dependent base class is a base class that is a dependent type and is not the current instantiation. [ Note:
a base class can be the current instantiation in the case of a nested class naming an enclosing class as a base.
[ Example:

template<class T> struct A {

typedef int M;
struct B {

typedef void M;
struct C;

template<class T> struct A<T>::B::C : A<T> {

M m; // OK, A<T>::M

};

};

};

};

}

— end example ] — end note ]

5 A name is a member of the current instantiation if it is

(5.1)

(5.2)

—

—

(5.3)

—

An unqualiﬁed name that, when looked up, refers to at least one member of a class that is the current
instantiation or a non-dependent base class thereof.
[ Note: This can only occur when looking up a
name in a scope enclosed by the deﬁnition of a class template. — end note ]
A qualiﬁed-id in which the nested-name-speciﬁer refers to the current instantiation and that, when
looked up, refers to at least one member of a class that is the current instantiation or a non-dependent
base class thereof. [ Note: if no such member is found, and the current instantiation has any dependent
base classes, then the qualiﬁed-id is a member of an unknown specialization; see below. — end note ]
An id-expression denoting the member in a class member access expression (5.2.5) for which the type
of the object expression is the current instantiation, and the id-expression, when looked up (3.4.5),
refers to at least one member of a class that is the current instantiation or a non-dependent base class
thereof.
if no such member is found, and the current instantiation has any dependent base
classes, then the id-expression is a member of an unknown specialization; see below. — end note ]

[ Note:

[ Example:

template <class T> class A {

static const int i = 5;
int n1[i];
int n2[A::i];
int n3[A<T>::i]; // A<T>::i refers to a member of the current instantiation
int f();

// i refers to a member of the current instantiation
// A::i refers to a member of the current instantiation

template <class T> int A<T>::f() {

return i;

// i refers to a member of the current instantiation

— end example ]
A name is a dependent member of the current instantiation if it is a member of the current instantiation
that, when looked up, refers to at least one member of a class that is the current instantiation.

§ 14.6.2.1

373

c(cid:13) ISO/IEC

N4296

6 A name is a member of an unknown specialization if it is

(6.1)

(6.2)

(6.3)

(6.3.1)

(6.3.2)

7

—

—

—

A qualiﬁed-id in which the nested-name-speciﬁer names a dependent type that is not the current
instantiation.
A qualiﬁed-id in which the nested-name-speciﬁer refers to the current instantiation, the current instan-
tiation has at least one dependent base class, and name lookup of the qualiﬁed-id does not ﬁnd any
member of a class that is the current instantiation or a non-dependent base class thereof.
An id-expression denoting the member in a class member access expression (5.2.5) in which either
—

the type of the object expression is the current instantiation, the current instantiation has at least
one dependent base class, and name lookup of the id-expression does not ﬁnd a member of a class
that is the current instantiation or a non-dependent base class thereof; or
the type of the object expression is dependent and is not the current instantiation.

—

If a qualiﬁed-id in which the nested-name-speciﬁer refers to the current instantiation is not a member of
the current instantiation or a member of an unknown specialization, the program is ill-formed even if the
template containing the qualiﬁed-id is not instantiated; no diagnostic required. Similarly, if the id-expression
in a class member access expression for which the type of the object expression is the current instantiation
does not refer to a member of the current instantiation or a member of an unknown specialization, the
program is ill-formed even if the template containing the member access expression is not instantiated; no
diagnostic required. [ Example:
template<class T> class A {

typedef int type;
void f() {

}
};

A<T>::type i;
typename A<T>::other j; // error: neither a member of the current instantiation nor

// OK: refers to a member of the current instantiation

// a member of an unknown specialization

8

— end example ]
If, for a given set of template arguments, a specialization of a template is instantiated that refers to a member
of the current instantiation with a qualiﬁed-id or class member access expression, the name in the qualiﬁed-id
or class member access expression is looked up in the template instantiation context. If the result of this
lookup diﬀers from the result of name lookup in the template deﬁnition context, name lookup is ambiguous.
[ Note: the result of name lookup diﬀers only when the member of the current instantiation was found in a
non-dependent base class of the current instantiation and a member with the same name is also introduced
by the substitution for a dependent base class of the current instantiation. — end note ]

9 A type is dependent if it is

(9.1)

(9.2)

(9.3)

(9.4)

(9.5)

(9.6)

—
—
—
—
—
—

a template parameter,
a member of an unknown specialization,
a nested class or enumeration that is a dependent member of the current instantiation,
a cv-qualiﬁed type where the cv-unqualiﬁed type is dependent,
a compound type constructed from any dependent type,
an array type constructed from any dependent type or whose size is speciﬁed by a constant expression
that is value-dependent,

§ 14.6.2.1

374

c(cid:13) ISO/IEC

N4296

(9.7)

(9.8)

10

—

—

a simple-template-id in which either the template name is a template parameter or any of the template
arguments is a dependent type or an expression that is type-dependent or value-dependent, or
denoted by decltype(expression), where expression is type-dependent (14.6.2.2).

[ Note: Because typedefs do not introduce new types, but instead simply refer to other types, a name that
refers to a typedef that is a member of the current instantiation is dependent only if the type referred to is
dependent. — end note ]
14.6.2.2 Type-dependent expressions

[temp.dep.expr]

1 Except as described below, an expression is type-dependent if any subexpression is type-dependent.
2 this is type-dependent if the class type of the enclosing member function is dependent (14.6.2.1).
3 An id-expression is type-dependent if it contains

(3.1)

(3.2)

(3.3)

(3.4)

(3.5)

(3.6)

—
—

—

—
—
—

an identiﬁer associated by name lookup with one or more declarations declared with a dependent type,
an identiﬁer associated by name lookup with one or more declarations of member functions of the
current instantiation declared with a return type that contains a placeholder type (7.1.6.4),
the identiﬁer __func__ (8.4.1), where any enclosing function is a template, a member of a class
template, or a generic lambda,
a template-id that is dependent,
a conversion-function-id that speciﬁes a dependent type, or
a nested-name-speciﬁer or a qualiﬁed-id that names a member of an unknown specialization;

or if it names a dependent member of the current instantiation that is a static data member of type “array
of unknown bound of T” for some T (14.5.1.3). Expressions of the following forms are type-dependent only if
the type speciﬁed by the type-id, simple-type-speciﬁer or new-type-id is dependent, even if any subexpression
is type-dependent:

simple-type-speciﬁer ( expression-listopt)
::opt new new-placementopt new-type-id new-initializeropt
::opt new new-placementopt( type-id ) new-initializeropt
dynamic_cast < type-id > ( expression )
static_cast < type-id > ( expression )
const_cast < type-id > ( expression )
reinterpret_cast < type-id > ( expression )
( type-id ) cast-expression

4 Expressions of the following forms are never type-dependent (because the type of the expression cannot be

dependent):
literal
postﬁx-expression . pseudo-destructor-name
postﬁx-expression -> pseudo-destructor-name
sizeof unary-expression
sizeof ( type-id )
sizeof ... ( identiﬁer )
alignof ( type-id )
typeid ( expression )
typeid ( type-id )
::opt delete cast-expression
::opt delete [ ] cast-expression
throw assignment-expressionopt
noexcept ( expression )

§ 14.6.2.2

375

c(cid:13) ISO/IEC

N4296

[ Note: For the standard library macro offsetof, see 18.2. — end note ]

5 A class member access expression (5.2.5) is type-dependent if the expression refers to a member of the current
instantiation and the type of the referenced member is dependent, or the class member access expression
refers to a member of an unknown specialization.
[ Note: In an expression of the form x.y or xp->y the
type of the expression is usually the type of the member y of the class of x (or the class pointed to by xp).
However, if x or xp refers to a dependent type that is not the current instantiation, the type of y is always
dependent. If x or xp refers to a non-dependent type or refers to the current instantiation, the type of y is
the type of the class member access expression. — end note ]

6 A braced-init-list is type-dependent if any element is type-dependent or is a pack expansion.
7 A fold-expression is type-dependent.

14.6.2.3 Value-dependent expressions

[temp.dep.constexpr]
1 Except as described below, a constant expression is value-dependent if any subexpression is value-dependent.
2 An id-expression is value-dependent if:

(2.1)

(2.2)

(2.3)

(2.4)

(2.5)

(2.6)

—
—
—
—

—
—

it is a name declared with a dependent type,
it is the name of a non-type template parameter,
it names a member of an unknown specialization,
it names a static data member that is a dependent member of the current instantiation and is not
initialized in a member-declarator,
it names a static member function that is a dependent member of the current instantiation, or
it is a constant with literal type and is initialized with an expression that is value-dependent.

Expressions of the following form are value-dependent if the unary-expression or expression is type-dependent
or the type-id is dependent:
sizeof unary-expression
sizeof ( type-id )
typeid ( expression )
typeid ( type-id )
alignof ( type-id )
noexcept ( expression )

[ Note: For the standard library macro offsetof, see 18.2. — end note ]

3 Expressions of the following form are value-dependent if either the type-id or simple-type-speciﬁer is depen-

dent or the expression or cast-expression is value-dependent:

simple-type-speciﬁer ( expression-listopt)
static_cast < type-id > ( expression )
const_cast < type-id > ( expression )
reinterpret_cast < type-id > ( expression )
( type-id ) cast-expression

4 Expressions of the following form are value-dependent:

sizeof ... ( identiﬁer )
fold-expression

5 An expression of the form &qualiﬁed-id where the qualiﬁed-id names a dependent member of the current

instantiation is value-dependent.

§ 14.6.2.3

376

c(cid:13) ISO/IEC

N4296

14.6.2.4 Dependent template arguments

[temp.dep.temp]

1 A type template-argument is dependent if the type it speciﬁes is dependent.
2 A non-type template-argument is dependent if its type is dependent or the constant expression it speciﬁes

is value-dependent.

3 Furthermore, a non-type template-argument is dependent if the corresponding non-type template-parameter
is of reference or pointer type and the template-argument designates or points to a member of the current
instantiation or a member of a dependent type.

4 A template template-argument is dependent if it names a template-parameter or is a qualiﬁed-id that refers

to a member of an unknown specialization.
14.6.3 Non-dependent names

[temp.nondep]
1 Non-dependent names used in a template deﬁnition are found using the usual name lookup and bound at

the point they are used. [ Example:

void g(double);
void h();

template<class T> class Z {
public:

void f() {

g(1);
h++;

}
};

void g(int);

// calls g(double)
// ill-formed: cannot increment function;
// this could be diagnosed either here or
// at the point of instantiation

// not in scope at the point of the template
// deﬁnition, not considered for the call g(1)

— end example ]
14.6.4 Dependent name resolution
In resolving dependent names, names from the following sources are considered:

[temp.dep.res]

—
—

Declarations that are visible at the point of deﬁnition of the template.
Declarations from namespaces associated with the types of the function arguments both from the
instantiation context (14.6.4.1) and from the deﬁnition context.

1

(1.1)

(1.2)

14.6.4.1 Point of instantiation

[temp.point]
1 For a function template specialization, a member function template specialization, or a specialization for a
member function or static data member of a class template, if the specialization is implicitly instantiated
because it is referenced from within another template specialization and the context from which it is ref-
erenced depends on a template parameter, the point of instantiation of the specialization is the point of
instantiation of the enclosing specialization. Otherwise, the point of instantiation for such a specialization
immediately follows the namespace scope declaration or deﬁnition that refers to the specialization.
If a function template or member function of a class template is called in a way which uses the deﬁnition of
a default argument of that function template or member function, the point of instantiation of the default
argument is the point of instantiation of the function template or member function specialization.

2

3 For an exception-speciﬁcation of a function template specialization or specialization of a member function
of a class template, if the exception-speciﬁcation is implicitly instantiated because it is needed by another

§ 14.6.4.1

377

c(cid:13) ISO/IEC

N4296

template specialization and the context that requires it depends on a template parameter, the point of
instantiation of the exception-speciﬁcation is the point of instantiation of the specialization that requires it.
Otherwise, the point of instantiation for such an exception-speciﬁcation immediately follows the namespace
scope declaration or deﬁnition that requires the exception-speciﬁcation.

4 For a class template specialization, a class member template specialization, or a specialization for a class
member of a class template, if the specialization is implicitly instantiated because it is referenced from
within another template specialization, if the context from which the specialization is referenced depends
on a template parameter, and if the specialization is not instantiated previous to the instantiation of the
enclosing template, the point of instantiation is immediately before the point of instantiation of the enclosing
template. Otherwise, the point of instantiation for such a specialization immediately precedes the namespace
scope declaration or deﬁnition that refers to the specialization.
If a virtual function is implicitly instantiated, its point of instantiation is immediately following the point of
instantiation of its enclosing class template specialization.

5

6 An explicit instantiation deﬁnition is an instantiation point for the specialization or specializations speciﬁed

by the explicit instantiation.

7 The instantiation context of an expression that depends on the template arguments is the set of declarations
with external linkage declared prior to the point of instantiation of the template specialization in the same
translation unit.

8 A specialization for a function template, a member function template, or of a member function or static
data member of a class template may have multiple points of instantiations within a translation unit, and
in addition to the points of instantiation described above, for any such specialization that has a point
of instantiation within the translation unit, the end of the translation unit is also considered a point of
instantiation. A specialization for a class template has at most one point of instantiation within a translation
unit. A specialization for any template may have points of instantiation in multiple translation units. If
two diﬀerent points of instantiation give a template specialization diﬀerent meanings according to the one
deﬁnition rule (3.2), the program is ill-formed, no diagnostic required.
14.6.4.2 Candidate functions

[temp.dep.candidate]
1 For a function call where the postﬁx-expression is a dependent name, the candidate functions are found using

the usual lookup rules (3.4.1, 3.4.2) except that:

(1.1)

(1.2)

—

—

For the part of the lookup using unqualiﬁed name lookup (3.4.1), only function declarations from the
template deﬁnition context are found.
For the part of the lookup using associated namespaces (3.4.2), only function declarations found in
either the template deﬁnition context or the template instantiation context are found.

If the call would be ill-formed or would ﬁnd a better match had the lookup within the associated namespaces
considered all the function declarations with external linkage introduced in those namespaces in all transla-
tion units, not just considering those declarations found in the template deﬁnition and template instantiation
contexts, then the program has undeﬁned behavior.
14.6.5 Friend names declared within a class template

[temp.inject]
1 Friend classes or functions can be declared within a class template. When a template is instantiated, the
names of its friends are treated as if the specialization had been explicitly declared at its point of instantiation.
2 As with non-template classes, the names of namespace-scope friend functions of a class template specializa-
tion are not visible during an ordinary lookup unless explicitly declared at namespace scope (11.3). Such
names may be found under the rules for associated classes (3.4.2).141 [ Example:
141) Friend declarations do not introduce new names into any scope, either when the template is declared or when it is
instantiated.

§ 14.6.5

378

c(cid:13) ISO/IEC

N4296

template<typename T> struct number {

number(int);
friend number gcd(number x, number y) { return 0; };

};

void g() {

number<double> a(3), b(4);
a = gcd(a,b);

// ﬁnds gcd because number<double> is an
// associated class, making gcd visible
// in its namespace (global scope)
// ill-formed; gcd is not visible

b = gcd(3,4);

}

— end example ]
14.7 Template instantiation and specialization

[temp.spec]
1 The act of instantiating a function, a class, a member of a class template or a member template is referred

to as template instantiation.

2 A function instantiated from a function template is called an instantiated function. A class instantiated from
a class template is called an instantiated class. A member function, a member class, a member enumeration,
or a static data member of a class template instantiated from the member deﬁnition of the class template
is called, respectively, an instantiated member function, member class, member enumeration, or static data
member. A member function instantiated from a member function template is called an instantiated member
function. A member class instantiated from a member class template is called an instantiated member class.
3 An explicit specialization may be declared for a function template, a class template, a member of a class
template or a member template. An explicit specialization declaration is introduced by template<>. In
an explicit specialization declaration for a class template, a member of a class template or a class member
template, the name of the class that is explicitly specialized shall be a simple-template-id. In the explicit
specialization declaration for a function template or a member function template, the name of the function
or member function explicitly specialized may be a template-id. [ Example:

template<class T = int> struct A {

static int x;

};
template<class U> void g(U) { }

template<> struct A<double> { };
template<> struct A<> { };
template<> void g(char) { }

template<> void g<int>(int) { }
template<> int A<char>::x = 0;

// specialize for T == double
// specialize for T == int
// specialize for U == char
// U is deduced from the parameter type
// specialize for U == int
// specialize for T == char

template<class T = int> struct B {

static int x;

};
template<> int B<>::x = 1;

// specialize for T == int

— end example ]

4 An instantiated template specialization can be either implicitly instantiated (14.7.1) for a given argument
list or be explicitly instantiated (14.7.2). A specialization is a class, function, or class member that is either
instantiated or explicitly specialized (14.7.3).

5 For a given template and a given set of template-arguments,

§ 14.7

379

c(cid:13) ISO/IEC

N4296

(5.1)

(5.2)

(5.3)

—
—
—

an explicit instantiation deﬁnition shall appear at most once in a program,
an explicit specialization shall be deﬁned at most once in a program (according to 3.2), and
both an explicit instantiation and a declaration of an explicit specialization shall not appear in a
program unless the explicit instantiation follows a declaration of the explicit specialization.

An implementation is not required to diagnose a violation of this rule.

6 Each class template specialization instantiated from a template has its own copy of any static members.

[ Example:

template<class T> class X {

static T s;

};
template<class T> T X<T>::s = 0;
X<int> aa;
X<char*> bb;

Implicit instantiation

X<int> has a static member s of type int and X<char*> has a static member s of type char*. — end
example ]
14.7.1

[temp.inst]
1 Unless a class template specialization has been explicitly instantiated (14.7.2) or explicitly specialized (14.7.3),
the class template specialization is implicitly instantiated when the specialization is referenced in a context
that requires a completely-deﬁned object type or when the completeness of the class type aﬀects the seman-
tics of the program. [ Note: Within a template declaration, a local class or enumeration and the members
of a local class are never considered to be entities that can be separately instantiated (this includes their
default arguments, exception-speciﬁcations, and non-static data member initializers, if any). As a result, the
dependent names are looked up, the semantic constraints are checked, and any templates used are instanti-
ated as part of the instantiation of the entity within which the local class or enumeration is declared. — end
note ] The implicit instantiation of a class template specialization causes the implicit instantiation of the
declarations, but not of the deﬁnitions, default arguments, or exception-speciﬁcations of the class member
functions, member classes, scoped member enumerations, static data members and member templates; and
it causes the implicit instantiation of the deﬁnitions of unscoped member enumerations and member anony-
mous unions. However, for the purpose of determining whether an instantiated redeclaration of a member
is valid according to 9.2, a declaration that corresponds to a deﬁnition in the template is considered to be a
deﬁnition. [ Example:

template<class T, class U>
struct Outer {

template<class X, class Y> struct Inner;
template<class Y> struct Inner<T, Y>;
template<class Y> struct Inner<T, Y> { };
template<class Y> struct Inner<U, Y> { };

};

// #1a
// #1b; OK: valid redeclaration of #1a
// #2

Outer<int, int> outer;

// error at #2

Outer<int, int>::Inner<int, Y> is redeclared at #1b. (It is not deﬁned but noted as being associated
with a deﬁnition in Outer<T, U>.) #2 is also a redeclaration of #1a.
It is noted as associated with a
deﬁnition, so it is an invalid redeclaration of the same partial specialization. — end example ]

2 Unless a member of a class template or a member template has been explicitly instantiated or explicitly
specialized, the specialization of the member is implicitly instantiated when the specialization is referenced

§ 14.7.1

380

c(cid:13) ISO/IEC

N4296

in a context that requires the member deﬁnition to exist; in particular, the initialization (and any associated
side-eﬀects) of a static data member does not occur unless the static data member is itself used in a way
that requires the deﬁnition of the static data member to exist.

3 Unless a function template specialization has been explicitly instantiated or explicitly specialized, the func-
tion template specialization is implicitly instantiated when the specialization is referenced in a context that
requires a function deﬁnition to exist. Unless a call is to a function template explicit specialization or to a
member function of an explicitly specialized class template, a default argument for a function template or a
member function of a class template is implicitly instantiated when the function is called in a context that
requires the value of the default argument.
[ Example:

4

template<class T> struct Z {

void f();
void g();

};

void h() {
Z<int> a;
Z<char>* p;
Z<double>* q;

a.f();
p->g();

}

// instantiation of class Z<int> required
// instantiation of class Z<char> not required
// instantiation of class Z<double> not required

// instantiation of Z<int>::f() required
// instantiation of class Z<char> required, and
// instantiation of Z<char>::g() required

Nothing in this example requires class Z<double>, Z<int>::g(), or Z<char>::f() to be implicitly instan-
tiated. — end example ]

5 Unless a variable template specialization has been explicitly instantiated or explicitly specialized, the vari-
able template specialization is implicitly instantiated when the specialization is used. A default template
argument for a variable template is implicitly instantiated when the variable template is referenced in a
context that requires the value of the default argument.

6 A class template specialization is implicitly instantiated if the class type is used in a context that requires
a completely-deﬁned object type or if the completeness of the class type might aﬀect the semantics of the
program. [ Note: In particular, if the semantics of an expression depend on the member or base class lists
of a class template specialization, the class template specialization is implicitly generated. For instance,
deleting a pointer to class type depends on whether or not the class declares a destructor, and conversion
between pointer to class types depends on the inheritance relationship between the two classes involved.
— end note ] [ Example:

template<class T> class B { /∗ ... ∗/ };
template<class T> class D : public B<T> { /∗ ... ∗/ };

void f(void*);
void f(B<int>*);

void g(D<int>* p, D<char>* pp, D<double>* ppp) {

f(p);
B<char>* q = pp; // instantiation of D<char> required:

// instantiation of D<int> required: call f(B<int>*)

// convert D<char>* to B<char>*
// instantiation of D<double> required

delete ppp;

}

§ 14.7.1

381

c(cid:13) ISO/IEC

N4296

7

— end example ]
If the overload resolution process can determine the correct function to call without instantiating a class
template deﬁnition, it is unspeciﬁed whether that instantiation actually takes place. [ Example:

template <class T> struct S {

operator int();

};

void f(int);
void f(S<int>&);
void f(S<float>);

void g(S<int>& sr) {

f(sr);

};

// instantiation of S<int> allowed but not required
// instantiation of S<float> allowed but not required

8

— end example ]
If an implicit instantiation of a class template specialization is required and the template is declared but not
deﬁned, the program is ill-formed. [ Example:

template<class T> class X;

X<char> ch;

// error: deﬁnition of X required

— end example ]

9 The implicit instantiation of a class template does not cause any static data members of that class to be

implicitly instantiated.
If a function template or a member function template specialization is used in a way that involves overload
resolution, a declaration of the specialization is implicitly instantiated (14.8.3).

10

11 An implementation shall not implicitly instantiate a function template, a variable template, a member tem-
plate, a non-virtual member function, a member class, or a static data member of a class template that
does not require instantiation. It is unspeciﬁed whether or not an implementation implicitly instantiates
a virtual member function of a class template if the virtual member function would not otherwise be in-
stantiated. The use of a template specialization in a default argument shall not cause the template to be
implicitly instantiated except that a class template may be instantiated where its complete type is needed to
determine the correctness of the default argument. The use of a default argument in a function call causes
specializations in the default argument to be implicitly instantiated.
Implicitly instantiated class, function, and variable template specializations are placed in the namespace
where the template is deﬁned. Implicitly instantiated specializations for members of a class template are
placed in the namespace where the enclosing class template is deﬁned.
Implicitly instantiated member
templates are placed in the namespace where the enclosing class or class template is deﬁned. [ Example:

12

namespace N {

template<class T> class List {
public:

T* get();

};

}

template<class K, class V> class Map {
public:

N::List<V> lt;

§ 14.7.1

382

c(cid:13) ISO/IEC

V get(K);

};

N4296

void g(Map<const char*,int>& m) {

int i = m.get("Nicholas");

}

13

a call of lt.get() from Map<const char*,int>::get() would place List<int>::get() in the namespace
N rather than in the global namespace. — end example ]
If a function template f is called in a way that requires a default argument to be used, the dependent names
are looked up, the semantics constraints are checked, and the instantiation of any template used in the default
argument is done as if the default argument had been an initializer used in a function template specialization
with the same scope, the same template parameters and the same access as that of the function template
f used at that point, except that the scope in which a closure type is declared (5.1.2) – and therefore its
associated namespaces – remain as determined from the context of the deﬁnition for the default argument.
This analysis is called default argument instantiation. The instantiated default argument is then used as the
argument of f.

14 Each default argument is instantiated independently. [ Example:

template<class T> void f(T x, T y = ydef(T()), T z = zdef(T()));

class

A { };

A zdef(A);

void g(A a, A b, A c) {

// no default argument instantiation
// default argument z = zdef(T()) instantiated
// ill-formed; ydef is not declared

f(a, b, c);
f(a, b);
f(a);

}

— end example ]

15 The exception-speciﬁcation of a function template specialization is not instantiated along with the function
declaration; it is instantiated when needed (15.4). If such an exception-speciﬁcation is needed but has not
yet been instantiated, the dependent names are looked up, the semantics constraints are checked, and the
instantiation of any template used in the exception-speciﬁcation is done as if it were being done as part of
instantiating the declaration of the specialization at that point.
[ Note: 14.6.4.1 deﬁnes the point of instantiation of a template specialization. — end note ]

16
17 There is an implementation-deﬁned quantity that speciﬁes the limit on the total depth of recursive instan-
tiations, which could involve more than one template. The result of an inﬁnite recursion in instantiation is
undeﬁned. [ Example:

X<T>* p;
X<T*> a;

template<class T> class X {
// OK
// implicit generation of X<T> requires
// the implicit instantiation of X<T*> which requires
// the implicit instantiation of X<T**> which ...

};

— end example ]

§ 14.7.1

383

c(cid:13) ISO/IEC

N4296

14.7.2 Explicit instantiation

[temp.explicit]
1 A class, function, variable, or member template specialization can be explicitly instantiated from its template.
A member function, member class or static data member of a class template can be explicitly instantiated
from the member deﬁnition associated with its class template. An explicit instantiation of a function template
or member function of a class template shall not use the inline or constexpr speciﬁers.

2 The syntax for explicit instantiation is:

3

explicit-instantiation:

externopt template declaration

There are two forms of explicit instantiation: an explicit instantiation deﬁnition and an explicit instantiation
declaration. An explicit instantiation declaration begins with the extern keyword.
If the explicit instantiation is for a class or member class, the elaborated-type-speciﬁer in the declaration shall
include a simple-template-id. If the explicit instantiation is for a function or member function, the unqualiﬁed-
id in the declaration shall be either a template-id or, where all template arguments can be deduced, a
template-name or operator-function-id. [ Note: The declaration may declare a qualiﬁed-id, in which case the
unqualiﬁed-id of the qualiﬁed-id must be a template-id. — end note ] If the explicit instantiation is for a
member function, a member class or a static data member of a class template specialization, the name of
the class template specialization in the qualiﬁed-id for the member name shall be a simple-template-id. If
the explicit instantiation is for a variable, the unqualiﬁed-id in the declaration shall be a template-id. An
explicit instantiation shall appear in an enclosing namespace of its template. If the name declared in the
explicit instantiation is an unqualiﬁed name, the explicit instantiation shall appear in the namespace where
its template is declared or, if that namespace is inline (7.3.1), any namespace from its enclosing namespace
set. [ Note: Regarding qualiﬁed names in declarators, see 8.3. — end note ] [ Example:

template<class T> class Array { void mf(); };
template class Array<char>;
template void Array<int>::mf();
template<class T> void sort(Array<T>& v) { /∗ ... ∗/ }
template void sort(Array<char>&);

// argument is deduced here

namespace N {

template<class T> void f(T&) { }

}
template void N::f<int>(int&);

— end example ]

4 A declaration of a function template, a variable template, a member function or static data member of a class
template, or a member function template of a class or class template shall precede an explicit instantiation
of that entity. A deﬁnition of a class template, a member class of a class template, or a member class
template of a class or class template shall precede an explicit instantiation of that entity unless the explicit
instantiation is preceded by an explicit specialization of the entity with the same template arguments. If the
declaration of the explicit instantiation names an implicitly-declared special member function (Clause 12),
the program is ill-formed.

5 For a given set of template arguments, if an explicit instantiation of a template appears after a declaration
of an explicit specialization for that template, the explicit instantiation has no eﬀect. Otherwise, for an
explicit instantiation deﬁnition the deﬁnition of a function template, a variable template, a member function
template, or a member function or static data member of a class template shall be present in every translation
unit in which it is explicitly instantiated.

6 An explicit instantiation of a class, function template, or variable template specialization is placed in the
namespace in which the template is deﬁned. An explicit instantiation for a member of a class template is

§ 14.7.2

384

c(cid:13) ISO/IEC

N4296

placed in the namespace where the enclosing class template is deﬁned. An explicit instantiation for a member
template is placed in the namespace where the enclosing class or class template is deﬁned. [ Example:

namespace N {

}

template<class T> class Y { void mf() { } };

template class Y<int>;

using N::Y;
template class Y<int>;

template class N::Y<char*>;
template void N::Y<double>::mf();

— end example ]

// error: class template Y not visible
// in the global namespace

// error: explicit instantiation outside of the
// namespace of the template

// OK: explicit instantiation in namespace N
// OK: explicit instantiation
// in namespace N

7 A trailing template-argument can be left unspeciﬁed in an explicit instantiation of a function template
specialization or of a member function template specialization provided it can be deduced from the type of
a function parameter (14.8.2). [ Example:

template<class T> class Array { /∗ ... ∗/ };
template<class T> void sort(Array<T>& v) { /∗ ... ∗/ }

// instantiate sort(Array<int>&) - template-argument deduced
template void sort<>(Array<int>&);

— end example ]

8 An explicit instantiation that names a class template specialization is also an explicit instantiation of the
same kind (declaration or deﬁnition) of each of its members (not including members inherited from base
classes and members that are templates) that has not been previously explicitly specialized in the translation
unit containing the explicit instantiation, except as described below. [ Note: In addition, it will typically be
an explicit instantiation of certain implementation-dependent data about the class. — end note ]

9 An explicit instantiation deﬁnition that names a class template specialization explicitly instantiates the
class template specialization and is an explicit instantiation deﬁnition of only those members that have been
deﬁned at the point of instantiation.

11

10 Except for inline functions, declarations with types deduced from their initializer or return value (7.1.6.4),
const variables of literal types, variables of reference types, and class template specializations, explicit
instantiation declarations have the eﬀect of suppressing the implicit instantiation of the entity to which they
refer. [ Note: The intent is that an inline function that is the subject of an explicit instantiation declaration
will still be implicitly instantiated when odr-used (3.2) so that the body can be considered for inlining, but
that no out-of-line copy of the inline function would be generated in the translation unit. — end note ]
If an entity is the subject of both an explicit instantiation declaration and an explicit instantiation deﬁnition
in the same translation unit, the deﬁnition shall follow the declaration. An entity that is the subject of
an explicit instantiation declaration and that is also used in a way that would otherwise cause an implicit
instantiation (14.7.1) in the translation unit shall be the subject of an explicit instantiation deﬁnition some-
where in the program; otherwise the program is ill-formed, no diagnostic required.
[ Note: This rule does
apply to inline functions even though an explicit instantiation declaration of such an entity has no other
normative eﬀect. This is needed to ensure that if the address of an inline function is taken in a translation
unit in which the implementation chose to suppress the out-of-line body, another translation unit will supply

§ 14.7.2

385

c(cid:13) ISO/IEC

N4296

the body. — end note ] An explicit instantiation declaration shall not name a specialization of a template
with internal linkage.

12 The usual access checking rules do not apply to names used to specify explicit instantiations.

[ Note: In
particular, the template arguments and names used in the function declarator (including parameter types,
return types and exception speciﬁcations) may be private types or objects which would normally not be
accessible and the template may be a member template or member function which would not normally be
accessible. — end note ]

13 An explicit instantiation does not constitute a use of a default argument, so default argument instantiation

is not done. [ Example:

char* p = 0;
template<class T> T g(T x = &p) { return x; }
template int g<int>(int);

// OK even though &p isn’t an int.

[temp.expl.spec]

— end example ]
14.7.3 Explicit specialization

1 An explicit specialization of any of the following:

(1.1)

(1.2)

(1.3)

(1.4)

(1.5)

(1.6)

(1.7)

(1.8)

(1.9)

—
—
—
—
—
—
—
—
—

function template
class template
variable template
member function of a class template
static data member of a class template
member class of a class template
member enumeration of a class template
member class template of a class or class template
member function template of a class or class template

can be declared by a declaration introduced by template<>; that is:

explicit-specialization:

template < > declaration

[ Example:

template<class T> class stream;
template<> class stream<char> { /∗ ... ∗/ };
template<class T> class Array { /∗ ... ∗/ };
template<class T> void sort(Array<T>& v) { /∗ ... ∗/ }

template<> void sort<char*>(Array<char*>&) ;

Given these declarations, stream<char> will be used as the deﬁnition of streams of chars; other streams will
be handled by class template specializations instantiated from the class template. Similarly, sort<char*>
will be used as the sort function for arguments of type Array<char*>; other Array types will be sorted by
functions generated from the template. — end example ]

§ 14.7.3

386

c(cid:13) ISO/IEC

N4296

2 An explicit specialization shall be declared in a namespace enclosing the specialized template. An explicit
specialization whose declarator-id is not qualiﬁed shall be declared in the nearest enclosing namespace of
the template, or, if the namespace is inline (7.3.1), any namespace from its enclosing namespace set. Such a
declaration may also be a deﬁnition. If the declaration is not a deﬁnition, the specialization may be deﬁned
later (7.3.1.2).

3 A declaration of a function template, class template, or variable template being explicitly specialized shall
precede the declaration of the explicit specialization.
[ Note: A declaration, but not a deﬁnition of the
template is required. — end note ] The deﬁnition of a class or class template shall precede the declaration
of an explicit specialization for a member template of the class or class template. [ Example:

template<> class X<int> { /∗ ... ∗/ };

// error: X not a template

template<class T> class X;
template<> class X<char*> { /∗ ... ∗/ };

// OK: X is a template

— end example ]

4 A member function, a member function template, a member class, a member enumeration, a member class
template, a static data member, or a static data member template of a class template may be explicitly
specialized for a class specialization that is implicitly instantiated; in this case, the deﬁnition of the class
template shall precede the explicit specialization for the member of the class template. If such an explicit
specialization for the member of a class template names an implicitly-declared special member function
(Clause 12), the program is ill-formed.

5 A member of an explicitly specialized class is not implicitly instantiated from the member declaration of the
class template; instead, the member of the class template specialization shall itself be explicitly deﬁned if its
deﬁnition is required. In this case, the deﬁnition of the class template explicit specialization shall be in scope
at the point at which the member is deﬁned. The deﬁnition of an explicitly specialized class is unrelated
to the deﬁnition of a generated specialization. That is, its members need not have the same names, types,
etc. as the members of a generated specialization. Members of an explicitly specialized class template are
deﬁned in the same manner as members of normal classes, and not using the template<> syntax. The same
is true when deﬁning a member of an explicitly specialized member class. However, template<> is used in
deﬁning a member of an explicitly specialized member class template that is specialized as a class template.
[ Example:

template<class T> struct A {

struct B { };
template<class U> struct C { };

};

};

template<> struct A<int> {

void f(int);

void h() {
A<int> a;
a.f(16);

}

// A<int>::f must be deﬁned somewhere

// template<> not used for a member of an
// explicitly specialized class template
void A<int>::f(int) { /∗ ... ∗/ }

template<> struct A<char>::B {

§ 14.7.3

387

c(cid:13) ISO/IEC

N4296

void f();

};
// template<> also not used when deﬁning a member of
// an explicitly specialized member class
void A<char>::B::f() { /∗ ... ∗/ }

template<> template<class U> struct A<char>::C {

void f();

};
// template<> is used when deﬁning a member of an explicitly
// specialized member class template specialized as a class template
template<>
template<class U> void A<char>::C<U>::f() { /∗ ... ∗/ }

template<> struct A<short>::B {

void f();

};
template<> void A<short>::B::f() { /∗ ... ∗/ } // error: template<> not permitted

template<> template<class U> struct A<short>::C {

void f();

6

};
template<class U> void A<short>::C<U>::f() { /∗ ... ∗/ } // error: template<> required
— end example ]
If a template, a member template or a member of a class template is explicitly specialized then that special-
ization shall be declared before the ﬁrst use of that specialization that would cause an implicit instantiation
to take place, in every translation unit in which such a use occurs; no diagnostic is required. If the program
does not provide a deﬁnition for an explicit specialization and either the specialization is used in a way
that would cause an implicit instantiation to take place or the member is a virtual member function, the
program is ill-formed, no diagnostic required. An implicit instantiation is never generated for an explicit
specialization that is declared but not deﬁned. [ Example:

class String { };
template<class T> class Array { /∗ ... ∗/ };
template<class T> void sort(Array<T>& v) { /∗ ... ∗/ }

void f(Array<String>& v) {

sort(v);

// use primary template
// sort(Array<T>&), T is String

}

template<> void sort<String>(Array<String>& v); // error: specialization

// after use of primary template
// OK: sort<char*> not yet used

template<> void sort<>(Array<char*>& v);
template<class T> struct A {

enum E : T;
enum class S : T;

};
template<> enum A<int>::E : int { eint };
template<> enum class A<int>::S : int { sint };
template<class T> enum A<T>::E : T { eT };
template<class T> enum class A<T>::S : T { sT };
template<> enum A<char>::E : char { echar };

// OK
// OK

// ill-formed, A<char>::E was instantiated
// when A<char> was instantiated

§ 14.7.3

388

c(cid:13) ISO/IEC

N4296

template<> enum class A<char>::S : char { schar }; // OK

— end example ]

7 The placement of explicit specialization declarations for function templates, class templates, variable tem-
plates, member functions of class templates, static data members of class templates, member classes of class
templates, member enumerations of class templates, member class templates of class templates, member
function templates of class templates, static data member templates of class templates, member functions
of member templates of class templates, member functions of member templates of non-template classes,
static data member templates of non-template classes, member function templates of member classes of
class templates, etc., and the placement of partial specialization declarations of class templates, variable
templates, member class templates of non-template classes, static data member templates of non-template
classes, member class templates of class templates, etc., can aﬀect whether a program is well-formed ac-
cording to the relative positioning of the explicit specialization declarations and their points of instantiation
in the translation unit as speciﬁed above and below. When writing a specialization, be careful about its
location; or to make it compile will be such a trial as to kindle its self-immolation.

8 A template explicit specialization is in the scope of the namespace in which the template was deﬁned.

[ Example:

namespace N {

template<class T> class X { /∗ ... ∗/ };
template<class T> class Y { /∗ ... ∗/ };
template<> class X<int> { /∗ ... ∗/ };

template<> class Y<double>;

}
template<> class N::Y<double> { /∗ ... ∗/ };
template<> class N::Y<short> { /∗ ... ∗/ };

// OK: specialization
// in same namespace
// forward declare intent to
// specialize for double

// OK: specialization
// in enclosing namespace
// OK: specialization
// in enclosing namespace

— end example ]

9 A simple-template-id that names a class template explicit specialization that has been declared but not

deﬁned can be used exactly like the names of other incompletely-deﬁned classes (3.9). [ Example:

template<class T> class X;
template<> class X<int>;

// X is a class template

X<int>* p;
X<int> x;

— end example ]

// OK: pointer to declared class X<int>
// error: object of incomplete class X<int>

10 A trailing template-argument can be left unspeciﬁed in the template-id naming an explicit function template

specialization provided it can be deduced from the function argument type. [ Example:

template<class T> class Array { /∗ ... ∗/ };
template<class T> void sort(Array<T>& v);

// explicit specialization for sort(Array<int>&)
// with deduced template-argument of type int
template<> void sort(Array<int>&);

§ 14.7.3

389

c(cid:13) ISO/IEC

— end example ]

N4296

11 A function with the same name as a template and a type that exactly matches that of a template special-

ization is not an explicit specialization (14.5.6).

12 An explicit specialization of a function template is inline only if it is declared with the inline speciﬁer or

deﬁned as deleted, and independently of whether its function template is inline. [ Example:

template<class T> void f(T) { /∗ ... ∗/ }
template<class T> inline T g(T) { /∗ ... ∗/ }
template<> inline void f<>(int) { /∗ ... ∗/ }
template<> int g<>(int) { /∗ ... ∗/ }

// OK: inline
// OK: not inline

— end example ]

13 An explicit specialization of a static data member of a template or an explicit specialization of a static
data member template is a deﬁnition if the declaration includes an initializer; otherwise, it is a declaration.
[ Note: The deﬁnition of a static data member of a template that requires default initialization must use a
braced-init-list:

template<> X Q<int>::x;
template<> X Q<int>::x ();
template<> X Q<int>::x { };

// declaration
// error: declares a function
// deﬁnition

— end note ]

14 A member or a member template of a class template may be explicitly specialized for a given implicit
instantiation of the class template, even if the member or member template is deﬁned in the class template
deﬁnition. An explicit specialization of a member or member template is speciﬁed using the syntax for
explicit specialization. [ Example:
template<class T> struct A {

void f(T);
template<class X1> void g1(T, X1);
template<class X2> void g2(T, X2);
void h(T) { }

};

// specialization
template<> void A<int>::f(int);

// out of class member template deﬁnition
template<class T> template<class X1> void A<T>::g1(T, X1) { }

// member template specialization
template<> template<class X1> void A<int>::g1(int, X1);

//member template specialization
template<> template<>

void A<int>::g1(int, char);

template<> template<>

void A<int>::g2<char>(int, char);

// X1 deduced as char

// X2 speciﬁed as char

// member specialization even if deﬁned in class deﬁnition
template<> void A<int>::h(int) { }

— end example ]

§ 14.7.3

390

c(cid:13) ISO/IEC

N4296

15 A member or a member template may be nested within many enclosing class templates.

In an explicit
specialization for such a member, the member declaration shall be preceded by a template<> for each
enclosing class template that is explicitly specialized. [ Example:

template<class T1> class A {

template<class T2> class B {

void mf();

};

};
template<> template<> class A<int>::B<double>;
template<> template<> void A<char>::B<char>::mf();

16

— end example ]
In an explicit specialization declaration for a member of a class template or a member template that ap-
pears in namespace scope, the member template and some of its enclosing class templates may remain
unspecialized, except that the declaration shall not explicitly specialize a class member template if its en-
closing class templates are not explicitly specialized as well. In such explicit specialization declaration, the
keyword template followed by a template-parameter-list shall be provided instead of the template<> pre-
ceding the explicit specialization declaration of the member. The types of the template-parameters in the
template-parameter-list shall be the same as those speciﬁed in the primary template deﬁnition. [ Example:

template <class T1> class A {
template<class T2> class B {

template<class T3> void mf1(T3);
void mf2();

};
template <> template <class X>

class A<int>::B {

template <class T> void mf1(T);

};

};

template <> template <> template<class T>

void A<int>::B<double>::mf1(T t) { }

template <class Y> template <>

void A<Y>::B<double>::mf2() { }

// ill-formed; B<double> is specialized but
// its enclosing class template A is not

— end example ]

17 A specialization of a member function template, member class template, or static data member template of

a non-specialized class template is itself a template.

18 An explicit specialization declaration shall not be a friend declaration.
19 Default function arguments shall not be speciﬁed in a declaration or a deﬁnition for one of the following

explicit specializations:

(19.1)

(19.2)

(19.3)

—
—
—

the explicit specialization of a function template;
the explicit specialization of a member function template;
the explicit specialization of a member function of a class template where the class template special-
ization to which the member function specialization belongs is implicitly instantiated. [ Note: Default
function arguments may be speciﬁed in the declaration or deﬁnition of a member function of a class
template specialization that is explicitly specialized. — end note ]

§ 14.7.3

391

c(cid:13) ISO/IEC

N4296

14.8 Function template specializations

[temp.fct.spec]
1 A function instantiated from a function template is called a function template specialization; so is an
explicit specialization of a function template. Template arguments can be explicitly speciﬁed when naming
the function template specialization, deduced from the context (e.g., deduced from the function arguments
in a call to the function template specialization, see 14.8.2), or obtained from default template arguments.
2 Each function template specialization instantiated from a template has its own copy of any static variable.

[ Example:

template<class T> void f(T* p) {

static T s;

};

}

f(&a);
f(&b);

void g(int a, char* b) {

// calls f<int>(int*)
// calls f<char*>(char**)

Here f<int>(int*) has a static variable s of type int and f<char*>(char**) has a static variable s of
type char*. — end example ]
14.8.1 Explicit template argument speciﬁcation

[temp.arg.explicit]
1 Template arguments can be speciﬁed when referring to a function template specialization by qualifying the
function template name with the list of template-arguments in the same way as template-arguments are
speciﬁed in uses of a class template specialization. [ Example:

template<class T> void sort(Array<T>& v);
void f(Array<dcomplex>& cv, Array<int>& ci) {

sort<dcomplex>(cv);
sort<int>(ci);

// sort(Array<dcomplex>&)
// sort(Array<int>&)

template<class U, class V> U convert(V v);

void g(double d) {

int i = convert<int,double>(d);
char c = convert<char,double>(d);

// int convert(double)
// char convert(double)

}

and

}

— end example ]

2 A template argument list may be speciﬁed when referring to a specialization of a function template

(2.1)

(2.2)

(2.3)

(2.4)

(2.5)

—
—

—
—
—

when a function is called,
when the address of a function is taken, when a function initializes a reference to function, or when a
pointer to member function is formed,
in an explicit specialization,
in an explicit instantiation, or
in a friend declaration.

§ 14.8.1

392

c(cid:13) ISO/IEC

N4296

3 Trailing template arguments that can be deduced (14.8.2) or obtained from default template-arguments may
be omitted from the list of explicit template-arguments. A trailing template parameter pack (14.5.3) not
otherwise deduced will be deduced to an empty sequence of template arguments.
If all of the template
arguments can be deduced, they may all be omitted; in this case, the empty template argument list <>
itself may also be omitted. In contexts where deduction is done and fails, or in contexts where deduction
is not done, if a template argument list is speciﬁed and it, along with any default template arguments,
identiﬁes a single function template specialization, then the template-id is an lvalue for the function template
specialization. [ Example:

template<class X, class Y> X f(Y);
template<class X, class Y, class ... Z> X g(Y);
void h() {

int i = f<int>(5.6);
int j = f(5.6);
f<void>(f<int, bool>);

f<void>(f<int>);

int k = g<int>(5.6);
f<void>(g<int, bool>);

}

// Y is deduced to be double
// ill-formed: X cannot be deduced
// Y for outer f deduced to be
// int (*)(bool)
// ill-formed: f<int> does not denote a
// single function template specialization
// Y is deduced to be double, Z is deduced to an empty sequence
// Y for outer f is deduced to be
// int (*)(bool), Z is deduced to an empty sequence

4

— end example ]
[ Note: An empty template argument list can be used to indicate that a given use refers to a specialization
of a function template even when a non-template function (8.3.5) is visible that would otherwise be used.
For example:

template <class T> int f(T);
int f(int);
int k = f(1);
int l = f<>(1);

// #1
// #2
// uses #2
// uses #1

— end note ]

5 Template arguments that are present shall be speciﬁed in the declaration order of their corresponding
template-parameters. The template argument list shall not specify more template-arguments than there
are corresponding template-parameters unless one of the template-parameters is a template parameter pack.
[ Example:

template<class X, class Y, class Z> X f(Y,Z);
template<class ... Args> void f2();
void g() {

f<int,const char*,double>("aa",3.0);
f<int,const char*>("aa",3.0);
f<int>("aa",3.0);

// Z is deduced to be double

// Y is deduced to be const char*, and
// Z is deduced to be double
// error: X cannot be deduced

f("aa",3.0);
f2<char, short, int, long>(); // OK

}

6

— end example ]
Implicit conversions (Clause 4) will be performed on a function argument to convert it to the type of the
corresponding function parameter if the parameter type contains no template-parameters that participate
in template argument deduction.
[ Note: Template parameters do not participate in template argument
deduction if they are explicitly speciﬁed. For example,

§ 14.8.1

393

c(cid:13) ISO/IEC

template<class T> void f(T);

N4296

class Complex {

Complex(double);

};

void g() {

f<Complex>(1);

}

// OK, means f<Complex>(Complex(1))

7

8

— end note ]
[ Note: Because the explicit template argument list follows the function template name, and because con-
version member function templates and constructor member function templates are called without using a
function name, there is no way to provide an explicit template argument list for these function templates.
— end note ]
[ Note: For simple function names, argument dependent lookup (3.4.2) applies even when the function name
is not visible within the scope of the call. This is because the call still has the syntactic form of a function
call (3.4.1). But when a function template with explicit template arguments is used, the call does not have
the correct syntactic form unless there is a function template with that name visible at the point of the call.
If no such name is visible, the call is not syntactically well-formed and argument-dependent lookup does not
apply. If some such name is visible, argument dependent lookup applies and additional function templates
may be found in other namespaces. [ Example:

namespace A {

struct B { };
template<int X> void f(B);

template<class T> void f(T t);

}
namespace C {

}
void g(A::B b) {

f<3>(b);
A::f<3>(b);
C::f<3>(b);

using C::f;
f<3>(b);

}

— end example ] — end note ]

// ill-formed: not a function call
// well-formed
// ill-formed; argument dependent lookup
// applies only to unqualiﬁed names

// well-formed because C::f is visible; then
// A::f is found by argument dependent lookup

9 Template argument deduction can extend the sequence of template arguments corresponding to a template

parameter pack, even when the sequence contains explicitly speciﬁed template arguments. [ Example:

template<class ... Types> void f(Types ... values);

void g() {

}

f<int*, float*>(0, 0, 0);

// Types is deduced to the sequence int*, float*, int

— end example ]

§ 14.8.1

394

c(cid:13) ISO/IEC

N4296

14.8.2 Template argument deduction

[temp.deduct]
1 When a function template specialization is referenced, all of the template arguments shall have values.
The values can be explicitly speciﬁed or, in some cases, be deduced from the use or obtained from default
template-arguments. [ Example:

void f(Array<dcomplex>& cv, Array<int>& ci) {

// calls sort(Array<dcomplex>&)
// calls sort(Array<int>&)

sort(cv);
sort(ci);

}

and

void g(double d) {

int i = convert<int>(d);
int c = convert<char>(d);

}

// calls convert<int,double>(double)
// calls convert<char,double>(double)

— end example ]

2 When an explicit template argument list is speciﬁed, the template arguments must be compatible with the
template parameter list and must result in a valid function type as described below; otherwise type deduc-
tion fails. Speciﬁcally, the following steps are performed when evaluating an explicitly speciﬁed template
argument list with respect to a given function template:

(2.1)

—

(2.2)

(2.3)

—

—

The speciﬁed template arguments must match the template parameters in kind (i.e., type, non-type,
template). There must not be more arguments than there are parameters unless at least one parameter
is a template parameter pack, and there shall be an argument for each non-pack parameter. Otherwise,
type deduction fails.
Non-type arguments must match the types of the corresponding non-type template parameters, or must
be convertible to the types of the corresponding non-type parameters as speciﬁed in 14.3.2, otherwise
type deduction fails.
The speciﬁed template argument values are substituted for the corresponding template parameters as
speciﬁed below.

3 After this substitution is performed, the function parameter type adjustments described in 8.3.5 are per-
formed. [ Example: A parameter type of “void ()(const int, int[5])” becomes “void(*)(int,int*)”.
— end example ] [ Note: A top-level qualiﬁer in a function parameter declaration does not aﬀect the function
type but still aﬀects the type of the function parameter variable within the function. — end note ] [ Example:

template <class T> void f(T t);
template <class X> void g(const X x);
template <class Z> void h(Z, Z*);

int main() {

// #1: function type is f(int), t is non const
f<int>(1);

// #2: function type is f(int), t is const
f<const int>(1);

// #3: function type is g(int), x is const
g<int>(1);

// #4: function type is g(int), x is const
g<const int>(1);

§ 14.8.2

395

c(cid:13) ISO/IEC

N4296

// #5: function type is h(int, const int*)
h<const int>(1,0);

}

4

— end example ]
[ Note: f<int>(1) and f<const int>(1) call distinct functions even though both of the functions called
have the same function type. — end note ]

5 The resulting substituted and adjusted function type is used as the type of the function template for template
argument deduction. If a template argument has not been deduced and its corresponding template parameter
has a default argument, the template argument is determined by substituting the template arguments
determined for preceding template parameters into the default argument. If the substitution results in an
invalid type, as described above, type deduction fails. [ Example:

template <class T, class U = double>
void f(T t = 0, U u = 0);

void g() {

f(1, ’c’);
f(1);
f();
f<int>();
f<int,char>();

}

// f<int,char>(1,’c’)
// f<int,double>(1,0)
// error: T cannot be deduced
// f<int,double>(0,0)
// f<int,char>(0,0)

— end example ]
When all template arguments have been deduced or obtained from default template arguments, all uses of
template parameters in the template parameter list of the template and the function type are replaced with
the corresponding deduced or default argument values.
If the substitution results in an invalid type, as
described above, type deduction fails.

6 At certain points in the template argument deduction process it is necessary to take a function type that
makes use of template parameters and replace those template parameters with the corresponding template
arguments. This is done at the beginning of template argument deduction when any explicitly speciﬁed tem-
plate arguments are substituted into the function type, and again at the end of template argument deduction
when any template arguments that were deduced or obtained from default arguments are substituted.

7 The substitution occurs in all types and expressions that are used in the function type and in template
parameter declarations. The expressions include not only constant expressions such as those that appear in
array bounds or as nontype template arguments but also general expressions (i.e., non-constant expressions)
inside sizeof, decltype, and other contexts that allow non-constant expressions. The substitution proceeds
in lexical order and stops when a condition that causes deduction to fail is encountered. [ Note: The equiva-
lent substitution in exception speciﬁcations is done only when the exception-speciﬁcation is instantiated, at
which point a program is ill-formed if the substitution results in an invalid type or expression. — end note ]
[ Example:

template <class T> struct A { using X = typename T::X; };
template <class T> typename T::X f(typename A<T>::X);
template <class T> void f(...) { }
template <class T> auto g(typename A<T>::X) -> typename T::X;
template <class T> void g(...) { }

void h() {

f<int>(0); // OK, substituting return type causes deduction to fail

§ 14.8.2

396

c(cid:13) ISO/IEC

N4296

g<int>(0); // error, substituting parameter type instantiates A<int>

}

8

— end example ]
If a substitution results in an invalid type or expression, type deduction fails. An invalid type or expression is
one that would be ill-formed, with a diagnostic required, if written using the substituted arguments. [ Note:
If no diagnostic is required, the program is still ill-formed. Access checking is done as part of the substitution
process. — end note ] Only invalid types and expressions in the immediate context of the function type and
its template parameter types can result in a deduction failure. [ Note: The evaluation of the substituted types
and expressions can result in side eﬀects such as the instantiation of class template specializations and/or
function template specializations, the generation of implicitly-deﬁned functions, etc. Such side eﬀects are
not in the “immediate context” and can result in the program being ill-formed. — end note ]
[ Example:

struct X { };
struct Y {

Y(X){}

};

template <class T> auto f(T t1, T t2) -> decltype(t1 + t2); // #1
X f(Y, Y); // #2

X x1, x2;
X x3 = f(x1, x2); // deduction fails on #1 (cannot add X+X), calls #2

— end example ]
[ Note: Type deduction may fail for the following reasons:

(8.1)

(8.2)

—
—

Attempting to instantiate a pack expansion containing multiple parameter packs of diﬀering lengths.
Attempting to create an array with an element type that is void, a function type, a reference type, or
an abstract class type, or attempting to create an array with a size that is zero or negative. [ Example:

template <class T> int f(T[5]);
int I = f<int>(0);
int j = f<void>(0);

// invalid array

— end example ]
Attempting to use a type that is not a class or enumeration type in a qualiﬁed name. [ Example:

(8.3)

—

template <class T> int f(typename T::B*);
int i = f<int>(0);

(8.4)

—

(8.4.1)

(8.4.2)

(8.4.3)

— end example ]
Attempting to use a type in a nested-name-speciﬁer of a qualiﬁed-id when that type does not contain
the speciﬁed member, or
—
—
—
[ Example:

the speciﬁed member is not a type where a type is required, or
the speciﬁed member is not a template where a template is required, or
the speciﬁed member is not a non-type where a non-type is required.

§ 14.8.2

397

c(cid:13) ISO/IEC

N4296

template <int I> struct X { };
template <template <class T> class> struct Z { };
template <class T> void f(typename T::Y*){}
template <class T> void g(X<T::N>*){}
template <class T> void h(Z<T::template TT>*){}
struct A {};
struct B { int Y; };
struct C {

typedef int N;

};
struct D {

typedef int TT;

};

}

int main() {

// Deduction fails in each of these cases:
f<A>(0); // A does not contain a member Y
f<B>(0); // The Y member of B is not a type
g<C>(0); // The N member of C is not a non-type
h<D>(0); // The TT member of D is not a template

— end example ]
Attempting to create a pointer to reference type.
Attempting to create a reference to void.
Attempting to create “pointer to member of T” when T is not a class type. [ Example:

—
—
—

(8.5)

(8.6)

(8.7)

template <class T> int f(int T::*);
int i = f<int>(0);

— end example ]
Attempting to give an invalid type to a non-type template parameter. [ Example:

(8.8)

—

template <class T, T> struct S {};
template <class T> int f(S<T, T()>*);
struct X {};
int i0 = f<X>(0);

(8.9)

—

— end example ]
Attempting to perform an invalid conversion in either a template argument expression, or an expression
used in the function declaration. [ Example:

template <class T, T*> int f(int);
int i2 = f<int,1>(0);

// can’t conv 1 to int*

(8.10)

(8.11)

— end example ]
Attempting to create a function type in which a parameter has a type of void, or in which the return
type is a function type or array type.
Attempting to create a function type in which a parameter type or the return type is an abstract class
type (10.4).

—

—

§ 14.8.2

398

c(cid:13) ISO/IEC

N4296

9

— end note ]
[ Example: In the following example, assuming a signed char cannot represent the value 1000, a narrowing
conversion (8.5.4) would be required to convert the template-argument of type int to signed char, therefore
substitution fails for the second template (14.3.2).

template <int> int f(int);
template <signed char> int f(int);
// OK
int i1 = f<1000>(0);
// ambiguous; not narrowing
int i2 = f<1>(0);

— end example ]
14.8.2.1 Deducing template arguments from a function call

[temp.deduct.call]
1 Template argument deduction is done by comparing each function template parameter type (call it P) with
the type of the corresponding argument of the call (call it A) as described below. If P is a dependent type,
removing references and cv-qualiﬁers from P gives std::initializer_list<P0> or P0[N] for some P0 and
N and the argument is a non-empty initializer list (8.5.4), then deduction is performed instead for each
element of the initializer list, taking P0 as a function template parameter type and the initializer element as
its argument, and in the P0[N] case, if N is a non-type template parameter, N is deduced from the length of the
initializer list. Otherwise, an initializer list argument causes the parameter to be considered a non-deduced
context (14.8.2.5). [ Example:

template<class T> void f(std::initializer_list<T>);
f({1,2,3});
f({1,"asdf"});

// T deduced to int
// error: T deduced to both int and const char*

template<class T> void g(T);
g({1,2,3});

// error: no argument deduced for T

template<class T, int N> void h(T const(&)[N]);
h({1,2,3});

// T deduced to int, N deduced to 3

template<class T> void j(T const(&)[3]);
j({42});

// T deduced to int, array bound not considered

struct Aggr { int i; int j; };
template<int N> void k(Aggr const(&)[N]);
k({1,2,3});
k({{1},{2},{3}});

// error: deduction fails, no conversion from int to Aggr
// OK, N deduced to 3

template<int M, int N> void m(int const(&)[M][N]);
m({{1,2},{3,4}});

// M and N both deduced to 2

template<class T, int N> void n(T const(&)[N], T);
// OK, T is Aggr, N is 3
n({{1},{2},{3}},Aggr());

— end example ] For a function parameter pack that occurs at the end of the parameter-declaration-list,
the type A of each remaining argument of the call is compared with the type P of the declarator-id of the
function parameter pack. Each comparison deduces template arguments for subsequent positions in the
template parameter packs expanded by the function parameter pack. When a function parameter pack
appears in a non-deduced context (14.8.2.5), the type of that parameter pack is never deduced. [ Example:

template<class ... Types> void f(Types& ...);
template<class T1, class ... Types> void g(T1, Types ...);
template<class T1, class ... Types> void g1(Types ..., T1);

§ 14.8.2.1

399

c(cid:13) ISO/IEC

N4296

void h(int x, float& y) {

const int z = x;
f(x, y, z);
g(x, y, z);
g1(x, y, z);
g1<int, int, int>(x, y, z); // OK, no deduction occurs

// Types is deduced to int, float, const int
// T1 is deduced to int; Types is deduced to float, int
// error: Types is not deduced

2

(2.1)

(2.2)

(2.3)

3

}

— end example ]
If P is not a reference type:

—

—

—

If A is an array type, the pointer type produced by the array-to-pointer standard conversion (4.2) is
used in place of A for type deduction; otherwise,
If A is a function type, the pointer type produced by the function-to-pointer standard conversion (4.3)
is used in place of A for type deduction; otherwise,
If A is a cv-qualiﬁed type, the top level cv-qualiﬁers of A’s type are ignored for type deduction.

If P is a cv-qualiﬁed type, the top level cv-qualiﬁers of P’s type are ignored for type deduction. If P is a
reference type, the type referred to by P is used for type deduction. A forwarding reference is an rvalue
reference to a cv-unqualiﬁed template parameter.
If P is a forwarding reference and the argument is an
lvalue, the type “lvalue reference to A” is used in place of A for type deduction. [ Example:

template <class T> int f(T&& heisenreference);
template <class T> int g(const T&&);
int i;
int n1 = f(i);
int n2 = f(0);
int n3 = g(i);

// calls f<int&>(int&)
// calls f<int>(int&&)
// error: would call g<int>(const int&&), which
// would bind an rvalue reference to an lvalue

4

— end example ]
In general, the deduction process attempts to ﬁnd template argument values that will make the deduced A
identical to A (after the type A is transformed as described above). However, there are three cases that allow
a diﬀerence:

(4.1)

(4.2)

(4.3)

—

—

—

If the original P is a reference type, the deduced A (i.e., the type referred to by the reference) can be
more cv-qualiﬁed than the transformed A.
The transformed A can be another pointer or pointer to member type that can be converted to the
deduced A via a qualiﬁcation conversion (4.4).
If P is a class and P has the form simple-template-id, then the transformed A can be a derived class of
the deduced A. Likewise, if P is a pointer to a class of the form simple-template-id, the transformed A
can be a pointer to a derived class pointed to by the deduced A.

[ Note: as speciﬁed in 14.8.1, implicit conversions will be performed on a function argument to convert it
to the type of the corresponding function parameter if the parameter contains no template-parameters that
participate in template argument deduction. Such conversions are also allowed, in addition to the ones
described in the preceding list. — end note ]

5 These alternatives are considered only if type deduction would otherwise fail. If they yield more than one
[ Note: If a template-parameter is not used in any of the

possible deduced A, the type deduction fails.

§ 14.8.2.1

400

c(cid:13) ISO/IEC

N4296

function parameters of a function template, or is used only in a non-deduced context, its corresponding
template-argument cannot be deduced from a function call and the template-argument must be explicitly
speciﬁed. — end note ]

6 When P is a function type, pointer to function type, or pointer to member function type:

(6.1)

(6.2)

—

—

7

8

9

If the argument is an overload set containing one or more function templates, the parameter is treated
as a non-deduced context.
If the argument is an overload set (not containing function templates), trial argument deduction is
attempted using each of the members of the set. If deduction succeeds for only one of the overload
set members, that member is used as the argument value for the deduction. If deduction succeeds for
more than one member of the overload set the parameter is treated as a non-deduced context.
[ Example:

// Only one function of an overload set matches the call so the function
// parameter is a deduced context.
template <class T> int f(T (*p)(T));
int g(int);
int g(char);
int i = f(g);

// calls f(int (*)(int))

— end example ]
[ Example:

// Ambiguous deduction causes the second function parameter to be a
// non-deduced context.
template <class T> int f(T, T (*p)(T));
int g(int);
char g(char);
int i = f(1, g);

// calls f(int, int (*)(int))

— end example ]
[ Example:

// The overload set contains a template, causing the second function
// parameter to be a non-deduced context.
template <class T> int f(T, T (*p)(T));
char g(char);
template <class T> T g(T);
int i = f(1, g);

// calls f(int, int (*)(int))

— end example ]

14.8.2.2 Deducing template arguments taking the address of a function template

[temp.deduct.funcaddr]

1 Template arguments can be deduced from the type speciﬁed when taking the address of an overloaded
function (13.4). The function template’s function type and the speciﬁed type are used as the types of P and
A, and the deduction is done as described in 14.8.2.5.

2 A placeholder type (7.1.6.4) in the return type of a function template is a non-deduced context. If template
argument deduction succeeds for such a function, the return type is determined from instantiation of the
function body.

§ 14.8.2.2

401

c(cid:13) ISO/IEC

N4296

14.8.2.3 Deducing conversion function template arguments

[temp.deduct.conv]
1 Template argument deduction is done by comparing the return type of the conversion function template (call
it P) with the type that is required as the result of the conversion (call it A; see 8.5, 13.3.1.5, and 13.3.1.6
for the determination of that type) as described in 14.8.2.5.
If P is a reference type, the type referred to by P is used in place of P for type deduction and for any further
references to or transformations of P in the remainder of this section.
If A is not a reference type:

2

3

(3.1)

(3.2)

(3.3)

—

—

—

If P is an array type, the pointer type produced by the array-to-pointer standard conversion (4.2) is
used in place of P for type deduction; otherwise,
If P is a function type, the pointer type produced by the function-to-pointer standard conversion (4.3)
is used in place of P for type deduction; otherwise,
If P is a cv-qualiﬁed type, the top level cv-qualiﬁers of P’s type are ignored for type deduction.

4

5

If A is a cv-qualiﬁed type, the top level cv-qualiﬁers of A’s type are ignored for type deduction. If A is a
reference type, the type referred to by A is used for type deduction.
In general, the deduction process attempts to ﬁnd template argument values that will make the deduced A
identical to A. However, there are two cases that allow a diﬀerence:

(5.1)

(5.2)

—

—

If the original A is a reference type, A can be more cv-qualiﬁed than the deduced A (i.e., the type
referred to by the reference)
The deduced A can be another pointer or pointer to member type that can be converted to A via a
qualiﬁcation conversion.

6 These alternatives are considered only if type deduction would otherwise fail. If they yield more than one

possible deduced A, the type deduction fails.

7 When the deduction process requires a qualiﬁcation conversion for a pointer or pointer to member type as

described above, the following process is used to determine the deduced template argument values:
If A is a type

cv1,0 “pointer to . . .” cv1,n−1 “pointer to” cv1,nT1

and P is a type

cv2,0 “pointer to . . .” cv2,n−1 “pointer to” cv2,nT2

The cv-unqualiﬁed T1 and T2 are used as the types of A and P respectively for type deduction. [ Example:

struct A {

template <class T> operator T***();

};
A a;
const int * const * const * p1 = a;

— end example ]

§ 14.8.2.3

// T is deduced as int, not const int

402

c(cid:13) ISO/IEC

N4296

14.8.2.4 Deducing template arguments during partial ordering

[temp.deduct.partial]
1 Template argument deduction is done by comparing certain types associated with the two function templates

being compared.

2 Two sets of types are used to determine the partial ordering. For each of the templates involved there is
the original function type and the transformed function type. [ Note: The creation of the transformed type
is described in 14.5.6.2. — end note ] The deduction process uses the transformed type as the argument
template and the original type of the other template as the parameter template. This process is done twice
for each type involved in the partial ordering comparison: once using the transformed template-1 as the
argument template and template-2 as the parameter template and again using the transformed template-2
as the argument template and template-1 as the parameter template.

3 The types used to determine the ordering depend on the context in which the partial ordering is done:

(3.1)

(3.2)

(3.3)

—

—

—

In the context of a function call, the types used are those function parameter types for which the
function call has arguments.142
In the context of a call to a conversion function, the return types of the conversion function templates
are used.
In other contexts (14.5.6.2) the function template’s function type is used.

4 Each type nominated above from the parameter template and the corresponding type from the argument

template are used as the types of P and A.

5 Before the partial ordering is done, certain transformations are performed on the types used for partial

ordering:

(5.1)

(5.2)

6

—
—

If P is a reference type, P is replaced by the type referred to.
If A is a reference type, A is replaced by the type referred to.

If both P and A were reference types (before being replaced with the type referred to above), determine
which of the two types (if any) is more cv-qualiﬁed than the other; otherwise the types are considered to be
equally cv-qualiﬁed for partial ordering purposes. The result of this determination will be used below.

7 Remove any top-level cv-qualiﬁers:

(7.1)

(7.2)

8

—
—

If P is a cv-qualiﬁed type, P is replaced by the cv-unqualiﬁed version of P.
If A is a cv-qualiﬁed type, A is replaced by the cv-unqualiﬁed version of A.

If A was transformed from a function parameter pack and P is not a parameter pack, type deduction fails.
Otherwise, using the resulting types P and A, the deduction is then done as described in 14.8.2.5.
If P
is a function parameter pack, the type A of each remaining parameter type of the argument template is
compared with the type P of the declarator-id of the function parameter pack. Each comparison deduces
template arguments for subsequent positions in the template parameter packs expanded by the function
parameter pack. If deduction succeeds for a given type, the type from the argument template is considered
to be at least as specialized as the type from the parameter template. [ Example:

template<class... Args>
template<class T1, class... Args> void f(T1 a1, Args... args);
template<class T1, class T2>

void f(Args... args);

void f(T1 a1, T2 a2);

// #1
// #2
// #3

f();

// calls #1

142) Default arguments are not considered to be arguments in this context; they only become arguments after a function has
been selected.

§ 14.8.2.4

403

c(cid:13) ISO/IEC

f(1, 2, 3);
f(1, 2);

// calls #2
// calls #3; non-variadic template #3 is more
// specialized than the variadic templates #1 and #2

N4296

9

— end example ]
If, for a given type, deduction succeeds in both directions (i.e., the types are identical after the transfor-
mations above) and both P and A were reference types (before being replaced with the type referred to
above):

(9.1)

(9.2)

—

—

if the type from the argument template was an lvalue reference and the type from the parameter
template was not, the parameter type is not considered to be at least as specialized as the argument
type; otherwise,
if the type from the argument template is more cv-qualiﬁed than the type from the parameter template
(as described above), the parameter type is not considered to be at least as specialized as the argument
type.

10 Function template F is at least as specialized as function template G if, for each pair of types used to
determine the ordering, the type from F is at least as specialized as the type from G. F is more specialized
than G if F is at least as specialized as G and G is not at least as specialized as F.
In most cases, all template parameters must have values in order for deduction to succeed, but for partial
ordering purposes a template parameter may remain without a value provided it is not used in the types
being used for partial ordering. [ Note: A template parameter used in a non-deduced context is considered
used. — end note ] [ Example:

11

// #1
template <class T> T f(int);
template <class T, class U> T f(U); // #2
void g() {

}

f<int>(1);

// calls #1

12

— end example ]
[ Note: Partial ordering of function templates containing template parameter packs is independent of the
number of deduced arguments for those template parameter packs. — end note ] [ Example:

template<class ...> struct Tuple { };
// #1
template<class ... Types> void g(Tuple<Types ...>);
// #2
template<class T1, class ... Types> void g(Tuple<T1, Types ...>);
template<class T1, class ... Types> void g(Tuple<T1, Types& ...>); // #3

g(Tuple<>());
g(Tuple<int, float>());
g(Tuple<int, float&>());
g(Tuple<int>());

// calls #1
// calls #2
// calls #3
// calls #3

— end example ]
14.8.2.5 Deducing template arguments from a type

[temp.deduct.type]
1 Template arguments can be deduced in several diﬀerent contexts, but in each case a type that is speciﬁed
in terms of template parameters (call it P) is compared with an actual type (call it A), and an attempt is
made to ﬁnd template argument values (a type for a type parameter, a value for a non-type parameter, or
a template for a template parameter) that will make P, after substitution of the deduced values (call it the
deduced A), compatible with A.

§ 14.8.2.5

404

c(cid:13) ISO/IEC

N4296

2

In some cases, the deduction is done using a single set of types P and A, in other cases, there will be a set
of corresponding types P and A. Type deduction is done independently for each P/A pair, and the deduced
template argument values are then combined. If type deduction cannot be done for any P/A pair, or if for any
pair the deduction leads to more than one possible set of deduced values, or if diﬀerent pairs yield diﬀerent
deduced values, or if any template argument remains neither deduced nor explicitly speciﬁed, template
argument deduction fails.

—
—

3 A given type P can be composed from a number of other types, templates, and non-type values:
A function type includes the types of each of the function parameters and the return type.
A pointer to member type includes the type of the class object pointed to and the type of the member
pointed to.
A type that is a specialization of a class template (e.g., A<int>) includes the types, templates, and
non-type values referenced by the template argument list of the specialization.
An array type includes the array element type and the value of the array bound.

—

(3.3)

—

(3.1)

(3.2)

(3.4)

4

In most cases, the types, templates, and non-type values that are used to compose P participate in template
argument deduction. That is, they may be used to determine the value of a template argument, and the
value so determined must be consistent with the values determined elsewhere. In certain contexts, however,
the value does not participate in type deduction, but instead uses the values of template arguments that
were either deduced elsewhere or explicitly speciﬁed. If a template parameter is used only in non-deduced
contexts and is not explicitly speciﬁed, template argument deduction fails.

5 The non-deduced contexts are:

(5.1)

(5.2)

(5.3)

(5.4)

(5.5)

(5.5.1)

(5.5.2)

(5.5.3)

(5.6)

—
—
—

—

—

—

The nested-name-speciﬁer of a type that was speciﬁed using a qualiﬁed-id.
The expression of a decltype-speciﬁer.
A non-type template argument or an array bound in which a subexpression references a template
parameter.
A template parameter used in the parameter type of a function parameter that has a default argument
that is being used in the call for which argument deduction is being done.
A function parameter for which argument deduction cannot be done because the associated function
argument is a function, or a set of overloaded functions (13.4), and one or more of the following apply:
more than one function matches the function parameter type (resulting in an ambiguous deduc-
—
tion), or
no function matches the function parameter type, or
the set of functions supplied as an argument contains one or more function templates.

—
—
A function parameter for which the associated argument is an initializer list (8.5.4) but the parameter
does not have a type for which deduction from an initializer list is speciﬁed (14.8.2.1). [ Example:

template<class T> void g(T);
g({1,2,3});

// error: no argument deduced for T

— end example ]
A function parameter pack that does not occur at the end of the parameter-declaration-list.

(5.7)

—

§ 14.8.2.5

405

c(cid:13) ISO/IEC

N4296

6 When a type name is speciﬁed in a way that includes a non-deduced context, all of the types that comprise
that type name are also non-deduced. However, a compound type can include both deduced and non-deduced
types. [ Example: If a type is speciﬁed as A<T>::B<T2>, both T and T2 are non-deduced. Likewise, if a type is
speciﬁed as A<I+J>::X<T>, I, J, and T are non-deduced. If a type is speciﬁed as void f(typename A<T>::B,
A<T>), the T in A<T>::B is non-deduced but the T in A<T> is deduced. — end example ]
[ Example: Here is an example in which diﬀerent parameter/argument pairs produce inconsistent template
argument deductions:

7

template<class T> void f(T x, T y) { /∗ ... ∗/ }
struct A { /∗ ... ∗/ };
struct B : A { /∗ ... ∗/ };
void g(A a, B b) {

f(a,b);
f(b,a);
f(a,a);
f(b,b);

// error: T could be A or B
// error: T could be A or B
// OK: T is A
// OK: T is B

}

}

}

Here is an example where two template arguments are deduced from a single function parameter/argument
pair. This can lead to conﬂicts that cause type deduction to fail:
);

template <class T, class U> void f(

T (*)( T, U, U )

int g1( int, float, float);
char g2( int, float, float);
int g3( int, char, float);

void r() {

f(g1);
f(g2);
f(g3);

// OK: T is int and U is float
// error: T could be char or int
// error: U could be char or float

Here is an example where a qualiﬁcation conversion applies between the argument type on the function call
and the deduced template argument type:
template<class T> void f(const T*) { }
int* p;
void s() {

f(p);

// f(const int*)

Here is an example where the template argument is used to instantiate a derived class type of the corre-
sponding function parameter type:

template <class T> struct B { };
template <class T> struct D : public B<T> {};
struct D2 : public B<int> {};
template <class T> void f(B<T>&){}
void t() {
D<int> d;
D2
d2;
f(d);
f(d2);

// calls f(B<int>&)
// calls f(B<int>&)

}

§ 14.8.2.5

406

c(cid:13) ISO/IEC

— end example ]

N4296

8 A template type argument T, a template template argument TT or a template non-type argument i can be

deduced if P and A have one of the following forms:

T
cv-list T
T*
T&
T&&
T[integer-constant ]
template-name <T>
type (T)
T()
T(T)
T type ::*
type T::*
T T::*
T (type ::*)()
type (T::*)()
type (type ::*)(T)
type (T::*)(T)
T (type ::*)(T)
T (T::*)()
T (T::*)(T)
type [i]
template-name <i>
TT<T>
TT<i>
TT<>

(where template-name refers to a class template)

(where template-name refers to a class template)

9

where (T) represents a parameter-type-list where at least one parameter type contains a T, and () represents
a parameter-type-list where no parameter type contains a T. Similarly, <T> represents template argument
lists where at least one argument contains a T, <i> represents template argument lists where at least one
argument contains an i and <> represents template argument lists where no argument contains a T or an i.
If P has a form that contains <T> or <i>, then each argument Pi of the respective template argument list
P is compared with the corresponding argument Ai of the corresponding template argument list of A. If
the template argument list of P contains a pack expansion that is not the last template argument, the
entire template argument list is a non-deduced context. If Pi is a pack expansion, then the pattern of Pi
is compared with each remaining argument in the template argument list of A. Each comparison deduces
template arguments for subsequent positions in the template parameter packs expanded by Pi. During
partial ordering (14.8.2.4), if Ai was originally a pack expansion:

(9.1)

(9.2)

—
—

if P does not contain a template argument corresponding to Ai then Ai is ignored;
otherwise, if Pi is not a pack expansion, template argument deduction fails.

[ Example:

template<class T1, class... Z> class S;
template<class T1, class... Z> class S<T1, const Z&...> { };
template<class T1, class T2>
S<int, const int&> s;

class S<T1, const T2&> { };
// both #2 and #3 match; #3 is more specialized

// #1
// #2
// #3

// #1
template<class T, class... U>
template<class T1, class T2, class... U> struct A<T1, T2*, U...> { }; // #2

struct A { };

§ 14.8.2.5

407

c(cid:13) ISO/IEC

N4296

template<class T1, class T2>
template struct A<int, int*>; // selects #2

struct A<T1, T2> { };

// #3

— end example ]

10 Similarly, if P has a form that contains (T), then each parameter type Pi of the respective parameter-type-
list of P is compared with the corresponding parameter type Ai of the corresponding parameter-type-list
of A. If P and A are function types that originated from deduction when taking the address of a function
template (14.8.2.2) or when deducing template arguments from a function declaration (14.8.2.6) and Pi
and Ai are parameters of the top-level parameter-type-list of P and A, respectively, Pi is adjusted if it is a
forwarding reference (14.8.2.1) and Ai is an lvalue reference, in which case the type of Pi is changed to be
the template parameter type (i.e., T&& is changed to simply T). [ Note: As a result, when Pi is T&& and Ai is
X&, the adjusted Pi will be T, causing T to be deduced as X&. — end note ] [ Example:

template <class T> void f(T&&);
template <> void f(int&) { } // #1
template <> void f(int&&) { } // #2
void g(int i) {

// calls f<int&>(int&), i.e., #1
// calls f<int>(int&&), i.e., #2

f(i);
f(0);

}

— end example ]
If the parameter-declaration corresponding to Pi is a function parameter pack, then the type of its declarator-
id is compared with each remaining parameter type in the parameter-type-list of A. Each comparison deduces
template arguments for subsequent positions in the template parameter packs expanded by the function
parameter pack. During partial ordering (14.8.2.4), if Ai was originally a function parameter pack:

(10.1)

(10.2)

—
—

if P does not contain a function parameter type corresponding to Ai then Ai is ignored;
otherwise, if Pi is not a function parameter pack, template argument deduction fails.

[ Example:

template<class T, class... U> void f(T*, U...) { }
template<class T>
template void f(int*);

void f(T) { }

// selects #1

// #1
// #2

— end example ]

11 These forms can be used in the same way as T is for further composition of types. [ Example:

X<int> (*)(char[6])

is of the form

template-name <T> (*)(type [i])

which is a variant of

type (*)(T)

where type is X<int> and T is char[6]. — end example ]

12 Template arguments cannot be deduced from function arguments involving constructs other than the ones

speciﬁed above.

13 A template type argument cannot be deduced from the type of a non-type template-argument.
14

[ Example:

§ 14.8.2.5

408

c(cid:13) ISO/IEC

N4296

template<class T, T i> void f(double a[10][i]);
int v[10][20];
f(v);

// error: argument for template-parameter T cannot be deduced

15

— end example ]
[ Note: Except for reference and pointer types, a major array bound is not part of a function parameter type
and cannot be deduced from an argument:
template<int i> void f1(int a[10][i]);
template<int i> void f2(int a[i][20]);
template<int i> void f3(int (&a)[i][20]);

void g() {

int v[10][20];
f1(v);
f1<20>(v);
f2(v);
f2<10>(v);
f3(v);

// OK: i deduced to be 20
// OK
// error: cannot deduce template-argument i
// OK
// OK: i deduced to be 10

16

If, in the declaration of a function template with a non-type template parameter, the non-type template
parameter is used in a subexpression in the function parameter list, the expression is a non-deduced context
as speciﬁed above. [ Example:

}

}

template <int i> class A { /∗ ... ∗/ };
template <int i> void g(A<i+1>);
template <int i> void f(A<i>, A<i+1>);
void k() {
A<1> a1;
A<2> a2;
g(a1);
g<0>(a1);
f(a1, a2);

// error: deduction fails for expression i+1
// OK
// OK

— end example ] — end note ] [ Note: Template parameters do not participate in template argument deduc-
tion if they are used only in non-deduced contexts. For example,

template<int i, typename T>
T deduce(typename A<T>::X x,

T t,
typename B<i>::Y y);

A<int> a;
B<77>
b;

// T is not deduced here
// but T is deduced here
// i is not deduced here

x = deduce<77>(a.xm, 62, b.ym);

int
// T is deduced to be int, a.xm must be convertible to
// A<int>::X
// i is explicitly speciﬁed to be 77, b.ym must be convertible
// to B<77>::Y

17

— end note ]
If P has a form that contains <i>, and if the type of the corresponding value of A diﬀers from the type of
i, deduction fails. If P has a form that contains [i], and if the type of i is not an integral type, deduction

§ 14.8.2.5

409

c(cid:13) ISO/IEC

fails.143 [ Example:

N4296

template<int i> class A { /∗ ... ∗/ };
template<short s> void f(A<s>);
void k1() {

// error: deduction fails for conversion from int to short
// OK

A<1> a;
f(a);
f<1>(a);

B<1> b;
g(b);

template<const short cs> class B { };
template<short s> void g(B<s>);
void k2() {

// OK: cv-qualiﬁers are ignored on template parameter types

— end example ]

18 A template-argument can be deduced from a function, pointer to function, or pointer to member function

type.
[ Example:

template<class T> void f(void(*)(T,int));
template<class T> void foo(T,int);
void g(int,int);
void g(char,int);

void h(int,int,int);
void h(char,int);
int m() {
f(&g);
f(&h);
f(&foo);

// error: ambiguous
// OK: void h(char,int) is a unique match
// error: type deduction fails because foo is a template

}

}

}

}

— end example ]

19 A template type-parameter cannot be deduced from the type of a function default argument. [ Example:

template <class T> void f(T = 5, T = 7);
void g() {

f(1);
f();
f<int>();

// OK: call f<int>(1,7)
// error: cannot deduce T
// OK: call f<int>(5,7)

— end example ]

20 The template-argument corresponding to a template template-parameter is deduced from the type of the
template-argument of a class template specialization used in the argument list of a function call. [ Example:

template <template <class T> class X> struct A { };
template <template <class T> class X> void f(A<X>) { }
template<class T> struct B { };

143) Although the template-argument corresponding to a template-parameter of type bool may be deduced from an array
bound, the resulting value will always be true because the array bound will be non-zero.

§ 14.8.2.5

410

c(cid:13) ISO/IEC

A<B> ab;
f(ab);

// calls f(A<B>)

N4296

21

— end example ]
[ Note: Template argument deduction involving parameter packs (14.5.3) can deduce zero or more arguments
for each parameter pack. — end note ] [ Example:

template<class> struct X { };
template<class R, class ... ArgTypes> struct X<R(int, ArgTypes ...)> { };
template<class ... Types> struct Y { };
template<class T, class ... Types> struct Y<T, Types& ...> { };

template<class ... Types> int f(void (*)(Types ...));
void g(int, float);

// uses primary template

X<int> x1;
X<int(int, float, double)> x2; // uses partial specialization; ArgTypes contains float, double
X<int(float, int)> x3;
Y<> y1;
Y<int&, float&, double&> y2;
Y<int, float, double> y3;
int fv = f(g);

// uses primary template
// use primary template; Types is empty
// uses partial specialization; T is int&, Types contains float, double
// uses primary template; Types contains int, float, double
// OK; Types contains int, float

1

2

— end example ]
14.8.2.6 Deducing template arguments from a function declaration
[temp.deduct.decl]
In a declaration whose declarator-id refers to a specialization of a function template, template argument
deduction is performed to identify the specialization to which the declaration refers. Speciﬁcally, this is done
for explicit instantiations (14.7.2), explicit specializations (14.7.3), and certain friend declarations (14.5.4).
This is also done to determine whether a deallocation function template specialization matches a placement
operator new (3.7.4.2, 5.3.4). In all these cases, P is the type of the function template being considered
as a potential match and A is either the function type from the declaration or the type of the deallocation
function that would match the placement operator new as described in 5.3.4. The deduction is done as
described in 14.8.2.5.
If, for the set of function templates so considered, there is either no match or more than one match after
partial ordering has been considered (14.5.6.2), deduction fails and, in the declaration cases, the program is
ill-formed.
14.8.3 Overload resolution

[temp.over]
1 A function template can be overloaded either by (non-template) functions of its name or by (other) function
templates of the same name. When a call to that name is written (explicitly, or implicitly using the operator
notation), template argument deduction (14.8.2) and checking of any explicit template arguments (14.3) are
performed for each function template to ﬁnd the template argument values (if any) that can be used with
that function template to instantiate a function template specialization that can be invoked with the call
arguments. For each function template, if the argument deduction and checking succeeds, the template-
arguments (deduced and/or explicit) are used to synthesize the declaration of a single function template
specialization which is added to the candidate functions set to be used in overload resolution. If, for a given
function template, argument deduction fails, no such function is added to the set of candidate functions for
that template. The complete set of candidate functions includes all the synthesized declarations and all of
the non-template overloaded functions of the same name. The synthesized declarations are treated like any

§ 14.8.3

411

c(cid:13) ISO/IEC

N4296

other functions in the remainder of overload resolution, except as explicitly noted in 13.3.3.144
[ Example:

template<class T> T max(T a, T b) { return a>b?a:b; }

void f(int a, int b, char c, char d) {

int m1 = max(a,b);
char m2 = max(c,d);
int m3 = max(a,c);

}

// max(int a, int b)
// max(char a, char b)
// error: cannot generate max(int,char)

2 Adding the non-template function

int max(int,int);

to the example above would resolve the third call, by providing a function that could be called for max(a,c)
after using the standard conversion of char to int for c.

3 Here is an example involving conversions on a function argument involved in template-argument deduction:

template<class T> struct B { /∗ ... ∗/ };
template<class T> struct D : public B<T> { /∗ ... ∗/ };
template<class T> void f(B<T>&);

void g(B<int>& bi, D<int>& di) {

// f(bi)
// f((B<int>&)di)

f(bi);
f(di);

}

4 Here is an example involving conversions on a function argument not involved in template-parameter deduc-

tion:

template<class T> void f(T*,int);
template<class T> void f(T,char);

// #1
// #2

void h(int* pi, int i, char c) {

f(pi,i);
f(pi,c);

// #1: f<int>(pi,i)
// #2: f<int*>(pi,c)

f(i,c);
f(i,i);

}

— end example ]

// #2: f<int>(i,c);
// #2: f<int>(i,char(i))

5 Only the signature of a function template specialization is needed to enter the specialization in a set of
candidate functions. Therefore only the function template declaration is needed to resolve a call for which
a template specialization is a candidate. [ Example:

template<class T> void f(T);

// declaration

void g() {

f("Annemarie");

}

// call of f<const char*>

144) The parameters of function template specializations contain no template parameter types. The set of conversions allowed
on deduced arguments is limited, because the argument deduction process produces function templates with parameters that
either match the call arguments exactly or diﬀer only in ways that can be bridged by the allowed limited conversions. Non-
deduced arguments allow the full range of conversions. Note also that 13.3.3 speciﬁes that a non-template function will be given
preference over a template specialization if the two functions are otherwise equally good candidates for an overload match.

§ 14.8.3

412

c(cid:13) ISO/IEC

N4296

6 The call of f is well-formed even if the template f is only declared and not deﬁned at the point of the call.
The program will be ill-formed unless a specialization for f<const char*>, either implicitly or explicitly
generated, is present in some translation unit. — end example ]

§ 14.8.3

413

c(cid:13) ISO/IEC

N4296

15 Exception handling

[except]

1 Exception handling provides a way of transferring control and information from a point in the execution of
a thread to an exception handler associated with a point previously passed by the execution. A handler will
be invoked only by throwing an exception in code executed in the handler’s try block or in functions called
from the handler’s try block.

try-block:

try compound-statement handler-seq

function-try-block:

try ctor-initializeropt compound-statement handler-seq

handler-seq:

handler handler-seqopt

handler:

catch ( exception-declaration ) compound-statement

exception-declaration:

attribute-speciﬁer-seqopt type-speciﬁer-seq declarator
attribute-speciﬁer-seqopt type-speciﬁer-seq abstract-declaratoropt
...

The optional attribute-speciﬁer-seq in an exception-declaration appertains to the parameter of the catch
clause (15.3).

2 A try-block is a statement (Clause 6). [ Note: Within this Clause “try block” is taken to mean both try-block

and function-try-block. — end note ]

3 A goto or switch statement shall not be used to transfer control into a try block or into a handler.

[ Example:

void f() {
goto l1;
goto l2;
try {

} catch (...) {

goto l1;
goto l2;
l1: ;

l2: ;
goto l1;
goto l2;

}

}

// Ill-formed
// Ill-formed

// OK
// Ill-formed

// Ill-formed
// OK

— end example ] A goto, break, return, or continue statement can be used to transfer control out of a
try block or handler. When this happens, each variable declared in the try block will be destroyed in the
context that directly contains its declaration. [ Example:

lab:

try {

T1 t1;
try {

T2 t2;
if (condition )

goto lab;

Exception handling

414

c(cid:13) ISO/IEC

} catch(...) { /∗ handler 2 ∗/ }

} catch(...) { /∗ handler 1 ∗/ }

N4296

Here, executing goto lab; will destroy ﬁrst t2, then t1, assuming the condition does not declare a variable.
Any exception raised while destroying t2 will result in executing handler 2; any exception raised while
destroying t1 will result in executing handler 1. — end example ]

4 A function-try-block associates a handler-seq with the ctor-initializer, if present, and the compound-statement.
An exception thrown during the execution of the compound-statement or, for constructors and destructors,
during the initialization or destruction, respectively, of the class’s subobjects, transfers control to a handler
in a function-try-block in the same way as an exception thrown during the execution of a try-block transfers
control to other handlers. [ Example:

int f(int);
class C {
int i;
double d;

public:

C(int, double);

C::C(int ii, double id)
try : i(f(ii)), d(id) {

// constructor statements

}
catch (...) {

};

}

}

and

};

§ 15.1

415

// handles exceptions thrown from the ctor-initializer
// and from the constructor statements

— end example ]
15.1 Throwing an exception

1 Throwing an exception transfers control to a handler.

[except.throw]
[ Note: An exception can be thrown from one
of the following contexts:
throw-expressions (5.17), allocation functions (3.7.4.1), dynamic_cast (5.2.7),
typeid (5.2.8), new-expressions (5.3.4), and standard library functions (17.5.1.4). — end note ] An object
is passed and the type of that object determines which handlers can catch it. [ Example:

throw "Help!";

can be caught by a handler of const char* type:

try {

// ...

}
catch(const char* p) {

// handle character string exceptions here

class Overflow {
public:

Overflow(char,double,double);

c(cid:13) ISO/IEC

N4296

void f(double x) {

throw Overflow(’+’,x,3.45e107);

}

}

can be caught by a handler for exceptions of type Overflow

try {

f(1.2);

} catch(Overflow& oo) {

// handle exceptions of type Overflow here

— end example ]

2 When an exception is thrown, control is transferred to the nearest handler with a matching type (15.3);
“nearest” means the handler for which the compound-statement or ctor-initializer following the try keyword
was most recently entered by the thread of control and not yet exited.

3 Throwing an exception copy-initializes (8.5, 12.8) a temporary object, called the exception object. The
temporary is an lvalue and is used to initialize the variable declared in the matching handler (15.3). If the
type of the exception object would be an incomplete type or a pointer to an incomplete type other than
(possibly cv-qualiﬁed) void the program is ill-formed.

4 The memory for the exception object is allocated in an unspeciﬁed way, except as noted in 3.7.4.1. If a
handler exits by rethrowing, control is passed to another handler for the same exception. The exception
object is destroyed after either the last remaining active handler for the exception exits by any means other
than rethrowing, or the last object of type std::exception_ptr (18.8.5) that refers to the exception object is
destroyed, whichever is later. In the former case, the destruction occurs when the handler exits, immediately
after the destruction of the object declared in the exception-declaration in the handler, if any. In the latter
case, the destruction occurs before the destructor of std::exception_ptr returns. The implementation
may then deallocate the memory for the exception object; any such deallocation is done in an unspeciﬁed
way.
[ Note: a thrown exception does not propagate to other threads unless caught, stored, and rethrown
using appropriate library functions; see 18.8.5 and 30.6. — end note ]

5 When the thrown object is a class object, the constructor selected for the copy-initialization and the de-

structor shall be accessible, even if the copy/move operation is elided (12.8).

6 An exception is considered caught when a handler for that exception becomes active (15.3).

[ Note: An

exception can have active handlers and still be considered uncaught if it is rethrown. — end note ]
If the exception handling mechanism, after completing the initialization of the exception object but before
the activation of a handler for the exception, calls a function that exits via an exception, std::terminate
is called (15.5.1). [ Example:

7

struct C {
C() { }
C(const C&) {

}

}
};

if (std::uncaught_exceptions()) {

throw 0;

// throw during copy to handler’s exception-declaration object (15.3)

int main() {

try {

throw C();

} catch(C) { }

§ 15.1

// calls std::terminate() if construction of the handler’s
// exception-declaration object is not elided (12.8)

416

c(cid:13) ISO/IEC

}

N4296

— end example ]
15.2 Constructors and destructors

[except.ctor]
1 As control passes from the point where an exception is thrown to a handler, destructors are invoked by a
process, speciﬁed in this section, called stack unwinding. If a destructor directly invoked by stack unwind-
ing exits with an exception, std::terminate is called (15.5.1).
[ Note: Consequently, destructors should
generally catch exceptions and not let them propagate out of the destructor. — end note ]

2 The destructor is invoked for each automatic object of class type constructed since the try block was entered.

The automatic objects are destroyed in the reverse order of the completion of their construction.

3 For an object of class type of any storage duration whose initialization or destruction is terminated by an
exception, the destructor is invoked for each of the object’s fully constructed subobjects, that is, for each
subobject for which the principal constructor (12.6.2) has completed execution and the destructor has not
yet begun execution, except that in the case of destruction, the variant members of a union-like class are not
destroyed. The subobjects are destroyed in the reverse order of the completion of their construction. Such
destruction is sequenced before entering a handler of the function-try-block of the constructor or destructor,
if any.

5

4 Similarly, if the non-delegating constructor for an object has completed execution and a delegating construc-
tor for that object exits with an exception, the object’s destructor is invoked. Such destruction is sequenced
before entering a handler of the function-try-block of a delegating constructor for that object, if any.
[ Note: If the object was allocated by a new-expression (5.3.4), the matching deallocation function (3.7.4.2,
5.3.4, 12.5), if any, is called to free the storage occupied by the object. — end note ]
15.3 Handling an exception

[except.handle]
1 The exception-declaration in a handler describes the type(s) of exceptions that can cause that handler to
be entered. The exception-declaration shall not denote an incomplete type, an abstract class type, or an
rvalue reference type. The exception-declaration shall not denote a pointer or reference to an incomplete
type, other than void*, const void*, volatile void*, or const volatile void*.

2 A handler of type “array of T” or “function returning T” is adjusted to be of type “pointer to T” or “pointer

to function returning T”, respectively.

3 A handler is a match for an exception object of type E if

(3.1)

(3.2)

(3.3)

(3.3.1)

(3.3.2)

(3.4)

—

—
—

—

The handler is of type cv T or cv T& and E and T are the same type (ignoring the top-level cv-qualiﬁers),
or
the handler is of type cv T or cv T& and T is an unambiguous public base class of E, or
the handler is of type cv T or const T& where T is a pointer type and E is a pointer type that can be
converted to T by either or both of
—

a standard pointer conversion (4.10) not involving conversions to pointers to private or protected
or ambiguous classes
a qualiﬁcation conversion, or

—
the handler is of type cv T or const T& where T is a pointer or pointer to member type and E is
std::nullptr_t.

[ Note: A throw-expression whose operand is an integer literal with value zero does not match a handler of
pointer or pointer to member type. — end note ]

§ 15.3

417

c(cid:13) ISO/IEC

[ Example:

class Matherr { /∗ ... ∗/ virtual void vf(); };
class Overflow: public Matherr { /∗ ... ∗/ };
class Underflow: public Matherr { /∗ ... ∗/ };
class Zerodivide: public Matherr { /∗ ... ∗/ };

N4296

void f() {

try {
g();

// ...

// ...

} catch (Overflow oo) {

} catch (Matherr mm) {

}

}

Here, the Overflow handler will catch exceptions of type Overflow and the Matherr handler will catch
exceptions of type Matherr and of all types publicly derived from Matherr including exceptions of type
Underflow and Zerodivide. — end example ]

4 The handlers for a try block are tried in order of appearance. That makes it possible to write handlers that
can never be executed, for example by placing a handler for a derived class after a handler for a corresponding
base class.

5 A ... in a handler’s exception-declaration functions similarly to ... in a function parameter declaration;
it speciﬁes a match for any exception. If present, a ... handler shall be the last handler for its try block.
If no match is found among the handlers for a try block, the search for a matching handler continues in a
dynamically surrounding try block of the same thread.

6

7 A handler is considered active when initialization is complete for the parameter (if any) of the catch clause.
[ Note: The stack will have been unwound at that point. — end note ] Also, an implicit handler is considered
active when std::terminate() or std::unexpected() is entered due to a throw. A handler is no longer
considered active when the catch clause exits or when std::unexpected() exits after being entered due to
a throw.

8 The exception with the most recently activated handler that is still active is called the currently handled

exception.
If no matching handler is found, the function std::terminate() is called; whether or not the stack is
unwound before this call to std::terminate() is implementation-deﬁned (15.5.1).

9

10 Referring to any non-static member or base class of an object in the handler for a function-try-block of a

constructor or destructor for that object results in undeﬁned behavior.

11 The scope and lifetime of the parameters of a function or constructor extend into the handlers of a function-

try-block.

12 Exceptions thrown in destructors of objects with static storage duration or in constructors of namespace-
scope objects with static storage duration are not caught by a function-try-block on main(). Exceptions
thrown in destructors of objects with thread storage duration or in constructors of namespace-scope objects
with thread storage duration are not caught by a function-try-block on the initial function of the thread.
If a return statement appears in a handler of the function-try-block of a constructor, the program is ill-formed.
13
14 The currently handled exception is rethrown if control reaches the end of a handler of the function-try-block
of a constructor or destructor. Otherwise, a function returns when control reaches the end of a handler for
the function-try-block (6.6.3). Flowing oﬀ the end of a function-try-block is equivalent to a return with no
value; this results in undeﬁned behavior in a value-returning function (6.6.3).

§ 15.3

418

c(cid:13) ISO/IEC

N4296

15 The variable declared by the exception-declaration, of type cv T or cv T&, is initialized from the exception

object, of type E, as follows:

(15.1)

(15.2)

—

—

if T is a base class of E, the variable is copy-initialized (8.5) from the corresponding base class subobject
of the exception object;
otherwise, the variable is copy-initialized (8.5) from the exception object.

The lifetime of the variable ends when the handler exits, after the destruction of any automatic objects
initialized within the handler.

16 When the handler declares an object, any changes to that object will not aﬀect the exception object. When
the handler declares a reference to an object, any changes to the referenced object are changes to the
exception object and will have eﬀect should that object be rethrown.
15.4 Exception speciﬁcations

[except.spec]
1 The exception speciﬁcation of a function is a (possibly empty) set of types, indicating that the function
might exit via an exception that matches a handler of one of the types in the set; the (conceptual) set of all
types is used to denote that the function might exit via an exception of arbitrary type. If the set is empty,
the function is said to have a non-throwing exception speciﬁcation. The exception speciﬁcation is either
deﬁned explicitly by using an exception-speciﬁcation as a suﬃx of a function declaration’s declarator (8.3.5)
or implicitly.

exception-speciﬁcation:

dynamic-exception-speciﬁcation
noexcept-speciﬁcation

dynamic-exception-speciﬁcation:

throw ( type-id-listopt)

type-id-list:

type-id ...opt
type-id-list , type-id ...opt

noexcept-speciﬁcation:

noexcept ( constant-expression )
noexcept

In a noexcept-speciﬁcation, the constant-expression, if supplied, shall be a constant expression (5.20) that
is contextually converted to bool (Clause 4). A ( token that follows noexcept is part of the noexcept-
speciﬁcation and does not commence an initializer (8.5).

2 An exception-speciﬁcation shall appear only on a function declarator for a function type, pointer to function
type, reference to function type, or pointer to member function type that is the top-level type of a declaration
or deﬁnition, or on such a type appearing as a parameter or return type in a function declarator. An
exception-speciﬁcation shall not appear in a typedef declaration or alias-declaration. [ Example:

void f() throw(int);
void (*fp)() throw (int);
void g(void pfa() throw(int));
typedef int (*pf)() throw(int);

// OK
// OK
// OK
// ill-formed

— end example ]
A type denoted in a dynamic-exception-speciﬁcation shall not denote an incomplete type or an rvalue ref-
erence type. A type denoted in a dynamic-exception-speciﬁcation shall not denote a pointer or reference to
an incomplete type, other than “pointer to cv void”. A type cv T, “array of T”, or “function returning T”
denoted in a dynamic-exception-speciﬁcation is adjusted to type T, “pointer to T”, or “pointer to function
returning T”, respectively. A dynamic-exception-speciﬁcation denotes an exception speciﬁcation that is the
set of adjusted types speciﬁed thereby.

§ 15.4

419

c(cid:13) ISO/IEC

N4296

3 The exception-speciﬁcation noexcept or noexcept(constant-expression), where the constant-expression yields
true, denotes an exception speciﬁcation that is the empty set. The exception-speciﬁcation noexcept(constant-
expression), where the constant-expression yields false, or the absence of an exception-speciﬁcation in a
function declarator other than that for a destructor (12.4) or a deallocation function (3.7.4.2) denotes an
exception speciﬁcation that is the set of all types.

4 Two exception-speciﬁcations are compatible if the sets of types they denote are the same.
5

If any declaration of a function has an exception-speciﬁcation that is not a noexcept-speciﬁcation allowing
all exceptions, all declarations, including the deﬁnition and any explicit specialization, of that function shall
have a compatible exception-speciﬁcation. If any declaration of a pointer to function, reference to function,
or pointer to member function has an exception-speciﬁcation, all occurrences of that declaration shall have
a compatible exception-speciﬁcation. If a declaration of a function has an implicit exception speciﬁcation,
other declarations of the function shall not specify an exception-speciﬁcation. In an explicit instantiation an
exception-speciﬁcation may be speciﬁed, but is not required. If an exception-speciﬁcation is speciﬁed in an
explicit instantiation directive, it shall be compatible with the exception-speciﬁcations of other declarations
of that function. A diagnostic is required only if the exception-speciﬁcations are not compatible within a
single translation unit.
If a virtual function has an exception speciﬁcation, all declarations, including the deﬁnition, of any function
that overrides that virtual function in any derived class shall only allow exceptions that are allowed by the
exception speciﬁcation of the base class virtual function, unless the overriding function is deﬁned as deleted.
[ Example:

6

struct B {

virtual void f() throw (int, double);
virtual void g();

};

};

struct D: B {

void f();
void g() throw (int);

// ill-formed
// OK

The declaration of D::f is ill-formed because it allows all exceptions, whereas B::f allows only int and
double. — end example ] A similar restriction applies to assignment to and initialization of pointers to
functions, pointers to member functions, and references to functions: the target entity shall allow at least
the exceptions allowed by the source value in the assignment or initialization. [ Example:

class A { /∗ ... ∗/ };
void (*pf1)();
void (*pf2)() throw(A);

// no exception speciﬁcation

void f() {

pf1 = pf2;
pf2 = pf1;

}

// OK: pf1 is less restrictive
// error: pf2 is more restrictive

7

— end example ]
In such an assignment or initialization, exception-speciﬁcations on return types and parameter types shall
be compatible. In other assignments or initializations, exception-speciﬁcations shall be compatible.

8 An exception-speciﬁcation can include the same type more than once and can include classes that are related
[ Note: An exception-speciﬁcation can also include the

by inheritance, even though doing so is redundant.
class std::bad_exception (18.8.2). — end note ]

§ 15.4

420

c(cid:13) ISO/IEC

N4296

9 A function is said to allow an exception of type E if its exception speciﬁcation contains a type T for which
a handler of type T would be a match (15.3) for an exception of type E. A function is said to allow all
exceptions if its exception speciﬁcation is the set of all types.

10 Whenever an exception of type E is thrown and the search for a handler (15.3) encounters the outermost

block of a function with an exception speciﬁcation that does not allow E, then,

(10.1)

(10.2)

—

—

if the function deﬁnition has a dynamic-exception-speciﬁcation, the function std::unexpected() is
called (15.5.2),
otherwise, the function std::terminate() is called (15.5.1).

[ Example:

class X { };
class Y { };
class Z: public X { };
class W { };

void f() throw (X, Y) {

int n = 0;
if (n) throw X();
if (n) throw Z();
throw W();

}

// OK
// also OK
// will call std::unexpected()

— end example ]
[ Note: A function can have multiple declarations with diﬀerent non-throwing exception-speciﬁcations; for
this purpose, the one on the function deﬁnition is used. — end note ]

11 An implementation shall not reject an expression merely because when executed it throws or might throw

an exception that the containing function does not allow. [ Example:

extern void f() throw(X, Y);

void g() throw(X) {

f();

}

// OK

the call to f is well-formed even though when called, f might throw exception Y that g does not allow.
— end example ]
[ Note: An exception speciﬁcation is not considered part of a function’s type; see 8.3.5. — end note ]

12
13 A potential exception of a given context is either a type that might be thrown as an exception or a pseudo-
type, denoted by “any”, that represents the situation where an exception of an arbitrary type might be
thrown. A subexpression e1 of an expression e is an immediate subexpression if there is no subexpression
e2 of e such that e1 is a subexpression of e2.

14 The set of potential exceptions of a function, function pointer, or member function pointer f is deﬁned as

follows:

(14.1)

(14.2)

—
—

If the exception speciﬁcation of f is the set of all types, the set consists of the pseudo-type “any”.
Otherwise, the set consists of every type in the exception speciﬁcation of f.

15 The set of potential exceptions of an expression e is empty if e is a core constant expression (5.20). Otherwise,
it is the union of the sets of potential exceptions of the immediate subexpressions of e, including default
argument expressions used in a function call, combined with a set S deﬁned by the form of e, as follows:

§ 15.4

421

c(cid:13) ISO/IEC

N4296

(15.1)

(15.1.1)

(15.1.2)

(15.2)

(15.3)

(15.4)

(15.5)

(15.6)

—

—

—

—

—

—

If e is a function call (5.2.2):
—

If its postﬁx-expression is a (possibly parenthesized) id-expression (5.1.1), class member access
(5.2.5), or pointer-to-member operation (5.5) whose cast-expression is an id-expression, S is the
set of potential exceptions of the entity selected by the contained id-expression (after overload
resolution, if applicable).
Otherwise, S contains the pseudo-type “any”.

—
If e implicitly invokes a function (such as an overloaded operator, an allocation function in a new-
expression, or a destructor if e is a full-expression (1.9)), S is the set of potential exceptions of the
function.
if e is a throw-expression (5.17), S consists of the type of the exception object that would be initialized
by the operand, if present, or the pseudo-type “any” otherwise.
if e is a dynamic_cast expression that casts to a reference type and requires a run-time check (5.2.7),
S consists of the type std::bad_cast.
if e is a typeid expression applied to a glvalue expression whose type is a polymorphic class type
(5.2.8), S consists of the type std::bad_typeid.
if e is a new-expression with a non-constant expression in the noptr-new-declarator (5.3.4), S consists
of the type std::bad_array_new_length.

[ Example: Given the following declarations

void f() throw(int);
void g();
struct A { A(); };
struct B { B() noexcept; };
struct D() { D() throw (double); };

the set of potential exceptions for some sample expressions is:

(15.7)

(15.8)

(15.9)

(15.10)

(15.11)

—
—
—
—
—

for f(), the set consists of int;
for g(), the set consists of “any”;
for new A, the set consists of “any”;
for B(), the set is empty;
for new D, the set consists of “any” and double.

— end example ]

16 Given a member function f of some class X, where f is an inheriting constructor (12.9) or an implicitly-
declared special member function, the set of potential exceptions of the implicitly-declared member function
f consists of all the members from the following sets:

(16.1)

—

(16.1.1)

(16.1.1.1)
(16.1.1.2)
(16.1.1.3)

if f is a constructor,
—

the sets of potential exceptions of the constructor invocations
—
—
—

for X’s non-variant non-static data members,
for X’s direct base classes, and
if X is non-abstract (10.4), for X’s virtual base classes,

§ 15.4

422

c(cid:13) ISO/IEC

N4296

(including default argument expressions used in such invocations) as selected by overload resolu-
tion for the implicit deﬁnition of f (12.1). [ Note: Even though destructors for fully-constructed
subobjects are invoked when an exception is thrown during the execution of a constructor (15.2),
their exception speciﬁcations do not contribute to the exception speciﬁcation of the constructor,
because an exception thrown from such a destructor could never escape the constructor (15.1,
15.5.1). — end note ]
the sets of potential exceptions of the initialization of non-static data members from brace-or-
equal-initializers that are not ignored (12.6.2);

(16.1.2)

—

(16.2)

—

(16.3)

—

if f is an assignment operator, the sets of potential exceptions of the assignment operator invocations
for X’s non-variant non-static data members and for X’s direct base classes (including default argument
expressions used in such invocations), as selected by overload resolution for the implicit deﬁnition of
f (12.8);
if f is a destructor, the sets of potential exceptions of the destructor invocations for X’s non-variant
non-static data members and for X’s virtual and direct base classes.

17 An inheriting constructor (12.9) and an implicitly-declared special member function (Clause 12) are consid-
ered to have an implicit exception speciﬁcation, as follows, where S is the set of potential exceptions of the
implicitly-declared member function:

(17.1)

(17.2)

—
—

if S contains the pseudo-type “any”, the implicit exception speciﬁcation is the set of all types;
otherwise, the implicit exception speciﬁcation contains all the types in S.

[ Note: An instantiation of an inheriting constructor template has an implied exception speciﬁcation as if it
were a non-template inheriting constructor. — end note ] [ Example:

struct A {

A(int = (A(5), 0)) noexcept;
A(const A&) throw();
A(A&&) throw();
~A() throw(X);

};
struct B {

B() throw();
B(const B&) = default; // exception speciﬁcation contains no types
B(B&&, int = (throw Y(), 0)) noexcept;
~B() throw(Y);

};
int n = 7;
struct D : public A, public B {

int * p = new (std::nothrow) int[n];
// exception speciﬁcation of D::D() contains X and std::bad_array_new_length
// exception speciﬁcation of D::D(const D&) contains no types
// exception speciﬁcation of D::D(D&&) contains Y
// exception speciﬁcation of D::~D() contains X and Y

};

Furthermore, if A::~A() or B::~B() were virtual, D::~D() would not be as restrictive as that of A::~A,
and the program would be ill-formed since a function that overrides a virtual function from a base class shall
have an exception-speciﬁcation at least as restrictive as that in the base class. — end example ]

18 A deallocation function (3.7.4.2) with no explicit exception-speciﬁcation has an exception speciﬁcation that

is the empty set.

19 An exception-speciﬁcation is considered to be needed when:

§ 15.4

423

c(cid:13) ISO/IEC

N4296

—

—

—

—
—

in an expression, the function is the unique lookup result or the selected member of a set of overloaded
functions (3.4, 13.3, 13.4);
the function is odr-used (3.2) or, if it appears in an unevaluated operand, would be odr-used if the
expression were potentially-evaluated;
the exception-speciﬁcation is compared to that of another declaration (e.g., an explicit specialization
or an overriding virtual function);
the function is deﬁned; or
the exception-speciﬁcation is needed for a defaulted special member function that calls the function.
[ Note: A defaulted declaration does not require the exception-speciﬁcation of a base member function
to be evaluated until the implicit exception-speciﬁcation of the derived function is needed, but an
explicit exception-speciﬁcation needs the implicit exception-speciﬁcation to compare against. — end
note ]

(19.1)

(19.2)

(19.3)

(19.4)

(19.5)

20

21

1

The exception-speciﬁcation of a defaulted special member function is evaluated as described above only when
needed; similarly, the exception-speciﬁcation of a specialization of a function template or member function
of a class template is instantiated only when needed.
In a dynamic-exception-speciﬁcation, a type-id followed by an ellipsis is a pack expansion (14.5.3).
[ Note: The use of dynamic-exception-speciﬁcations is deprecated (see Annex D). — end note ]
15.5 Special functions

[except.special]
1 The functions std::terminate() (15.5.1) and std::unexpected() (15.5.2) are used by the exception han-
dling mechanism for coping with errors related to the exception handling mechanism itself. The function
std::current_exception() (18.8.5) and the class std::nested_exception (18.8.6) can be used by a pro-
gram to capture the currently handled exception.
15.5.1 The std::terminate() function
[except.terminate]
In some situations exception handling must be abandoned for less subtle error handling techniques. [ Note:
These situations are:

(1.1)

(1.2)

(1.3)

(1.4)

(1.5)

(1.6)

(1.7)

(1.8)

—

—
—

—

—

—
—

—

when the exception handling mechanism, after completing the initialization of the exception object
but before activation of a handler for the exception (15.1), calls a function that exits via an exception,
or
when the exception handling mechanism cannot ﬁnd a handler for a thrown exception (15.3), or
when the search for a handler (15.3) encounters the outermost block of a function with a noexcept-
speciﬁcation that does not allow the exception (15.4), or
when the destruction of an object during stack unwinding (15.2) terminates by throwing an exception,
or
when initialization of a non-local variable with static or thread storage duration (3.6.2) exits via an
exception, or
when destruction of an object with static or thread storage duration exits via an exception (3.6.3), or
when execution of a function registered with std::atexit or std::at_quick_exit exits via an ex-
ception (18.5), or
when a throw-expression (5.17) with no operand attempts to rethrow an exception and no exception
is being handled (15.1), or

§ 15.5.1

424

c(cid:13) ISO/IEC

N4296

(1.9)

(1.10)

(1.11)

(1.12)

(1.13)

—

—
—

—
—

when std::unexpected exits via an exception of a type that is not allowed by the previously vio-
lated exception speciﬁcation, and std::bad_exception is not included in that exception speciﬁca-
tion (15.5.2), or
when the implementation’s default unexpected exception handler is called (D.8.1), or
when the function std::nested_exception::rethrow_nested is called for an object that has captured
no exception (18.8.6), or
when execution of the initial function of a thread exits via an exception (30.3.1.2), or
when the destructor or the copy assignment operator is invoked on an object of type std::thread
that refers to a joinable thread (30.3.1.3, 30.3.1.4).

2

1

2

— end note ]
In such cases, std::terminate() is called (18.8.3). In the situation where no matching handler is found,
it is implementation-deﬁned whether or not the stack is unwound before std::terminate() is called. In
the situation where the search for a handler (15.3) encounters the outermost block of a function with a
noexcept-speciﬁcation that does not allow the exception (15.4), it is implementation-deﬁned whether the
stack is unwound, unwound partially, or not unwound at all before std::terminate() is called. In all other
situations, the stack shall not be unwound before std::terminate() is called. An implementation is not
permitted to ﬁnish stack unwinding prematurely based on a determination that the unwind process will
eventually cause a call to std::terminate().
15.5.2 The std::unexpected() function
[except.unexpected]
If a function with a dynamic-exception-speciﬁcation exits via an exception of a type that is not allowed by
its exception speciﬁcation, the function std::unexpected() is called (D.8) immediately after completing
the stack unwinding for the former function.
[ Note: By default, std::unexpected() calls std::terminate(), but a program can install its own handler
function (D.8.2). In either case, the constraints in the following paragraph apply. — end note ]

4

3 The std::unexpected() function shall not return, but it can throw (or rethrow) an exception. If it throws a
new exception which is allowed by the exception speciﬁcation which previously was violated, then the search
for another handler will continue at the call of the function whose exception speciﬁcation was violated. If it
exits via an exception of a type that the dynamic-exception-speciﬁcation does not allow, then the following
happens: If the dynamic-exception-speciﬁcation does not include the class std::bad_exception (18.8.2) then
the function std::terminate() is called, otherwise the thrown exception is replaced by an implementation-
deﬁned object of type std::bad_exception and the search for another handler will continue at the call of
the function whose dynamic-exception-speciﬁcation was violated.
[ Note: Thus, a dynamic-exception-speciﬁcation guarantees that a function exits only via an exception of
one of the listed types.
If the dynamic-exception-speciﬁcation includes the type std::bad_exception
then any exception type not on the list may be replaced by std::bad_exception within the function
std::unexpected(). — end note ]
15.5.3 The std::uncaught_exceptions() function

[except.uncaught]
1 An exception is considered uncaught after completing the initialization of the exception object (15.1) until
completing the activation of a handler for the exception (15.3). This includes stack unwinding.
If the
exception is rethrown (15.1), it is considered uncaught from the point of rethrow until the rethrown exception
is caught again. The function std::uncaught_exceptions() (18.8.4) returns the number of uncaught
exceptions.

§ 15.5.3

425

c(cid:13) ISO/IEC

16 Preprocessing directives

N4296

[cpp]

1 A preprocessing directive consists of a sequence of preprocessing tokens that satisﬁes the following constraints:
The ﬁrst token in the sequence is a # preprocessing token that (at the start of translation phase 4) is either
the ﬁrst character in the source ﬁle (optionally after white space containing no new-line characters) or that
follows white space containing at least one new-line character. The last token in the sequence is the ﬁrst new-
line character that follows the ﬁrst token in the sequence.145 A new-line character ends the preprocessing
directive even if it occurs within what would otherwise be an invocation of a function-like macro.

preprocessing-ﬁle:

groupopt

group:

group-part:

group-part
group group-part

if-section
control-line
text-line
# non-directive

if-section:

if-group elif-groupsopt else-groupopt endif-line

if-group:

# if
# ifdef
# ifndef

constant-expression new-line groupopt
identiﬁer new-line groupopt
identiﬁer new-line groupopt

elif-groups:

elif-group
elif-groups elif-group

elif-group:

# elif

else-group:

# else

endif-line:

# endif

control-line:

# include
# define
# define
# define
# define
# undef
# line
# error
# pragma
# new-line

constant-expression new-line groupopt

new-line groupopt

new-line

pp-tokens new-line
identiﬁer replacement-list new-line
identiﬁer lparen identiﬁer-listopt) replacement-list new-line
identiﬁer lparen ... ) replacement-list new-line
identiﬁer lparen identiﬁer-list, ... ) replacement-list new-line
identiﬁer new-line
pp-tokens new-line
pp-tokensopt new-line
pp-tokensopt new-line

145) Thus, preprocessing directives are commonly called “lines.” These “lines” have no other syntactic signiﬁcance, as all white
space is equivalent except in certain situations during preprocessing (see the # character string literal creation operator in 16.3.2,
for example).

Preprocessing directives

426

N4296

c(cid:13) ISO/IEC

text-line:

pp-tokensopt new-line

non-directive:

pp-tokens new-line

lparen:

a ( character not immediately preceded by white-space

identiﬁer-list:

identiﬁer
identiﬁer-list , identiﬁer

replacement-list:

pp-tokensopt

pp-tokens:

preprocessing-token
pp-tokens preprocessing-token

new-line:

the new-line character

2 A text line shall not begin with a # preprocessing token. A non-directive shall not begin with any of the

directive names appearing in the syntax.

3 When in a group that is skipped (16.1), the directive syntax is relaxed to allow any sequence of preprocessing

tokens to occur between the directive name and the following new-line character.

4 The only white-space characters that shall appear between preprocessing tokens within a preprocessing
directive (from just after the introducing # preprocessing token through just before the terminating new-line
character) are space and horizontal-tab (including spaces that have replaced comments or possibly other
white-space characters in translation phase 3).

5 The implementation can process and skip sections of source ﬁles conditionally, include other source ﬁles,
and replace macros. These capabilities are called preprocessing, because conceptually they occur before
translation of the resulting translation unit.

6 The preprocessing tokens within a preprocessing directive are not subject to macro expansion unless otherwise

stated.
[ Example: In:

#define EMPTY
EMPTY

#

include <file.h>

the sequence of preprocessing tokens on the second line is not a preprocessing directive, because it does not
begin with a # at the start of translation phase 4, even though it will do so after the macro EMPTY has been
replaced. — end example ]
16.1 Conditional inclusion

[cpp.cond]
1 The expression that controls conditional inclusion shall be an integral constant expression except that iden-
tiﬁers (including those lexically identical to keywords) are interpreted as described below146 and it may
contain unary operator expressions of the form

defined identiﬁer

or

defined ( identiﬁer )

146) Because the controlling constant expression is evaluated during translation phase 4, all identiﬁers either are or are not
macro names — there simply are no keywords, enumeration constants, etc.

§ 16.1

427

c(cid:13) ISO/IEC

N4296

which evaluate to 1 if the identiﬁer is currently deﬁned as a macro name (that is, if it is predeﬁned or if it
has been the subject of a #define preprocessing directive without an intervening #undef directive with the
same subject identiﬁer), 0 if it is not.

2 Each preprocessing token that remains (in the list of preprocessing tokens that will become the controlling

expression) after all macro replacements have occurred shall be in the lexical form of a token (2.6).

3 Preprocessing directives of the forms

# if
# elif

constant-expression new-line groupopt
constant-expression new-line groupopt

check whether the controlling constant expression evaluates to nonzero.

4 Prior to evaluation, macro invocations in the list of preprocessing tokens that will become the controlling
constant expression are replaced (except for those macro names modiﬁed by the defined unary operator),
just as in normal text.
If the token defined is generated as a result of this replacement process or use
of the defined unary operator does not match one of the two speciﬁed forms prior to macro replacement,
the behavior is undeﬁned. After all replacements due to macro expansion and the defined unary operator
have been performed, all remaining identiﬁers and keywords147, except for true and false, are replaced
with the pp-number 0, and then each preprocessing token is converted into a token. The resulting tokens
comprise the controlling constant expression which is evaluated according to the rules of 5.20 using arithmetic
that has at least the ranges speciﬁed in 18.3. For the purposes of this token conversion and evaluation all
signed and unsigned integer types act as if they have the same representation as, respectively, intmax_t
or uintmax_t (18.4).148 This includes interpreting character literals, which may involve converting escape
sequences into execution character set members. Whether the numeric value for these character literals
matches the value obtained when an identical character literal occurs in an expression (other than within a
#if or #elif directive) is implementation-deﬁned.149 Also, whether a single-character character literal may
have a negative value is implementation-deﬁned. Each subexpression with type bool is subjected to integral
promotion before processing continues.

5 Preprocessing directives of the forms

# ifdef
# ifndef

identiﬁer new-line groupopt
identiﬁer new-line groupopt

check whether the identiﬁer is or is not currently deﬁned as a macro name. Their conditions are equivalent
to #if defined identiﬁer and #if !defined identiﬁer respectively.

6 Each directive’s condition is checked in order. If it evaluates to false (zero), the group that it controls is
skipped: directives are processed only through the name that determines the directive in order to keep track
of the level of nested conditionals; the rest of the directives’ preprocessing tokens are ignored, as are the other
preprocessing tokens in the group. Only the ﬁrst group whose control condition evaluates to true (nonzero)
is processed. If none of the conditions evaluates to true, and there is a #else directive, the group controlled
by the #else is processed; lacking a #else directive, all the groups until the #endif are skipped.150
147) An alternative token (2.5) is not an identiﬁer, even when its spelling consists entirely of letters and underscores. Therefore
it is not subject to this replacement.
148) Thus on an implementation where std::numeric_limits<int>::max() is 0x7FFF and std::numeric_limits<unsigned
int>::max() is 0xFFFF, the integer literal 0x8000 is signed and positive within a #if expression even though it is unsigned
in translation phase 7 (2.2).
149) Thus, the constant expression in the following #if directive and if statement is not guaranteed to evaluate to the same
value in these two contexts.

#if ’z’ - ’a’ == 25
if (’z’ - ’a’ == 25)

150) As indicated by the syntax, a preprocessing token shall not follow a #else or #endif directive before the terminating
new-line character. However, comments may appear anywhere in a source ﬁle, including within a preprocessing directive.

§ 16.1

428

c(cid:13) ISO/IEC

16.2 Source ﬁle inclusion

N4296

[cpp.include]

1 A #include directive shall identify a header or source ﬁle that can be processed by the implementation.
2 A preprocessing directive of the form

# include < h-char-sequence> new-line

searches a sequence of implementation-deﬁned places for a header identiﬁed uniquely by the speciﬁed se-
quence between the < and > delimiters, and causes the replacement of that directive by the entire contents
of the header. How the places are speciﬁed or the header identiﬁed is implementation-deﬁned.

3 A preprocessing directive of the form

# include " q-char-sequence" new-line

causes the replacement of that directive by the entire contents of the source ﬁle identiﬁed by the speciﬁed
sequence between the " delimiters. The named source ﬁle is searched for in an implementation-deﬁned
manner. If this search is not supported, or if the search fails, the directive is reprocessed as if it read

# include < h-char-sequence> new-line

with the identical contained sequence (including > characters, if any) from the original directive.

4 A preprocessing directive of the form

# include pp-tokens new-line

(that does not match one of the two previous forms) is permitted. The preprocessing tokens after include
in the directive are processed just as in normal text (i.e., each identiﬁer currently deﬁned as a macro name is
replaced by its replacement list of preprocessing tokens). If the directive resulting after all replacements does
not match one of the two previous forms, the behavior is undeﬁned.151 The method by which a sequence
of preprocessing tokens between a < and a > preprocessing token pair or a pair of " characters is combined
into a single header name preprocessing token is implementation-deﬁned.

5 The implementation shall provide unique mappings for sequences consisting of one or more nondigits or
digits (2.10) followed by a period (.) and a single nondigit. The ﬁrst character shall not be a digit. The
implementation may ignore distinctions of alphabetical case.

6 A #include preprocessing directive may appear in a source ﬁle that has been read because of a #include

directive in another ﬁle, up to an implementation-deﬁned nesting limit.
[ Note: Although an implementation may provide a mechanism for making arbitrary source ﬁles available to
the < > search, in general programmers should use the < > form for headers provided with the implementa-
tion, and the " " form for sources outside the control of the implementation. For instance:

7

#include <stdio.h>
#include <unistd.h>
#include "usefullib.h"
#include "myprog.h"

— end note ]
[ Example: This illustrates macro-replaced #include directives:

8

#if VERSION == 1

#define INCFILE
#elif VERSION == 2
#define INCFILE

#else

#define INCFILE

"vers1.h"

"vers2.h"

// and so on

"versN.h"

151) Note that adjacent string literals are not concatenated into a single string literal (see the translation phases in 2.2); thus,
an expansion that results in two string literals is an invalid directive.

§ 16.2

429

c(cid:13) ISO/IEC

#endif
#include INCFILE

N4296

— end example ]
16.3 Macro replacement

[cpp.replace]
1 Two replacement lists are identical if and only if the preprocessing tokens in both have the same number,

ordering, spelling, and white-space separation, where all white-space separations are considered identical.

2 An identiﬁer currently deﬁned as an object-like macro may be redeﬁned by another #define preprocessing
directive provided that the second deﬁnition is an object-like macro deﬁnition and the two replacement lists
are identical, otherwise the program is ill-formed. Likewise, an identiﬁer currently deﬁned as a function-like
macro may be redeﬁned by another #define preprocessing directive provided that the second deﬁnition is a
function-like macro deﬁnition that has the same number and spelling of parameters, and the two replacement
lists are identical, otherwise the program is ill-formed.

4

3 There shall be white-space between the identiﬁer and the replacement list in the deﬁnition of an object-like

macro.
If the identiﬁer-list in the macro deﬁnition does not end with an ellipsis, the number of arguments (including
those arguments consisting of no preprocessing tokens) in an invocation of a function-like macro shall equal
the number of parameters in the macro deﬁnition. Otherwise, there shall be more arguments in the invocation
than there are parameters in the macro deﬁnition (excluding the ...). There shall exist a ) preprocessing
token that terminates the invocation.

5 The identiﬁer __VA_ARGS__ shall occur only in the replacement-list of a function-like macro that uses the

ellipsis notation in the parameters.

6 A parameter identiﬁer in a function-like macro shall be uniquely declared within its scope.
7 The identiﬁer immediately following the define is called the macro name. There is one name space for macro
names. Any white-space characters preceding or following the replacement list of preprocessing tokens are
not considered part of the replacement list for either form of macro.
If a # preprocessing token, followed by an identiﬁer, occurs lexically at the point at which a preprocessing
directive could begin, the identiﬁer is not subject to macro replacement.

8

9 A preprocessing directive of the form

# define identiﬁer replacement-list new-line

deﬁnes an object-like macro that causes each subsequent instance of the macro name152 to be replaced by the
replacement list of preprocessing tokens that constitute the remainder of the directive.153 The replacement
list is then rescanned for more macro names as speciﬁed below.

10 A preprocessing directive of the form

# define identiﬁer lparen identiﬁer-listopt) replacement-list new-line
# define identiﬁer lparen ... ) replacement-list new-line
# define identiﬁer lparen identiﬁer-list , ... ) replacement-list new-line

deﬁnes a function-like macro with parameters, whose use is similar syntactically to a function call. The
parameters are speciﬁed by the optional list of identiﬁers, whose scope extends from their declaration in the
identiﬁer list until the new-line character that terminates the #define preprocessing directive. Each subse-
quent instance of the function-like macro name followed by a ( as the next preprocessing token introduces
152) Since, by macro-replacement time, all character literals and string literals are preprocessing tokens, not sequences possibly
containing identiﬁer-like subsequences (see 2.2, translation phases), they are never scanned for macro names or parameters.
153) An alternative token (2.5) is not an identiﬁer, even when its spelling consists entirely of letters and underscores. Therefore
it is not possible to deﬁne a macro whose name is the same as that of an alternative token.

§ 16.3

430

c(cid:13) ISO/IEC

N4296

the sequence of preprocessing tokens that is replaced by the replacement list in the deﬁnition (an invocation
of the macro). The replaced sequence of preprocessing tokens is terminated by the matching ) preprocessing
token, skipping intervening matched pairs of left and right parenthesis preprocessing tokens. Within the
sequence of preprocessing tokens making up an invocation of a function-like macro, new-line is considered a
normal white-space character.

12

11 The sequence of preprocessing tokens bounded by the outside-most matching parentheses forms the list of
arguments for the function-like macro. The individual arguments within the list are separated by comma
preprocessing tokens, but comma preprocessing tokens between matching inner parentheses do not separate
arguments. If there are sequences of preprocessing tokens within the list of arguments that would otherwise
act as preprocessing directives,154 the behavior is undeﬁned.
If there is a ... immediately preceding the ) in the function-like macro deﬁnition, then the trailing argu-
ments, including any separating comma preprocessing tokens, are merged to form a single item: the variable
arguments. The number of arguments so combined is such that, following merger, the number of arguments
is one more than the number of parameters in the macro deﬁnition (excluding the ...).
16.3.1 Argument substitution

[cpp.subst]
1 After the arguments for the invocation of a function-like macro have been identiﬁed, argument substitution
takes place. A parameter in the replacement list, unless preceded by a # or ## preprocessing token or
followed by a ## preprocessing token (see below), is replaced by the corresponding argument after all macros
contained therein have been expanded. Before being substituted, each argument’s preprocessing tokens are
completely macro replaced as if they formed the rest of the preprocessing ﬁle; no other preprocessing tokens
are available.

2 An identiﬁer __VA_ARGS__ that occurs in the replacement list shall be treated as if it were a parameter, and

the variable arguments shall form the preprocessing tokens used to replace it.
16.3.2 The # operator

[cpp.stringize]
1 Each # preprocessing token in the replacement list for a function-like macro shall be followed by a parameter

as the next preprocessing token in the replacement list.

2 A character string literal

is a string-literal with no preﬁx.

If, in the replacement list, a parameter is
immediately preceded by a # preprocessing token, both are replaced by a single character string literal
preprocessing token that contains the spelling of the preprocessing token sequence for the corresponding
argument. Each occurrence of white space between the argument’s preprocessing tokens becomes a single
space character in the character string literal. White space before the ﬁrst preprocessing token and after
the last preprocessing token comprising the argument is deleted. Otherwise, the original spelling of each
preprocessing token in the argument is retained in the character string literal, except for special handling
for producing the spelling of string literals and character literals: a \ character is inserted before each " and
\ character of a character literal or string literal (including the delimiting " characters). If the replacement
that results is not a valid character string literal, the behavior is undeﬁned. The character string literal
corresponding to an empty argument is "". The order of evaluation of # and ## operators is unspeciﬁed.
16.3.3 The ## operator

[cpp.concat]
1 A ## preprocessing token shall not occur at the beginning or at the end of a replacement list for either form

2

of macro deﬁnition.
If, in the replacement list of a function-like macro, a parameter is immediately preceded or followed by
a ## preprocessing token, the parameter is replaced by the corresponding argument’s preprocessing token
154) Despite the name, a non-directive is a preprocessing directive.

§ 16.3.3

431

c(cid:13) ISO/IEC

N4296

sequence; however, if an argument consists of no preprocessing tokens, the parameter is replaced by a
placemarker preprocessing token instead.155

3 For both object-like and function-like macro invocations, before the replacement list is reexamined for more
macro names to replace, each instance of a ## preprocessing token in the replacement list (not from an
argument) is deleted and the preceding preprocessing token is concatenated with the following preprocessing
token. Placemarker preprocessing tokens are handled specially: concatenation of two placemarkers results
in a single placemarker preprocessing token, and concatenation of a placemarker with a non-placemarker
preprocessing token results in the non-placemarker preprocessing token. If the result is not a valid prepro-
cessing token, the behavior is undeﬁned. The resulting token is available for further macro replacement.
The order of evaluation of ## operators is unspeciﬁed.
[ Example: In the following fragment:

#define hash_hash # ## #
#define mkstr(a) # a
#define in_between(a) mkstr(a)
#define join(c, d) in_between(c hash_hash d)
char p[] = join(x, y);

// equivalent to
// char p[] = "x ## y";

The expansion produces, at various stages:

join(x, y)
in_between(x hash_hash y)
in_between(x ## y)
mkstr(x ## y)
"x ## y"

In other words, expanding hash_hash produces a new token, consisting of two adjacent sharp signs, but this
new token is not the ## operator. — end example ]
16.3.4 Rescanning and further replacement

[cpp.rescan]
1 After all parameters in the replacement list have been substituted and # and ## processing has taken
place, all placemarker preprocessing tokens are removed. Then the resulting preprocessing token sequence
is rescanned, along with all subsequent preprocessing tokens of the source ﬁle, for more macro names to
replace.
If the name of the macro being replaced is found during this scan of the replacement list (not including the
rest of the source ﬁle’s preprocessing tokens), it is not replaced. Furthermore, if any nested replacements
encounter the name of the macro being replaced, it is not replaced. These nonreplaced macro name prepro-
cessing tokens are no longer available for further replacement even if they are later (re)examined in contexts
in which that macro name preprocessing token would otherwise have been replaced.

2

3 The resulting completely macro-replaced preprocessing token sequence is not processed as a preprocessing
directive even if it resembles one, but all pragma unary operator expressions within it are then processed as
speciﬁed in 16.9 below.
16.3.5 Scope of macro deﬁnitions

[cpp.scope]
1 A macro deﬁnition lasts (independent of block structure) until a corresponding #undef directive is encoun-
tered or (if none is encountered) until the end of the translation unit. Macro deﬁnitions have no signiﬁcance
after translation phase 4.

2 A preprocessing directive of the form

155) Placemarker preprocessing tokens do not appear in the syntax because they are temporary entities that exist only within
translation phase 4.

§ 16.3.5

432

c(cid:13) ISO/IEC

# undef identiﬁer new-line

N4296

3

4

causes the speciﬁed identiﬁer no longer to be deﬁned as a macro name. It is ignored if the speciﬁed identiﬁer
is not currently deﬁned as a macro name.
[ Example: The simplest use of this facility is to deﬁne a “manifest constant,” as in

#define TABSIZE 100
int table[TABSIZE];

— end example ]
[ Example: The following deﬁnes a function-like macro whose value is the maximum of its arguments. It has
the advantages of working for any compatible types of the arguments and of generating in-line code without
the overhead of function calling. It has the disadvantages of evaluating one or the other of its arguments a
second time (including side eﬀects) and generating more code than a function if invoked several times. It
also cannot have its address taken, as it has none.

#define max(a, b) ((a) > (b) ? (a) : (b))

The parentheses ensure that the arguments and the resulting expression are bound properly. — end example ]
[ Example: To illustrate the rules for redeﬁnition and reexamination, the sequence

5

#define x
#define f(a)
x
#undef
#define x
#define g
#define z
#define h
#define m(a)
#define w
#define t(a)
#define p()
#define q(x)
#define r(x,y)
#define str(x)

3
f(x * (a))

2
f
z[0]
g(~
a(w)
0,1
a
int
x
x ## y
# x

f(y+1) + f(f(z)) % t(t(g)(0) + t)(1);
g(x+(3,4)-w) | h 5) & m

(f)^m(m);

p() i[q()] = { q(1), r(2,3), r(4,), r(,5), r(,) };
char c[2][6] = { str(hello), str() };

results in

f(2 * (y+1)) + f(2 * (f(2 * (z[0])))) % f(2 * (0)) + t(1);
f(2 * (2+(3,4)-0,1)) | f(2 * (~ 5)) & f(2 * (0,1))^m(0,1);
int i[] = { 1, 23, 4, 5, };
char c[2][6] = { "hello", "" };

— end example ]
[ Example: To illustrate the rules for creating character string literals and concatenating tokens, the sequence

6

#define str(s)
#define xstr(s)
#define debug(s, t) printf("x" # s "= %d, x" # t "= %s", \

# s
str(s)

x ## s, x ## t)

§ 16.3.5

433

c(cid:13) ISO/IEC

N4296

vers ## n
a ## b

#define INCFILE(n)
#define glue(a, b)
#define xglue(a, b) glue(a, b)
#define HIGHLOW
#define LOW

"hello"
LOW ", world"

debug(1, 2);
fputs(str(strncmp("abc\0d", "abc", ’\4’) // this goes away

== 0) str(: @\n), s);

#include xstr(INCFILE(2).h)
glue(HIGH, LOW);
xglue(HIGH, LOW)

results in

printf("x" "1" "= %d, x" "2" "= %s", x1, x2);
fputs("strncmp(\"abc\\0d\", \"abc\", ’\\4’) == 0" ": @\n", s);
#include "vers2.h"
"hello";
"hello" ", world"

(after macro replacement, before file access)

or, after concatenation of the character string literals,

printf("x1= %d, x2= %s", x1, x2);
fputs("strncmp(\"abc\\0d\", \"abc\", ’\\4’) == 0: @\n", s);
#include "vers2.h"
"hello";
"hello, world"

(after macro replacement, before file access)

Space around the # and ## tokens in the macro deﬁnition is optional. — end example ]
[ Example: To illustrate the rules for placemarker preprocessing tokens, the sequence

7

#define t(x,y,z) x ## y ## z
int j[] = { t(1,2,3), t(,4,5), t(6,,7), t(8,9,),

t(10,,), t(,11,), t(,,12), t(,,) };

results in

int j[] = { 123, 45, 67, 89,

10, 11, 12, };

— end example ]
[ Example: To demonstrate the redeﬁnition rules, the following sequence is valid.

8

#define OBJ_LIKE
#define OBJ_LIKE
#define FUNC_LIKE(a)
#define FUNC_LIKE( a )(

(1-1)
/* white space */ (1-1) /* other */
( a )

/* note the white space */ \

a /* other stuff on this line

*/ )

But the following redeﬁnitions are invalid:

#define OBJ_LIKE
#define OBJ_LIKE
#define FUNC_LIKE(b) ( a )
#define FUNC_LIKE(b) ( b )

(0)
(1 - 1) // diﬀerent white space

// diﬀerent token sequence

// diﬀerent parameter usage
// diﬀerent parameter spelling

§ 16.3.5

434

c(cid:13) ISO/IEC

N4296

— end example ]
[ Example: Finally, to show the variable argument list macro facilities:

9

#define debug(...) fprintf(stderr, __VA_ARGS__)
#define showlist(...) puts(#__VA_ARGS__)
#define report(test, ...) ((test) ? puts(#test) : printf(__VA_ARGS__))
debug("Flag");
debug("X = %d\n", x);
showlist(The first, second, and third items.);
report(x>y, "x is %d but y is %d", x, y);

results in

fprintf(stderr, "Flag");
fprintf(stderr, "X = %d\n", x);
puts("The first, second, and third items.");
((x>y) ? puts("x>y") : printf("x is %d but y is %d", x, y));

— end example ]
16.4 Line control

[cpp.line]

1 The string literal of a #line directive, if present, shall be a character string literal.
2 The line number of the current source line is one greater than the number of new-line characters read or

introduced in translation phase 1 (2.2) while processing the source ﬁle to the current token.

3 A preprocessing directive of the form

# line digit-sequence new-line

causes the implementation to behave as if the following sequence of source lines begins with a source line
that has a line number as speciﬁed by the digit sequence (interpreted as a decimal integer). If the digit
sequence speciﬁes zero or a number greater than 2147483647, the behavior is undeﬁned.

4 A preprocessing directive of the form

# line digit-sequence " s-char-sequenceopt" new-line

sets the presumed line number similarly and changes the presumed name of the source ﬁle to be the contents
of the character string literal.

5 A preprocessing directive of the form

# line pp-tokens new-line

(that does not match one of the two previous forms) is permitted. The preprocessing tokens after line
on the directive are processed just as in normal text (each identiﬁer currently deﬁned as a macro name is
replaced by its replacement list of preprocessing tokens). If the directive resulting after all replacements
does not match one of the two previous forms, the behavior is undeﬁned; otherwise, the result is processed
as appropriate.
16.5 Error directive

[cpp.error]

1 A preprocessing directive of the form

# error pp-tokensopt new-line

causes the implementation to produce a diagnostic message that includes the speciﬁed sequence of prepro-
cessing tokens, and renders the program ill-formed.
16.6 Pragma directive

[cpp.pragma]

1 A preprocessing directive of the form

§ 16.6

435

c(cid:13) ISO/IEC

N4296

# pragma pp-tokensopt new-line

causes the implementation to behave in an implementation-deﬁned manner. The behavior might cause
translation to fail or cause the translator or the resulting program to behave in a non-conforming manner.
Any pragma that is not recognized by the implementation is ignored.
16.7 Null directive

[cpp.null]

1 A preprocessing directive of the form

# new-line

has no eﬀect.
16.8 Predeﬁned macro names

[cpp.predeﬁned]

1 The following macro names shall be deﬁned by the implementation:

__cplusplus

The name __cplusplus is deﬁned to the value 201402L when compiling a C++ translation unit.156

__DATE__

The date of translation of the source ﬁle: a character string literal of the form "Mmm dd yyyy", where
the names of the months are the same as those generated by the asctime function, and the ﬁrst
character of dd is a space character if the value is less than 10.
If the date of translation is not
available, an implementation-deﬁned valid date shall be supplied.

__FILE__

The presumed name of the current source ﬁle (a character string literal).157

__LINE__

The presumed line number (within the current source ﬁle) of the current source line (an integer
literal).158

__STDC_HOSTED__

The integer literal 1 if the implementation is a hosted implementation or the integer literal 0 if it is
not.
__TIME__

The time of translation of the source ﬁle: a character string literal of the form "hh:mm:ss" as in the
time generated by the asctime function. If the time of translation is not available, an implementation-
deﬁned valid time shall be supplied.

2 The following macro names are conditionally deﬁned by the implementation:

__STDC__

Whether __STDC__ is predeﬁned and if so, what its value is, are implementation-deﬁned.

__STDC_MB_MIGHT_NEQ_WC__

The integer literal 1, intended to indicate that, in the encoding for wchar_t, a member of the basic
character set need not have a code value equal to its value when used as the lone character in an
ordinary character literal.

__STDC_VERSION__

Whether __STDC_VERSION__ is predeﬁned and if so, what its value is, are implementation-deﬁned.

156) It is intended that future versions of this standard will replace the value of this macro with a greater value. Non-conforming
compilers should use a value with at most ﬁve decimal digits.
157) The presumed source ﬁle name can be changed by the #line directive.
158) The presumed line number can be changed by the #line directive.

§ 16.8

436

c(cid:13) ISO/IEC

N4296

__STDC_ISO_10646__

An integer literal of the form yyyymmL (for example, 199712L). If this symbol is deﬁned, then every
character in the Unicode required set, when stored in an object of type wchar_t, has the same value
as the short identiﬁer of that character. The Unicode required set consists of all the characters that
are deﬁned by ISO/IEC 10646, along with all amendments and technical corrigenda as of the speciﬁed
year and month.

__STDCPP_STRICT_POINTER_SAFETY__

Deﬁned, and has the value integer literal 1, if and only if the implementation has strict pointer
safety (3.7.4.3).

__STDCPP_THREADS__

Deﬁned, and has the value integer literal 1, if and only if a program can have more than one thread of
execution (1.10).

3 The values of the predeﬁned macros (except for __FILE__ and __LINE__) remain constant throughout the

4

translation unit.
If any of the pre-deﬁned macro names in this subclause, or the identiﬁer defined, is the subject of a #define
or a #undef preprocessing directive, the behavior is undeﬁned. Any other predeﬁned macro names shall begin
with a leading underscore followed by an uppercase letter or a second underscore.
16.9 Pragma operator
A unary operator expression of the form:

[cpp.pragma.op]

_Pragma ( string-literal )

is processed as follows: The string literal is destringized by deleting the L preﬁx, if present, deleting the
leading and trailing double-quotes, replacing each escape sequence \" by a double-quote, and replacing
each escape sequence \\ by a single backslash. The resulting sequence of characters is processed through
translation phase 3 to produce preprocessing tokens that are executed as if they were the pp-tokens in a
pragma directive. The original four preprocessing tokens in the unary operator expression are removed.
[ Example:

#pragma listing on "..\listing.dir"

can also be expressed as:

_Pragma ( "listing on \"..\\listing.dir\"" )

The latter form is processed in the same way whether it appears literally as shown, or results from macro
replacement, as in:

#define LISTING(x) PRAGMA(listing on #x)
#define PRAGMA(x) _Pragma(#x)

LISTING( ..\listing.dir )

— end example ]

§ 16.9

437

c(cid:13) ISO/IEC

N4296

17 Library introduction
17.1 General

[library]
[library.general]
1 This Clause describes the contents of the C++ standard library, how a well-formed C++ program makes use

of the library, and how a conforming implementation may provide the entities in the library.

2 The following subclauses describe the deﬁnitions (17.3), method of description (17.5), and organization (17.6.1)
of the library. Clause 17.6, Clauses 18 through 30, and Annex D specify the contents of the library, as well as
library requirements and constraints on both well-formed C++ programs and conforming implementations.
3 Detailed speciﬁcations for each of the components in the library are in Clauses 18–30, as shown in Table 13.

Table 13 — Library categories

Clause Category
18
19
20
21
22
23
24
25
26
27
28
29
30

Language support library
Diagnostics library
General utilities library
Strings library
Localization library
Containers library
Iterators library
Algorithms library
Numerics library
Input/output library
Regular expressions library
Atomic operations library
Thread support library

4 The language support library (Clause 18) provides components that are required by certain parts of the C++

language, such as memory allocation (5.3.4, 5.3.5) and exception processing (Clause 15).

5 The diagnostics library (Clause 19) provides a consistent framework for reporting errors in a C++ program,

including predeﬁned exception classes.

6 The general utilities library (Clause 20) includes components used by other library elements, such as a
predeﬁned storage allocator for dynamic storage management (3.7.4), and components used as infrastructure
in C++ programs, such as a tuples, function wrappers, and time facilities.

7 The strings library (Clause 21) provides support for manipulating text represented as sequences of type
char, sequences of type char16_t, sequences of type char32_t, sequences of type wchar_t, and sequences
of any other character-like type.

8 The localization library (Clause 22) provides extended internationalization support for text processing.
9 The containers (Clause 23), iterators (Clause 24), and algorithms (Clause 25) libraries provide a C++ program

with access to a subset of the most widely used algorithms and data structures.

10 The numerics library (Clause 26) provides numeric algorithms and complex number components that extend
support for numeric processing. The valarray component provides support for n-at-a-time processing,
potentially implemented as parallel operations on platforms that support such processing. The random
number component provides facilities for generating pseudo-random numbers.

§ 17.1

438

c(cid:13) ISO/IEC

N4296

11 The input/output library (Clause 27) provides the iostream components that are the primary mechanism
for C++ program input and output. They can be used with other elements of the library, particularly strings,
locales, and iterators.

12 The regular expressions library (Clause 28) provides regular expression matching and searching.
13 The atomic operations library (Clause 29) allows more ﬁne-grained concurrent access to shared data than

is possible with locks.

14 The thread support library (Clause 30) provides components to create and manage threads, including mutual

exclusion and interthread communication.
17.2 The C standard library

[library.c]
1 The C++ standard library also makes available the facilities of the C standard library, suitably adjusted to

ensure static type safety.

2 The descriptions of many library functions rely on the C standard library for the signatures and semantics

of those functions. In all such cases, any use of the restrict qualiﬁer shall be omitted.
17.3 Deﬁnitions

[deﬁnitions]

17.3.1
arbitrary-positional stream
a stream (described in Clause 27) that can seek to any integral position within the length of the stream
[ Note: Every arbitrary-positional stream is also a repositional stream. — end note ]

[defns.arbitrary.stream]

17.3.2
block
place a thread in the blocked state

[defns.block]

17.3.3
blocked thread
a thread that is waiting for some condition (other than the availability of a processor) to be satisﬁed before
it can continue execution159

[defns.blocked]

17.3.4
character
<Clauses 21, 22, 27, and 28> any object which, when treated sequentially, can represent text
[ Note: The term does not mean only char, char16_t, char32_t, and wchar_t objects, but any value that
can be represented by a type that provides the deﬁnitions speciﬁed in these Clauses. — end note ]

[defns.character]

17.3.5
character container type
a class or a type used to represent a character
[ Note: It is used for one of the template parameters of the string, iostream, and regular expression class
templates. A character container type is a POD (3.9) type. — end note ]

[defns.character.container]

17.3.6
159) This deﬁnition is taken from POSIX.

§ 17.3

[defns.comparison]

439

c(cid:13) ISO/IEC

N4296

comparison function
an operator function (13.5) for any of the equality (5.10) or relational (5.9) operators

17.3.7
component
a group of library entities directly related as members, parameters, or return types
[ Note: For example, the class template basic_string and the non-member function templates that operate
on strings are referred to as the string component. — end note ]

[defns.component]

17.3.8
deadlock
one or more threads are unable to continue execution because each is blocked waiting for one or more of the
others to satisfy some condition

[defns.deadlock]

17.3.9
default behavior
<implementation> any speciﬁc behavior provided by the implementation, within the scope of the required
behavior

[defns.default.behavior.impl]

17.3.10
default behavior
<speciﬁcation> a description of replacement function and handler function semantics

[defns.default.behavior.func]

17.3.11
handler function
a non-reserved function whose deﬁnition may be provided by a C++ program
[ Note: A C++ program may designate a handler function at various points in its execution by supplying a
pointer to the function when calling any of the library functions that install handler functions (Clause 18).
— end note ]

[defns.handler]

17.3.12
iostream class templates
templates, deﬁned in Clause 27, that take two template arguments
[ Note: The arguments are named charT and traits. The argument charT is a character container class,
and the argument traits is a class which deﬁnes additional characteristics and functions of the character
type represented by charT necessary to implement the iostream class templates. — end note ]

[defns.iostream.templates]

17.3.13
modiﬁer function
a class member function (9.3) other than a constructor, assignment operator, or destructor that alters the
state of an object of the class

[defns.modiﬁer]

17.3.14
move construction
direct-initialization of an object of some type with an rvalue of the same type

[defns.move.constr]

17.3.15

§ 17.3

[defns.move.assign]

440

c(cid:13) ISO/IEC

N4296

move assignment
assignment of an rvalue of some object type to a modiﬁable lvalue of the same type

17.3.16
object state
the current value of all non-static class members of an object (9.2)
[ Note: The state of an object can be obtained by using one or more observer functions. — end note ]

[defns.obj.state]

17.3.17
NTCTS
a sequence of values that have character type that precede the terminating null character type value charT()

[defns.ntcts]

17.3.18
observer function
a class member function (9.3) that accesses the state of an object of the class but does not alter that state
[ Note: Observer functions are speciﬁed as const member functions (9.3.2). — end note ]

[defns.observer]

17.3.19
referenceable type
An object type, a function type that does not have cv-qualiﬁers or a ref-qualiﬁer, or a reference type. [ Note:
The term describes a type to which a reference can be created, including reference types. — end note ]

[defns.referenceable]

17.3.20
replacement function
a non-reserved function whose deﬁnition is provided by a C++ program
[ Note: Only one deﬁnition for such a function is in eﬀect for the duration of the program’s execution, as the
result of creating the program (2.2) and resolving the deﬁnitions of all translation units (3.5). — end note ]

[defns.replacement]

17.3.21
repositional stream
a stream (described in Clause 27) that can seek to a position that was previously encountered

[defns.repositional.stream]

17.3.22
required behavior
a description of replacement function and handler function semantics applicable to both the behavior pro-
vided by the implementation and the behavior of any such function deﬁnition in the program
[ Note: If such a function deﬁned in a C++ program fails to meet the required behavior when it executes,
the behavior is undeﬁned. — end note ]

[defns.required.behavior]

17.3.23
reserved function
a function, speciﬁed as part of the C++ standard library, that must be deﬁned by the implementation
[ Note: If a C++ program provides a deﬁnition for any reserved function, the results are undeﬁned. — end
note ]

[defns.reserved.function]

17.3.24
stable algorithm

§ 17.3

[defns.stable]

441

c(cid:13) ISO/IEC

N4296

an algorithm that preserves, as appropriate to the particular algorithm, the order of elements
[ Note: Requirements for stable algorithms are given in 17.6.5.7. — end note ]

17.3.25
traits class
a class that encapsulates a set of types and functions necessary for class templates and function templates
to manipulate objects of types for which they are instantiated
[ Note: Traits classes deﬁned in Clauses 21, 22 and 27 are character traits, which provide the character
handling support needed by the string and iostream classes. — end note ]

[defns.traits]

17.3.26
unblock
place a thread in the unblocked state

[defns.unblock]

17.3.27
valid but unspeciﬁed state
an object state that is not speciﬁed except that the object’s invariants are met and operations on the object
behave as speciﬁed for its type
[ Example: If an object x of type std::vector<int> is in a valid but unspeciﬁed state, x.empty() can be
called unconditionally, and x.front() can be called only if x.empty() returns false. — end example ]
17.4 Additional deﬁnitions

[defns.additional]

[defns.valid]

1 1.3 deﬁnes additional terms used elsewhere in this International Standard.

17.5 Method of description (Informative)

[description]
1 This subclause describes the conventions used to specify the C++ standard library. 17.5.1 describes the
structure of the normative Clauses 18 through 30 and Annex D. 17.5.2 describes other editorial conventions.
17.5.1 Structure of each clause
[structure]
[structure.elements]
17.5.1.1 Elements

1 Each library clause contains the following elements, as applicable:160

(1.1)

(1.2)

(1.3)

(1.4)

—
—
—
—

Summary
Requirements
Detailed speciﬁcations
References to the Standard C library

17.5.1.2 Summary

[structure.summary]
1 The Summary provides a synopsis of the category, and introduces the ﬁrst-level subclauses. Each subclause
also provides a summary, listing the headers speciﬁed in the subclause and the library entities provided in
each header.

2 Paragraphs labeled “Note(s):” or “Example(s):” are informative, other paragraphs are normative.
3 The contents of the summary and the detailed speciﬁcations include:

(3.1)

—

macros

160) To save space, items that do not apply to a Clause are omitted. For example, if a Clause does not specify any requirements,
there will be no “Requirements” subclause.

§ 17.5.1.2

442

c(cid:13) ISO/IEC

N4296

(3.2)

(3.3)

(3.4)

(3.5)

(3.6)

—
—
—
—
—

values
types
classes and class templates
functions and function templates
objects

17.5.1.3 Requirements

[structure.requirements]
1 Requirements describe constraints that shall be met by a C++ program that extends the standard library.

Such extensions are generally one of the following:

(1.1)

(1.2)

(1.3)

—
—
—

Template arguments
Derived classes
Containers, iterators, and algorithms that meet an interface convention

2 The string and iostream components use an explicit representation of operations required of template argu-

ments. They use a class template char_traits to deﬁne these constraints.
Interface convention requirements are stated as generally as possible.
Instead of stating “class X has to
deﬁne a member function operator++(),” the interface requires “for any object x of class X, ++x is deﬁned.”
That is, whether the operator is a member is unspeciﬁed.

3

4 Requirements are stated in terms of well-deﬁned expressions that deﬁne valid terms of the types that satisfy
the requirements. For every set of well-deﬁned expression requirements there is a table that speciﬁes an
initial set of the valid expressions and their semantics. Any generic algorithm (Clause 25) that uses the
well-deﬁned expression requirements is described in terms of the valid expressions for its template type
parameters.

5 Template argument requirements are sometimes referenced by name. See 17.5.2.1.
6

In some cases the semantic requirements are presented as C++ code. Such code is intended as a speciﬁca-
tion of equivalence of a construct to another construct, not necessarily as the way the construct must be
implemented.161
17.5.1.4 Detailed speciﬁcations

[structure.speciﬁcations]

1 The detailed speciﬁcations each contain the following elements:

(1.1)

(1.2)

(1.3)

(1.4)

(1.5)

—
—
—
—
—

name and brief description
synopsis (class deﬁnition or function declaration, as appropriate)
restrictions on template arguments, if any
description of class invariants
description of function semantics

2 Descriptions of class member functions follow the order (as appropriate):162

(2.1)

(2.2)

—
—

constructor(s) and destructor
copying, moving & assignment functions

161) Although in some cases the code given is unambiguously the optimum implementation.
162) To save space, items that do not apply to a class are omitted. For example, if a class does not specify any comparison
functions, there will be no “Comparison functions” subclause.

§ 17.5.1.4

443

c(cid:13) ISO/IEC

N4296

(2.3)

(2.4)

(2.5)

(2.6)

—
—
—
—

comparison functions
modiﬁer functions
observer functions
operators and other non-member functions

3 Descriptions of function semantics contain the following elements (as appropriate):163

(3.1)

(3.2)

(3.3)

(3.4)

(3.5)

(3.6)

(3.7)

(3.8)

(3.9)

(3.10)

—
—
—
—
—
—
—
—
—
—

Requires: the preconditions for calling the function
Eﬀects: the actions performed by the function
Synchronization: the synchronization operations (1.10) applicable to the function
Postconditions: the observable results established by the function
Returns: a description of the value(s) returned by the function
Throws: any exceptions thrown by the function, and the conditions that would cause the exception
Complexity: the time and/or space complexity of the function
Remarks: additional semantic constraints on the function
Error conditions: the error conditions for error codes reported by the function.
Notes: non-normative comments about the function

4 Whenever the Eﬀects: element speciﬁes that the semantics of some function F are Equivalent to some code
sequence, then the various elements are interpreted as follows. If F’s semantics speciﬁes a Requires: element,
then that requirement is logically imposed prior to the equivalent-to semantics. Next, the semantics of the
code sequence are determined by the Requires:, Eﬀects:, Postconditions:, Returns:, Throws:, Complexity:,
Remarks:, Error conditions:, and Notes: speciﬁed for the function invocations contained in the code sequence.
The value returned from F is speciﬁed by F’s Returns: element, or if F has no Returns: element, a non-void
return from F is speciﬁed by the Returns: elements in the code sequence. If F’s semantics contains a Throws:,
Postconditions:, or Complexity: element, then that supersedes any occurrences of that element in the code
sequence.

5 For non-reserved replacement and handler functions, Clause 18 speciﬁes two behaviors for the functions in
question: their required and default behavior. The default behavior describes a function deﬁnition provided
by the implementation. The required behavior describes the semantics of a function deﬁnition provided by
either the implementation or a C++ program. Where no distinction is explicitly made in the description,
the behavior described is the required behavior.
If the formulation of a complexity requirement calls for a negative number of operations, the actual require-
ment is zero operations.164

6

7 Complexity requirements speciﬁed in the library clauses are upper bounds, and implementations that provide

better complexity guarantees satisfy the requirements.

8 Error conditions specify conditions where a function may fail. The conditions are listed, together with a

suitable explanation, as the enum class errc constants (19.5).
163) To save space, items that do not apply to a function are omitted. For example, if a function does not specify any further
preconditions, there will be no “Requires” paragraph.
164) This simpliﬁes the presentation of complexity requirements in some cases.

§ 17.5.1.4

444

c(cid:13) ISO/IEC

N4296

17.5.1.5 C library

[structure.see.also]
1 Paragraphs labeled “See also:” contain cross-references to the relevant portions of this International Stan-

dard and the ISO C standard, which is incorporated into this International Standard by reference.
17.5.2 Other conventions

[conventions]
1 This subclause describes several editorial conventions used to describe the contents of the C++ standard
library. These conventions are for describing implementation-deﬁned types (17.5.2.1), and member func-
tions (17.5.2.2).
17.5.2.1 Type descriptions
17.5.2.1.1 General

[type.descriptions]
[type.descriptions.general]
1 The Requirements subclauses may describe names that are used to specify constraints on template argu-
ments.165 These names are used in library Clauses to describe the types that may be supplied as arguments
by a C++ program when instantiating template components from the library.

2 Certain types deﬁned in Clause 27 are used to describe implementation-deﬁned types. They are based on

other types, but with added constraints.
17.5.2.1.2 Enumerated types

[enumerated.types]
1 Several types deﬁned in Clause 27 are enumerated types. Each enumerated type may be implemented as an

enumeration or as a synonym for an enumeration.166

2 The enumerated type enumerated can be written:
enum enumerated { V0, V1, V2, V3, ..... };

static const enumerated C0 (V0);
static const enumerated C1 (V1);
static const enumerated C2 (V2);
static const enumerated C3 (V3);

.....

3 Here, the names C0, C1, etc. represent enumerated elements for this particular enumerated type. All such

elements have distinct values.
17.5.2.1.3 Bitmask types

[bitmask.types]
1 Several types deﬁned in Clauses 18 through 30 and Annex D are bitmask types. Each bitmask type can be im-
plemented as an enumerated type that overloads certain operators, as an integer type, or as a bitset (20.6).

2 The bitmask type bitmask can be written:

// For exposition only.
// int_type is an integral type capable of
// representing all values of the bitmask type.
enum bitmask : int_type {

V0 = 1 << 0, V1 = 1 << 1, V2 = 1 << 2, V3 = 1 << 3, .....

};

constexpr bitmask C0(V0);
constexpr bitmask C1(V1);

165) Examples from 17.6.3 include: EqualityComparable, LessThanComparable, CopyConstructible. Examples from 24.2 in-
clude: InputIterator, ForwardIterator, Function, Predicate.
166) Such as an integer type, with constant integer values (3.9.1).

§ 17.5.2.1.3

445

c(cid:13) ISO/IEC

constexpr bitmask C2(V2);
constexpr bitmask C3(V3);

.....

N4296

constexpr bitmask operator&(bitmask X, bitmask Y) {

return static_cast<bitmask >(

static_cast<int_type>(X) & static_cast<int_type>(Y));

}
constexpr bitmask operator|(bitmask X, bitmask Y) {

return static_cast<bitmask >(

static_cast<int_type>(X) | static_cast<int_type>(Y));

}
constexpr bitmask operator^(bitmask X, bitmask Y){

return static_cast<bitmask >(

static_cast<int_type>(X) ^ static_cast<int_type>(Y));

}
constexpr bitmask operator~(bitmask X){

return static_cast<bitmask >(~static_cast<int_type>(X));

}
bitmask & operator&=(bitmask & X, bitmask Y){

X = X & Y; return X;

}
bitmask & operator|=(bitmask & X, bitmask Y) {

X = X | Y; return X;

}
bitmask & operator^=(bitmask & X, bitmask Y) {

X = X ^ Y; return X;

}

3 Here, the names C0, C1, etc. represent bitmask elements for this particular bitmask type. All such elements
have distinct, nonzero values such that, for any pair Ci and Cj where i != j, Ci & Ci is nonzero and Ci &
Cj is zero. Additionally, the value 0 is used to represent an empty bitmask, in which no bitmask elements
are set.

4 The following terms apply to objects and values of bitmask types:

(4.1)

(4.2)

(4.3)

—
—
—

To set a value Y in an object X is to evaluate the expression X |= Y.
To clear a value Y in an object X is to evaluate the expression X &= ~Y.
The value Y is set in the object X if the expression X & Y is nonzero.

17.5.2.1.4 Character sequences

[character.seq]
1 The C standard library makes widespread use of characters and character sequences that follow a few uniform

conventions:

(1.1)

(1.2)

—
—

A letter is any of the 26 lowercase or 26 uppercase letters in the basic execution character set.167
The decimal-point character is the (single-byte) character used by functions that convert between a
(single-byte) character sequence and a value of one of the ﬂoating-point types. It is used in the character
sequence to denote the beginning of a fractional part. It is represented in Clauses 18 through 30 and
Annex D by a period, ’.’, which is also its value in the "C" locale, but may change during program
execution by a call to setlocale(int, const char*),168 or by a change to a locale object, as
described in Clauses 22.3 and 27.

167) Note that this deﬁnition diﬀers from the deﬁnition in ISO C 7.1.1.
168) declared in <clocale> (22.6).

§ 17.5.2.1.4

446

c(cid:13) ISO/IEC

N4296

(1.3)

—

A character sequence is an array object (8.3.4) A that can be declared as T A [N ], where T is any of
the types char, unsigned char, or signed char (3.9.1), optionally qualiﬁed by any combination of
const or volatile. The initial elements of the array have deﬁned contents up to and including an
element determined by some predicate. A character sequence can be designated by a pointer value S
that points to its ﬁrst element.

17.5.2.1.4.1 Byte strings

[byte.strings]
1 A null-terminated byte string, or ntbs, is a character sequence whose highest-addressed element with deﬁned
content has the value zero (the terminating null character); no other element in the sequence has the value
zero.169

2 The length of an ntbs is the number of elements that precede the terminating null character. An empty

ntbs has a length of zero.

3 The value of an ntbs is the sequence of values of the elements up to and including the terminating null

character.

4 A static ntbs is an ntbs with static storage duration.170

17.5.2.1.4.2 Multibyte strings

[multibyte.strings]
1 A null-terminated multibyte string, or ntmbs, is an ntbs that constitutes a sequence of valid multibyte

characters, beginning and ending in the initial shift state.171

2 A static ntmbs is an ntmbs with static storage duration.

2

17.5.2.2 Functions within classes

[functions.within.classes]
1 For the sake of exposition, Clauses 18 through 30 and Annex D do not describe copy/move constructors,
assignment operators, or (non-virtual) destructors with the same apparent semantics as those that can be
generated by default (12.1, 12.4, 12.8).
It is unspeciﬁed whether the implementation provides explicit deﬁnitions for such member function signa-
tures, or for virtual destructors that can be generated by default.
17.5.2.3 Private members

[objects.within.classes]
1 Clauses 18 through 30 and Annex D do not specify the representation of classes, and intentionally omit
speciﬁcation of class members (9.2). An implementation may deﬁne static or non-static class members, or
both, as needed to implement the semantics of the member functions speciﬁed in Clauses 18 through 30 and
Annex D.

2 Objects of certain classes are sometimes required by the external speciﬁcations of their classes to store data,
apparently in member objects. For the sake of exposition, some subclauses provide representative declara-
tions, and semantic requirements, for private member objects of classes that meet the external speciﬁcations
of the classes. The declarations for such member objects and the deﬁnitions of related member types are
followed by a comment that ends with exposition only, as in:

streambuf* sb; // exposition only

3 An implementation may use any technique that provides equivalent external behavior.

169) Many of the objects manipulated by function signatures declared in <cstring> (21.8) are character sequences or ntbss.
The size of some of these character sequences is limited by a length value, maintained separately from the character sequence.
170) A string literal, such as "abc", is a static ntbs.
171) An ntbs that contains characters only from the basic execution character set is also an ntmbs. Each multibyte character
then consists of a single byte.

§ 17.5.2.3

447

c(cid:13) ISO/IEC

N4296

17.6 Library-wide requirements

[requirements]
1 This subclause speciﬁes requirements that apply to the entire C++ standard library. Clauses 18 through 30

and Annex D specify the requirements of individual entities within the library.

2 Requirements speciﬁed in terms of interactions between threads do not apply to programs having only a

single thread of execution.

3 Within this subclause, 17.6.1 describes the library’s contents and organization, 17.6.2 describes how well-
formed C++ programs gain access to library entities, 17.6.3 describes constraints on types and functions
used with the C++ standard library, 17.6.4 describes constraints on well-formed C++ programs, and 17.6.5
describes constraints on conforming implementations.
17.6.1 Library contents and organization

[organization]
1 17.6.1.1 describes the entities deﬁned in the C++ standard library. 17.6.1.2 lists the standard library headers
and some constraints on those headers. 17.6.1.3 lists requirements for a freestanding implementation of the
C++ standard library.
17.6.1.1 Library contents

[contents]
1 The C++ standard library provides deﬁnitions for the following types of entities: macros, values, types,

templates, classes, functions, objects.

2 All library entities except macros, operator new and operator delete are deﬁned within the namespace
std or namespaces nested within namespace std.172 It is unspeciﬁed whether names declared in a speciﬁc
namespace are declared directly in that namespace or in an inline namespace inside that namespace.173

3 Whenever a name x deﬁned in the standard library is mentioned, the name x is assumed to be fully qualiﬁed
as ::std::x, unless explicitly described otherwise. For example, if the Eﬀects section for library function F
is described as calling library function G, the function ::std::G is meant.
17.6.1.2 Headers

[headers]

1 Each element of the C++ standard library is declared or deﬁned (as appropriate) in a header.174
2 The C++ standard library provides 53 C++ library headers, as shown in Table 14.

Table 14 — C++ library headers

<algorithm>
<array>
<atomic>
<bitset>
<chrono>
<codecvt>
<complex>
<condition_variable>
<deque>
<exception>
<forward_list>

<fstream>
<functional>
<future>
<initializer_list>
<iomanip>
<ios>
<iosfwd>
<iostream>
<istream>
<iterator>
<limits>

<list>
<locale>
<map>
<memory>
<mutex>
<new>
<numeric>
<ostream>
<queue>
<random>
<ratio>

<regex>
<scoped_allocator>
<set>
<sstream>
<stack>
<stdexcept>
<streambuf>
<string>
<strstream>
<system_error>
<thread>

<tuple>
<type_traits>
<typeindex>
<typeinfo>
<unordered_map>
<unordered_set>
<utility>
<valarray>
<vector>

3 The facilities of the C standard Library are provided in 26 additional headers, as shown in Table 15.
4 Except as noted in Clauses 18 through 30 and Annex D, the contents of each header cname shall be the same
as that of the corresponding header name.h, as speciﬁed in the C standard library (1.2) or the C Unicode
172) The C standard library headers (Annex D.5) also deﬁne names within the global namespace, while the C++ headers for C

§ 17.6.1.2

448

c(cid:13) ISO/IEC

N4296

Table 15 — C++ headers for C library facilities

<cassert>
<ccomplex>
<cctype>
<cerrno>
<cfenv>
<cfloat>

<cinttypes>
<ciso646>
<climits>
<clocale>
<cmath>
<csetjmp>

<csignal>
<cstdalign>
<cstdarg>
<cstdbool>
<cstddef>
<cstdint>

<cstdio>
<cstdlib>
<cstring>
<ctgmath>
<ctime>
<cuchar>

<cwchar>
<cwctype>

TR, as appropriate, as if by inclusion. In the C++ standard library, however, the declarations (except for
names which are deﬁned as macros in C) are within namespace scope (3.3.6) of the namespace std. It is
unspeciﬁed whether these names are ﬁrst declared within the global namespace scope and are then injected
into namespace std by explicit using-declarations (7.3.3).

5 Names which are deﬁned as macros in C shall be deﬁned as macros in the C++ standard library, even if
[ Note: The names deﬁned as macros in C include the

C grants license for implementation as functions.
following: assert, offsetof, setjmp, va_arg, va_end, and va_start. — end note ]

6 Names that are deﬁned as functions in C shall be deﬁned as functions in the C++ standard library.175
7

Identiﬁers that are keywords or operators in C++ shall not be deﬁned as macros in C++ standard library
headers.176

8 D.5, C standard library headers, describes the eﬀects of using the name.h (C header) form in a C++ pro-

gram.177
17.6.1.3 Freestanding implementations

[compliance]
1 Two kinds of implementations are deﬁned: hosted and freestanding (1.4). For a hosted implementation, this

International Standard describes the set of available headers.

2 A freestanding implementation has an implementation-deﬁned set of headers. This set shall include at least

the headers shown in Table 16.

3 The supplied version of the header <cstdlib> shall declare at least the functions abort, atexit, at_quick_-
exit, exit, and quick_exit (18.5). The other headers listed in this table shall meet the same requirements
as for a hosted implementation.
17.6.2 Using the library
17.6.2.1 Overview

[using]
[using.overview]
1 This section describes how a C++ program gains access to the facilities of the C++ standard library. 17.6.2.2

describes eﬀects during translation phase 4, while 17.6.2.3 describes eﬀects during phase 8 (2.2).
17.6.2.2 Headers

[using.headers]
1 The entities in the C++ standard library are deﬁned in headers, whose contents are made available to a

translation unit when it contains the appropriate #include preprocessing directive (16.2).

library facilities (17.6.1.2) may also deﬁne names within the global namespace.
173) This gives implementers freedom to use inline namespaces to support multiple conﬁgurations of the library.
174) A header is not necessarily a source ﬁle, nor are the sequences delimited by < and > in header names necessarily valid
source ﬁle names (16.2).
175) This disallows the practice, allowed in C, of providing a masking macro in addition to the function prototype. The only
way to achieve equivalent inline behavior in C++ is to provide a deﬁnition as an extern inline function.
176) In particular, including the standard header <iso646.h> or <ciso646> has no eﬀect.
177) The ".h" headers dump all their names into the global namespace, whereas the newer forms keep their names in namespace
std. Therefore, the newer forms are the preferred forms for all uses except for C++ programs which are intended to be strictly
compatible with C.

§ 17.6.2.2

449

c(cid:13) ISO/IEC

N4296

Table 16 — C++ headers for freestanding implementations

Subclause

Types
Implementation properties
Integer types
Start and termination
Dynamic memory management
Type identiﬁcation
Exception handling
Initializer lists

18.2
18.3
18.4
18.5
18.6
18.7
18.8
18.9
18.10 Other runtime support
20.10 Type traits
29

Atomics

Header(s)
<ciso646>
<cstddef>
<cfloat> <limits> <climits>
<cstdint>
<cstdlib>
<new>
<typeinfo>
<exception>
<initializer_list>
<cstdalign> <cstdarg> <cstdbool>
<type_traits>
<atomic>

2 A translation unit may include library headers in any order (Clause 2). Each may be included more than
once, with no eﬀect diﬀerent from being included exactly once, except that the eﬀect of including either
<cassert> or <assert.h> depends each time on the lexically current deﬁnition of NDEBUG.178

3 A translation unit shall include a header only outside of any external declaration or deﬁnition, and shall
include the header lexically before the ﬁrst reference in that translation unit to any of the entities declared
in that header. No diagnostic is required.
17.6.2.3 Linkage

[using.linkage]
1 Entities in the C++ standard library have external linkage (3.5). Unless otherwise speciﬁed, objects and

functions have the default extern "C++" linkage (7.5).

2 Whether a name from the C standard library declared with external linkage has extern "C" or extern
It is recommended that an implementation use extern "C++"

"C++" linkage is implementation-deﬁned.
linkage for this purpose.179

3 Objects and functions deﬁned in the library and required by a C++ program are included in the program

prior to program startup.
See also: replacement functions (17.6.4.6), run-time changes (17.6.4.7).
17.6.3 Requirements on types and expressions

[utility.requirements]
1 17.6.3.1 describes requirements on types and expressions used to instantiate templates deﬁned in the C++
standard library. 17.6.3.2 describes the requirements on swappable types and swappable expressions. 17.6.3.3
describes the requirements on pointer-like types that support null values. 17.6.3.4 describes the requirements
on hash function objects. 17.6.3.5 describes the requirements on storage allocators.
17.6.3.1 Template argument requirements

[utility.arg.requirements]
1 The template deﬁnitions in the C++ standard library refer to various named requirements whose details are
set out in tables 17–24. In these tables, T is an object or reference type to be supplied by a C++ program
instantiating a template; a, b, and c are values of type (possibly const) T; s and t are modiﬁable lvalues of
type T; u denotes an identiﬁer; rv is an rvalue of type T; and v is an lvalue of type (possibly const) T or an
rvalue of type const T.
178) This is the same as the Standard C library.
179) The only reliable way to declare an object or function signature from the Standard C library is by including the header
that declares it, notwithstanding the latitude granted in 7.1.4 of the C Standard.

§ 17.6.3.1

450

c(cid:13) ISO/IEC

N4296

2

In general, a default constructor is not required. Certain container class member function signatures specify
T() as a default argument. T() shall be a well-deﬁned expression (8.5) if one of those signatures is called
using the default argument (8.3.6).

Table 17 — EqualityComparable requirements [equalitycomparable]

Expression
a == b

Return type
convertible to
bool

Requirement

== is an equivalence relation, that is, it has the
following properties:

— For all a, a == a.
— If a == b, then b == a.
— If a == b and b == c, then a == c.

Table 18 — LessThanComparable requirements [lessthancomparable]

Expression
a < b

Return type
convertible to
bool

Requirement
< is a strict weak ordering relation (25.4)

Table 19 — DefaultConstructible requirements [defaultconstructible]

Expression
T t;
T u{};
T()
T{}

Post-condition
object t is default-initialized
object u is value-initialized or aggregate-initialized
a temporary object of type T is value-initialized or
aggregate-initialized

Table 20 — MoveConstructible requirements [moveconstructible]

Post-condition
u is equivalent to the value of rv before the construction
T(rv) is equivalent to the value of rv before the construction

Expression
T u = rv;
T(rv)
rv’s state is unspeciﬁed [ Note:rv must still meet the requirements of the library compo-
nent that is using it. The operations listed in those requirements must work as speciﬁed
whether rv has been moved from or not. — end note ]

Table 21 — CopyConstructible requirements (in addition to MoveConstructible) [copyconstructible]

Expression
T u = v;
T(v)

Post-condition
the value of v is unchanged and is equivalent to u
the value of v is unchanged and is equivalent to T(v)

§ 17.6.3.1

451

c(cid:13) ISO/IEC

N4296

Table 22 — MoveAssignable requirements [moveassignable]

Expression
t = rv

Return type
T&

Return value
t

Post-condition
t is equivalent to the value of
rv before the assignment

rv’s state is unspeciﬁed.
[ Note: rv must still meet the requirements of the library
component that is using it. The operations listed in those requirements must work as
speciﬁed whether rv has been moved from or not. — end note ]

Table 23 — CopyAssignable requirements (in addition to MoveAssignable) [copyassignable]

Expression
t = v

Return type
T&

Return value
t

Post-condition
t is equivalent to v, the value of
v is unchanged

Table 24 — Destructible requirements [destructible]

Expression
u.~T()

Post-condition
All resources owned by u are reclaimed, no exception is propagated.

17.6.3.2 Swappable requirements

[swappable.requirements]
1 This subclause provides deﬁnitions for swappable types and expressions. In these deﬁnitions, let t denote

an expression of type T, and let u denote an expression of type U.

2 An object t is swappable with an object u if and only if:

(2.1)

(2.2)
(2.2.1)

(2.2.2)

—

—

the expressions swap(t, u) and swap(u, t) are valid when evaluated in the context described below,
and
these expressions have the following eﬀects:
—
—

the object referred to by t has the value originally held by u and
the object referred to by u has the value originally held by t.

3 The context in which swap(t, u) and swap(u, t) are evaluated shall ensure that a binary non-member

function named “swap” is selected via overload resolution (13.3) on a candidate set that includes:

(3.1)

(3.2)

—
—

the two swap function templates deﬁned in <utility> (20.2) and
the lookup set produced by argument-dependent lookup (3.4.2).

[ Note: If T and U are both fundamental types or arrays of fundamental types and the declarations from the
header <utility> are in scope, the overall lookup set described above is equivalent to that of the qualiﬁed
name lookup applied to the expression std::swap(t, u) or std::swap(u, t) as appropriate. — end note ]
[ Note: It is unspeciﬁed whether a library component that has a swappable requirement includes the header
<utility> to ensure an appropriate evaluation context. — end note ]

4 An rvalue or lvalue t is swappable if and only if t is swappable with any rvalue or lvalue, respectively, of

type T.

5 A type X satisfying any of the iterator requirements (24.2) satisﬁes the requirements of ValueSwappable if,

for any dereferenceable object x of type X, *x is swappable.
[ Example: User code can ensure that the evaluation of swap calls is performed in an appropriate context
under the various conditions as follows:

§ 17.6.3.2

452

c(cid:13) ISO/IEC

#include <utility>

N4296

// Requires: std::forward<T>(t) shall be swappable with std::forward<U>(u).
template <class T, class U>
void value_swap(T&& t, U&& u) {

using std::swap;
swap(std::forward<T>(t), std::forward<U>(u)); // OK: uses “swappable with” conditions

// for rvalues and lvalues

}

}

// Requires: lvalues of T shall be swappable.
template <class T>
void lv_swap(T& t1 T& t2) {

using std::swap;
swap(t1, t2);

namespace N {

struct A { int m; };
struct Proxy { A* a; };
Proxy proxy(A& a) { return Proxy{ &a }; }

void swap(A& x, Proxy p) {
std::swap(x.m, p.a->m);

}
void swap(Proxy p, A& x) { swap(x, p); }

}

int main() {

int i = 1, j = 2;
lv_swap(i, j);
assert(i == 2 && j == 1);

N::A a1 = { 5 }, a2 = { -5 };
value_swap(a1, proxy(a2));
assert(a1.m == -5 && a2.m == 5);

}

// OK: uses swappable conditions for
// lvalues of type T

// OK: uses context equivalent to swappable
// conditions for fundamental types

// satisfy symmetry constraint

— end example ]
17.6.3.3 NullablePointer requirements

[nullablepointer.requirements]
1 A NullablePointer type is a pointer-like type that supports null values. A type P meets the requirements

of NullablePointer if:

(1.1)

(1.2)

(1.3)

(1.4)

—

—
—
—

P satisﬁes the requirements of EqualityComparable, DefaultConstructible, CopyConstructible,
CopyAssignable, and Destructible,
lvalues of type P are swappable (17.6.3.2),
the expressions shown in Table 25 are valid and have the indicated semantics, and
P satisﬁes all the other requirements of this subclause.

2 A value-initialized object of type P produces the null value of the type. The null value shall be equivalent
[ Note: Operations

only to itself. A default-initialized object of type P may have an indeterminate value.
involving indeterminate values may cause undeﬁned behavior. — end note ]

§ 17.6.3.3

453

c(cid:13) ISO/IEC

N4296

3 An object p of type P can be contextually converted to bool (Clause 4). The eﬀect shall be as if p !=

nullptr had been evaluated in place of p.

4 No operation which is part of the NullablePointer requirements shall exit via an exception.
5

In Table 25, u denotes an identiﬁer, t denotes a non-const lvalue of type P, a and b denote values of type
(possibly const) P, and np denotes a value of type (possibly const) std::nullptr_t.

Table 25 — NullablePointer requirements [nullablepointer]

Expression Return type
P u(np);
P u = np;
P(np)
t = np
a != b
a == np
np == a
a != np
np != a

P&
contextually convertible to bool
contextually convertible to bool

contextually convertible to bool

Operational semantics
post: u == nullptr

post: P(np) == nullptr
post: t == nullptr
!(a == b)
a == P()

!(a == np)

17.6.3.4 Hash requirements

[hash.requirements]

(1.1)

(1.2)

1 A type H meets the Hash requirements if:
it is a function object type (20.9),
it satisﬁes the requirements of CopyConstructible and Destructible (17.6.3.1), and
the expressions shown in Table 26 are valid and have the indicated semantics.

—
—
—

(1.3)

2 Given Key is an argument type for function objects of type H, in Table 26 h is a value of type (possibly

const) H, u is an lvalue of type Key, and k is a value of a type convertible to (possibly const) Key.

Table 26 — Hash requirements [hash]

Expression Return type Requirement
h(k)

size_t

The value returned shall depend only on the argument k
for the duration of the program.
[ Note: Thus all eval-
uations of the expression h(k) with the same value for
k yield the same result for a given execution of the pro-
gram. — end note ] [ Note: For two diﬀerent values t1
and t2, the probability that h(t1) and h(t2) compare
equal should be very small, approaching 1.0 / numeric_-
limits<size_t>::max(). — end note ]
Shall not modify u.

h(u)

size_t

17.6.3.5 Allocator requirements

[allocator.requirements]
1 The library describes a standard set of requirements for allocators, which are class-type objects that encap-
sulate the information about an allocation model. This information includes the knowledge of pointer types,
the type of their diﬀerence, the type of the size of objects in this allocation model, as well as the memory al-
location and deallocation primitives for it. All of the string types (Clause 21), containers (Clause 23) (except
array), string buﬀers and string streams (Clause 27), and match_results (Clause 28) are parameterized in
terms of allocators.

§ 17.6.3.5

454

c(cid:13) ISO/IEC

N4296

2 The template struct allocator_traits (20.7.8) supplies a uniform interface to all allocator types. Table 27
describes the types manipulated through allocators. Table 28 describes the requirements on allocator types
and thus on types used to instantiate allocator_traits. A requirement is optional if the last column of
Table 28 speciﬁes a default for a given expression. Within the standard library allocator_traits template,
an optional requirement that is not supplied by an allocator is replaced by the speciﬁed default expression.
A user specialization of allocator_traits may provide diﬀerent defaults and may provide defaults for
diﬀerent requirements than the primary template. Within Tables 27 and 28, the use of move and forward
always refers to std::move and std::forward, respectively.

Table 27 — Descriptive variable deﬁnitions

Deﬁnition

any non-const object type (3.9)
a type convertible to T
an Allocator class for type T
the corresponding Allocator class for type U
the type allocator_traits<X>
the type allocator_traits<Y>
a value of type const T&
values of type X&
an rvalue of type X
a value of type Y
a pointer of type C* through which indirection is valid
a value of type XX::pointer, obtained by calling
a1.allocate, where a1 == a
a value of type XX::const_pointer obtained by
conversion from a value p.
a value of type XX::void_pointer obtained by conversion
from a value p
a value of type XX::const_void_pointer obtained by
conversion from a value q or a value w
a value of type T& obtained by the expression *p.
a value of type const T& obtained by the expression *q or
by conversion from a value r.
a value of type XX:const_void_pointer obtained by
conversion from a result value of YY::allocate, or else a
value of type (possibly const) std::nullptr_t.
a value of type V
a value of type XX::size_type.
a template parameter pack
a function parameter pack with the pattern Args&&

Variable
T, U, C
V
X
Y
XX
YY
t
a, a1, a2
a3
b
c
p

q

w

z

r
s

u

v
n
Args
args

Table 28 — Allocator requirements

Expression

Return type

X::pointer

§ 17.6.3.5

Assertion/note

pre-/post-condition

Default

T*

455

c(cid:13) ISO/IEC

N4296

Table 28 — Allocator requirements (continued)

Expression

Return type

X::const_pointer

X::void_pointer
Y::void_pointer

X::const_void_-
pointer
Y::const_void_-
pointer

X::value_type
X::size_type

Identical to T
unsigned integer type

X::difference_type

signed integer type

typename
X::template
rebind<U>::other
*p
*q

p->m

q->m

static_-
cast<X::pointer>(w)
static_cast<X
::const_pointer>(z)

Y

T&
const T&

type of T::m

type of T::m

X::pointer

X::const_pointer

Default

pointer_-
traits<X::
pointer>::
rebind<const
T>
pointer_-
traits<X::
pointer>::
rebind<void>

pointer_-
traits<X::
pointer>::
rebind<const
void>

make_-
unsigned_-
t<X::
difference_-
type>
pointer_-
traits<X::
pointer>::
difference_-
type
See Note A,
below.

Assertion/note

pre-/post-condition
X::pointer is convertible to
X::const_pointer

X::pointer is convertible to
X::void_pointer.
X::void_pointer and
Y::void_pointer are the same
type.
X::pointer,
X::const_pointer, and
X::void_pointer are
convertible to
X::const_void_pointer.
X::const_void_pointer and
Y::const_void_pointer are
the same type.

a type that can represent the
size of the largest object in the
allocation model.

a type that can represent the
diﬀerence between any two
pointers in the allocation
model.

For all U (including T),
Y::template
rebind<T>::other is X.

*q refers to the same object as
*p
pre: (*p).m is well-deﬁned.
equivalent to (*p).m
pre: (*q).m is well-deﬁned.
equivalent to (*q).m
static_cast<X::pointer>(w)
== p
static_cast<X
::const_pointer>(z) == q

§ 17.6.3.5

456

c(cid:13) ISO/IEC

Table 28 — Allocator requirements (continued)

Expression

Return type

a.allocate(n)

X::pointer

a.allocate(n, u)

X::pointer

a.deallocate(p,n)

(not used)

a.max_size()

X::size_type

a1 == a2

bool

bool
bool

bool

a1 != a2
a == b

a != b
X a1(a);
X a1 = a;
X a(b);

X a1(move(a));
X a1 = move(a);

X a(move(b));

a.construct(c,
args)

(not used)

§ 17.6.3.5

Assertion/note

pre-/post-condition
Memory is allocated for n
objects of type T but objects
are not constructed. allocate
may raise an appropriate
exception.180[ Note: If n == 0,
the return value is unspeciﬁed.
— end note ]
Same as a.allocate(n). The
use of u is unspeciﬁed, but it is
intended as an aid to locality.
All n T objects in the area
pointed to by p shall be
destroyed prior to this call. n
shall match the value passed to
allocate to obtain this
memory. Does not throw
exceptions. [ Note:p shall not be
singular. — end note ]
the largest value that can
meaningfully be passed to
X::allocate()
returns true only if storage
allocated from each can be
deallocated via the other.
operator== shall be reﬂexive,
symmetric, and transitive, and
shall not exit via an exception.
same as !(a1 == a2)
same as a ==
Y::rebind<T>::other(b)
same as !(a == b)
Shall not exit via an exception.
post: a1 == a
Shall not exit via an exception.
post: Y(a) == b, a == X(b)
Shall not exit via an exception.
post: a1 equals the prior value
of a.
Shall not exit via an exception.
post: a equals the prior value of
X(b).
Eﬀect: Constructs an object of
type C at c

N4296

Default

a.allocate(n)

numeric_-
limits<size_-
type>::max()

::new
((void*)c)
C(forward<
Args>
(args)...)

457

c(cid:13) ISO/IEC

N4296

Table 28 — Allocator requirements (continued)

Expression

Return type

a.destroy(c)
a.select_on_-
container_copy_-
construction()
X::propagate_on_-
container_copy_-
assignment

(not used)
X

Identical to or derived
from true_type or
false_type

X::propagate_on_-
container_move_-
assignment

Identical to or derived
from true_type or
false_type

X::propagate_on_-
container_swap

X::is_always_equal

Identical to or derived
from true_type or
false_type

Identical to or derived
from true_type or
false_type

Assertion/note

pre-/post-condition

Eﬀect: Destroys the object at c
Typically returns either a or
X()

true_type only if an allocator
of type X should be copied when
the client container is
copy-assigned. See Note B,
below.
true_type only if an allocator
of type X should be moved
when the client container is
move-assigned. See Note B,
below.
true_type only if an allocator
of type X should be swapped
when the client container is
swapped. See Note B, below.
true_type only if the
expression a1 == a2 is
guaranteed to be true for any
two (possibly const) values a1,
a2 of type X.

Default

c->~C()
return a;

false_type

false_type

false_type

is_empty<X>

3 Note A: The member class template rebind in the table above is eﬀectively a typedef template. [ Note: In
general, if the name Allocator is bound to SomeAllocator<T>, then Allocator::rebind<U>::other is the
same type as SomeAllocator<U>, where SomeAllocator<T>::value_type is T and SomeAllocator<U>::
value_type is U. — end note ] If Allocator is a class template instantiation of the form SomeAllocator<T,
Args>, where Args is zero or more type arguments, and Allocator does not supply a rebind member
template, the standard allocator_traits template uses SomeAllocator<U, Args> in place of Allocator::
rebind<U>::other by default. For allocator types that are not template instantiations of the above form,
no default is provided.

4 Note B: If X::propagate_on_container_copy_assignment::value is true, X shall satisfy the CopyAssignable

requirements (Table 23) and the copy operation shall not throw exceptions. If X::propagate_on_container_-
move_assignment::value is true, X shall satisfy the MoveAssignable requirements (Table 22) and the move
operation shall not throw exceptions. If X::propagate_on_container_swap::value is true, lvalues of type
X shall be swappable (17.6.3.2) and the swap operation shall not throw exceptions.

5 An allocator type X shall satisfy the requirements of CopyConstructible (17.6.3.1). The X::pointer,
X::const_pointer, X::void_pointer, and X::const_void_pointer types shall satisfy the requirements
of NullablePointer (17.6.3.3). No constructor, comparison operator, copy operation, move operation, or
swap operation on these types shall exit via an exception. X::pointer and X::const_pointer shall also
satisfy the requirements for a random access iterator (24.2).
180) It is intended that a.allocate be an eﬃcient means of allocating a single object of type T, even when sizeof(T) is small.
That is, there is no need for a container to maintain its own free list.

§ 17.6.3.5

458

c(cid:13) ISO/IEC

N4296

6 Let x1 and x2 denote objects of (possibly diﬀerent) types X::void_pointer, X::const_void_pointer,
X::pointer, or X::const_pointer. Then, x1 and x2 are equivalently-valued pointer values, if and only if
both x1 and x2 can be explicitly converted to the two corresponding objects px1 and px2 of type X::const_-
pointer, using a sequence of static_casts using only these four types, and the expression px1 == px2
evaluates to true.

7 Let w1 and w2 denote objects of type X::void_pointer. Then for the expressions

w1 == w2
w1 != w2

either or both objects may be replaced by an equivalently-valued object of type X::const_void_pointer
with no change in semantics.

8 Let p1 and p2 denote objects of type X::pointer. Then for the expressions

p1 == p2
p1 != p2
p1 < p2
p1 <= p2
p1 >= p2
p1 > p2
p1 - p2

either or both objects may be replaced by an equivalently-valued object of type X::const_pointer with no
change in semantics.

9 An allocator may constrain the types on which it can be instantiated and the arguments for which its
construct member may be called. If a type cannot be used with a particular allocator, the allocator class
or the call to construct may fail to instantiate.
[ Example: the following is an allocator class template supporting the minimal interface that satisﬁes the
requirements of Table 28:

template <class Tp>
struct SimpleAllocator {
typedef Tp value_type;
SimpleAllocator(ctor args );

template <class T> SimpleAllocator(const SimpleAllocator<T>& other);

Tp* allocate(std::size_t n);
void deallocate(Tp* p, std::size_t n);

};

template <class T, class U>
bool operator==(const SimpleAllocator<T>&, const SimpleAllocator<U>&);
template <class T, class U>
bool operator!=(const SimpleAllocator<T>&, const SimpleAllocator<U>&);

10

— end example ]
If the alignment associated with a speciﬁc over-aligned type is not supported by an allocator, instantiation
of the allocator for that type may fail. The allocator also may silently ignore the requested alignment.
[ Note: Additionally, the member function allocate for that type may fail by throwing an object of type
std::bad_alloc. — end note ]

§ 17.6.3.5

459

c(cid:13) ISO/IEC

N4296

17.6.4 Constraints on programs
17.6.4.1 Overview

[constraints]
[constraints.overview]
1 This section describes restrictions on C++ programs that use the facilities of the C++ standard library.
The following subclauses specify constraints on the program’s use of namespaces (17.6.4.2.1), its use of
various reserved names (17.6.4.3), its use of headers (17.6.4.4), its use of standard library classes as base
classes (17.6.4.5), its deﬁnitions of replacement functions (17.6.4.6), and its installation of handler functions
during execution (17.6.4.7).
17.6.4.2 Namespace use
17.6.4.2.1 Namespace std

[namespace.constraints]
[namespace.std]
1 The behavior of a C++ program is undeﬁned if it adds declarations or deﬁnitions to namespace std or to a
namespace within namespace std unless otherwise speciﬁed. A program may add a template specialization
for any standard library template to namespace std only if the declaration depends on a user-deﬁned type
and the specialization meets the standard library requirements for the original template and is not explicitly
prohibited.181

2 The behavior of a C++ program is undeﬁned if it declares

(2.1)

(2.2)

(2.3)

—
—

—

an explicit specialization of any member function of a standard library class template, or
an explicit specialization of any member function template of a standard library class or class template,
or
an explicit or partial specialization of any member class template of a standard library class or class
template.

A program may explicitly instantiate a template deﬁned in the standard library only if the declaration
depends on the name of a user-deﬁned type and the instantiation meets the standard library requirements
for the original template.

3 A translation unit shall not declare namespace std to be an inline namespace (7.3.1).

17.6.4.2.2 Namespace posix

[namespace.posix]
1 The behavior of a C++ program is undeﬁned if it adds declarations or deﬁnitions to namespace posix or to
a namespace within namespace posix unless otherwise speciﬁed. The namespace posix is reserved for use
by ISO/IEC 9945 and other POSIX standards.
17.6.4.3 Reserved names

[reserved.names]

1 The C++ standard library reserves the following kinds of names:

(1.1)

(1.2)

(1.3)

2

—
—
—

macros
global names
names with external linkage

If a program declares or deﬁnes a name in a context where it is reserved, other than as explicitly allowed by
this Clause, its behavior is undeﬁned.
181) Any library code that instantiates other library templates must be prepared to work adequately with any user-supplied
specialization that meets the minimum requirements of the Standard.

§ 17.6.4.3

460

c(cid:13) ISO/IEC

N4296

17.6.4.3.1 Macro names

[macro.names]
1 A translation unit that includes a standard library header shall not #define or #undef names declared in

any standard library header.

2 A translation unit shall not #define or #undef names lexically identical to keywords, to the identiﬁers listed

in Table 2, or to the attribute-tokens described in 7.6.
17.6.4.3.2 External linkage

[extern.names]
1 Each name declared as an object with external linkage in a header is reserved to the implementation to
designate that library object with external linkage,182 both in namespace std and in the global namespace.
2 Each global function signature declared with external linkage in a header is reserved to the implementation

to designate that function signature with external linkage. 183

3 Each name from the Standard C library declared with external linkage is reserved to the implementation

for use as a name with extern "C" linkage, both in namespace std and in the global namespace.

4 Each function signature from the Standard C library declared with external linkage is reserved to the
implementation for use as a function signature with both extern "C" and extern "C++" linkage, 184 or as
a name of namespace scope in the global namespace.
17.6.4.3.3 Types

[extern.types]
1 For each type T from the Standard C library,185 the types ::T and std::T are reserved to the implementation

and, when deﬁned, ::T shall be identical to std::T.
17.6.4.3.4 User-deﬁned literal suﬃxes

1

[usrlit.suﬃx]
1 Literal suﬃx identiﬁers (13.5.8) that do not start with an underscore are reserved for future standardization.
17.6.4.4 Headers
[alt.headers]
If a ﬁle with a name equivalent to the derived ﬁle name for one of the C++ standard library headers is not
provided as part of the implementation, and a ﬁle with that name is placed in any of the standard places
for a source ﬁle to be included (16.2), the behavior is undeﬁned.
17.6.4.5 Derived classes

[derived.classes]
1 Virtual member function signatures deﬁned for a base class in the C++ standard library may be overridden

in a derived class deﬁned in the program (10.3).
17.6.4.6 Replacement functions

[replacement.functions]
1 Clauses 18 through 30 and Annex D describe the behavior of numerous functions deﬁned by the C++ standard
library. Under some circumstances, however, certain of these function descriptions also apply to replacement
functions deﬁned in the program (17.3).

2 A C++ program may provide the deﬁnition for any of twelve dynamic memory allocation function signatures

declared in header <new> (3.7.4, 18.6):

(2.1)

(2.2)

—
—

operator new(std::size_t)

operator new(std::size_t, const std::nothrow_t&)

182) The list of such reserved names includes errno, declared or deﬁned in <cerrno>.
183) The list of such reserved function signatures with external linkage includes setjmp(jmp_buf), declared or deﬁned in
<csetjmp>, and va_end(va_list), declared or deﬁned in <cstdarg>.
184) The function signatures declared in <cuchar>, <cwchar>, and <cwctype> are always reserved, notwithstanding the restric-
tions imposed in subclause 4.5.1 of Amendment 1 to the C Standard for these headers.
185) These types are clock_t, div_t, FILE, fpos_t, lconv, ldiv_t, mbstate_t, ptrdiff_t, sig_atomic_t, size_t, time_t, tm,
va_list, wctrans_t, wctype_t, and wint_t.

§ 17.6.4.6

461

c(cid:13) ISO/IEC

N4296

(2.3)

(2.4)

(2.5)

(2.6)

(2.7)

(2.8)

(2.9)

(2.10)

(2.11)

(2.12)

—
—
—
—
—
—
—
—
—
—

operator new[](std::size_t)

operator new[](std::size_t, const std::nothrow_t&)

operator delete(void*)

operator delete(void*, const std::nothrow_t&)

operator delete[](void*)

operator delete[](void*, const std::nothrow_t&)

operator delete(void*, std::size_t)

operator delete(void*, std::size_t, const std::nothrow_t&)

operator delete[](void*, std::size_t)

operator delete[](void*, std::size_t, const std::nothrow_t&)

3 The program’s deﬁnitions are used instead of the default versions supplied by the implementation (18.6).
Such replacement occurs prior to program startup (3.2, 3.6). The program’s declarations shall not be
speciﬁed as inline. No diagnostic is required.
17.6.4.7 Handler functions

[handler.functions]

1 The C++ standard library provides default versions of the following handler functions (Clause 18):

(1.1)

(1.2)

—
—

unexpected_handler

terminate_handler

2 A C++ program may install diﬀerent handler functions during execution, by supplying a pointer to a function

deﬁned in the program or the library as an argument to (respectively):

(2.1)

(2.2)

(2.3)

—
—
—

set_new_handler

set_unexpected

set_terminate
See also: subclauses 18.6.2, Storage allocation errors, and 18.8, Exception handling.

3 A C++ program can get a pointer to the current handler function by calling the following functions:

(3.1)

(3.2)

(3.3)

—
—
—

get_new_handler

get_unexpected

get_terminate

4 Calling the set_* and get_* functions shall not incur a data race. A call to any of the set_* functions shall

synchronize with subsequent calls to the same set_* function and to the corresponding get_* function.

§ 17.6.4.7

462

c(cid:13) ISO/IEC

N4296

[res.on.functions]
17.6.4.8 Other functions
In certain cases (replacement functions, handler functions, operations on types used to instantiate standard
library template components), the C++ standard library depends on components supplied by a C++ pro-
gram. If these components do not meet their requirements, the Standard places no requirements on the
implementation.
In particular, the eﬀects are undeﬁned in the following cases:

1

2

(2.1)

(2.2)

(2.3)

(2.4)

(2.5)

—

—

—

—

—

for replacement functions (18.6.1), if the installed replacement function does not implement the se-
mantics of the applicable Required behavior: paragraph.
for handler functions (18.6.2.3, 18.8.3.1, D.8.1), if the installed handler function does not implement
the semantics of the applicable Required behavior: paragraph
for types used as template arguments when instantiating a template component, if the operations on
the type do not implement the semantics of the applicable Requirements subclause (17.6.3.5, 23.2,
24.2, 26.2). Operations on such types can report a failure by throwing an exception unless otherwise
speciﬁed.
if any replacement function or handler function or destructor operation exits via an exception, unless
speciﬁcally allowed in the applicable Required behavior: paragraph.
if an incomplete type (3.9) is used as a template argument when instantiating a template component,
unless speciﬁcally allowed for that component.

17.6.4.9 Function arguments

[res.on.arguments]
1 Each of the following applies to all arguments to functions deﬁned in the C++ standard library, unless

explicitly stated otherwise.

(1.1)

(1.2)

(1.3)

—

—

—

If an argument to a function has an invalid value (such as a value outside the domain of the function
or a pointer invalid for its intended use), the behavior is undeﬁned.
If a function argument is described as being an array, the pointer actually passed to the function shall
have a value such that all address computations and accesses to objects (that would be valid if the
pointer did point to the ﬁrst element of such an array) are in fact valid.
If a function argument binds to an rvalue reference parameter, the implementation may assume that
this parameter is a unique reference to this argument. [ Note: If the parameter is a generic parameter of
the form T&& and an lvalue of type A is bound, the argument binds to an lvalue reference (14.8.2.1) and
thus is not covered by the previous sentence. — end note ] [ Note: If a program casts an lvalue to an
xvalue while passing that lvalue to a library function (e.g. by calling the function with the argument
move(x)), the program is eﬀectively asking that function to treat that lvalue as a temporary. The
implementation is free to optimize away aliasing checks which might be needed if the argument was
an lvalue. — end note ]

17.6.4.10 Shared objects and the library

[res.on.objects]
1 The behavior of a program is undeﬁned if calls to standard library functions from diﬀerent threads may
introduce a data race. The conditions under which this may occur are speciﬁed in 17.6.5.9. [ Note: Modifying
an object of a standard library type that is shared between threads risks undeﬁned behavior unless objects
of that type are explicitly speciﬁed as being sharable without data races or the user supplies a locking
mechanism. — end note ]
[ Note: In particular, the program is required to ensure that completion of the constructor of any object of
a class type deﬁned in the standard library happens before any other member function invocation on that
object and, unless otherwise speciﬁed, to ensure that completion of any member function invocation other

2

§ 17.6.4.10

463

c(cid:13) ISO/IEC

N4296

than destruction on such an object happens before destruction of that object. This applies even to objects
such as mutexes intended for thread synchronization. — end note ]
17.6.4.11 Requires paragraph

[res.on.required]
1 Violation of the preconditions speciﬁed in a function’s Requires: paragraph results in undeﬁned behavior
unless the function’s Throws: paragraph speciﬁes throwing an exception when the precondition is violated.
17.6.5 Conforming implementations
[conforming]
[conforming.overview]
17.6.5.1 Overview
1 This section describes the constraints upon, and latitude of, implementations of the C++ standard library.
2 An implementation’s use of headers is discussed in 17.6.5.2, its use of macros in 17.6.5.3, global functions
in 17.6.5.4, member functions in 17.6.5.5, data race avoidance in 17.6.5.9, access speciﬁers in 17.6.5.10, class
derivation in 17.6.5.11, and exceptions in 17.6.5.12.
17.6.5.2 Headers

[res.on.headers]
1 A C++ header may include other C++ headers. A C++ header shall provide the declarations and deﬁnitions
that appear in its synopsis. A C++ header shown in its synopsis as including other C++ headers shall provide
the declarations and deﬁnitions that appear in the synopses of those other headers.

2 Certain types and macros are deﬁned in more than one header. Every such entity shall be deﬁned such that

any header that deﬁnes it may be included after any other header that also deﬁnes it (3.2).

3 The C standard headers (D.5) shall include only their corresponding C++ standard header, as described

in 17.6.1.2.
17.6.5.3 Restrictions on macro deﬁnitions

[res.on.macro.deﬁnitions]

1 The names and global function signatures described in 17.6.1.1 are reserved to the implementation.
2 All object-like macros deﬁned by the C standard library and described in this Clause as expanding to
integral constant expressions are also suitable for use in #if preprocessing directives, unless explicitly stated
otherwise.
17.6.5.4 Global and non-member functions
[global.functions]
It is unspeciﬁed whether any global or non-member functions in the C++ standard library are deﬁned as
inline (7.1.2).

1

2 A call to a global or non-member function signature described in Clauses 18 through 30 and Annex D shall

behave as if the implementation declared no additional global or non-member function signatures.186

3 An implementation shall not declare a global or non-member function signature with additional default

arguments.

4 Unless otherwise speciﬁed, global and non-member functions in the standard library shall not use functions
from another namespace which are found through argument-dependent name lookup (3.4.2).
[ Note: The
phrase “unless otherwise speciﬁed” is intended to allow argument-dependent lookup in cases like that of
ostream_iterator::operator= (24.6.2.2):
Eﬀects:

*out_stream << value;
if (delim != 0)

*out_stream << delim ;

return *this;

186) A valid C++ program always calls the expected library global or non-member function. An implementation may also
deﬁne additional global or non-member functions that would otherwise not be called by a valid C++ program.

§ 17.6.5.4

464

c(cid:13) ISO/IEC

N4296

— end note ]
17.6.5.5 Member functions
[member.functions]
It is unspeciﬁed whether any member functions in the C++ standard library are deﬁned as inline (7.1.2).

1
2 An implementation may declare additional non-virtual member function signatures within a class:

(2.1)

(2.2)

(2.3)

—

—

—

by adding arguments with default values to a member function signature;187 [ Note: An implementation
may not add arguments with default values to virtual, global, or non-member functions. — end note ]
by replacing a member function signature with default values by two or more member function signa-
tures with equivalent behavior; and
by adding a member function signature for a member function name.

3 A call to a member function signature described in the C++ standard library behaves as if the implementation

declares no additional member function signatures.188
17.6.5.6 constexpr functions and constructors

[constexpr.functions]
1 This standard explicitly requires that certain standard library functions are constexpr (7.1.5). An imple-
mentation shall not declare any standard library function signature as constexpr except for those where it
is explicitly required. Within any header that provides any non-deﬁning declarations of constexpr functions
or constructors an implementation shall provide corresponding deﬁnitions.
17.6.5.7 Requirements for stable algorithms

[algorithm.stable]

1 When the requirements for an algorithm state that it is “stable” without further elaboration, it means:

(1.1)

(1.2)

(1.3)

—
—
—

For the sort algorithms the relative order of equivalent elements is preserved.
For the remove and copy algorithms the relative order of the elements that are not removed is preserved.
For the merge algorithms, for equivalent elements in the original two ranges, the elements from the
ﬁrst range (preserving their original order) precede the elements from the second range (preserving
their original order).
17.6.5.8 Reentrancy

[reentrancy]
1 Except where explicitly speciﬁed in this standard, it is implementation-deﬁned which functions in the Stan-

dard C++ library may be recursively reentered.
17.6.5.9 Data race avoidance

[res.on.data.races]
1 This section speciﬁes requirements that implementations shall meet to prevent data races (1.10). Every
Implementations may

standard library function shall meet each requirement unless otherwise speciﬁed.
prevent data races in cases other than those speciﬁed below.

2 A C++ standard library function shall not directly or indirectly access objects (1.10) accessible by threads
other than the current thread unless the objects are accessed directly or indirectly via the function’s argu-
ments, including this.

3 A C++ standard library function shall not directly or indirectly modify objects (1.10) accessible by threads
other than the current thread unless the objects are accessed directly or indirectly via the function’s non-const
arguments, including this.
187) Hence, the address of a member function of a class in the C++ standard library has an unspeciﬁed type.
188) A valid C++ program always calls the expected library member function, or one with equivalent behavior. An implemen-
tation may also deﬁne additional member functions that would otherwise not be called by a valid C++ program.

§ 17.6.5.9

465

c(cid:13) ISO/IEC

N4296

4

[ Note: This means, for example, that implementations can’t use a static object for internal purposes without
synchronization because it could cause a data race even in programs that do not explicitly share objects
between threads. — end note ]

5 A C++ standard library function shall not access objects indirectly accessible via its arguments or via
elements of its container arguments except by invoking functions required by its speciﬁcation on those
container elements.

6 Operations on iterators obtained by calling a standard library container or string member function may
[ Note: In particular, container operations that

access the underlying container, but shall not modify it.
invalidate iterators conﬂict with operations on iterators associated with that container. — end note ]
Implementations may share their own internal objects between threads if the objects are not visible to users
and are protected against data races.

7

8 Unless otherwise speciﬁed, C++ standard library functions shall perform all operations solely within the

9

1

current thread if those operations have eﬀects that are visible (1.10) to users.
[ Note: This allows implementations to parallelize operations if there are no visible side eﬀects. — end note ]
17.6.5.10 Protection within classes
[protection.within.classes]
It is unspeciﬁed whether any function signature or class described in Clauses 18 through 30 and Annex D is
a friend of another class in the C++ standard library.
17.6.5.11 Derived classes

[derivation]
1 An implementation may derive any class in the C++ standard library from a class with a name reserved to

the implementation.

2 Certain classes deﬁned in the C++ standard library are required to be derived from other classes in the C++
standard library. An implementation may derive such a class directly from the required base or indirectly
through a hierarchy of base classes with names reserved to the implementation.
In any case:

3

(3.1)

(3.2)

(3.3)

—
—
—

Every base class described as virtual shall be virtual;
Every base class described as non-virtual shall not be virtual;
Unless explicitly stated otherwise, types with distinct names shall be distinct types.189

17.6.5.12 Restrictions on exception handling

[res.on.exception.handling]
1 Any of the functions deﬁned in the C++ standard library can report a failure by throwing an exception of a
type described in its Throws: paragraph. An implementation may strengthen the exception speciﬁcation
for a non-virtual function by adding a non-throwing noexcept-speciﬁcation.

2 A function may throw an object of a type not listed in its Throws clause if its type is derived from a type

named in the Throws clause and would be caught by an exception handler for the base type.

3 Functions from the C standard library shall not throw exceptions190 except when such a function calls a

program-supplied function that throws an exception.191

4 Destructor operations deﬁned in the C++ standard library shall not throw exceptions. Every destructor in
the C++ standard library shall behave as if it had a non-throwing exception speciﬁcation. Any other functions
189) There is an implicit exception to this rule for types that are described as synonyms for basic integral types, such as
size_t (18.2) and streamoff (27.5.2).
190) That is, the C library functions can all be treated as if they are marked noexcept. This allows implementations to make
performance optimizations based on the absence of exceptions at runtime.
191) The functions qsort() and bsearch() (25.5) meet this condition.

§ 17.6.5.12

466

c(cid:13) ISO/IEC

N4296

deﬁned in the C++ standard library that do not have an exception-speciﬁcation may throw implementation-
deﬁned exceptions unless otherwise speciﬁed.192 An implementation may strengthen this implicit exception-
speciﬁcation by adding an explicit one.193
17.6.5.13 Restrictions on storage of pointers

[res.on.pointer.storage]
1 Objects constructed by the standard library that may hold a user-supplied pointer value or an integer of
type std::intptr_t shall store such values in a traceable pointer location (3.7.4.3). [ Note: Other libraries
are strongly encouraged to do the same, since not doing so may result in accidental use of pointers that are
not safely derived. Libraries that store pointers outside the user’s address space should make it appear that
they are stored and retrieved from a traceable pointer location. — end note ]
17.6.5.14 Value of error codes

[value.error.codes]
1 Certain functions in the C++ standard library report errors via a std::error_code (19.5.2.1) object. That
object’s category() member shall return std::system_category() for errors originating from the oper-
ating system, or a reference to an implementation-deﬁned error_category object for errors originating
elsewhere. The implementation shall deﬁne the possible values of value() for each of these error categories.
[ Example: For operating systems that are based on POSIX, implementations are encouraged to deﬁne the
std::system_category() values as identical to the POSIX errno values, with additional values as de-
ﬁned by the operating system’s documentation. Implementations for operating systems that are not based
on POSIX are encouraged to deﬁne values identical to the operating system’s values. For errors that do
not originate from the operating system, the implementation may provide enums for the associated values.
— end example ]
17.6.5.15 Moved-from state of library types

[lib.types.movedfrom]
1 Objects of types deﬁned in the C++ standard library may be moved from (12.8). Move operations may
be explicitly speciﬁed or implicitly generated. Unless otherwise speciﬁed, such moved-from objects shall be
placed in a valid but unspeciﬁed state.

192) In particular, they can report a failure to allocate storage by throwing an exception of type bad_alloc, or a class derived
from bad_alloc (18.6.2.1). Library implementations should report errors by throwing exceptions of or derived from the standard
exception classes (18.6.2.1, 18.8, 19.2).
193) That is, an implementation may provide an explicit exception-speciﬁcation that deﬁnes the subset of “any” exceptions
thrown by that function. This implies that the implementation may list implementation-deﬁned types in such an exception-
speciﬁcation.

§ 17.6.5.15

467

c(cid:13) ISO/IEC

N4296

18 Language support library
[language.support]
18.1 General

[support.general]
1 This Clause describes the function signatures that are called implicitly, and the types of objects generated
It also describes the headers that declare these

implicitly, during the execution of some C++ programs.
function signatures and deﬁne any related types.

2 The following subclauses describe common type deﬁnitions used throughout the library, characteristics of
the predeﬁned types, functions supporting start and termination of a C++ program, support for dynamic
memory management, support for dynamic type identiﬁcation, support for exception processing, support
for initializer lists, and other runtime support, as summarized in Table 29.

Table 29 — Language support library summary

Subclause

Types

Implementation properties

Integer types
Start and termination
Dynamic memory management
Type identiﬁcation
Exception handling
Initializer lists

18.2

18.3

18.4
18.5
18.6
18.7
18.8
18.9

18.10 Other runtime support

Header(s)
<cstddef>
<limits>
<climits>
<cfloat>
<cstdint>
<cstdlib>
<new>
<typeinfo>
<exception>
<initializer_list>
<csignal>
<csetjmp>
<cstdalign>
<cstdarg>
<cstdbool>
<cstdlib>
<ctime>

18.2 Types

1 Table 30 describes the header <cstddef>.

[support.types]

Table 30 — Header <cstddef> synopsis

Type
Macros:
Types:

Name(s)

NULL
ptrdiff_t
max_align_t

offsetof
size_t
nullptr_t

2 The contents are the same as the Standard C library header <stddef.h>, with the following changes:

§ 18.2

468

c(cid:13) ISO/IEC

N4296

3 The macro NULL is an implementation-deﬁned C++ null pointer constant in this International Standard

(4.10).194

4 The macro offsetof(type, member-designator) accepts a restricted set of type arguments in this International
Standard. If type is not a standard-layout class (Clause 9), the results are undeﬁned.195 The expression
offsetof(type, member-designator) is never type-dependent (14.6.2.2) and it is value-dependent (14.6.2.3)
if and only if type is dependent. The result of applying the offsetof macro to a ﬁeld that is a static data
member or a function member is undeﬁned. No operation invoked by the offsetof macro shall throw an
exception and noexcept(offsetof(type, member-designator)) shall be true.

5 The type ptrdiff_t is an implementation-deﬁned signed integer type that can hold the diﬀerence of two

subscripts in an array object, as described in 5.7.

6 The type size_t is an implementation-deﬁned unsigned integer type that is large enough to contain the size

in bytes of any object.
[ Note: It is recommended that implementations choose types for ptrdiff_t and size_t whose integer
conversion ranks (4.13) are no greater than that of signed long int unless a larger size is necessary to
contain all the possible values. — end note ]

7

8 The type max_align_t is a POD type whose alignment requirement is at least as great as that of every

scalar type, and whose alignment requirement is supported in every context.

9 nullptr_t is deﬁned as follows:

namespace std {

typedef decltype(nullptr) nullptr_t;

}

The type for which nullptr_t is a synonym has the characteristics described in 3.9.1 and 4.10.
[ Note:
Although nullptr’s address cannot be taken, the address of another nullptr_t object that is an lvalue can
be taken. — end note ]
See also: Alignment (3.11), Sizeof (5.3.3), Additive operators (5.7), Free store (12.5), and ISO C 7.1.6.
18.3 Implementation properties
18.3.1

[support.limits]
[support.limits.general]
1 The headers <limits> (18.3.2), <climits>, and <cfloat> (18.3.3) supply characteristics of implementation-

In general

dependent arithmetic types (3.9.1).
18.3.2 Numeric limits
18.3.2.1 Class template numeric_limits

[limits]
[limits.numeric]
1 The numeric_limits class template provides a C++ program with information about various properties of

the implementation’s representation of the arithmetic types.

2 Specializations shall be provided for each arithmetic type, both ﬂoating point and integer, including bool.

The member is_specialized shall be true for all such specializations of numeric_limits.

3 For all members declared static constexpr in the numeric_limits template, specializations shall deﬁne

these values in such a way that they are usable as constant expressions.

4 Non-arithmetic standard types, such as complex<T> (26.4.2), shall not have specializations.

18.3.2.2 Header <limits> synopsis

[limits.syn]

194) Possible deﬁnitions include 0 and 0L, but not (void*)0.
195) Note that offsetof is required to work as speciﬁed even if unary operator& is overloaded for any of the types involved.

§ 18.3.2.2

469

c(cid:13) ISO/IEC

N4296

namespace std {

template<class T> class numeric_limits;
enum float_round_style;
enum float_denorm_style;

template<> class numeric_limits<bool>;

template<> class numeric_limits<char>;
template<> class numeric_limits<signed char>;
template<> class numeric_limits<unsigned char>;
template<> class numeric_limits<char16_t>;
template<> class numeric_limits<char32_t>;
template<> class numeric_limits<wchar_t>;

template<> class numeric_limits<short>;
template<> class numeric_limits<int>;
template<> class numeric_limits<long>;
template<> class numeric_limits<long long>;
template<> class numeric_limits<unsigned short>;
template<> class numeric_limits<unsigned int>;
template<> class numeric_limits<unsigned long>;
template<> class numeric_limits<unsigned long long>;

template<> class numeric_limits<float>;
template<> class numeric_limits<double>;
template<> class numeric_limits<long double>;

}

18.3.2.3 Class template numeric_limits

[numeric.limits]

namespace std {

template<class T> class numeric_limits {
public:

static constexpr bool is_specialized = false;
static constexpr T min() noexcept { return T(); }
static constexpr T max() noexcept { return T(); }
static constexpr T lowest() noexcept { return T(); }

digits = 0;
static constexpr int
digits10 = 0;
static constexpr int
static constexpr int
max_digits10 = 0;
static constexpr bool is_signed = false;
static constexpr bool is_integer = false;
static constexpr bool is_exact = false;
static constexpr int
static constexpr T epsilon() noexcept { return T(); }
static constexpr T round_error() noexcept { return T(); }

radix = 0;

static constexpr int
static constexpr int
static constexpr int
static constexpr int

min_exponent = 0;
min_exponent10 = 0;
max_exponent = 0;
max_exponent10 = 0;

static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;

§ 18.3.2.3

470

c(cid:13) ISO/IEC

N4296

static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss = false;
static constexpr T infinity() noexcept { return T(); }
static constexpr T quiet_NaN() noexcept { return T(); }
static constexpr T signaling_NaN() noexcept { return T(); }
static constexpr T denorm_min() noexcept { return T(); }

static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = false;
static constexpr bool is_modulo = false;

static constexpr bool traps = false;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;

};

template<class T> class numeric_limits<const T>;
template<class T> class numeric_limits<volatile T>;
template<class T> class numeric_limits<const volatile T>;

}

1 The default numeric_limits<T> template shall have all members, but with 0 or false values.
2 The value of each member of a specialization of numeric_limits on a cv-qualiﬁed type cv T shall be equal

to the value of the corresponding member of the specialization on the unqualiﬁed type T.
18.3.2.4 numeric_limits members
static constexpr T min() noexcept;

[numeric.limits.members]

1

2

3

4

5

6

7

8

9

10

Minimum ﬁnite value.196
For ﬂoating types with denormalization, returns the minimum positive normalized value.
Meaningful for all specializations in which is_bounded != false, or is_bounded == false && is_-
signed == false.

static constexpr T max() noexcept;

Maximum ﬁnite value.197
Meaningful for all specializations in which is_bounded != false.

static constexpr T lowest() noexcept;

A ﬁnite value x such that there is no other ﬁnite value y where y < x.198
Meaningful for all specializations in which is_bounded != false.

static constexpr int digits;

Number of radix digits that can be represented without change.
For integer types, the number of non-sign bits in the representation.
For ﬂoating point types, the number of radix digits in the mantissa.199

196) Equivalent to CHAR_MIN, SHRT_MIN, FLT_MIN, DBL_MIN, etc.
197) Equivalent to CHAR_MAX, SHRT_MAX, FLT_MAX, DBL_MAX, etc.
198) lowest() is necessary because not all ﬂoating-point representations have a smallest (most negative) value that is the
negative of the largest (most positive) ﬁnite value.
199) Equivalent to FLT_MANT_DIG, DBL_MANT_DIG, LDBL_MANT_DIG.

§ 18.3.2.4

471

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

c(cid:13) ISO/IEC

N4296

static constexpr int digits10;

Number of base 10 digits that can be represented without change.200
Meaningful for all specializations in which is_bounded != false.

static constexpr int max_digits10;

Number of base 10 digits required to ensure that values which diﬀer are always diﬀerentiated.
Meaningful for all ﬂoating point types.

static constexpr bool is_signed;

True if the type is signed.
Meaningful for all specializations.

static constexpr bool is_integer;

True if the type is integer.
Meaningful for all specializations.

static constexpr bool is_exact;

True if the type uses an exact representation. All integer types are exact, but not all exact types are
integer. For example, rational and ﬁxed-exponent representations are exact but not integer.
Meaningful for all specializations.

static constexpr int radix;

For ﬂoating types, speciﬁes the base or radix of the exponent representation (often 2).201
For integer types, speciﬁes the base of the representation.202
Meaningful for all specializations.

static constexpr T epsilon() noexcept;

Machine epsilon: the diﬀerence between 1 and the least value greater than 1 that is representable.203
Meaningful for all ﬂoating point types.

static constexpr T round_error() noexcept;

Measure of the maximum rounding error.204

static constexpr int

min_exponent;

Minimum negative integer such that radix raised to the power of one less than that integer is a
normalized ﬂoating point number.205
Meaningful for all ﬂoating point types.

static constexpr int

min_exponent10;

200) Equivalent to FLT_DIG, DBL_DIG, LDBL_DIG.
201) Equivalent to FLT_RADIX.
202) Distinguishes types with bases other than 2 (e.g. BCD).
203) Equivalent to FLT_EPSILON, DBL_EPSILON, LDBL_EPSILON.
204) Rounding error is described in ISO/IEC 10967-1 Language independent arithmetic - Part 1 Section 5.2.8 and Annex A
Rationale Section A.5.2.8 - Rounding constants.
205) Equivalent to FLT_MIN_EXP, DBL_MIN_EXP, LDBL_MIN_EXP.

§ 18.3.2.4

472

c(cid:13) ISO/IEC

N4296

Minimum negative integer such that 10 raised to that power is in the range of normalized ﬂoating
point numbers.206
Meaningful for all ﬂoating point types.

static constexpr int

max_exponent;

Maximum positive integer such that radix raised to the power one less than that integer is a repre-
sentable ﬁnite ﬂoating point number.207
Meaningful for all ﬂoating point types.

static constexpr int

max_exponent10;

Maximum positive integer such that 10 raised to that power is in the range of representable ﬁnite
ﬂoating point numbers.208
Meaningful for all ﬂoating point types.

static constexpr bool has_infinity;

True if the type has a representation for positive inﬁnity.
Meaningful for all ﬂoating point types.
Shall be true for all specializations in which is_iec559 != false.

static constexpr bool has_quiet_NaN;

True if the type has a representation for a quiet (non-signaling) “Not a Number.”209
Meaningful for all ﬂoating point types.
Shall be true for all specializations in which is_iec559 != false.

static constexpr bool has_signaling_NaN;

True if the type has a representation for a signaling “Not a Number.”210
Meaningful for all ﬂoating point types.
Shall be true for all specializations in which is_iec559 != false.

static constexpr float_denorm_style has_denorm;

denorm_present if the type allows denormalized values (variable number of exponent bits)211, denorm_-
absent if the type does not allow denormalized values, and denorm_indeterminate if it is indetermi-
nate at compile time whether the type allows denormalized values.
Meaningful for all ﬂoating point types.

static constexpr bool has_denorm_loss;

True if loss of accuracy is detected as a denormalization loss, rather than as an inexact result.212

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

static constexpr T infinity() noexcept;

206) Equivalent to FLT_MIN_10_EXP, DBL_MIN_10_EXP, LDBL_MIN_10_EXP.
207) Equivalent to FLT_MAX_EXP, DBL_MAX_EXP, LDBL_MAX_EXP.
208) Equivalent to FLT_MAX_10_EXP, DBL_MAX_10_EXP, LDBL_MAX_10_EXP.
209) Required by LIA-1.
210) Required by LIA-1.
211) Required by LIA-1.
212) See IEC 559.

§ 18.3.2.4

473

c(cid:13) ISO/IEC

N4296

Representation of positive inﬁnity, if available.213
Meaningful for all specializations for which has_infinity != false. Required in specializations for
which is_iec559 != false.

static constexpr T quiet_NaN() noexcept;

Representation of a quiet “Not a Number,” if available.214
Meaningful for all specializations for which has_quiet_NaN != false. Required in specializations for
which is_iec559 != false.

static constexpr T signaling_NaN() noexcept;

Representation of a signaling “Not a Number,” if available.215
Meaningful for all specializations for which has_signaling_NaN != false. Required in specializations
for which is_iec559 != false.

static constexpr T denorm_min() noexcept;

Minimum positive denormalized value.216
Meaningful for all ﬂoating point types.
In specializations for which has_denorm == false, returns the minimum positive normalized value.

static constexpr bool is_iec559;

True if and only if the type adheres to IEC 559 standard.217
Meaningful for all ﬂoating point types.

static constexpr bool is_bounded;

True if the set of values representable by the type is ﬁnite.218 [ Note: All fundamental types (3.9.1)
are bounded. This member would be false for arbitrary precision types. — end note ]
Meaningful for all specializations.

static constexpr bool is_modulo;

True if the type is modulo.219 A type is modulo if, for any operation involving +, -, or * on values
of that type whose result would fall outside the range [min(),max()], the value returned diﬀers from
the true value by an integer multiple of max() - min() + 1.
On most machines, this is false for ﬂoating types, true for unsigned integers, and true for signed
integers.
Meaningful for all specializations.

static constexpr bool traps;

true if, at program startup, there exists a value of the type that would cause an arithmetic operation
using that value to trap.220
Meaningful for all specializations.

47

48

49

50

51

52

53

54

55

56

57

58

59

60

61

62

63

64

213) Required by LIA-1.
214) Required by LIA-1.
215) Required by LIA-1.
216) Required by LIA-1.
217) International Electrotechnical Commission standard 559 is the same as IEEE 754.
218) Required by LIA-1.
219) Required by LIA-1.
220) Required by LIA-1.

§ 18.3.2.4

474

c(cid:13) ISO/IEC

N4296

65

66

67

68

static constexpr bool tinyness_before;

true if tinyness is detected before rounding.221
Meaningful for all ﬂoating point types.

static constexpr float_round_style round_style;

The rounding style for the type.222
Meaningful for all ﬂoating point types. Specializations for integer types shall return round_toward_-
zero.

18.3.2.5 Type float_round_style

[round.style]

namespace std {

enum float_round_style {

= -1,
round_indeterminate
0,
=
round_toward_zero
1,
=
round_to_nearest
2,
round_toward_infinity
=
round_toward_neg_infinity =
3

};

}

1 The rounding mode for ﬂoating point arithmetic is characterized by the values:

(1.1)

(1.2)

(1.3)

(1.4)

(1.5)

—
—
—
—
—

round_indeterminate if the rounding style is indeterminable
round_toward_zero if the rounding style is toward zero
round_to_nearest if the rounding style is to the nearest representable value
round_toward_infinity if the rounding style is toward inﬁnity
round_toward_neg_infinity if the rounding style is toward negative inﬁnity

18.3.2.6 Type float_denorm_style

[denorm.style]

namespace std {

enum float_denorm_style {

denorm_indeterminate = -1,
denorm_absent = 0,
denorm_present = 1

};

}

1 The presence or absence of denormalization (variable number of exponent bits) is characterized by the values:
denorm_indeterminate if it cannot be determined whether or not the type allows denormalized values
denorm_absent if the type does not allow denormalized values
denorm_present if the type does allow denormalized values

—
—
—

(1.1)

(1.2)

(1.3)

221) Refer to IEC 559. Required by LIA-1.
222) Equivalent to FLT_ROUNDS. Required by LIA-1.

§ 18.3.2.6

475

c(cid:13) ISO/IEC

N4296

18.3.2.7 numeric_limits specializations

[numeric.special]
1 All members shall be provided for all specializations. However, many values are only required to be mean-
ingful under certain conditions (for example, epsilon() is only meaningful if is_integer is false). Any
value that is not “meaningful” shall be set to 0 or false.
[ Example:

2

namespace std {

template<> class numeric_limits<float> {
public:

static constexpr bool is_specialized = true;

inline static constexpr float min() noexcept { return 1.17549435E-38F; }
inline static constexpr float max() noexcept { return 3.40282347E+38F; }
inline static constexpr float lowest() noexcept { return -3.40282347E+38F; }

= 24;
static constexpr int digits
static constexpr int digits10 =
6;
static constexpr int max_digits10 =

9;

static constexpr bool is_signed
= true;
static constexpr bool is_integer = false;
static constexpr bool is_exact
= false;

static constexpr int radix = 2;
inline static constexpr float epsilon() noexcept
inline static constexpr float round_error() noexcept { return 0.5F; }

{ return 1.19209290E-07F; }

static constexpr int min_exponent
= -125;
static constexpr int min_exponent10 = - 37;
static constexpr int max_exponent
= +128;
static constexpr int max_exponent10 = + 38;

static constexpr bool has_infinity
static constexpr bool has_quiet_NaN
static constexpr bool has_signaling_NaN
static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss

= true;
= true;
= true;

= false;

noexcept { return value ; }
inline static constexpr float infinity()
inline static constexpr float quiet_NaN()
noexcept { return value ; }
inline static constexpr float signaling_NaN() noexcept { return value ; }
inline static constexpr float denorm_min()
noexcept { return min(); }

static constexpr bool is_iec559 = true;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = false;
static constexpr bool traps
= true;
static constexpr bool tinyness_before = true;

static constexpr float_round_style round_style = round_to_nearest;

};

}

— end example ]

§ 18.3.2.7

476

c(cid:13) ISO/IEC

N4296

3 The specialization for bool shall be provided as follows:

namespace std {

template<> class numeric_limits<bool> {
public:

static constexpr bool is_specialized = true;
static constexpr bool min() noexcept { return false; }
static constexpr bool max() noexcept { return true; }
static constexpr bool lowest() noexcept { return false; }

static constexpr int
static constexpr int
static constexpr int

digits = 1;
digits10 = 0;
max_digits10 = 0;

static constexpr bool is_signed = false;
static constexpr bool is_integer = true;
static constexpr bool is_exact = true;
static constexpr int
static constexpr bool epsilon() noexcept { return 0; }
static constexpr bool round_error() noexcept { return 0; }

radix = 2;

static constexpr int
static constexpr int
static constexpr int
static constexpr int

min_exponent = 0;
min_exponent10 = 0;
max_exponent = 0;
max_exponent10 = 0;

static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss = false;
static constexpr bool infinity() noexcept { return 0; }
static constexpr bool quiet_NaN() noexcept { return 0; }
static constexpr bool signaling_NaN() noexcept { return 0; }
static constexpr bool denorm_min() noexcept { return 0; }

static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = false;

static constexpr bool traps = false;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;

};

}

18.3.3 C library

[c.limits]

1 Table 31 describes the header <climits>.
2 The contents are the same as the Standard C library header <limits.h>. [ Note: The types of the constants
deﬁned by macros in <climits> are not required to match the types to which the macros refer. — end note ]

3 Table 32 describes the header <cfloat>.
4 The contents are the same as the Standard C library header <float.h>.

See also: ISO C 7.1.5, 5.2.4.2.2, 5.2.4.2.1.

§ 18.3.3

477

c(cid:13) ISO/IEC

N4296

Table 31 — Header <climits> synopsis

Name(s)

INT_MAX
LLONG_MAX
LLONG_MIN

LONG_MAX
LONG_MIN
MB_LEN_MAX

SCHAR_MIN
SCHAR_MAX
SHRT_MAX

SHRT_MIN
UCHAR_MAX
UINT_MAX

ULLONG_MAX
ULONG_MAX
USHRT_MAX

Type
Values:
CHAR_BIT
CHAR_MAX
CHAR_MIN
INT_MIN

Type

Values:
DBL_DIG
DBL_EPSILON
DBL_MANT_DIG
DBL_MAX
DBL_MAX_10_EXP
DBL_MAX_EXP
DBL_MIN
DBL_MIN_10_EXP

Table 32 — Header <cfloat> synopsis

Name(s)

DBL_MIN_EXP
DECIMAL_DIG
FLT_DIG
FLT_EPSILON
FLT_EVAL_METHOD
FLT_MANT_DIG
FLT_MAX
FLT_MAX_10_EXP

FLT_MAX_EXP
FLT_MIN
FLT_MIN_10_EXP
FLT_MIN_EXP
FLT_RADIX
FLT_ROUNDS
LDBL_DIG
LDBL_EPSILON

LDBL_MANT_DIG
LDBL_MAX_10_EXP
LDBL_MAX_EXP
LDBL_MAX
LDBL_MIN
LDBL_MIN_10_EXP
LDBL_MIN_EXP

[cstdint]
[cstdint.syn]

18.4 Integer types
18.4.1 Header <cstdint> synopsis

namespace std {

typedef signed integer type int8_t;
typedef signed integer type int16_t;
typedef signed integer type int32_t;
typedef signed integer type int64_t;

// optional
// optional
// optional
// optional

typedef signed integer type int_fast8_t;
typedef signed integer type int_fast16_t;
typedef signed integer type int_fast32_t;
typedef signed integer type int_fast64_t;

typedef signed integer type int_least8_t;
typedef signed integer type int_least16_t;
typedef signed integer type int_least32_t;
typedef signed integer type int_least64_t;

typedef signed integer type intmax_t;
typedef signed integer type intptr_t;

typedef unsigned integer type uint8_t;
typedef unsigned integer type uint16_t;
typedef unsigned integer type uint32_t;
typedef unsigned integer type uint64_t;

// optional

// optional
// optional
// optional
// optional

typedef unsigned integer type uint_fast8_t;
typedef unsigned integer type uint_fast16_t;
typedef unsigned integer type uint_fast32_t;
typedef unsigned integer type uint_fast64_t;

§ 18.4.1

478

c(cid:13) ISO/IEC

N4296

typedef unsigned integer type uint_least8_t;
typedef unsigned integer type uint_least16_t;
typedef unsigned integer type uint_least32_t;
typedef unsigned integer type uint_least64_t;

typedef unsigned integer type uintmax_t;
typedef unsigned integer type uintptr_t;

} // namespace std

// optional

1 The header also deﬁnes numerous macros of the form:

INT_[FAST LEAST]{8 16 32 64}_MIN
[U]INT_[FAST LEAST]{8 16 32 64}_MAX
INT{MAX PTR}_MIN
[U]INT{MAX PTR}_MAX
{PTRDIFF SIG_ATOMIC WCHAR WINT}{_MAX _MIN}
SIZE_MAX

plus function macros of the form:

[U]INT{8 16 32 64 MAX}_C

2 The header deﬁnes all functions, types, and macros the same as 7.18 in the C standard. [ Note: The macros
deﬁned by <cstdint> are provided unconditionally. In particular, the symbols __STDC_LIMIT_MACROS and
__STDC_CONSTANT_MACROS (mentioned in footnotes 219, 220, and 222 in the C standard) play no role in
C++. — end note ]
18.5 Start and termination

[support.start.term]

1 Table 33 describes some of the contents of the header <cstdlib>.

Table 33 — Header <cstdlib> synopsis

Type
Macros:
Functions:

EXIT_FAILURE
_Exit
at_quick_exit

Name(s)
EXIT_SUCCESS
abort
exit

atexit
quick_exit

2 The contents are the same as the Standard C library header <stdlib.h>, with the following changes:

3
(3.1)

4
(4.1)

[[noreturn]] void _Exit(int status) noexcept;

The function _Exit(int status) has additional behavior in this International Standard:
—

The program is terminated without executing destructors for objects of automatic, thread, or
static storage duration and without calling functions passed to atexit() (3.6.3).

[[noreturn]] void abort(void) noexcept;

The function abort() has additional behavior in this International Standard:
—

The program is terminated without executing destructors for objects of automatic, thread, or
static storage duration and without calling functions passed to atexit() (3.6.3).

extern "C" int atexit(void (*f)(void)) noexcept;
extern "C++" int atexit(void (*f)(void)) noexcept;

§ 18.5

479

5

6

7

8
(8.1)

(8.2)

(8.3)

9

10

11

12

c(cid:13) ISO/IEC

N4296

Eﬀects: The atexit() functions register the function pointed to by f to be called without arguments
at normal program termination. It is unspeciﬁed whether a call to atexit() that does not happen
before (1.10) a call to exit() will succeed. [ Note: The atexit() functions do not introduce a data
race (17.6.5.9). — end note ]
Implementation limits: The implementation shall support the registration of at least 32 functions.
Returns: The atexit() function returns zero if the registration succeeds, non-zero if it fails.

[[noreturn]] void exit(int status)

The function exit() has additional behavior in this International Standard:
—

First, objects with thread storage duration and associated with the current thread are destroyed.
Next, objects with static storage duration are destroyed and functions registered by calling atexit
are called.223 See 3.6.3 for the order of destructions and calls.
(Automatic objects are not
destroyed as a result of calling exit().)224
If control leaves a registered function called by exit because the function does not provide a
handler for a thrown exception, std::terminate() shall be called (15.5.1).
Next, all open C streams (as mediated by the function signatures declared in <cstdio>) with
unwritten buﬀered data are ﬂushed, all open C streams are closed, and all ﬁles created by calling
tmpfile() are removed.
Finally, control is returned to the host environment.
If status is zero or EXIT_SUCCESS, an
implementation-deﬁned form of the status successful termination is returned. If status is EXIT_-
FAILURE, an implementation-deﬁned form of the status unsuccessful termination is returned.
Otherwise the status returned is implementation-deﬁned.225

—

—

extern "C" int at_quick_exit(void (*f)(void)) noexcept;
extern "C++" int at_quick_exit(void (*f)(void)) noexcept;

Eﬀects: The at_quick_exit() functions register the function pointed to by f to be called without
It is unspeciﬁed whether a call to at_quick_exit() that
arguments when quick_exit is called.
does not happen before (1.10) all calls to quick_exit will succeed.
[ Note: The at_quick_exit()
functions do not introduce a data race (17.6.5.9). — end note ] [ Note: The order of registration may
be indeterminate if at_quick_exit was called from more than one thread. — end note ] [ Note: The
at_quick_exit registrations are distinct from the atexit registrations, and applications may need to
call both registration functions with the same argument. — end note ]
Implementation limits: The implementation shall support the registration of at least 32 functions.
Returns: Zero if the registration succeeds, non-zero if it fails.

[[noreturn]] void quick_exit(int status) noexcept;

Eﬀects: Functions registered by calls to at_quick_exit are called in the reverse order of their reg-
istration, except that a function shall be called after any previously registered functions that had
already been called at the time it was registered. Objects shall not be destroyed as a result of calling
quick_exit. If control leaves a registered function called by quick_exit because the function does not
provide a handler for a thrown exception, std::terminate() shall be called. [ Note: at_quick_exit
may call a registered function from a diﬀerent thread than the one that registered it, so registered
functions should not rely on the identity of objects with thread storage duration. — end note ] After
calling registered functions, quick_exit shall call _Exit(status).
[ Note: The standard ﬁle buﬀers
are not ﬂushed. See: ISO C 7.20.4.4. — end note ]

223) A function is called for every time it is registered.
224) Objects with automatic storage duration are all destroyed in a program whose function main() contains no automatic
objects and executes the call to exit(). Control can be transferred directly to such a main() by throwing an exception that is
caught in main().
225) The macros EXIT_FAILURE and EXIT_SUCCESS are deﬁned in <cstdlib>.

§ 18.5

480

c(cid:13) ISO/IEC

N4296

See also: 3.6, 3.6.3, ISO C 7.10.4.
18.6 Dynamic memory management

[support.dynamic]
1 The header <new> deﬁnes several functions that manage the allocation of dynamic storage in a program. It

also deﬁnes components for reporting storage management errors.
Header <new> synopsis

namespace std {

class bad_alloc;
class bad_array_new_length;
struct nothrow_t {};
extern const nothrow_t nothrow;
typedef void (*new_handler)();
new_handler get_new_handler() noexcept;
new_handler set_new_handler(new_handler new_p) noexcept;

}

void* operator new(std::size_t size);
void* operator new(std::size_t size, const std::nothrow_t&) noexcept;
void
void
void
void

operator delete(void* ptr) noexcept;
operator delete(void* ptr, const std::nothrow_t&) noexcept;
operator delete(void* ptr, std::size_t size) noexcept;
operator delete(void* ptr, std::size_t size,

const std::nothrow_t&) noexcept;

void* operator new[](std::size_t size);
void* operator new[](std::size_t size, const std::nothrow_t&) noexcept;
void
void
void
void

operator delete[](void* ptr) noexcept;
operator delete[](void* ptr, const std::nothrow_t&) noexcept;
operator delete[](void* ptr, std::size_t size) noexcept;
operator delete[](void* ptr, std::size_t size,

const std::nothrow_t&) noexcept;

void* operator new
(std::size_t size, void* ptr) noexcept;
void* operator new[](std::size_t size, void* ptr) noexcept;
void
void

operator delete
(void* ptr, void*) noexcept;
operator delete[](void* ptr, void*) noexcept;

See also: 1.7, 3.7.4, 5.3.4, 5.3.5, 12.5, 20.7.
18.6.1 Storage allocation and deallocation

[new.delete]
1 Except where otherwise speciﬁed, the provisions of (3.7.4) apply to the library versions of operator new

[new.delete.single]

and operator delete.
18.6.1.1 Single-object forms
void* operator new(std::size_t size);

1

2

3

4

Eﬀects: The allocation function (3.7.4.1) called by a new-expression (5.3.4) to allocate size bytes of
storage suitably aligned to represent any object of that size.
Replaceable: a C++ program may deﬁne a function with this function signature that displaces the
default version deﬁned by the C++ standard library.
Required behavior: Return a non-null pointer to suitably aligned storage (3.7.4), or else throw a bad_-
alloc exception. This requirement is binding on a replacement version of this function.
Default behavior:

§ 18.6.1.1

481

(4.1)

(4.2)

(4.3)

(4.4)

5

6

7

8

9

10

11

12

13

14

15

c(cid:13) ISO/IEC

N4296

—

—

—

—

Executes a loop: Within the loop, the function ﬁrst attempts to allocate the requested storage.
Whether the attempt involves a call to the Standard C library function malloc is unspeciﬁed.
Returns a pointer to the allocated storage if the attempt is successful. Otherwise, if the current
new_handler (18.6.2.5) is a null pointer value, throws bad_alloc.
Otherwise, the function calls the current new_handler function (18.6.2.3). If the called function
returns, the loop repeats.
The loop terminates when an attempt to allocate the requested storage is successful or when a
called new_handler function does not return.

void* operator new(std::size_t size, const std::nothrow_t&) noexcept;

Eﬀects: Same as above, except that it is called by a placement version of a new-expression when a
C++ program prefers a null pointer result as an error indication, instead of a bad_alloc exception.
Replaceable: a C++ program may deﬁne a function with this function signature that displaces the
default version deﬁned by the C++ standard library.
Required behavior: Return a non-null pointer to suitably aligned storage (3.7.4), or else return a null
pointer. This nothrow version of operator new returns a pointer obtained as if acquired from the
(possibly replaced) ordinary version. This requirement is binding on a replacement version of this
function.
Default behavior: Calls operator new(size). If the call returns normally, returns the result of that
call. Otherwise, returns a null pointer.
[ Example:

T* p1 = new T;
T* p2 = new(nothrow) T;

// throws bad_alloc if it fails
// returns nullptr if it fails

— end example ]

void operator delete(void* ptr) noexcept;
void operator delete(void* ptr, std::size_t size) noexcept;

Eﬀects: The deallocation function (3.7.4.2) called by a delete-expression to render the value of ptr
invalid.
Replaceable: a C++ program may deﬁne a function with signature void operator delete(void*
ptr) noexcept that displaces the default version deﬁned by the C++ standard library. If this function
(without size parameter) is deﬁned, the program should also deﬁne void operator delete(void*
ptr, std::size_t size) noexcept. If this function with size parameter is deﬁned, the program
shall also deﬁne the version without the size parameter.
[ Note: The default behavior below may
change in the future, which will require replacing both deallocation functions when replacing the
allocation function. — end note ]
Requires: ptr shall be a null pointer or its value shall be a value returned by an earlier call to the (possi-
bly replaced) operator new(std::size_t) or operator new(std::size_t,const std::nothrow_-
t&) which has not been invalidated by an intervening call to operator delete(void*).
Requires: If an implementation has strict pointer safety (3.7.4.3) then ptr shall be a safely-derived
pointer.
Requires: If present, the std::size_t size argument shall equal the size argument passed to the
allocation function that returned ptr.
Required behavior: Calls to operator delete(void* ptr, std::size_t size) may be changed to
calls to operator delete(void* ptr) without aﬀecting memory allocation.
[ Note: A conforming

§ 18.6.1.1

482

c(cid:13) ISO/IEC

N4296

16

17

18

19

20

21

22

23

24

1

2

3

4

implementation is for operator delete(void* ptr, std::size_t size) to simply call operator
delete(ptr). — end note ]
Default behavior: the function operator delete(void* ptr, std::size_t size) calls operator
delete(ptr). [ Note: See the note in the above Replaceable paragraph. — end note ]
Default behavior: If ptr is null, does nothing. Otherwise, reclaims the storage allocated by the earlier
call to operator new.
Remarks: It is unspeciﬁed under what conditions part or all of such reclaimed storage will be allocated
by subsequent calls to operator new or any of calloc, malloc, or realloc, declared in <cstdlib>.

void operator delete(void* ptr, const std::nothrow_t&) noexcept;
void operator delete(void* ptr, std::size_t size, const std::nothrow_t&) noexcept;

Eﬀects: The deallocation function (3.7.4.2) called by the implementation to render the value of ptr
invalid when the constructor invoked from a nothrow placement version of the new-expression throws
an exception.
Replaceable: a C++ program may deﬁne a function with signature void operator delete(void*
ptr, const std::nothrow_t&) noexcept that displaces the default version deﬁned by the C++ stan-
dard library.
If this function (without size parameter) is deﬁned, the program should also deﬁne
void operator delete(void* ptr, std::size_t size, const std::nothrow_t&) noexcept.
If
this function with size parameter is deﬁned, the program shall also deﬁne the version without the
size parameter.
[ Note: The default behavior below may change in the future, which will require
replacing both deallocation functions when replacing the allocation function. — end note ]
Requires: If an implementation has strict pointer safety (3.7.4.3) then ptr shall be a safely-derived
pointer.
Requires: If present, the std::size_t size argument must equal the size argument passed to the
allocation function that returned ptr.
Required behavior: Calls to operator delete(void* ptr, std::size_t size, const std::nothrow_-
t&) may be changed to calls to operator delete(void* ptr, const std::nothrow_t&) without af-
fecting memory allocation. [ Note: A conforming implementation is for operator delete(void* ptr,
std::size_t size, const std::nothrow_t&) to simply call operator delete(void* ptr, const
std::nothrow_t&). — end note ]
Default behavior: operator delete(void* ptr, std::size_t size, const std::nothrow_t&) calls
operator delete(ptr, std::nothrow), and operator delete(void* ptr, const std::nothrow_-
t&) calls operator delete(ptr).

18.6.1.2 Array forms
void* operator new[](std::size_t size);

[new.delete.array]

Eﬀects: The allocation function (3.7.4.1) called by the array form of a new-expression (5.3.4) to allocate
size bytes of storage suitably aligned to represent any array object of that size or smaller.226
Replaceable: a C++ program can deﬁne a function with this function signature that displaces the
default version deﬁned by the C++ standard library.
Required behavior: Same as for operator new(std::size_t). This requirement is binding on a re-
placement version of this function.
Default behavior: Returns operator new(size).

226) It is not the direct responsibility of operator new[](std::size_t) or operator delete[](void*) to note the repetition
count or element size of the array. Those operations are performed elsewhere in the array new and delete expressions. The
array new expression, may, however, increase the size argument to operator new[](std::size_t) to obtain space to store
supplemental information.

§ 18.6.1.2

483

c(cid:13) ISO/IEC

N4296

5

6

7

8

9

10

11

12

13

14

15

16

17

void* operator new[](std::size_t size, const std::nothrow_t&) noexcept;

Eﬀects: Same as above, except that it is called by a placement version of a new-expression when a
C++ program prefers a null pointer result as an error indication, instead of a bad_alloc exception.
Replaceable: a C++ program can deﬁne a function with this function signature that displaces the
default version deﬁned by the C++ standard library.
Required behavior: Return a non-null pointer to suitably aligned storage (3.7.4), or return a null
pointer. This requirement is binding on a replacement version of this function.
Default behavior: Calls operator new[](size). If the call returns normally, returns the result of that
call. Otherwise, returns a null pointer.

void operator delete[](void* ptr) noexcept;
void operator delete[](void* ptr, std::size_t size) noexcept;

Eﬀects: The deallocation function (3.7.4.2) called by the array form of a delete-expression to render
the value of ptr invalid.
Replaceable: a C++ program can deﬁne a function with signature void operator delete[](void*
ptr) noexcept that displaces the default version deﬁned by the C++ standard library. If this function
(without size parameter) is deﬁned, the program should also deﬁne void operator delete[](void*
ptr, std::size_t size) noexcept. If this function with size parameter is deﬁned, the program
shall also deﬁne the version without the size parameter.
[ Note: The default behavior below may
change in the future, which will require replacing both deallocation functions when replacing the
allocation function. — end note ]
Requires: ptr shall be a null pointer or its value shall be the value returned by an earlier call to
operator new[](std::size_t) or operator new[](std::size_t,const std::nothrow_t&) which
has not been invalidated by an intervening call to operator delete[](void*).
Requires: If present, the std::size_t size argument must equal the size argument passed to the
allocation function that returned ptr.
Required behavior: Calls to operator delete[](void* ptr, std::size_t size) may be changed to
calls to operator delete[](void* ptr) without aﬀecting memory allocation. [ Note: A conforming
implementation is for operator delete[](void* ptr, std::size_t size) to simply call operator
delete[](void* ptr). — end note ]
Requires: If an implementation has strict pointer safety (3.7.4.3) then ptr shall be a safely-derived
pointer.
Default behavior: operator delete[](void* ptr, std::size_t size) calls operator delete[](ptr),
and operator delete[](void* ptr) calls operator delete(ptr).

void operator delete[](void* ptr, const std::nothrow_t&) noexcept;
void operator delete[](void* ptr, std::size_t size, const std::nothrow_t&) noexcept;

Eﬀects: The deallocation function (3.7.4.2) called by the implementation to render the value of ptr
invalid when the constructor invoked from a nothrow placement version of the array new-expression
throws an exception.
Replaceable: a C++ program may deﬁne a function with signature void operator delete[](void*
ptr, const std::nothrow_t&) noexcept that displaces the default version deﬁned by the C++ stan-
dard library. If this function (without size parameter) is deﬁned, the program should also deﬁne void
operator delete[](void* ptr, std::size_t size, const std::nothrow_t&) noexcept. If this
function with size parameter is deﬁned, the program shall also deﬁne the version without the size
parameter. [ Note: The default behavior below may change in the future, which will require replacing
both deallocation functions when replacing the allocation function. — end note ]

§ 18.6.1.2

484

c(cid:13) ISO/IEC

N4296

18

19

20

21

Requires: If an implementation has strict pointer safety (3.7.4.3) then ptr shall be a safely-derived
pointer.
Requires: If present, the std::size_t size argument must equal the size argument passed to the
allocation function that returned ptr.
Required behavior: Calls to operator delete[](void* ptr, std::size_t size, const std::nothrow_-
t&) may be changed to calls to operator delete[](void* ptr, const std::nothrow_t&) without
aﬀecting memory allocation. [ Note: A conforming implementation is for operator delete[](void*
ptr, std::size_t size, const std::nothrow_t&) to simply call operator delete[](void* ptr,
const std::nothrow_t&). — end note ]
Default behavior: operator delete[](void* ptr, std::size_t size, const std::nothrow_t&)
calls operator delete[](ptr, std::nothrow), and operator delete[](void* ptr, const std::nothrow_-
t&) calls operator delete[](ptr).

18.6.1.3 Placement forms

[new.delete.placement]
1 These functions are reserved, a C++ program may not deﬁne functions that displace the versions in the
Standard C++ library (17.6.4). The provisions of (3.7.4) do not apply to these reserved placement forms of
operator new and operator delete.

2

3

4

5

6

7

8

9

10

11

12

void* operator new(std::size_t size, void* ptr) noexcept;

Returns: ptr.
Remarks: Intentionally performs no other action.
[ Example: This can be useful for constructing an object at a known address:

void* place = operator new(sizeof(Something));
Something* p = new (place) Something();

— end example ]

void* operator new[](std::size_t size, void* ptr) noexcept;

Returns: ptr.
Remarks: Intentionally performs no other action.

void operator delete(void* ptr, void*) noexcept;

Eﬀects: Intentionally performs no action.
Requires: If an implementation has strict pointer safety (3.7.4.3) then ptr shall be a safely-derived
pointer.
Remarks: Default function called when any part of the initialization in a placement new-expression that
invokes the library’s non-array placement operator new terminates by throwing an exception (5.3.4).

void operator delete[](void* ptr, void*) noexcept;

Eﬀects: Intentionally performs no action.
Requires: If an implementation has strict pointer safety (3.7.4.3) then ptr shall be a safely-derived
pointer.
Remarks: Default function called when any part of the initialization in a placement new-expression
that invokes the library’s array placement operator new terminates by throwing an exception (5.3.4).

§ 18.6.1.3

485

c(cid:13) ISO/IEC

N4296

18.6.1.4 Data races

[new.delete.dataraces]
1 For purposes of determining the existence of data races, the library versions of operator new, user replace-
ment versions of global operator new, the C standard library functions calloc and malloc, the library
versions of operator delete, user replacement versions of operator delete, the C standard library func-
tion free, and the C standard library function realloc shall not introduce a data race (17.6.5.9). Calls to
these functions that allocate or deallocate a particular unit of storage shall occur in a single total order, and
each such deallocation call shall happen before (1.10) the next allocation (if any) in this order.
18.6.2 Storage allocation errors
18.6.2.1 Class bad_alloc

[alloc.errors]
[bad.alloc]

namespace std {

class bad_alloc : public exception {
public:

bad_alloc() noexcept;
bad_alloc(const bad_alloc&) noexcept;
bad_alloc& operator=(const bad_alloc&) noexcept;
virtual const char* what() const noexcept;

};

}

1 The class bad_alloc deﬁnes the type of objects thrown as exceptions by the implementation to report a

failure to allocate storage.

2

3

4

5

bad_alloc() noexcept;

Eﬀects: Constructs an object of class bad_alloc.
Remarks: The result of calling what() on the newly constructed object is implementation-deﬁned.

bad_alloc(const bad_alloc&) noexcept;
bad_alloc& operator=(const bad_alloc&) noexcept;
Eﬀects: Copies an object of class bad_alloc.

virtual const char* what() const noexcept;

Returns: An implementation-deﬁned ntbs.

18.6.2.2 Class bad_array_new_length

[new.badlength]

namespace std {

class bad_array_new_length : public bad_alloc {
public:

bad_array_new_length() noexcept;

};

}

1 The class bad_array_new_length deﬁnes the type of objects thrown as exceptions by the implementation
to report an attempt to allocate an array of size less than zero or greater than an implementation-deﬁned
limit (5.3.4).

bad_array_new_length() noexcept;

2

3

Eﬀects: constructs an object of class bad_array_new_length.
Remarks: the result of calling what() on the newly constructed object is implementation-deﬁned.

§ 18.6.2.2

486

c(cid:13) ISO/IEC

18.6.2.3 Type new_handler
typedef void (*new_handler)();

N4296

[new.handler]

1

2
(2.1)

(2.2)

(2.3)

1

2

3

1

The type of a handler function to be called by operator new() or operator new[]() (18.6.1) when
they cannot satisfy a request for additional storage.
Required behavior: A new_handler shall perform one of the following:
—
—
—

make more storage available for allocation and then return;
throw an exception of type bad_alloc or a class derived from bad_alloc;
terminate execution of the program without returning to the caller;

18.6.2.4 set_new_handler
new_handler set_new_handler(new_handler new_p) noexcept;

[set.new.handler]

Eﬀects: Establishes the function designated by new_p as the current new_handler.
Returns: The previous new_handler.
Remarks: The initial new_handler is a null pointer.

18.6.2.5 get_new_handler
new_handler get_new_handler() noexcept;

[get.new.handler]

Returns: The current new_handler. [ Note: This may be a null pointer value. — end note ]

18.7 Type identiﬁcation

[support.rtti]
1 The header <typeinfo> deﬁnes a type associated with type information generated by the implementation.

It also deﬁnes two types for reporting dynamic type identiﬁcation errors.
Header <typeinfo> synopsis

namespace std {

class type_info;
class bad_cast;
class bad_typeid;

}

See also: 5.2.7, 5.2.8.
18.7.1 Class type_info

[type.info]

namespace std {

class type_info {
public:

virtual ~type_info();
bool operator==(const type_info& rhs) const noexcept;
bool operator!=(const type_info& rhs) const noexcept;
bool before(const type_info& rhs) const noexcept;
size_t hash_code() const noexcept;
const char* name() const noexcept;

// cannot be copied
type_info(const type_info& rhs) = delete;
type_info& operator=(const type_info& rhs) = delete; // cannot be copied

};

}

§ 18.7.1

487

c(cid:13) ISO/IEC

N4296

1 The class type_info describes type information generated by the implementation. Objects of this class
eﬀectively store a pointer to a name for the type, and an encoded value suitable for comparing two types for
equality or collating order. The names, encoding rule, and collating sequence for types are all unspeciﬁed
and may diﬀer between programs.

2

3

4

5

6

7

8

9

10

bool operator==(const type_info& rhs) const noexcept;

Eﬀects: Compares the current object with rhs.
Returns: true if the two values describe the same type.

bool operator!=(const type_info& rhs) const noexcept;

Returns: !(*this == rhs).

bool before(const type_info& rhs) const noexcept;
Eﬀects: Compares the current object with rhs.
Returns: true if *this precedes rhs in the implementation’s collation order.

size_t hash_code() const noexcept;

Returns: An unspeciﬁed value, except that within a single execution of the program, it shall return
the same value for any two type_info objects which compare equal.
Remark: an implementation should return diﬀerent values for two type_info objects which do not
compare equal.

const char* name() const noexcept;

Returns: An implementation-deﬁned ntbs.
Remarks: The message may be a null-terminated multibyte string (17.5.2.1.4.2), suitable for conversion
and display as a wstring (21.3, 22.4.1.4)

18.7.2 Class bad_cast

[bad.cast]

namespace std {

class bad_cast : public exception {
public:

bad_cast() noexcept;
bad_cast(const bad_cast&) noexcept;
bad_cast& operator=(const bad_cast&) noexcept;
virtual const char* what() const noexcept;

};

}

1 The class bad_cast deﬁnes the type of objects thrown as exceptions by the implementation to report the

execution of an invalid dynamic-cast expression (5.2.7).

bad_cast() noexcept;

Eﬀects: Constructs an object of class bad_cast.
Remarks: The result of calling what() on the newly constructed object is implementation-deﬁned.

bad_cast(const bad_cast&) noexcept;
bad_cast& operator=(const bad_cast&) noexcept;
Eﬀects: Copies an object of class bad_cast.

2

3

4

§ 18.7.2

488

c(cid:13) ISO/IEC

N4296

virtual const char* what() const noexcept;

5

6

Returns: An implementation-deﬁned ntbs.
Remarks: The message may be a null-terminated multibyte string (17.5.2.1.4.2), suitable for conversion
and display as a wstring (21.3, 22.4.1.4)

18.7.3 Class bad_typeid

[bad.typeid]

namespace std {

class bad_typeid : public exception {
public:

bad_typeid() noexcept;
bad_typeid(const bad_typeid&) noexcept;
bad_typeid& operator=(const bad_typeid&) noexcept;
virtual const char* what() const noexcept;

};

}

1 The class bad_typeid deﬁnes the type of objects thrown as exceptions by the implementation to report a

null pointer in a typeid expression (5.2.8).

2

3

4

5

6

bad_typeid() noexcept;

Eﬀects: Constructs an object of class bad_typeid.
Remarks: The result of calling what() on the newly constructed object is implementation-deﬁned.

bad_typeid(const bad_typeid&) noexcept;
bad_typeid& operator=(const bad_typeid&) noexcept;
Eﬀects: Copies an object of class bad_typeid.

virtual const char* what() const noexcept;

Returns: An implementation-deﬁned ntbs.
Remarks: The message may be a null-terminated multibyte string (17.5.2.1.4.2), suitable for conversion
and display as a wstring (21.3, 22.4.1.4)

18.8 Exception handling

[support.exception]
1 The header <exception> deﬁnes several types and functions related to the handling of exceptions in a C++

program.
Header <exception> synopsis

namespace std {

class exception;
class bad_exception;
class nested_exception;

typedef void (*unexpected_handler)();
unexpected_handler get_unexpected() noexcept;
unexpected_handler set_unexpected(unexpected_handler f) noexcept;
[[noreturn]] void unexpected();

typedef void (*terminate_handler)();
terminate_handler get_terminate() noexcept;
terminate_handler set_terminate(terminate_handler f) noexcept;
[[noreturn]] void terminate() noexcept;

§ 18.8

489

c(cid:13) ISO/IEC

N4296

bool uncaught_exception() noexcept;
int uncaught_exceptions() noexcept;

typedef unspecified

exception_ptr;

exception_ptr current_exception() noexcept;
[[noreturn]] void rethrow_exception(exception_ptr p);
template<class E> exception_ptr make_exception_ptr(E e) noexcept;

template <class T> [[noreturn]] void throw_with_nested(T&& t);
template <class E> void rethrow_if_nested(const E& e);

}

See also: 15.5.
18.8.1 Class exception

[exception]

namespace std {

class exception {
public:

exception() noexcept;
exception(const exception&) noexcept;
exception& operator=(const exception&) noexcept;
virtual ~exception();
virtual const char* what() const noexcept;

};

}

1 The class exception deﬁnes the base class for the types of objects thrown as exceptions by C++ standard

library components, and certain expressions, to report errors detected during program execution.

2 Each standard library class T that derives from class exception shall have a publicly accessible copy con-
structor and a publicly accessible copy assignment operator that do not exit with an exception. These
member functions shall meet the following postcondition: If two objects lhs and rhs both have dynamic
type T and lhs is a copy of rhs, then strcmp(lhs.what(), rhs.what()) shall equal 0.

3

4

5

6

7

8

exception() noexcept;

Eﬀects: Constructs an object of class exception.

exception(const exception& rhs) noexcept;
exception& operator=(const exception& rhs) noexcept;

Eﬀects: Copies an exception object.
Postcondition: If *this and rhs both have dynamic type exception then strcmp(what(), rhs.what())
shall equal 0.

virtual ~exception();

Eﬀects: Destroys an object of class exception.

virtual const char* what() const noexcept;

Returns: An implementation-deﬁned ntbs.
Remarks: The message may be a null-terminated multibyte string (17.5.2.1.4.2), suitable for conversion
and display as a wstring (21.3, 22.4.1.4). The return value remains valid until the exception object
from which it is obtained is destroyed or a non-const member function of the exception object is called.

§ 18.8.1

490

c(cid:13) ISO/IEC

18.8.2 Class bad_exception

N4296

[bad.exception]

namespace std {

class bad_exception : public exception {
public:

bad_exception() noexcept;
bad_exception(const bad_exception&) noexcept;
bad_exception& operator=(const bad_exception&) noexcept;
virtual const char* what() const noexcept;

};

}

1 The class bad_exception deﬁnes the type of objects thrown as described in (15.5.2).

bad_exception() noexcept;

Eﬀects: Constructs an object of class bad_exception.
Remarks: The result of calling what() on the newly constructed object is implementation-deﬁned.

bad_exception(const bad_exception&) noexcept;
bad_exception& operator=(const bad_exception&) noexcept;

Eﬀects: Copies an object of class bad_exception.

virtual const char* what() const noexcept;

Returns: An implementation-deﬁned ntbs.
Remarks: The message may be a null-terminated multibyte string (17.5.2.1.4.2), suitable for conversion
and display as a wstring (21.3, 22.4.1.4).

18.8.3 Abnormal termination
18.8.3.1 Type terminate_handler
typedef void (*terminate_handler)();

[exception.terminate]
[terminate.handler]

The type of a handler function to be called by std::terminate() when terminating exception pro-
cessing.
Required behavior: A terminate_handler shall terminate execution of the program without returning
to the caller.
Default behavior: The implementation’s default terminate_handler calls abort().

18.8.3.2 set_terminate
terminate_handler set_terminate(terminate_handler f) noexcept;

[set.terminate]

Eﬀects: Establishes the function designated by f as the current handler function for terminating
exception processing.
Remarks: It is unspeciﬁed whether a null pointer value designates the default terminate_handler.
Returns: The previous terminate_handler.

18.8.3.3 get_terminate
terminate_handler get_terminate() noexcept;

[get.terminate]

Returns: The current terminate_handler. [ Note: This may be a null pointer value. — end note ]

2

3

4

5

6

1

2

3

1

2

3

1

§ 18.8.3.3

491

c(cid:13) ISO/IEC

18.8.3.4 terminate
[[noreturn]] void terminate() noexcept;

N4296

[terminate]

1

2

1

2

1

2

3

4

5

6

7

8

Remarks: Called by the implementation when exception handling must be abandoned for any of several
reasons (15.5.1), in eﬀect immediately after throwing the exception. May also be called directly by the
program.
Eﬀects: Calls the current terminate_handler function.
always considered a callable handler in this context. — end note ]

[ Note: A default terminate_handler is

18.8.4 uncaught_exceptions
int uncaught_exceptions() noexcept;

[uncaught.exceptions]

Returns: The number of uncaught exceptions (15.5.3).
Remarks: When uncaught_exceptions() > 0, throwing an exception can result in a call of
std::terminate() (15.5.1).

18.8.5 Exception propagation
exception_ptr;
typedef unspecified

[propagation]

The type exception_ptr can be used to refer to an exception object.
exception_ptr shall satisfy the requirements of NullablePointer (17.6.3.3).
Two non-null values of type exception_ptr are equivalent and compare equal if and only if they refer
to the same exception.
The default constructor of exception_ptr produces the null value of the type.
exception_ptr shall not be implicitly convertible to any arithmetic, enumeration, or pointer type.
[ Note: An implementation might use a reference-counted smart pointer as exception_ptr. — end
note ]
For purposes of determining the presence of a data race, operations on exception_ptr objects shall
access and modify only the exception_ptr objects themselves and not the exceptions they refer to.
Use of rethrow_exception on exception_ptr objects that refer to the same exception object shall
not introduce a data race. [ Note: if rethrow_exception rethrows the same exception object (rather
than a copy), concurrent access to that rethrown exception object may introduce a data race. Changes
in the number of exception_ptr objects that refer to a particular exception do not introduce a data
race. — end note ]

exception_ptr current_exception() noexcept;

Returns: An exception_ptr object that refers to the currently handled exception (15.3) or a copy of
the currently handled exception, or a null exception_ptr object if no exception is being handled. The
referenced object shall remain valid at least as long as there is an exception_ptr object that refers to
it. If the function needs to allocate memory and the attempt fails, it returns an exception_ptr object
that refers to an instance of bad_alloc. It is unspeciﬁed whether the return values of two successive
calls to current_exception refer to the same exception object.
[ Note: That is, it is unspeciﬁed
whether current_exception creates a new copy each time it is called. — end note ] If the attempt
to copy the current exception object throws an exception, the function returns an exception_ptr
object that refers to the thrown exception or, if this is not possible, to an instance of bad_exception.
[ Note: The copy constructor of the thrown exception may also fail, so the implementation is allowed
to substitute a bad_exception object to avoid inﬁnite recursion. — end note ]

[[noreturn]] void rethrow_exception(exception_ptr p);

§ 18.8.5

492

c(cid:13) ISO/IEC

N4296

9

10

11

Requires: p shall not be a null pointer.
Throws: the exception object to which p refers.

template<class E> exception_ptr make_exception_ptr(E e) noexcept;

Eﬀects: Creates an exception_ptr object that refers to a copy of e, as if

try {

throw e;

} catch(...) {

return current_exception();

}

12

[ Note: This function is provided for convenience and eﬃciency reasons. — end note ]

18.8.6 nested_exception

[except.nested]

namespace std {

class nested_exception {
public:

nested_exception() noexcept;
nested_exception(const nested_exception&) noexcept = default;
nested_exception& operator=(const nested_exception&) noexcept = default;
virtual ~nested_exception() = default;

// access functions
[[noreturn]] void rethrow_nested() const;
exception_ptr nested_ptr() const noexcept;

};

template<class T> [[noreturn]] void throw_with_nested(T&& t);
template <class E> void rethrow_if_nested(const E& e);

}

1 The class nested_exception is designed for use as a mixin through multiple inheritance. It captures the

2

3

4

5

6

7

8

currently handled exception and stores it for later use.
[ Note: nested_exception has a virtual destructor to make it a polymorphic class.
tested for with dynamic_cast. — end note ]

Its presence can be

nested_exception() noexcept;

Eﬀects: The constructor calls current_exception() and stores the returned value.

[[noreturn]] void rethrow_nested() const;

Eﬀects: If nested_ptr() returns a null pointer, the function calls std::terminate(). Otherwise, it
throws the stored exception captured by *this.

exception_ptr nested_ptr() const noexcept;

Returns: The stored exception captured by this nested_exception object.

template <class T> [[noreturn]] void throw_with_nested(T&& t);

Let U be remove_reference_t<T>.
Requires: U shall be CopyConstructible.
if U is a non-union class type not derived from nested_exception, an exception of un-
Throws:
speciﬁed type that is publicly derived from both U and nested_exception and constructed from
std::forward<T>(t), otherwise std::forward<T>(t).

§ 18.8.6

493

c(cid:13) ISO/IEC

N4296

template <class E> void rethrow_if_nested(const E& e);

9

Eﬀects: If the dynamic type of e is publicly and unambiguously derived from nested_exception, calls
dynamic_cast<const nested_exception&>(e).rethrow_nested().

18.9 Initializer lists

[support.initlist]
1 The header <initializer_list> deﬁnes a class template and several support functions related to list-

initialization (see 8.5.4).
Header <initializer_list> synopsis

namespace std {

template<class E> class initializer_list {
public:

typedef E value_type;
typedef const E& reference;
typedef const E& const_reference;
typedef size_t size_type;

typedef const E* iterator;
typedef const E* const_iterator;

constexpr initializer_list() noexcept;

constexpr size_t size() const noexcept;
constexpr const E* begin() const noexcept;
constexpr const E* end() const noexcept;

// number of elements
// ﬁrst element
// one past the last element

};

// 18.9.3 initializer list range access
template<class E> constexpr const E* begin(initializer_list<E> il) noexcept;
template<class E> constexpr const E* end(initializer_list<E> il) noexcept;

}

3

2 An object of type initializer_list<E> provides access to an array of objects of type const E. [ Note:
A pair of pointers or a pointer plus a length would be obvious representations for initializer_list.
initializer_list is used to implement initializer lists as speciﬁed in 8.5.4. Copying an initializer list does
not copy the underlying elements. — end note ]
If an explicit specialization or partial specialization of initializer_list is declared, the program is ill-
formed.
18.9.1
constexpr initializer_list() noexcept;

Initializer list constructors

[support.initlist.cons]

1

2

1

Eﬀects: constructs an empty initializer_list object.
Postcondition: size() == 0
Initializer list access

18.9.2
constexpr const E* begin() const noexcept;

[support.initlist.access]

Returns: A pointer to the beginning of the array. If size() == 0 the values of begin() and end()
are unspeciﬁed but they shall be identical.

constexpr const E* end() const noexcept;

§ 18.9.2

494

c(cid:13) ISO/IEC

N4296

Returns: begin() + size()

constexpr size_t size() const noexcept;

Returns: The number of elements in the array.
Complexity: Constant time.

Initializer list range access

18.9.3
template<class E> constexpr const E* begin(initializer_list<E> il) noexcept;

[support.initlist.range]

Returns: il.begin().

template<class E> constexpr const E* end(initializer_list<E> il) noexcept;

Returns: il.end().

2

3

4

1

2

18.10 Other runtime support

[support.runtime]
1 Headers <csetjmp> (nonlocal jumps), <csignal> (signal handling), <cstdalign> (alignment), <cstdarg>
(variable arguments), <cstdbool> (__bool_true_false_are_defined). <cstdlib> (runtime environment
getenv(), system()), and <ctime> (system clock clock(), time()) provide further compatibility with C
code.

2 The contents of these headers are the same as the Standard C library headers <setjmp.h>, <signal.h>,
<stdalign.h>, <stdarg.h>, <stdbool.h>, <stdlib.h>, and <time.h>, respectively, with the following
changes:

3 The restrictions that ISO C places on the second parameter to the va_start() macro in header <stdarg.h>
are diﬀerent in this International Standard. The parameter parmN is the identiﬁer of the rightmost parameter
in the variable parameter list of the function deﬁnition (the one just before the ...).227 If the parameter
parmN is of a reference type, or of a type that is not compatible with the type that results when passing an
argument for which there is no parameter, the behavior is undeﬁned.
See also: ISO C 4.8.1.1.

4 The function signature longjmp(jmp_buf jbuf, int val) has more restricted behavior in this International
Standard. A setjmp/longjmp call pair has undeﬁned behavior if replacing the setjmp and longjmp by catch
and throw would invoke any non-trivial destructors for any automatic objects.
See also: ISO C 7.10.4, 7.8, 7.6, 7.12.

5 Calls to the function getenv shall not introduce a data race (17.6.5.9) provided that nothing modiﬁes the
[ Note: Calls to the POSIX functions setenv and putenv modify the environment. — end

environment.
note ]

6 A call to the setlocale function may introduce a data race with other calls to the setlocale function or
with calls to functions that are aﬀected by the current C locale. The implementation shall behave as if no
library function other than locale::global() calls the setlocale function.

7 The header <cstdalign> and the header <stdalign.h> shall not deﬁne a macro named alignas.
8 The header <cstdbool> and the header <stdbool.h> shall not deﬁne macros named bool, true, or false.
9 A call to the function signal synchronizes with any resulting invocation of the signal handler so installed.
10 The common subset of the C and C++ languages consists of all declarations, deﬁnitions, and expressions
that may appear in a well formed C++ program and also in a conforming C program. A POF (“plain old
function”) is a function that uses only features from this common subset, and that does not directly or
227) Note that va_start is required to work as speciﬁed even if unary operator& is overloaded for the type of parmN.

§ 18.10

495

c(cid:13) ISO/IEC

N4296

indirectly use any function that is not a POF, except that it may use plain lock-free atomic operations. A
plain lock-free atomic operation is an invocation of a function f from Clause 29, such that f is not a member
function, and either f
is the function atomic_is_lock_free, or for every atomic argument A passed to
f , atomic_is_lock_free(A) yields true. All signal handlers shall have C linkage. The behavior of any
function other than a POF used as a signal handler in a C++ program is implementation-deﬁned.228

Type

Macro:
Type:
Function:

Type
Macros:
SIG_IGN
Type:
Functions:

Type

Macro:

Type

Macros:
va_copy
Type:

Type

Macro:

Table 34 — Header <csetjmp> synopsis

Name(s)

setjmp
jmp_buf
longjmp

Table 35 — Header <csignal> synopsis

SIGABRT
SIGFPE
sig_atomic_t
raise

SIGILL
SIGINT

signal

Name(s)

SIGSEGV
SIGTERM

SIG_DFL
SIG_ERR

Table 36 — Header <cstdalign> synopsis

Name(s)

__alignas_is_defined

Table 37 — Header <cstdarg> synopsis

Name(s)

va_end

va_start

va_arg

va_list

Table 38 — Header <cstdbool> synopsis

__bool_true_false_are_defined

Name(s)

Type
Functions:

Table 39 — Header <cstdlib> synopsis

Name(s)

getenv

system

228) In particular, a signal handler using exception handling is very likely to have problems. Also, invoking std::exit may cause
destruction of objects, including those of the standard library implementation, which, in general, yields undeﬁned behavior in
a signal handler (see 1.9).

§ 18.10

496

c(cid:13) ISO/IEC

N4296

Type

Macro:
Type:
Function:

Table 40 — Header <ctime> synopsis

Name(s)

CLOCKS_PER_SEC
clock_t
clock

§ 18.10

497

c(cid:13) ISO/IEC

N4296

19 Diagnostics library
19.1 General

[diagnostics]
[diagnostics.general]

1 This Clause describes components that C++ programs may use to detect and report error conditions.
2 The following subclauses describe components for reporting several kinds of exceptional conditions, docu-

menting program assertions, and a global variable for error number codes, as summarized in Table 41.

Table 41 — Diagnostics library summary

Subclause

19.2 Exception classes
19.3 Assertions
19.4 Error numbers
19.5

System error support

Header(s)
<stdexcept>
<cassert>
<cerrno>
<system_error>

19.2 Exception classes

[std.exceptions]
1 The Standard C++ library provides classes to be used to report certain errors (17.6.5.12) in C++ programs.
In the error model reﬂected in these classes, errors are divided into two broad categories: logic errors and
runtime errors.

2 The distinguishing characteristic of logic errors is that they are due to errors in the internal logic of the

program. In theory, they are preventable.

3 By contrast, runtime errors are due to events beyond the scope of the program. They cannot be easily
predicted in advance. The header <stdexcept> deﬁnes several types of predeﬁned exceptions for reporting
errors in a C++ program. These exceptions are related by inheritance.
Header <stdexcept> synopsis

namespace std {

class logic_error;

class domain_error;
class invalid_argument;
class length_error;
class out_of_range;
class runtime_error;
class range_error;
class overflow_error;
class underflow_error;

}

19.2.1 Class logic_error

[logic.error]

namespace std {

class logic_error : public exception {
public:

explicit logic_error(const string& what_arg);
explicit logic_error(const char* what_arg);

};

}

§ 19.2.1

498

c(cid:13) ISO/IEC

N4296

1 The class logic_error deﬁnes the type of objects thrown as exceptions to report errors presumably de-

tectable before the program executes, such as violations of logical preconditions or class invariants.

2

3

4

5

logic_error(const string& what_arg);

Eﬀects: Constructs an object of class logic_error.
Postcondition: strcmp(what(), what_arg.c_str()) == 0.

logic_error(const char* what_arg);

Eﬀects: Constructs an object of class logic_error.
Postcondition: strcmp(what(), what_arg) == 0.

19.2.2 Class domain_error

[domain.error]

namespace std {

class domain_error : public logic_error {
public:

explicit domain_error(const string& what_arg);
explicit domain_error(const char* what_arg);

};

}

1 The class domain_error deﬁnes the type of objects thrown as exceptions by the implementation to report

domain errors.

2

3

4

5

domain_error(const string& what_arg);

Eﬀects: Constructs an object of class domain_error.
Postcondition: strcmp(what(), what_arg.c_str()) == 0.

domain_error(const char* what_arg);

Eﬀects: Constructs an object of class domain_error.
Postcondition: strcmp(what(), what_arg) == 0.

19.2.3 Class invalid_argument

[invalid.argument]

namespace std {

class invalid_argument : public logic_error {
public:

explicit invalid_argument(const string& what_arg);
explicit invalid_argument(const char* what_arg);

};

}

1 The class invalid_argument deﬁnes the type of objects thrown as exceptions to report an invalid argument.

invalid_argument(const string& what_arg);

Eﬀects: Constructs an object of class invalid_argument.
Postcondition: strcmp(what(), what_arg.c_str()) == 0.

invalid_argument(const char* what_arg);

Eﬀects: Constructs an object of class invalid_argument.
Postcondition: strcmp(what(), what_arg) == 0.

2

3

4

5

§ 19.2.3

499

c(cid:13) ISO/IEC

19.2.4 Class length_error

N4296

[length.error]

namespace std {

class length_error : public logic_error {
public:

explicit length_error(const string& what_arg);
explicit length_error(const char* what_arg);

};

}

1 The class length_error deﬁnes the type of objects thrown as exceptions to report an attempt to produce

an object whose length exceeds its maximum allowable size.

2

3

4

5

length_error(const string& what_arg);

Eﬀects: Constructs an object of class length_error.
Postcondition: strcmp(what(), what_arg.c_str()) == 0.

length_error(const char* what_arg);

Eﬀects: Constructs an object of class length_error.
Postcondition: strcmp(what(), what_arg) == 0.

19.2.5 Class out_of_range

[out.of.range]

namespace std {

class out_of_range : public logic_error {
public:

explicit out_of_range(const string& what_arg);
explicit out_of_range(const char* what_arg);

};

}

1 The class out_of_range deﬁnes the type of objects thrown as exceptions to report an argument value not

in its expected range.

2

3

4

5

out_of_range(const string& what_arg);

Eﬀects: Constructs an object of class out_of_range.
Postcondition: strcmp(what(), what_arg.c_str()) == 0.

out_of_range(const char* what_arg);

Eﬀects: Constructs an object of class out_of_range.
Postcondition: strcmp(what(), what_arg) == 0.

19.2.6 Class runtime_error

[runtime.error]

namespace std {

class runtime_error : public exception {
public:

explicit runtime_error(const string& what_arg);
explicit runtime_error(const char* what_arg);

};

}

1 The class runtime_error deﬁnes the type of objects thrown as exceptions to report errors presumably

detectable only when the program executes.

§ 19.2.6

500

c(cid:13) ISO/IEC

N4296

2

3

4

5

runtime_error(const string& what_arg);

Eﬀects: Constructs an object of class runtime_error.
Postcondition: strcmp(what(), what_arg.c_str()) == 0.

runtime_error(const char* what_arg);

Eﬀects: Constructs an object of class runtime_error.
Postcondition: strcmp(what(), what_arg) == 0.

19.2.7 Class range_error

[range.error]

namespace std {

class range_error : public runtime_error {
public:

explicit range_error(const string& what_arg);
explicit range_error(const char* what_arg);

};

}

1 The class range_error deﬁnes the type of objects thrown as exceptions to report range errors in internal

computations.

2

3

4

5

range_error(const string& what_arg);

Eﬀects: Constructs an object of class range_error.
Postcondition: strcmp(what(), what_arg.c_str()) == 0.

range_error(const char* what_arg);

Eﬀects: Constructs an object of class range_error.
Postcondition: strcmp(what(), what_arg) == 0.

19.2.8 Class overflow_error

[overﬂow.error]

namespace std {

class overflow_error : public runtime_error {
public:

explicit overflow_error(const string& what_arg);
explicit overflow_error(const char* what_arg);

};

}

1 The class overflow_error deﬁnes the type of objects thrown as exceptions to report an arithmetic overﬂow

error.

overflow_error(const string& what_arg);

Eﬀects: Constructs an object of class overflow_error.
Postcondition: strcmp(what(), what_arg.c_str()) == 0.

overflow_error(const char* what_arg);

Eﬀects: Constructs an object of class overflow_error.
Postcondition: strcmp(what(), what_arg) == 0.

2

3

4

5

§ 19.2.8

501

c(cid:13) ISO/IEC

19.2.9 Class underflow_error

N4296

[underﬂow.error]

class underflow_error : public runtime_error {
public:

explicit underflow_error(const string& what_arg);
explicit underflow_error(const char* what_arg);

namespace std {

};

}

1 The class underflow_error deﬁnes the type of objects thrown as exceptions to report an arithmetic under-

ﬂow error.

underflow_error(const string& what_arg);

Eﬀects: Constructs an object of class underflow_error.
Postcondition: strcmp(what(), what_arg.c_str()) == 0.

underflow_error(const char* what_arg);

Eﬀects: Constructs an object of class underflow_error.
Postcondition: strcmp(what(), what_arg) == 0.

2

3

4

5

19.3 Assertions

[assertions]
1 The header <cassert>, described in (Table 42), provides a macro for documenting C++ program assertions

and a mechanism for disabling the assertion checks.

Table 42 — Header <cassert> synopsis

Type Name(s)
Macro:

assert

2 The contents are the same as the Standard C library header <assert.h>.

See also: ISO C 7.2.
19.4 Error numbers

[errno]
1 The header <cerrno> is described in Table 43. Its contents are the same as the POSIX header <errno.h>,
except that errno shall be deﬁned as a macro. [ Note: The intent is to remain in close alignment with the
POSIX standard. — end note ] A separate errno value shall be provided for each thread.
19.5 System error support

[syserr]
1 This subclause describes components that the standard library and C++ programs may use to report error

conditions originating from the operating system or other low-level application program interfaces.

2 Components described in this subclause shall not change the value of errno (19.4). Implementations should

leave the error states provided by other libraries unchanged.
Header <system_error> synopsis

namespace std {

class error_category;
const error_category& generic_category() noexcept;
const error_category& system_category() noexcept;

class error_code;

§ 19.5

502

c(cid:13) ISO/IEC

Table 43 — Header <cerrno> synopsis

Type

Macros:
E2BIG
EACCES
EADDRINUSE
EADDRNOTAVAIL
EAFNOSUPPORT
EAGAIN
EALREADY
EBADF
EBADMSG
EBUSY
ECANCELED
ECHILD
ECONNABORTED

ECONNREFUSED
ECONNRESET
EDEADLK
EDESTADDRREQ
EDOM
EEXIST
EFAULT
EFBIG
EHOSTUNREACH
EIDRM
EILSEQ
EINPROGRESS
EINTR
EINVAL

EIO
EISCONN
EISDIR
ELOOP
EMFILE
EMLINK
EMSGSIZE
ENAMETOOLONG
ENETDOWN
ENETRESET
ENETUNREACH
ENFILE
ENOBUFS
ENODATA

Name(s)

ENODEV
ENOENT
ENOEXEC
ENOLCK
ENOLINK
ENOMEM
ENOMSG
ENOPROTOOPT
ENOSPC
ENOSR
ENOSTR
ENOSYS
ENOTCONN
ENOTDIR

ENOTEMPTY
ENOTRECOVERABLE
ENOTSOCK
ENOTSUP
ENOTTY
ENXIO
EOPNOTSUPP
EOVERFLOW
EOWNERDEAD
EPERM
EPIPE
EPROTO
EPROTONOSUPPORT
EPROTOTYPE

N4296

ERANGE
EROFS
ESPIPE
ESRCH
ETIME
ETIMEDOUT
ETXTBSY
EWOULDBLOCK
EXDEV
errno

class error_condition;
class system_error;

template <class T>
struct is_error_code_enum : public false_type {};

template <class T>
struct is_error_condition_enum : public false_type {};

enum class errc {

address_family_not_supported,
address_in_use,
address_not_available,
already_connected,
argument_list_too_long,
argument_out_of_domain,
bad_address,
bad_file_descriptor,
bad_message,
broken_pipe,
connection_aborted,
connection_already_in_progress,
connection_refused,
connection_reset,
cross_device_link,
destination_address_required,
device_or_resource_busy,
directory_not_empty,
executable_format_error,
file_exists,
file_too_large,
filename_too_long,
function_not_supported,
host_unreachable,
identifier_removed,

// EAFNOSUPPORT
// EADDRINUSE
// EADDRNOTAVAIL
// EISCONN
// E2BIG
// EDOM
// EFAULT
// EBADF
// EBADMSG
// EPIPE
// ECONNABORTED
// EALREADY
// ECONNREFUSED
// ECONNRESET
// EXDEV
// EDESTADDRREQ
// EBUSY
// ENOTEMPTY
// ENOEXEC
// EEXIST
// EFBIG
// ENAMETOOLONG
// ENOSYS
// EHOSTUNREACH
// EIDRM

§ 19.5

503

c(cid:13) ISO/IEC

N4296

// EILSEQ
illegal_byte_sequence,
inappropriate_io_control_operation, // ENOTTY
// EINTR
interrupted,
// EINVAL
invalid_argument,
// ESPIPE
invalid_seek,
// EIO
io_error,
// EISDIR
is_a_directory,
// EMSGSIZE
message_size,
// ENETDOWN
network_down,
// ENETRESET
network_reset,
// ENETUNREACH
network_unreachable,
// ENOBUFS
no_buffer_space,
// ECHILD
no_child_process,
// ENOLINK
no_link,
// ENOLCK
no_lock_available,
// ENODATA
no_message_available,
// ENOMSG
no_message,
// ENOPROTOOPT
no_protocol_option,
// ENOSPC
no_space_on_device,
// ENOSR
no_stream_resources,
// ENXIO
no_such_device_or_address,
// ENODEV
no_such_device,
// ENOENT
no_such_file_or_directory,
// ESRCH
no_such_process,
// ENOTDIR
not_a_directory,
// ENOTSOCK
not_a_socket,
// ENOSTR
not_a_stream,
// ENOTCONN
not_connected,
// ENOMEM
not_enough_memory,
// ENOTSUP
not_supported,
// ECANCELED
operation_canceled,
// EINPROGRESS
operation_in_progress,
// EPERM
operation_not_permitted,
// EOPNOTSUPP
operation_not_supported,
// EWOULDBLOCK
operation_would_block,
// EOWNERDEAD
owner_dead,
// EACCES
permission_denied,
// EPROTO
protocol_error,
// EPROTONOSUPPORT
protocol_not_supported,
// EROFS
read_only_file_system,
// EDEADLK
resource_deadlock_would_occur,
// EAGAIN
resource_unavailable_try_again,
// ERANGE
result_out_of_range,
// ENOTRECOVERABLE
state_not_recoverable,
// ETIME
stream_timeout,
// ETXTBSY
text_file_busy,
// ETIMEDOUT
timed_out,
// ENFILE
too_many_files_open_in_system,
// EMFILE
too_many_files_open,
// EMLINK
too_many_links,
// ELOOP
too_many_symbolic_link_levels,
// EOVERFLOW
value_too_large,
// EPROTOTYPE
wrong_protocol_type,

};

§ 19.5

504

c(cid:13) ISO/IEC

N4296

template <> struct is_error_condition_enum<errc> : true_type { }

error_code make_error_code(errc e) noexcept;
error_condition make_error_condition(errc e) noexcept;

// 19.5.4 Comparison operators:
bool operator==(const error_code& lhs, const error_code& rhs) noexcept;
bool operator==(const error_code& lhs, const error_condition& rhs) noexcept;
bool operator==(const error_condition& lhs, const error_code& rhs) noexcept;
bool operator==(const error_condition& lhs, const error_condition& rhs) noexcept;
bool operator!=(const error_code& lhs, const error_code& rhs) noexcept;
bool operator!=(const error_code& lhs, const error_condition& rhs) noexcept;
bool operator!=(const error_condition& lhs, const error_code& rhs) noexcept;
bool operator!=(const error_condition& lhs, const error_condition& rhs) noexcept;

// 19.5.5 Hash support
template <class T> struct hash;
template <> struct hash<error_code>;

} // namespace std

3 The value of each enum errc constant shall be the same as the value of the <cerrno> macro shown in
the above synopsis. Whether or not the <system_error> implementation exposes the <cerrno> macros is
unspeciﬁed.

4 The is_error_code_enum and is_error_condition_enum may be specialized for user-deﬁned types to indi-
cate that such types are eligible for class error_code and class error_condition automatic conversions,
respectively.
19.5.1 Class error_category
19.5.1.1 Class error_category overview

[syserr.errcat]
[syserr.errcat.overview]
1 The class error_category serves as a base class for types used to identify the source and encoding of a
particular category of error code. Classes may be derived from error_category to support categories of
errors in addition to those deﬁned in this International Standard. Such classes shall behave as speciﬁed in
this subclause.
[ Note: error_category objects are passed by reference, and two such objects are equal
if they have the same address. This means that applications using custom error_category types should
create a single object of each such type. — end note ]

namespace std {

class error_category {
public:

constexpr error_category() noexcept;
virtual ~error_category();
error_category(const error_category&) = delete;
error_category& operator=(const error_category&) = delete;
virtual const char* name() const noexcept = 0;
virtual error_condition default_error_condition(int ev) const noexcept;
virtual bool equivalent(int code, const error_condition& condition) const noexcept;
virtual bool equivalent(const error_code& code, int condition) const noexcept;
virtual string message(int ev) const = 0;

bool operator==(const error_category& rhs) const noexcept;
bool operator!=(const error_category& rhs) const noexcept;
bool operator<(const error_category& rhs) const noexcept;

};

§ 19.5.1.1

505

c(cid:13) ISO/IEC

N4296

const error_category& generic_category() noexcept;
const error_category& system_category() noexcept;

}

// namespace std

19.5.1.2 Class error_category virtual members
virtual ~error_category();

Eﬀects: Destroys an object of class error_category.

virtual const char* name() const noexcept = 0;
Returns: A string naming the error category.

[syserr.errcat.virtuals]

virtual error_condition default_error_condition(int ev) const noexcept;

Returns: error_condition(ev, *this).

virtual bool equivalent(int code, const error_condition& condition) const noexcept;

Returns: default_error_condition(code) == condition.

virtual bool equivalent(const error_code& code, int condition) const noexcept;

Returns: *this == code.category() && code.value() == condition.

virtual string message(int ev) const = 0;

Returns: A string that describes the error condition denoted by ev.

[syserr.errcat.nonvirtuals]

19.5.1.3 Class error_category non-virtual members
constexpr error_category() noexcept;

Eﬀects: Constructs an object of class error_category.

bool operator==(const error_category& rhs) const noexcept;

Returns: this == &rhs.

bool operator!=(const error_category& rhs) const noexcept;

Returns: !(*this == rhs).

bool operator<(const error_category& rhs) const noexcept;

Returns: less<const error_category*>()(this, &rhs).
[ Note: less (20.9.6) provides a total ordering for pointers. — end note ]

19.5.1.4 Program deﬁned classes derived from error_category
virtual const char* name() const noexcept = 0;
Returns: A string naming the error category.

virtual error_condition default_error_condition(int ev) const noexcept;
Returns: An object of type error_condition that corresponds to ev.

[syserr.errcat.derived]

virtual bool equivalent(int code, const error_condition& condition) const noexcept;

§ 19.5.1.4

506

1

2

3

4

5

6

1

2

3

4

1

2

c(cid:13) ISO/IEC

N4296

3

4

1

2

3

4

Returns: true if, for the category of error represented by *this, code is considered equivalent to
condition; otherwise, false.

virtual bool equivalent(const error_code& code, int condition) const noexcept;

Returns: true if, for the category of error represented by *this, code is considered equivalent to
condition; otherwise, false.

19.5.1.5 Error category objects
const error_category& generic_category() noexcept;

[syserr.errcat.objects]

Returns: A reference to an object of a type derived from class error_category. All calls to this
function shall return references to the same object.
Remarks: The object’s default_error_condition and equivalent virtual functions shall behave as
speciﬁed for the class error_category. The object’s name virtual function shall return a pointer to
the string "generic".

const error_category& system_category() noexcept;

Returns: A reference to an object of a type derived from class error_category. All calls to this
function shall return references to the same object.
Remarks: The object’s equivalent virtual functions shall behave as speciﬁed for class error_-
category. The object’s name virtual function shall return a pointer to the string "system". The
object’s default_error_condition virtual function shall behave as follows:
If the argument ev corresponds to a POSIX errno value posv, the function shall return error_-
condition(posv, generic_category()). Otherwise, the function shall return error_condition(ev,
system_category()). What constitutes correspondence for any given operating system is unspeci-
ﬁed.
[ Note: The number of potential system error codes is large and unbounded, and some may
not correspond to any POSIX errno value. Thus implementations are given latitude in determining
correspondence. — end note ]

19.5.2 Class error_code
19.5.2.1 Class error_code overview

[syserr.errcode]
[syserr.errcode.overview]
1 The class error_code describes an object used to hold error code values, such as those originating from the
operating system or other low-level application program interfaces. [ Note: Class error_code is an adjunct
to error reporting by exception. — end note ]

namespace std {

class error_code {
public:

// 19.5.2.2 constructors:
error_code() noexcept;
error_code(int val, const error_category& cat) noexcept;
template <class ErrorCodeEnum>

error_code(ErrorCodeEnum e) noexcept;

// 19.5.2.3 modiﬁers:
void assign(int val, const error_category& cat) noexcept;
template <class ErrorCodeEnum>

error_code& operator=(ErrorCodeEnum e) noexcept;

void clear() noexcept;

// 19.5.2.4 observers:

§ 19.5.2.1

507

c(cid:13) ISO/IEC

N4296

int value() const noexcept;
const error_category& category() const noexcept;
error_condition default_error_condition() const noexcept;
string message() const;
explicit operator bool() const noexcept;

private:

};

// exposition only
int val_;
const error_category* cat_; // exposition only

// 19.5.2.5 non-member functions:
error_code make_error_code(errc e) noexcept;
bool operator<(const error_code& lhs, const error_code& rhs) noexcept;

template <class charT, class traits>

basic_ostream<charT,traits>&

operator<<(basic_ostream<charT,traits>& os, const error_code& ec);

}

// namespace std

[syserr.errcode.constructors]

19.5.2.2 Class error_code constructors
error_code() noexcept;

Eﬀects: Constructs an object of type error_code.
Postconditions: val_ == 0 and cat_ == &system_category().

error_code(int val, const error_category& cat) noexcept;

Eﬀects: Constructs an object of type error_code.
Postconditions: val_ == val and cat_ == &cat.

template <class ErrorCodeEnum>

error_code(ErrorCodeEnum e) noexcept;

Eﬀects: Constructs an object of type error_code.
Postconditions: *this == make_error_code(e).
not
Remarks:
is_error_code_enum<ErrorCodeEnum>::value is true.

constructor

shall

This

participate

19.5.2.3 Class error_code modiﬁers
void assign(int val, const error_category& cat) noexcept;

Postconditions: val_ == val and cat_ == &cat.

template <class ErrorCodeEnum>

error_code& operator=(ErrorCodeEnum e) noexcept;
Postconditions: *this == make_error_code(e).
Returns: *this.
Remarks:
is_error_code_enum<ErrorCodeEnum>::value is true.

operator

shall

This

not

participate

in

overload

resolution

unless

[syserr.errcode.modiﬁers]

in

overload

resolution

unless

void clear() noexcept;

Postconditions: value() == 0 and category() == system_category().

§ 19.5.2.3

508

1

2

3

4

5

6

7

1

2

3

4

5

c(cid:13) ISO/IEC

19.5.2.4 Class error_code observers
int value() const noexcept;

Returns: val_.

const error_category& category() const noexcept;

Returns: *cat_.

error_condition default_error_condition() const noexcept;

Returns: category().default_error_condition(value()).

string message() const;

Returns: category().message(value()).

explicit operator bool() const noexcept;

Returns: value() != 0.

19.5.2.5 Class error_code non-member functions
error_code make_error_code(errc e) noexcept;

N4296

[syserr.errcode.observers]

[syserr.errcode.nonmembers]

Returns: error_code(static_cast<int>(e), generic_category()).

bool operator<(const error_code& lhs, const error_code& rhs) noexcept;

Returns: lhs.category() < rhs.category() || lhs.category() == rhs.category() && lhs.value()
< rhs.value().

template <class charT, class traits>

basic_ostream<charT,traits>&

operator<<(basic_ostream<charT,traits>& os, const error_code& ec);
Eﬀects: os << ec.category().name() << ’:’

<< ec.value().

1

2

3

4

5

1

2

3

19.5.3 Class error_condition
19.5.3.1 Class error_condition overview

[syserr.errcondition]
[syserr.errcondition.overview]
[ Note:
error_condition values are portable abstractions, while error_code values (19.5.2) are implementation
speciﬁc. — end note ]

1 The class error_condition describes an object used to hold values identifying error conditions.

namespace std {

class error_condition {
public:

// 19.5.3.2 constructors:
error_condition() noexcept;
error_condition(int val, const error_category& cat) noexcept;
template <class ErrorConditionEnum>

error_condition(ErrorConditionEnum e) noexcept;

// 19.5.3.3 modiﬁers:
void assign(int val, const error_category& cat) noexcept;
template<class ErrorConditionEnum>

error_condition& operator=(ErrorConditionEnum e) noexcept;

void clear() noexcept;

§ 19.5.3.1

509

c(cid:13) ISO/IEC

N4296

// 19.5.3.4 observers:
int value() const noexcept;
const error_category& category() const noexcept;
string message() const;
explicit operator bool() const noexcept;

private:

};

// exposition only
int val_;
const error_category* cat_; // exposition only

// 19.5.3.5 non-member functions:
bool operator<(const error_condition& lhs, const error_condition& rhs) noexcept;

} // namespace std

19.5.3.2 Class error_condition constructors
error_condition() noexcept;

[syserr.errcondition.constructors]

Eﬀects: Constructs an object of type error_condition.
Postconditions: val_ == 0 and cat_ == &generic_category().

error_condition(int val, const error_category& cat) noexcept;

Eﬀects: Constructs an object of type error_condition.
Postconditions: val_ == val and cat_ == &cat.

template <class ErrorConditionEnum>

error_condition(ErrorConditionEnum e) noexcept;

Eﬀects: Constructs an object of type error_condition.
Postcondition: *this == make_error_condition(e).
in
Remarks:
is_error_condition_enum<ErrorConditionEnum>::value is true.

constructor

participate

shall

This

not

overload

resolution

unless

19.5.3.3 Class error_condition modiﬁers
void assign(int val, const error_category& cat) noexcept;

Postconditions: val_ == val and cat_ == &cat.

[syserr.errcondition.modiﬁers]

template <class ErrorConditionEnum>

error_condition& operator=(ErrorConditionEnum e) noexcept;
Postcondition: *this == make_error_condition(e).
Returns: *this.
in
Remarks:
is_error_condition_enum<ErrorConditionEnum>::value is true.

participate

operator

shall

This

not

overload

resolution

unless

void clear() noexcept;

Postconditions: value() == 0 and category() == generic_category().

§ 19.5.3.3

510

1

2

3

4

5

6

7

1

2

3

4

N4296

[syserr.errcondition.observers]

c(cid:13) ISO/IEC

19.5.3.4 Class error_condition observers
int value() const noexcept;

Returns: val_.

const error_category& category() const noexcept;

Returns: *cat_.

string message() const;

Returns: category().message(value()).

explicit operator bool() const noexcept;

Returns: value() != 0.

19.5.3.5 Class error_condition non-member functions
error_condition make_error_condition(errc e) noexcept;

[syserr.errcondition.nonmembers]

Returns: error_condition(static_cast<int>(e), generic_category()).

bool operator<(const error_condition& lhs, const error_condition& rhs) noexcept;

Returns: lhs.category() < rhs.category() || lhs.category() == rhs.category() &&
lhs.value() < rhs.value().

19.5.4 Comparison operators
bool operator==(const error_code& lhs, const error_code& rhs) noexcept;

[syserr.compare]

Returns: lhs.category() == rhs.category() && lhs.value() == rhs.value().

bool operator==(const error_code& lhs, const error_condition& rhs) noexcept;

Returns: lhs.category().equivalent(lhs.value(), rhs) || rhs.category().equivalent(lhs,
rhs.value()).

bool operator==(const error_condition& lhs, const error_code& rhs) noexcept;

Returns: rhs.category().equivalent(rhs.value(), lhs) || lhs.category().equivalent(rhs,
lhs.value()).

bool operator==(const error_condition& lhs, const error_condition& rhs) noexcept;

Returns: lhs.category() == rhs.category() && lhs.value() == rhs.value().

bool operator!=(const error_code& lhs, const error_code& rhs) noexcept;
bool operator!=(const error_code& lhs, const error_condition& rhs) noexcept;
bool operator!=(const error_condition& lhs, const error_code& rhs) noexcept;
bool operator!=(const error_condition& lhs, const error_condition& rhs) noexcept;

Returns: !(lhs == rhs).

19.5.5 System error hash support
template <> struct hash<error_code>;

[syserr.hash]

The template specialization shall meet the requirements of class template hash (20.9.13).

§ 19.5.5

511

1

2

3

4

1

1

2

3

4

5

1

c(cid:13) ISO/IEC

N4296

19.5.6 Class system_error
19.5.6.1 Class system_error overview

[syserr.syserr]
[syserr.syserr.overview]
1 The class system_error describes an exception object used to report error conditions that have an associated
error code. Such error conditions typically originate from the operating system or other low-level application
program interfaces.
[ Note: If an error represents an out-of-memory condition, implementations are encouraged to throw an
exception object of type bad_alloc 18.6.2.1 rather than system_error. — end note ]

2

namespace std {

class system_error : public runtime_error {
public:

system_error(error_code ec, const string& what_arg);
system_error(error_code ec, const char* what_arg);
system_error(error_code ec);
system_error(int ev, const error_category& ecat,

const string& what_arg);

system_error(int ev, const error_category& ecat,

const char* what_arg);

system_error(int ev, const error_category& ecat);
const error_code& code() const noexcept;
const char* what() const noexcept;

};

}

// namespace std

[syserr.syserr.members]

19.5.6.2 Class system_error members
system_error(error_code ec, const string& what_arg);

Eﬀects: Constructs an object of class system_error.
Postconditions: code() == ec.
string(what()).find(what_arg) != string::npos.

system_error(error_code ec, const char* what_arg);

Eﬀects: Constructs an object of class system_error.
Postconditions: code() == ec.
string(what()).find(what_arg) != string::npos.

system_error(error_code ec);

Eﬀects: Constructs an object of class system_error.
Postconditions: code() == ec.

system_error(int ev, const error_category& ecat,

const string& what_arg);

Eﬀects: Constructs an object of class system_error.
Postconditions: code() == error_code(ev, ecat).
string(what()).find(what_arg) != string::npos.

1

2

3

4

5

6

7

8

system_error(int ev, const error_category& ecat,

const char* what_arg);

§ 19.5.6.2

512

c(cid:13) ISO/IEC

N4296

9

10

11

12

13

14

Eﬀects: Constructs an object of class system_error.
Postconditions: code() == error_code(ev, ecat).
string(what()).find(what_arg) != string::npos.

system_error(int ev, const error_category& ecat);

Eﬀects: Constructs an object of class system_error.
Postconditions: code() == error_code(ev, ecat).

const error_code& code() const noexcept;

Returns: ec or error_code(ev, ecat), from the constructor, as appropriate.

const char* what() const noexcept;

Returns: An ntbs incorporating the arguments supplied in the constructor.
[ Note: The returned NTBS might be the contents of what_arg + ": " + code.message(). — end
note ]

§ 19.5.6.2

513

c(cid:13) ISO/IEC

N4296

20 General utilities library
20.1 General

[utilities]
[utilities.general]
1 This Clause describes utilities that are generally useful in C++ programs; some of these utilities are used by

other elements of the C++ standard library. These utilities are summarized in Table 44.

20.7 Memory

20.2
20.3
20.4
20.5
20.6

Subclause
Utility components
Pairs
Tuples
Compile-time integer sequences
Fixed-size sequences of bits

Table 44 — General utilities library summary
Header(s)
<utility>
<utility>
<tuple>
<utility>
<bitset>
<memory>
<cstdlib>
<cstring>
<memory>
<functional>
<type_traits>
<ratio>
<chrono>
<ctime>
<scoped_allocator>
<typeindex>

20.8
20.9
20.10 Type traits
20.11 Compile-time rational arithmetic
20.12 Time utilities

Smart pointers
Function objects

Scoped allocators

20.13
20.14 Type indexes

20.2 Utility components

[utility]
1 This subclause contains some basic function and class templates that are used throughout the rest of the

library.
Header <utility> synopsis

2 The header <utility> deﬁnes several types and function templates that are described in this Clause. It

also deﬁnes the template pair and various function templates that operate on pair objects.

#include <initializer_list>

namespace std {

// 20.2.1, operators:
namespace rel_ops {

template<class T> bool operator!=(const T&, const T&);
template<class T> bool operator> (const T&, const T&);
template<class T> bool operator<=(const T&, const T&);
template<class T> bool operator>=(const T&, const T&);

}

// 20.2.2, swap:
template<class T> void swap(T& a, T& b) noexcept(see below );
template <class T, size_t N> void swap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));

§ 20.2

514

c(cid:13) ISO/IEC

N4296

// 20.2.3, exchange:
template <class T, class U=T> T exchange(T& obj, U&& new_val);

// 20.2.4, forward/move:
template <class T>

template <class T>

template <class T>

template <class T>

constexpr T&& forward(remove_reference_t<T>& t) noexcept;

constexpr T&& forward(remove_reference_t<T>&& t) noexcept;

constexpr remove_reference_t<T>&& move(T&&) noexcept;

constexpr conditional_t<
!is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,
const T&, T&&> move_if_noexcept(T& x) noexcept;

// 20.2.5, declval:
template <class T>

add_rvalue_reference_t<T> declval() noexcept; // as unevaluated operand

// 20.3, pairs:
template <class T1, class T2> struct pair;

// 20.3.3, pair specialized algorithms:
template <class T1, class T2>

template <class T1, class T2>

template <class T1, class T2>

template <class T1, class T2>

template <class T1, class T2>

template <class T1, class T2>

template <class T1, class T2>

constexpr bool operator==(const pair<T1,T2>&, const pair<T1,T2>&);

constexpr bool operator< (const pair<T1,T2>&, const pair<T1,T2>&);

constexpr bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&);

constexpr bool operator> (const pair<T1,T2>&, const pair<T1,T2>&);

constexpr bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&);

constexpr bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&);

void swap(pair<T1,T2>& x, pair<T1,T2>& y) noexcept(noexcept(x.swap(y)));

template <class T1, class T2>

constexpr see below make_pair(T1&&, T2&&);

// 20.3.4, tuple-like access to pair:
template <class T> class tuple_size;
template <size_t I, class T> class tuple_element;

template <class T1, class T2> struct tuple_size<pair<T1, T2> >;
template <class T1, class T2> struct tuple_element<0, pair<T1, T2> >;
template <class T1, class T2> struct tuple_element<1, pair<T1, T2> >;

template<size_t I, class T1, class T2>

constexpr tuple_element_t<I, pair<T1, T2>>&

get(pair<T1, T2>&) noexcept;

template<size_t I, class T1, class T2>

constexpr tuple_element_t<I, pair<T1, T2>>&&

get(pair<T1, T2>&&) noexcept;

§ 20.2

515

c(cid:13) ISO/IEC

N4296

template<size_t I, class T1, class T2>

constexpr const tuple_element_t<I, pair<T1, T2>>&

get(const pair<T1, T2>&) noexcept;

template <class T, class U>

constexpr T& get(pair<T, U>& p) noexcept;

template <class T, class U>

constexpr const T& get(const pair<T, U>& p) noexcept;

template <class T, class U>

constexpr T&& get(pair<T, U>&& p) noexcept;

template <class T, class U>

constexpr T& get(pair<U, T>& p) noexcept;

template <class T, class U>

constexpr const T& get(const pair<U, T>& p) noexcept;

template <class T, class U>

constexpr T&& get(pair<U, T>&& p) noexcept;

// 20.3.5, pair piecewise construction
struct piecewise_construct_t { };
constexpr piecewise_construct_t piecewise_construct{};
template <class... Types> class tuple; // deﬁned in <tuple>

// 20.5, Compile-time integer sequences
template<class T, T...> struct integer_sequence;
template<size_t... I>

using index_sequence = integer_sequence<size_t, I...>;

template<class T, T N>

template<size_t N>

using make_integer_sequence = integer_sequence<T, see below >;

using make_index_sequence = make_integer_sequence<size_t, N>;

template<class... T>

using index_sequence_for = make_index_sequence<sizeof...(T)>;

}

20.2.1 Operators

[operators]
1 To avoid redundant deﬁnitions of operator!= out of operator== and operators >, <=, and >= out of

operator<, the library provides the following:

2

3

4

5

6

7

template <class T> bool operator!=(const T& x, const T& y);

Requires: Type T is EqualityComparable (Table 17).
Returns: !(x == y).

template <class T> bool operator>(const T& x, const T& y);

Requires: Type T is LessThanComparable (Table 18).
Returns: y < x.

template <class T> bool operator<=(const T& x, const T& y);

Requires: Type T is LessThanComparable (Table 18).
Returns: !(y < x).

template <class T> bool operator>=(const T& x, const T& y);

§ 20.2.1

516

8

9

10

1

2

3

4

5

1

c(cid:13) ISO/IEC

N4296

Requires: Type T is LessThanComparable (Table 18).
Returns: !(x < y).

In this library, whenever a declaration is provided for an operator!=, operator>, operator>=, or operator<=,
and requirements and semantics are not explicitly provided, the requirements and semantics are as speciﬁed
in this Clause.
20.2.2
template<class T> void swap(T& a, T& b) noexcept(see below );
Remark: The expression inside noexcept is equivalent to:

[utility.swap]

swap

is_nothrow_move_constructible<T>::value &&
is_nothrow_move_assignable<T>::value

Requires: Type T shall be MoveConstructible (Table 20) and MoveAssignable (Table 22).
Eﬀects: Exchanges values stored in two locations.

template<class T, size_t N>

void swap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));

Requires: a[i] shall be swappable with (17.6.3.2) b[i] for all i in the range [0,N).
Eﬀects: swap_ranges(a, a + N, b)

exchange

20.2.3
template <class T, class U=T> T exchange(T& obj, U&& new_val);

[utility.exchange]

Eﬀects: Equivalent to:

T old_val = std::move(obj);
obj = std::forward<U>(new_val);
return old_val;

20.2.4

[forward]
1 The library provides templated helper functions to simplify applying move semantics to an lvalue and to

forward/move helpers

simplify the implementation of forwarding functions.

template <class T> constexpr T&& forward(remove_reference_t<T>& t) noexcept;
template <class T> constexpr T&& forward(remove_reference_t<T>&& t) noexcept;

2

3

4

Returns: static_cast<T&&>(t).
Remark: If the second form is instantiated with an lvalue reference type, the program is ill-formed.
[ Example:

template <class T, class A1, class A2>
shared_ptr<T> factory(A1&& a1, A2&& a2) {

return shared_ptr<T>(new T(std::forward<A1>(a1), std::forward<A2>(a2)));

}

};

struct A {

A(int&, const double&);

void g() {

§ 20.2.4

517

template <class T, class A1>
shared_ptr<T> factory(A1&& a1) {

return shared_ptr<T>(new T(std::forward<A1>(a1)));

struct A {

A();
A(const A&); // copies from lvalues
// moves from rvalues
A(A&&);

}

};

}

5

6

7

8

9

c(cid:13) ISO/IEC

N4296

shared_ptr<A> sp1 = factory<A>(2, 1.414); // error: 2 will not bind to int&
int i = 2;
shared_ptr<A> sp2 = factory<A>(i, 1.414); // OK

}

In the ﬁrst call to factory, A1 is deduced as int, so 2 is forwarded to A’s constructor as an rvalue. In
the second call to factory, A1 is deduced as int&, so i is forwarded to A’s constructor as an lvalue.
In both cases, A2 is deduced as double, so 1.414 is forwarded to A’s constructor as an rvalue.
— end example ]

template <class T> constexpr remove_reference_t<T>&& move(T&& t) noexcept;

Returns: static_cast<remove_reference_t<T>&&>(t).
[ Example:

void g() {

A a;
shared_ptr<A> sp1 = factory<A>(a);
shared_ptr<A> sp1 = factory<A>(std::move(a));

// “a” binds to A(const A&)
// “a” binds to A(A&&)

In the ﬁrst call to factory, A1 is deduced as A&, so a is forwarded as a non-const lvalue. This binds to
the constructor A(const A&), which copies the value from a. In the second call to factory, because of
the call std::move(a), A1 is deduced as A, so a is forwarded as an rvalue. This binds to the constructor
A(A&&), which moves the value from a.
— end example ]

template <class T> constexpr conditional_t<

!is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,
const T&, T&&> move_if_noexcept(T& x) noexcept;

Returns: std::move(x)

20.2.5 Function template declval

[declval]
1 The library provides the function template declval to simplify the deﬁnition of expressions which occur as

unevaluated operands (Clause 5).

template <class T>

add_rvalue_reference_t<T> declval() noexcept; // as unevaluated operand

2

3

Remarks: If this function is odr-used (3.2), the program is ill-formed.
Remarks: The template parameter T of declval may be an incomplete type.
[ Example:

§ 20.2.5

518

c(cid:13) ISO/IEC

N4296

template <class To, class From>

decltype(static_cast<To>(declval<From>())) convert(From&&);

declares a function template convert which only participates in overloading if the type From can be
explicitly converted to type To. For another example see class template common_type (20.10.7.6).
— end example ]

In general

20.3 Pairs
20.3.1

[pairs]
[pairs.general]
1 The library provides a template for heterogeneous pairs of values. The library also provides a matching
function template to simplify their construction and several templates that provide access to pair objects
as if they were tuple objects (see 20.4.2.5 and 20.4.2.6).
20.3.2 Class template pair

[pairs.pair]

// deﬁned in header <utility>

namespace std {

template <class T1, class T2>
struct pair {

typedef T1 first_type;
typedef T2 second_type;

T1 first;
T2 second;
pair(const pair&) = default;
pair(pair&&) = default;
constexpr pair();
constexpr pair(const T1& x, const T2& y);
template<class U, class V> constexpr pair(U&& x, V&& y);
template<class U, class V> constexpr pair(const pair<U, V>& p);
template<class U, class V> constexpr pair(pair<U, V>&& p);
template <class... Args1, class... Args2>

pair(piecewise_construct_t,

tuple<Args1...> first_args, tuple<Args2...> second_args);

pair& operator=(const pair& p);
template<class U, class V> pair& operator=(const pair<U, V>& p);
pair& operator=(pair&& p) noexcept(see below );
template<class U, class V> pair& operator=(pair<U, V>&& p);

void swap(pair& p) noexcept(see below );

};

}

1 Constructors and member functions of pair shall not throw exceptions unless one of the element-wise

operations speciﬁed to be called for that operation throws an exception.

2 The defaulted move and copy constructor, respectively, of pair shall be a constexpr function if and only if
all required element-wise initializations for copy and move, respectively, would satisfy the requirements for
a constexpr function.

constexpr pair();

3

Requires: is_default_constructible<first_type>::value is true and is_default_construct-
ible<second_type>::value is true.

§ 20.3.2

519

c(cid:13) ISO/IEC

N4296

Eﬀects: Value-initializes first and second.

constexpr pair(const T1& x, const T2& y);

Requires: is_copy_constructible<first_type>::value is true and is_copy_constructible<sec-
ond_type>::value is true.
Eﬀects: The constructor initializes first with x and second with y.

template<class U, class V> constexpr pair(U&& x, V&& y);

Requires: is_constructible<first_type, U&&>::value is true and is_constructible<second_-
type, V&&>::value is true.
Eﬀects: The constructor initializes first with std::forward<U>(x) and second with std::forward<
V>(y).
Remarks: If U is not implicitly convertible to first_type or V is not implicitly convertible to second_-
type this constructor shall not participate in overload resolution.

template<class U, class V> constexpr pair(const pair<U, V>& p);

Requires: is_constructible<first_type, const U&>::value is true and is_constructible<sec-
ond_type, const V&>::value is true.
Eﬀects: Initializes members from the corresponding members of the argument.
Remark: This constructor shall not participate in overload resolution unless const U& is implicitly
convertible to first_type and const V& is implicitly convertible to second_type.

template<class U, class V> constexpr pair(pair<U, V>&& p);

Requires: is_constructible<first_type, U&&>::value is true and is_constructible<second_-
type, V&&>::value is true.
Eﬀects: The constructor initializes first with std::forward<U>(p.first) and second with std::
forward<V>(p.second).
Remark: This constructor shall not participate in overload resolution unless U is implicitly convertible
to first_type and V is implicitly convertible to second_type.

template<class... Args1, class... Args2>

pair(piecewise_construct_t,

tuple<Args1...> first_args, tuple<Args2...> second_args);

Requires: is_constructible<first_type, Args1&&...>::value is true and is_constructible<second_-
type, Args2&&...>::value is true.
Eﬀects: The constructor initializes first with arguments of types Args1... obtained by forwarding
the elements of first_args and initializes second with arguments of types Args2... obtained by
forwarding the elements of second_args. (Here, forwarding an element x of type U within a tuple
object means calling std::forward<U>(x).) This form of construction, whereby constructor arguments
for first and second are each provided in a separate tuple object, is called piecewise construction.

pair& operator=(const pair& p);

Requires: is_copy_assignable<first_type>::value is true and is_copy_assignable<second_-
type>::value is true.
Eﬀects: Assigns p.first to first and p.second to second.
Returns: *this.

§ 20.3.2

520

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

c(cid:13) ISO/IEC

N4296

template<class U, class V> pair& operator=(const pair<U, V>& p);

Requires: is_assignable<first_type&, const U&>::value is true and is_assignable<second_-
type&, const V&>::value is true.
Eﬀects: Assigns p.first to first and p.second to second.
Returns: *this.

pair& operator=(pair&& p) noexcept(see below );

Remarks: The expression inside noexcept is equivalent to:

is_nothrow_move_assignable<T1>::value &&
is_nothrow_move_assignable<T2>::value

Requires: is_move_assignable<first_type>::value is true and is_move_assignable<second_-
type>::value is true.
Eﬀects: Assigns to first with std::forward<first_type>(p.first) and to second with
std::forward<second_type>(p.second).
Returns: *this.

template<class U, class V> pair& operator=(pair<U, V>&& p);

Requires: is_assignable<first_type&, U&&>::value is true and is_assignable<second_type&,
V&&>::value is true.
Eﬀects: Assigns to first with std::forward<U>(p.first) and to second with
std::forward<V>(p.second).
Returns: *this.

void swap(pair& p) noexcept(see below );

Remarks: The expression inside noexcept is equivalent to:

noexcept(swap(first, p.first)) &&
noexcept(swap(second, p.second))

Requires: first shall be swappable with (17.6.3.2) p.first and second shall be swappable with
p.second.
Eﬀects: Swaps first with p.first and second with p.second.

20.3.3 Specialized algorithms
template <class T1, class T2>

constexpr bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y);

[pairs.spec]

Returns: x.first == y.first && x.second == y.second.

template <class T1, class T2>

constexpr bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y);

Returns: x.first < y.first || (!(y.first < x.first) && x.second < y.second).

template <class T1, class T2>

constexpr bool operator!=(const pair<T1, T2>& x, const pair<T1, T2>& y);

Returns: !(x == y)

§ 20.3.3

521

21

22

23

24

25

26

27

28

29

30

31

32

33

1

2

3

c(cid:13) ISO/IEC

N4296

template <class T1, class T2>

constexpr bool operator>(const pair<T1, T2>& x, const pair<T1, T2>& y);

Returns: y < x

template <class T1, class T2>

constexpr bool operator>=(const pair<T1, T2>& x, const pair<T1, T2>& y);

Returns: !(x < y)

template <class T1, class T2>

constexpr bool operator<=(const pair<T1, T2>& x, const pair<T1, T2>& y);

Returns: !(y < x)

template<class T1, class T2> void swap(pair<T1, T2>& x, pair<T1, T2>& y)

noexcept(noexcept(x.swap(y)));

Eﬀects: x.swap(y)

template <class T1, class T2>

constexpr pair<V1, V2> make_pair(T1&& x, T2&& y);

Returns: pair<V1, V2>(std::forward<T1>(x), std::forward<T2>(y));
where V1 and V2 are determined as follows: Let Ui be decay_t<Ti> for each Ti. Then each Vi is X&
if Ui equals reference_wrapper<X>, otherwise Vi is Ui.
[ Example: In place of:

return pair<int, double>(5, 3.1415926);

// explicit types

a C++ program may contain:

return make_pair(5, 3.1415926);

// types are deduced

— end example ]

20.3.4 Tuple-like access to pair
template <class T1, class T2>
struct tuple_size<pair<T1, T2>>

: integral_constant<size_t, 2> { };

tuple_element<0, pair<T1, T2> >::type

Value: the type T1.

tuple_element<1, pair<T1, T2> >::type

Value: the type T2.

[pair.astuple]

template<size_t I, class T1, class T2>

constexpr tuple_element_t<I, pair<T1, T2>>&

get(pair<T1, T2>& p) noexcept;

template<size_t I, class T1, class T2>

constexpr const tuple_element_t<I, pair<T1, T2>>&

get(const pair<T1, T2>& p) noexcept;
Returns: If I == 0 returns p.first; if I == 1 returns p.second; otherwise the program is ill-formed.

4

5

6

7

8

9

1

2

3

§ 20.3.4

522

c(cid:13) ISO/IEC

N4296

template<size_t I, class T1, class T2>

constexpr tuple_element_t<I, pair<T1, T2>>&&

get(pair<T1, T2>&& p) noexcept;
Returns: If I == 0 returns std::forward<T1&&>(p.first); if I == 1 returns std::forward<T2&&>(
p.second); otherwise the program is ill-formed.

template <class T, class U>

constexpr T& get(pair<T, U>& p) noexcept;

template <class T, class U>

constexpr const T& get(const pair<T, U>& p) noexcept;

Requires: T and U are distinct types. Otherwise, the program is ill-formed.
Returns: get<0>(p);

template <class T, class U>

constexpr T&& get(pair<T, U>&& p) noexcept;

Requires: T and U are distinct types. Otherwise, the program is ill-formed.
Returns: get<0>(std::move(p));

template <class T, class U>

constexpr T& get(pair<U, T>& p) noexcept;

template <class T, class U>

constexpr const T& get(const pair<U, T>& p) noexcept;

Requires: T and U are distinct types. Otherwise, the program is ill-formed.
Returns: get<1>(p);

template <class T, class U>

constexpr T&& get(pair<U, T>&& p) noexcept;

Requires: T and U are distinct types. Otherwise, the program is ill-formed.
Returns: get<1>(std::move(p));
20.3.5 Piecewise construction
struct piecewise_construct_t { };
constexpr piecewise_construct_t piecewise_construct{};

[pair.piecewise]

4

5

6

7

8

9

10

11

12

1 The struct piecewise_construct_t is an empty structure type used as a unique type to disambiguate
constructor and function overloading. Speciﬁcally, pair has a constructor with piecewise_construct_t as
the ﬁrst argument, immediately followed by two tuple (20.4) arguments used for piecewise construction of
the elements of the pair object.
20.4 Tuples
20.4.1

[tuple]
[tuple.general]
1 This subclause describes the tuple library that provides a tuple type as the class template tuple that can
be instantiated with any number of arguments. Each template argument speciﬁes the type of an element
in the tuple. Consequently, tuples are heterogeneous, ﬁxed-size collections of values. An instantiation of
tuple with two arguments is similar to an instantiation of pair with the same two arguments. See 20.3.

In general

2 Header <tuple> synopsis

§ 20.4.1

523

c(cid:13) ISO/IEC

N4296

namespace std {

// 20.4.2, class template tuple:
template <class... Types> class tuple;

// 20.4.2.4, tuple creation functions:
const unspecified

ignore;

template <class... Types>

template <class... Types>

constexpr tuple<VTypes ...> make_tuple(Types&&...);

constexpr tuple<Types&&...> forward_as_tuple(Types&&...) noexcept;

template<class... Types>

constexpr tuple<Types&...> tie(Types&...) noexcept;

template <class... Tuples>

constexpr tuple<Ctypes ...> tuple_cat(Tuples&&...);

// 20.4.2.5, tuple helper classes:
template <class T> class tuple_size; // undeﬁned
template <class T> class tuple_size<const T>;
template <class T> class tuple_size<volatile T>;
template <class T> class tuple_size<const volatile T>;

template <class... Types> class tuple_size<tuple<Types...> >;

template <size_t I, class T> class tuple_element;
template <size_t I, class T> class tuple_element<I, const T>;
template <size_t I, class T> class tuple_element<I, volatile T>;
template <size_t I, class T> class tuple_element<I, const volatile T>;

// undeﬁned

template <size_t I, class... Types> class tuple_element<I, tuple<Types...> >;

template <size_t I, class T>

using tuple_element_t = typename tuple_element<I, T>::type;

// 20.4.2.6, element access:
template <size_t I, class... Types>

constexpr tuple_element_t<I, tuple<Types...>>&

get(tuple<Types...>&) noexcept;
template <size_t I, class... Types>

constexpr tuple_element_t<I, tuple<Types...>>&&

get(tuple<Types...>&&) noexcept;
template <size_t I, class... Types>

constexpr const tuple_element_t<I, tuple<Types...>>&

get(const tuple<Types...>&) noexcept;

template <class T, class... Types>

constexpr T& get(tuple<Types...>& t) noexcept;

template <class T, class... Types>

constexpr T&& get(tuple<Types...>&& t) noexcept;

template <class T, class... Types>

constexpr const T& get(const tuple<Types...>& t) noexcept;

// 20.4.2.7, relational operators:
template<class... TTypes, class... UTypes>

§ 20.4.1

524

c(cid:13) ISO/IEC

N4296

constexpr bool operator==(const tuple<TTypes...>&, const tuple<UTypes...>&);

template<class... TTypes, class... UTypes>

constexpr bool operator<(const tuple<TTypes...>&, const tuple<UTypes...>&);

template<class... TTypes, class... UTypes>

constexpr bool operator!=(const tuple<TTypes...>&, const tuple<UTypes...>&);

template<class... TTypes, class... UTypes>

constexpr bool operator>(const tuple<TTypes...>&, const tuple<UTypes...>&);

template<class... TTypes, class... UTypes>

constexpr bool operator<=(const tuple<TTypes...>&, const tuple<UTypes...>&);

template<class... TTypes, class... UTypes>

constexpr bool operator>=(const tuple<TTypes...>&, const tuple<UTypes...>&);

// 20.4.2.8, allocator-related traits
template <class... Types, class Alloc>

struct uses_allocator<tuple<Types...>, Alloc>;

// 20.4.2.9, specialized algorithms:
template <class... Types>

void swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(see below );

}

20.4.2 Class template tuple

[tuple.tuple]

namespace std {

template <class... Types>
class tuple
public:

{

// 20.4.2.1, tuple construction
constexpr tuple();
constexpr explicit tuple(const Types&...);
template <class... UTypes>

constexpr explicit tuple(UTypes&&...);

tuple(const tuple&) = default;
tuple(tuple&&) = default;

template <class... UTypes>

constexpr tuple(const tuple<UTypes...>&);

template <class... UTypes>

constexpr tuple(tuple<UTypes...>&&);

template <class U1, class U2>

constexpr tuple(const pair<U1, U2>&);

template <class U1, class U2>

constexpr tuple(pair<U1, U2>&&);

// only if sizeof...(Types) == 2

// only if sizeof...(Types) == 2

// allocator-extended constructors
template <class Alloc>

tuple(allocator_arg_t, const Alloc& a);

template <class Alloc>

tuple(allocator_arg_t, const Alloc& a, const Types&...);

template <class Alloc, class... UTypes>

tuple(allocator_arg_t, const Alloc& a, UTypes&&...);

template <class Alloc>

§ 20.4.2

525

c(cid:13) ISO/IEC

N4296

tuple(allocator_arg_t, const Alloc& a, const tuple&);

template <class Alloc>

tuple(allocator_arg_t, const Alloc& a, tuple&&);

template <class Alloc, class... UTypes>

tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&);

template <class Alloc, class... UTypes>

tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&);

template <class Alloc, class U1, class U2>

tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);

template <class Alloc, class U1, class U2>

tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);

// 20.4.2.2, tuple assignment
tuple& operator=(const tuple&);
tuple& operator=(tuple&&) noexcept(see below );

template <class... UTypes>

tuple& operator=(const tuple<UTypes...>&);

template <class... UTypes>

tuple& operator=(tuple<UTypes...>&&);

template <class U1, class U2>

tuple& operator=(const pair<U1, U2>&);

template <class U1, class U2>

tuple& operator=(pair<U1, U2>&&);

// only if sizeof...(Types) == 2

// only if sizeof...(Types) == 2

// 20.4.2.3, tuple swap
void swap(tuple&) noexcept(see below );

};

}

20.4.2.1 Construction

[tuple.cnstr]
1 For each tuple constructor, an exception is thrown only if the construction of one of the types in Types

throws an exception.

2 The defaulted move and copy constructor, respectively, of tuple shall be a constexpr function if and only
if all required element-wise initializations for copy and move, respectively, would satisfy the requirements for
a constexpr function. The defaulted move and copy constructor of tuple<> shall be constexpr functions.
In the constructor descriptions that follow, let i be in the range [0,sizeof...(Types)) in order, Ti be the
ith type in Types, and Ui be the ith type in a template parameter pack named UTypes, where indexing is
zero-based.

3

constexpr tuple();

Requires: is_default_constructible<Ti>::value is true for all i.
Eﬀects: Value initializes each element.

constexpr explicit tuple(const Types&...);

Requires: is_copy_constructible<Ti>::value is true for all i.
Eﬀects: Initializes each element with the value of the corresponding parameter.

4

5

6

7

template <class... UTypes>

constexpr explicit tuple(UTypes&&... u);

§ 20.4.2.1

526

c(cid:13) ISO/IEC

N4296

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

Requires: sizeof...(Types) == sizeof...(UTypes). is_constructible<Ti, Ui&&>::value is true
for all i.
Eﬀects: Initializes the elements in the tuple with the corresponding value in std::forward<UTypes>(u).
Remark: This constructor shall not participate in overload resolution unless each type in UTypes is
implicitly convertible to its corresponding type in Types.

tuple(const tuple& u) = default;

Requires: is_copy_constructible<Ti>::value is true for all i.
Eﬀects: Initializes each element of *this with the corresponding element of u.

tuple(tuple&& u) = default;

Requires: is_move_constructible<Ti>::value is true for all i.
Eﬀects: For all i, initializes the ith element of *this with std::forward<Ti>(get<i>(u)).

template <class... UTypes> constexpr tuple(const tuple<UTypes...>& u);

Requires: sizeof...(Types) == sizeof...(UTypes). is_constructible<Ti, const Ui&>::value
is true for all i.
Eﬀects: Constructs each element of *this with the corresponding element of u.
Remark: This constructor shall not participate in overload resolution unless const Ui& is implicitly
convertible to Ti for all i.

template <class... UTypes> constexpr tuple(tuple<UTypes...>&& u);

Requires: sizeof...(Types) == sizeof...(UTypes). is_constructible<Ti, Ui&&>::value is true
for all i.
Eﬀects: For all i, initializes the ith element of *this with std::forward<Ui>(get<i>(u)).
Remark: This constructor shall not participate in overload resolution unless each type in UTypes is
implicitly convertible to its corresponding type in Types.

template <class U1, class U2> constexpr tuple(const pair<U1, U2>& u);

Requires: sizeof...(Types) == 2. is_constructible<T0, const U1&>::value is true for the ﬁrst
type T0 in Types and is_constructible<T1, const U2&>::value is true for the second type T1 in
Types.
Eﬀects: Constructs the ﬁrst element with u.first and the second element with u.second.
Remark: This constructor shall not participate in overload resolution unless const U1& is implicitly
convertible to T0 and const U2& is implicitly convertible to T1.

template <class U1, class U2> constexpr tuple(pair<U1, U2>&& u);

Requires: sizeof...(Types) == 2. is_constructible<T0, U1&&>::value is true for the ﬁrst type
T0 in Types and is_constructible<T1, U2&&>::value is true for the second type T1 in Types.
Eﬀects: Initializes the ﬁrst element with std::forward<U1>(u.first) and the second element with
std::forward<U2>(u.second).
Remark: This constructor shall not participate in overload resolution unless U1 is implicitly convertible
to T0 and U2 is implicitly convertible to T1.

§ 20.4.2.1

527

c(cid:13) ISO/IEC

N4296

template <class Alloc>

tuple(allocator_arg_t, const Alloc& a);

template <class Alloc>

tuple(allocator_arg_t, const Alloc& a, const Types&...);

template <class Alloc, class... UTypes>

tuple(allocator_arg_t, const Alloc& a, UTypes&&...);

template <class Alloc>

template <class Alloc>

tuple(allocator_arg_t, const Alloc& a, const tuple&);

tuple(allocator_arg_t, const Alloc& a, tuple&&);

template <class Alloc, class... UTypes>

tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&);

template <class Alloc, class... UTypes>

tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&);

template <class Alloc, class U1, class U2>

tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);

template <class Alloc, class U1, class U2>

tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);

27

28

Requires: Alloc shall meet the requirements for an Allocator (17.6.3.5).
Eﬀects: Equivalent to the preceding constructors except that each element is constructed with uses-
allocator construction (20.7.7.2).

20.4.2.2 Assignment

[tuple.assign]
1 For each tuple assignment operator, an exception is thrown only if the assignment of one of the types in
Types throws an exception. In the function descriptions that follow, let i be in the range [0,sizeof...
(Types)) in order, Ti be the ith type in Types, and Ui be the ith type in a template parameter pack named
UTypes, where indexing is zero-based.

2

3

4

5

6

7

8

9

10

11

tuple& operator=(const tuple& u);

Requires: is_copy_assignable<Ti>::value is true for all i.
Eﬀects: Assigns each element of u to the corresponding element of *this.
Returns: *this

tuple& operator=(tuple&& u) noexcept(see below );

Remark: The expression inside noexcept is equivalent to the logical and of the following expressions:

is_nothrow_move_assignable<Ti>::value

where Ti is the ith type in Types.
Requires: is_move_assignable<Ti>::value is true for all i.
Eﬀects: For all i, assigns std::forward<Ti>(get<i>(u)) to get<i>(*this).
Returns: *this.

template <class... UTypes>

tuple& operator=(const tuple<UTypes...>& u);

Requires: sizeof...(Types) == sizeof...(UTypes) and is_assignable<Ti&, const Ui&>::value
is true for all i.
Eﬀects: Assigns each element of u to the corresponding element of *this.
Returns: *this

§ 20.4.2.2

528

c(cid:13) ISO/IEC

N4296

template <class... UTypes>

tuple& operator=(tuple<UTypes...>&& u);

Requires: is_assignable<Ti&, Ui&&>::value == true for all i. sizeof...(Types) ==
sizeof...(UTypes).
Eﬀects: For all i, assigns std::forward<Ui>(get<i)>(u)) to get<i>(*this).
Returns: *this.

template <class U1, class U2> tuple& operator=(const pair<U1, U2>& u);

Requires: sizeof...(Types) == 2. is_assignable<T0&, const U1&>::value is true for the ﬁrst
type T0 in Types and is_assignable<T1&, const U2&>::value is true for the second type T1 in
Types.
Eﬀects: Assigns u.first to the ﬁrst element of *this and u.second to the second element of *this.
Returns: *this

template <class U1, class U2> tuple& operator=(pair<U1, U2>&& u);

Requires: sizeof...(Types) == 2. is_assignable<T0&, U1&&>::value is true for the ﬁrst type T0
in Types and is_assignable<T1&, U2&&>::value is true for the second type T1 in Types.
Eﬀects: Assigns std::forward<U1>(u.first) to the ﬁrst element of *this and
std::forward<U2>(u.second) to the second element of *this.
Returns: *this.

20.4.2.3 swap
void swap(tuple& rhs) noexcept(see below );

[tuple.swap]

Remark: The expression inside noexcept is equivalent to the logical and of the following expressions:

noexcept(swap(declval<Ti&>>(), declval<Ti&>()))

where Ti is the ith type in Types.
Requires: Each element in *this shall be swappable with (17.6.3.2) the corresponding element in rhs.
Eﬀects: Calls swap for each element in *this and its corresponding element in rhs.
Throws: Nothing unless one of the element-wise swap calls throws an exception.

20.4.2.4 Tuple creation functions
[tuple.creation]
In the function descriptions that follow, let i be in the range [0,sizeof...(TTypes)) in order and let Ti
be the ith type in a template parameter pack named TTypes; let j be in the range [0,sizeof...(UTypes))
in order and Uj be the jth type in a template parameter pack named UTypes, where indexing is zero-based.
template<class... Types>

constexpr tuple<VTypes ...> make_tuple(Types&&... t);

Let Ui be decay_t<Ti> for each Ti in Types. Then each Vi in VTypes is X& if Ui equals reference_-
wrapper<X>, otherwise Vi is Ui.
Returns: tuple<VTypes...>(std::forward<Types>(t)...).
[ Example:

12

13

14

15

16

17

18

19

20

1

2

3

4

1

2

3

4

int i; float j;
make_tuple(1, ref(i), cref(j))

creates a tuple of type

§ 20.4.2.4

529

5

6

7

8

9

10

11

12

13

c(cid:13) ISO/IEC

N4296

tuple<int, int&, const float&>

— end example ]

template<class... Types>

constexpr tuple<Types&&...> forward_as_tuple(Types&&... t) noexcept;

Eﬀects: Constructs a tuple of references to the arguments in t suitable for forwarding as arguments to
a function. Because the result may contain references to temporary variables, a program shall ensure
that the return value of this function does not outlive any of its arguments. (e.g., the program should
typically not store the result in a named variable).
Returns: tuple<Types&&...>(std::forward<Types>(t)...)

template<class... Types>

constexpr tuple<Types&...> tie(Types&... t) noexcept;

Returns: tuple<Types&...>(t...). When an argument in t is ignore, assigning any value to the
corresponding tuple element has no eﬀect.
[ Example: tie functions allow one to create tuples that unpack tuples into variables. ignore can be
used for elements that are not needed:

int i; std::string s;
tie(i, ignore, s) = make_tuple(42, 3.14, "C++");
// i == 42, s == "C++"

— end example ]

template <class... Tuples>

constexpr tuple<CTypes ...> tuple_cat(Tuples&&... tpls);

In the following paragraphs, let Ti be the ith type in Tuples, Ui be remove_reference_t<Ti>, and
tpi be the ith parameter in the function parameter pack tpls, where all indexing is zero-based.
Requires: For all i, Ui shall be the type cvi tuple<Argsi...>, where cvi is the (possibly empty) ith
cv-qualiﬁer-seq and Argsi is the parameter pack representing the element types in Ui. Let Aik be
the ki
th type in Argsi. For all Aik the following requirements shall be satisﬁed: If Ti is deduced as
an lvalue reference type, then is_constructible<Aik, cvi Aik&>::value == true, otherwise is_-
constructible<Aik, cviAik&&>::value == true.
Remarks: The types in Ctypes shall be equal to the ordered sequence of the extended types Args0...,
Args1..., ... Argsn−1..., where n is equal to sizeof...(Tuples). Let ei... be the ith ordered
sequence of tuple elements of the resulting tuple object corresponding to the type sequence Argsi.
Returns: A tuple object constructed by initializing the ki
get<ki>(std::forward<Ti>(tpi)) for each valid ki and each group ei in order.
Note: An implementation may support additional types in the parameter pack Tuples that support
the tuple-like protocol, such as pair and array.

th type element eik in ei... with

20.4.2.5 Tuple helper classes
template <class T> struct tuple_size;

[tuple.helper]

Remarks: All specializations of tuple_size<T> shall meet the UnaryTypeTrait requirements (20.10.1)
with a BaseCharacteristic of integral_constant<size_t, N> for some N.

template <class... Types>
class tuple_size<tuple<Types...> >

: public integral_constant<size_t, sizeof...(Types)> { };

§ 20.4.2.5

530

c(cid:13) ISO/IEC

N4296

template <size_t I, class... Types>
class tuple_element<I, tuple<Types...> > {
public:

typedef TI type;

};

1

2

3

4

5

(5.1)

(5.2)

(5.3)
6

1

2

3

4

Requires: I < sizeof...(Types). The program is ill-formed if I is out of bounds.
Type: TI is the type of the Ith element of Types, where indexing is zero-based.

template <class T> class tuple_size<const T>;
template <class T> class tuple_size<volatile T>;
template <class T> class tuple_size<const volatile T>;

Let TS denote tuple_size<T> of the cv-unqualiﬁed type T. Then each of the three templates shall
meet the UnaryTypeTrait requirements (20.10.1) with a BaseCharacteristic of

integral_constant<size_t, TS::value>

In addition to being available via inclusion of the <tuple> header, the three templates are available
when either of the headers <array> or <utility> are included.

template <size_t I, class T> class tuple_element<I, const T>;
template <size_t I, class T> class tuple_element<I, volatile T>;
template <size_t I, class T> class tuple_element<I, const volatile T>;

Let TE denote tuple_element<I, T> of the cv-unqualiﬁed type T. Then each of the three templates
shall meet the TransformationTrait requirements (20.10.1) with a member typedef type that names
the following type:
—
—
—
In addition to being available via inclusion of the <tuple> header, the three templates are available
when either of the headers <array> or <utility> are included.

for the ﬁrst specialization, add_const_t<TE ::type>,
for the second specialization, add_volatile_t<TE ::type>, and
for the third specialization, add_cv_t<TE ::type>.

20.4.2.6 Element access
template <size_t I, class... Types>

constexpr tuple_element_t<I, tuple<Types...> >& get(tuple<Types...>& t) noexcept;
Requires: I < sizeof...(Types). The program is ill-formed if I is out of bounds.
Returns: A reference to the Ith element of t, where indexing is zero-based.

[tuple.elem]

template <size_t I, class... Types>

constexpr tuple_element_t<I, tuple<Types...> >&& get(tuple<Types...>&& t) noexcept;

Eﬀects: Equivalent to return std::forward<typename tuple_element<I, tuple<Types...> >
::type&&>(get<I>(t));
Note: if a T in Types is some reference type X&, the return type is X&, not X&&. However, if the element
type is a non-reference type T, the return type is T&&.

template <size_t I, class... Types>

constexpr tuple_element_t<I, tuple<Types...> > const& get(const tuple<Types...>& t) noexcept;

§ 20.4.2.6

531

5

6

7

8

9

10

11

1

2

3

4

5

c(cid:13) ISO/IEC

N4296

Requires: I < sizeof...(Types). The program is ill-formed if I is out of bounds.
Returns: A const reference to the Ith element of t, where indexing is zero-based.
[ Note: Constness is shallow. If a T in Types is some reference type X&, the return type is X&, not
const X&. However, if the element type is non-reference type T, the return type is const T&. This is
consistent with how constness is deﬁned to work for member variables of reference type. — end note ]

template <class T, class... Types>

constexpr T& get(tuple<Types...>& t) noexcept;

template <class T, class... Types>

constexpr T&& get(tuple<Types...>&& t) noexcept;

template <class T, class... Types>

constexpr const T& get(const tuple<Types...>& t) noexcept;

Requires: The type T occurs exactly once in Types.... Otherwise, the program is ill-formed.
Returns: A reference to the element of t corresponding to the type T in Types....
[ Example:

const tuple<int, const int, double, double> t(1, 2, 3.4, 5.6);
// OK. Not ambiguous. i1 == 1
const int &i1 = get<int>(t);
const int &i2 = get<const int>(t); // OK. Not ambiguous. i2 == 2
const double &d = get<double>(t);

// ERROR. ill-formed

— end example ]

[ Note: The reason get is a nonmember function is that if this functionality had been provided as a member
function, code where the type depended on a template parameter would have required using the template
keyword. — end note ]
20.4.2.7 Relational operators
template<class... TTypes, class... UTypes>

[tuple.rel]

constexpr bool operator==(const tuple<TTypes...>& t, const tuple<UTypes...>& u);

Requires: For all i, where 0 <= i and i < sizeof...(TTypes), get<i>(t) == get<i>(u) is a valid
expression returning a type that is convertible to bool. sizeof...(TTypes) == sizeof...(UTypes).
Returns: true if get<i>(t) == get<i>(u) for all i, otherwise false. For any two zero-length tuples
e and f, e == f returns true.
Eﬀects: The elementary comparisons are performed in order from the zeroth index upwards. No
comparisons or element accesses are performed after the ﬁrst equality comparison that evaluates to
false.

template<class... TTypes, class... UTypes>

constexpr bool operator<(const tuple<TTypes...>& t, const tuple<UTypes...>& u);

Requires: For all i, where 0 <= i and i < sizeof...(TTypes), get<i>(t) < get<i>(u) and get<i>(u)
< get<i>(t) are valid expressions returning types that are convertible to bool. sizeof...(TTypes)
== sizeof...(UTypes).
Returns: The result of a lexicographical comparison between t and u. The result is deﬁned as:
(bool)(get<0>(t) < get<0>(u)) || (!(bool)(get<0>(u) < get<0>(t)) && ttail < utail), where
rtail for some tuple r is a tuple containing all but the ﬁrst element of r. For any two zero-length tuples
e and f, e < f returns false.

template<class... TTypes, class... UTypes>

constexpr bool operator!=(const tuple<TTypes...>& t, const tuple<UTypes...>& u);

§ 20.4.2.7

532

N4296

c(cid:13) ISO/IEC

Returns: !(t == u).

template<class... TTypes, class... UTypes>

constexpr bool operator>(const tuple<TTypes...>& t, const tuple<UTypes...>& u);

Returns: u < t.

template<class... TTypes, class... UTypes>

constexpr bool operator<=(const tuple<TTypes...>& t, const tuple<UTypes...>& u);

Returns: !(u < t)

template<class... TTypes, class... UTypes>

constexpr bool operator>=(const tuple<TTypes...>& t, const tuple<UTypes...>& u);

Returns: !(t < u)

[ Note: The above deﬁnitions for comparison operators do not require ttail (or utail) to be constructed. It may
not even be possible, as t and u are not required to be copy constructible. Also, all comparison operators
are short circuited; they do not perform element accesses beyond what is required to determine the result
of the comparison. — end note ]
20.4.2.8 Tuple traits
template <class... Types, class Alloc>

[tuple.traits]

struct uses_allocator<tuple<Types...>, Alloc> : true_type { };

Requires: Alloc shall be an Allocator (17.6.3.5).
[ Note: Specialization of this trait informs other library components that tuple can be constructed
with an allocator, even though it does not have a nested allocator_type. — end note ]

20.4.2.9 Tuple specialized algorithms
template <class... Types>

void swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(see below );

Remark: The expression inside noexcept is equivalent to:

[tuple.special]

noexcept(x.swap(y))

Eﬀects: x.swap(y)

6

7

8

9

10

1

1

2

In general

20.5 Compile-time integer sequences
20.5.1

[intseq]
[intseq.general]
1 The library provides a class template that can represent an integer sequence. When used as an argument to
a function template the parameter pack deﬁning the sequence can be deduced and used in a pack expansion.
[ Example:

2

template<class F, class Tuple, std::size_t... I>

decltype(auto) apply_impl(F&& f, Tuple&& t, index_sequence<I...>) {
return std::forward<F>(f)(std::get<I>(std::forward<Tuple>(t))...);

}

}

template<class F, class Tuple>

decltype(auto) apply(F&& f, Tuple&& t) {

using Indices = make_index_sequence<std::tuple_size<std::decay_t<Tuple>>::value>;
return apply_impl(std::forward<F>(f), std::forward<Tuple>(t), Indices());

§ 20.5.1

533

c(cid:13) ISO/IEC

N4296

— end example ] [ Note: The index_sequence alias template is provided for the common case of an integer
sequence of type size_t. — end note ]
20.5.2 Class template integer_sequence

[intseq.intseq]

namespace std {

template<class T, T... I>
struct integer_sequence {

};

}

typedef T value_type;
static constexpr size_t size() noexcept { return sizeof...(I); }

1 T shall be an integer type.

20.5.3 Alias template make_integer_sequence
template<class T, T N>

using make_integer_sequence = integer_sequence<T, see below >;

[intseq.make]

1

If N is negative the program is ill-formed. The alias template make_integer_sequence denotes a
specialization of integer_sequence with N template non-type arguments. The type make_integer_-
sequence<T, N> denotes the type integer_sequence<T, 0, 1, ..., N-1>. [ Note: make_integer_-
sequence<int, 0> denotes the type integer_sequence<int> — end note ]

20.6 Class template bitset
Header <bitset> synopsis

[template.bitset]

#include <string>
#include <iosfwd>
namespace std {

template <size_t N> class bitset;

// for istream, ostream

// 20.6.4 bitset operators:
template <size_t N>

template <size_t N>

template <size_t N>

bitset<N> operator&(const bitset<N>&, const bitset<N>&) noexcept;

bitset<N> operator|(const bitset<N>&, const bitset<N>&) noexcept;

bitset<N> operator^(const bitset<N>&, const bitset<N>&) noexcept;

template <class charT, class traits, size_t N>

basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, bitset<N>& x);

template <class charT, class traits, size_t N>

basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);

}

1 The header <bitset> deﬁnes a class template and several related functions for representing and manipulating

ﬁxed-size sequences of bits.

namespace std {

template<size_t N> class bitset {
public:

// bit reference:
class reference {

friend class bitset;

§ 20.6

534

c(cid:13) ISO/IEC

N4296

reference() noexcept;

public:
~reference() noexcept;
reference& operator=(bool x) noexcept;
reference& operator=(const reference&) noexcept;
bool operator~() const noexcept;
operator bool() const noexcept;
reference& flip() noexcept;

};

// for b[i] = x;
// for b[i] = b[j];
// ﬂips the bit
// for x = b[i];
// for b[i].flip();

// 20.6.1 constructors:
constexpr bitset() noexcept;
constexpr bitset(unsigned long long val) noexcept;
template<class charT, class traits, class Allocator>

explicit bitset(

const basic_string<charT,traits,Allocator>& str,
typename basic_string<charT,traits,Allocator>::size_type pos = 0,
typename basic_string<charT,traits,Allocator>::size_type n =

basic_string<charT,traits,Allocator>::npos,
charT zero = charT(’0’), charT one = charT(’1’));

template <class charT>

explicit bitset(

const charT* str,
typename basic_string<charT>::size_type n = basic_string<charT>::npos,
charT zero = charT(’0’), charT one = charT(’1’));

// 20.6.2 bitset operations:
bitset<N>& operator&=(const bitset<N>& rhs) noexcept;
bitset<N>& operator|=(const bitset<N>& rhs) noexcept;
bitset<N>& operator^=(const bitset<N>& rhs) noexcept;
bitset<N>& operator<<=(size_t pos) noexcept;
bitset<N>& operator>>=(size_t pos) noexcept;
bitset<N>& set() noexcept;
bitset<N>& set(size_t pos, bool val = true);
bitset<N>& reset() noexcept;
bitset<N>& reset(size_t pos);
bitset<N>
bitset<N>& flip() noexcept;
bitset<N>& flip(size_t pos);

operator~() const noexcept;

// element access:
constexpr bool operator[](size_t pos) const;
reference operator[](size_t pos);

// for b[i];
// for b[i];

unsigned long to_ulong() const;
unsigned long long to_ullong() const;
template <class charT = char,

class traits = char_traits<charT>,
class Allocator = allocator<charT> >
basic_string<charT, traits, Allocator>
to_string(charT zero = charT(’0’), charT one = charT(’1’)) const;

size_t count() const noexcept;
constexpr size_t size() const noexcept;
bool operator==(const bitset<N>& rhs) const noexcept;
bool operator!=(const bitset<N>& rhs) const noexcept;

§ 20.6

535

c(cid:13) ISO/IEC

N4296

bool test(size_t pos) const;
bool all() const noexcept;
bool any() const noexcept;
bool none() const noexcept;
bitset<N> operator<<(size_t pos) const noexcept;
bitset<N> operator>>(size_t pos) const noexcept;

};

// 20.6.3 hash support
template <class T> struct hash;
template <size_t N> struct hash<bitset<N> >;

}

2 The class template bitset<N>describes an object that can store a sequence consisting of a ﬁxed number of

bits, N.

3 Each bit represents either the value zero (reset) or one (set). To toggle a bit is to change the value zero to
one, or the value one to zero. Each bit has a non-negative position pos. When converting between an object
of class bitset<N> and a value of some integral type, bit position pos corresponds to the bit value 1 <<pos.
The integral value corresponding to two or more bits is the sum of their bit values.

4 The functions described in this subclause can report three kinds of errors, each associated with a distinct

exception:

(4.1)

(4.2)

(4.3)

—
—
—

an invalid-argument error is associated with exceptions of type invalid_argument (19.2.3);
an out-of-range error is associated with exceptions of type out_of_range (19.2.5);
an overﬂow error is associated with exceptions of type overflow_error (19.2.8).

1

2

3

4

5

20.6.1 bitset constructors
constexpr bitset() noexcept;

[bitset.cons]

Eﬀects: Constructs an object of class bitset<N>, initializing all bits to zero.

constexpr bitset(unsigned long long val) noexcept;

Eﬀects: Constructs an object of class bitset<N>, initializing the ﬁrst M bit positions to the correspond-
ing bit values in val. M is the smaller of N and the number of bits in the value representation (3.9) of
unsigned long long. If M < N, the remaining bit positions are initialized to zero.

template <class charT, class traits, class Allocator>
explicit
bitset(const basic_string<charT, traits, Allocator>& str,

typename basic_string<charT, traits, Allocator>::size_type pos = 0,
typename basic_string<charT, traits, Allocator>::size_type n =

basic_string<charT, traits, Allocator>::npos,
charT zero = charT(’0’), charT one = charT(’1’));

Requires: pos <= str.size().
Throws: out_of_range if pos > str.size().
Eﬀects: Determines the eﬀective length rlen of the initializing string as the smaller of n and str.size()
- pos.
The function then throws invalid_argument if any of the rlen characters in str beginning at position
pos is other than zero or one. The function uses traits::eq() to compare the character values.

§ 20.6.1

536

c(cid:13) ISO/IEC

N4296

Otherwise, the function constructs an object of class bitset<N>, initializing the ﬁrst M bit positions to
values determined from the corresponding characters in the string str. M is the smaller of N and rlen.
An element of the constructed object has value zero if the corresponding character in str, beginning
at position pos, is zero. Otherwise, the element has the value one. Character position pos + M - 1
corresponds to bit position zero. Subsequent decreasing character positions correspond to increasing
bit positions.
If M < N, remaining bit positions are initialized to zero.

template <class charT>

explicit bitset(

const charT* str,
typename basic_string<charT>::size_type n = basic_string<charT>::npos,
charT zero = charT(’0’), charT one = charT(’1’));
Eﬀects: Constructs an object of class bitset<N> as if by

bitset(

n == basic_string<charT>::npos

? basic_string<charT>(str)
: basic_string<charT>(str, n),

0, n, zero, one)

20.6.2 bitset members
bitset<N>& operator&=(const bitset<N>& rhs) noexcept;

[bitset.members]

Eﬀects: Clears each bit in *this for which the corresponding bit in rhs is clear, and leaves all other
bits unchanged.
Returns: *this.

bitset<N>& operator|=(const bitset<N>& rhs) noexcept;

Eﬀects: Sets each bit in *this for which the corresponding bit in rhs is set, and leaves all other bits
unchanged.
Returns: *this.

bitset<N>& operator^=(const bitset<N>& rhs) noexcept;

Eﬀects: Toggles each bit in *this for which the corresponding bit in rhs is set, and leaves all other
bits unchanged.
Returns: *this.

6

7

8

1

2

3

4

5

6

bitset<N>& operator<<=(size_t pos) noexcept;

Eﬀects: Replaces each bit at position I in *this with a value determined as follows:
—
—
Returns: *this.

If I < pos, the new value is zero;
If I >= pos, the new value is the previous value of the bit at position I - pos.

bitset<N>& operator>>=(size_t pos) noexcept;

Eﬀects: Replaces each bit at position I in *this with a value determined as follows:
—
—

If pos >= N - I, the new value is zero;
If pos < N - I, the new value is the previous value of the bit at position I + pos.

7
(7.1)

(7.2)
8

9
(9.1)

(9.2)

§ 20.6.2

537

c(cid:13) ISO/IEC

N4296

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

Returns: *this.

bitset<N>& set() noexcept;

Eﬀects: Sets all bits in *this.
Returns: *this.

bitset<N>& set(size_t pos, bool val = true);

Requires: pos is valid
Throws: out_of_range if pos does not correspond to a valid bit position.
Eﬀects: Stores a new value in the bit at position pos in *this. If val is nonzero, the stored value is
one, otherwise it is zero.
Returns: *this.

bitset<N>& reset() noexcept;

Eﬀects: Resets all bits in *this.
Returns: *this.

bitset<N>& reset(size_t pos);

Requires: pos is valid
Throws: out_of_range if pos does not correspond to a valid bit position.
Eﬀects: Resets the bit at position pos in *this.
Returns: *this.

bitset<N> operator~() const noexcept;

Eﬀects: Constructs an object x of class bitset<N> and initializes it with *this.
Returns: x.flip().

bitset<N>& flip() noexcept;

Eﬀects: Toggles all bits in *this.
Returns: *this.

bitset<N>& flip(size_t pos);

Requires: pos is valid
Throws: out_of_range if pos does not correspond to a valid bit position.
Eﬀects: Toggles the bit at position pos in *this.
Returns: *this.

unsigned long to_ulong() const;

Throws: overflow_error if the integral value x corresponding to the bits in *this cannot be repre-
sented as type unsigned long.
Returns: x.

unsigned long long to_ullong() const;

§ 20.6.2

538

c(cid:13) ISO/IEC

N4296

Throws: overflow_error if the integral value x corresponding to the bits in *this cannot be repre-
sented as type unsigned long long.
Returns: x.

template <class charT = char,

class traits = char_traits<charT>,
class Allocator = allocator<charT> >
basic_string<charT, traits, Allocator>
to_string(charT zero = charT(’0’), charT one = charT(’1’)) const;

Eﬀects: Constructs a string object of the appropriate type and initializes it to a string of length N
characters. Each character is determined by the value of its corresponding bit position in *this.
Character position N - 1 corresponds to bit position zero. Subsequent decreasing character positions
correspond to increasing bit positions. Bit value zero becomes the character zero, bit value one
becomes the character one.
Returns: The created object.

size_t count() const noexcept;

Returns: A count of the number of bits set in *this.

constexpr size_t size() const noexcept;

Returns: N.

bool operator==(const bitset<N>& rhs) const noexcept;

Returns: true if the value of each bit in *this equals the value of the corresponding bit in rhs.

bool operator!=(const bitset<N>& rhs) const noexcept;

Returns: true if !(*this == rhs).

bool test(size_t pos) const;

Requires: pos is valid
Throws: out_of_range if pos does not correspond to a valid bit position.
Returns: true if the bit at position pos in *this has the value one.

bool all() const noexcept;

Returns: count() == size()

bool any() const noexcept;
Returns: count() != 0

bool none() const noexcept;
Returns: count() == 0

bitset<N> operator<<(size_t pos) const noexcept;

Returns: bitset<N>(*this) <<= pos.

bitset<N> operator>>(size_t pos) const noexcept;

Returns: bitset<N>(*this) >>= pos.

§ 20.6.2

539

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

53

54

55

1

1

2

3

4

5

(5.1)

(5.2)

(5.3)

6

7

c(cid:13) ISO/IEC

N4296

constexpr bool operator[](size_t pos) const;

Requires: pos shall be valid.
Returns: true if the bit at position pos in *this has the value one, otherwise false.
Throws: Nothing.

bitset<N>::reference operator[](size_t pos);

Requires: pos shall be valid.
Returns: An object of type bitset<N>::reference such that (*this)[pos] == this->test(pos),
and such that (*this)[pos] = val is equivalent to this->set(pos, val).
Throws: Nothing.
Remark: For the purpose of determining the presence of a data race (1.10), any access or update
through the resulting reference potentially accesses or modiﬁes, respectively, the entire underlying
bitset.

20.6.3 bitset hash support
template <size_t N> struct hash<bitset<N> >;

[bitset.hash]

The template specialization shall meet the requirements of class template hash (20.9.13).

20.6.4 bitset operators
bitset<N> operator&(const bitset<N>& lhs, const bitset<N>& rhs) noexcept;

[bitset.operators]

Returns: bitset<N>(lhs) &= rhs.

bitset<N> operator|(const bitset<N>& lhs, const bitset<N>& rhs) noexcept;

Returns: bitset<N>(lhs) |= rhs.

bitset<N> operator^(const bitset<N>& lhs, const bitset<N>& rhs) noexcept;

Returns: bitset<N>(lhs) ˆ= rhs.

template <class charT, class traits, size_t N>

basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, bitset<N>& x);

A formatted input function (27.7.2.2).
Eﬀects: Extracts up to N characters from is. Stores these characters in a temporary object str of type
basic_string<charT, traits>, then evaluates the expression x = bitset<N>(str). Characters are
extracted and stored until any of the following occurs:
—
—
—

N characters have been extracted and stored;
end-of-ﬁle occurs on the input sequence;
the next input character is neither is.widen(’0’) nor is.widen(’1’) (in which case the input
character is not extracted).

If no characters are stored in str, calls is.setstate(ios_base::failbit) (which may throw ios_-
base::failure (27.5.5.4)).
Returns: is.

template <class charT, class traits, size_t N>

basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);

§ 20.6.4

540

c(cid:13) ISO/IEC

8

Returns:

os << x.template to_string<charT,traits,allocator<charT> >(

use_facet<ctype<charT> >(os.getloc()).widen(’0’),
use_facet<ctype<charT> >(os.getloc()).widen(’1’))

N4296

(see 27.7.3.6).
20.7 Memory
20.7.1 In general

[memory]
[memory.general]
1 This subclause describes the contents of the header <memory> (20.7.2) and some of the contents of the C

headers <cstdlib> and <cstring> (20.7.13).
20.7.2 Header <memory> synopsis

[memory.syn]
1 The header <memory> deﬁnes several types and function templates that describe properties of pointers
and pointer-like types, manage memory for containers and other template types, and construct multiple
objects in uninitialized memory buﬀers (20.7.3–20.7.12). The header also deﬁnes the templates unique_ptr,
shared_ptr, weak_ptr, and various function templates that operate on objects of these types (20.8).

namespace std {

// 20.7.3, pointer traits
template <class Ptr> struct pointer_traits;
template <class T> struct pointer_traits<T*>;

// 20.7.4, pointer safety
enum class pointer_safety { relaxed, preferred, strict };
void declare_reachable(void* p);
template <class T> T* undeclare_reachable(T* p);
void declare_no_pointers(char* p, size_t n);
void undeclare_no_pointers(char* p, size_t n);
pointer_safety get_pointer_safety() noexcept;

// 20.7.5, pointer alignment function
void* align(std::size_t alignment, std::size_t size,

void*& ptr, std::size_t& space);

// 20.7.6, allocator argument tag
struct allocator_arg_t { };
constexpr allocator_arg_t allocator_arg{};

// 20.7.7, uses_allocator
template <class T, class Alloc> struct uses_allocator;

// 20.7.8, allocator traits
template <class Alloc> struct allocator_traits;

// 20.7.9, the default allocator:
template <class T> class allocator;
template <> class allocator<void>;
template <class T, class U>

template <class T, class U>

bool operator==(const allocator<T>&, const allocator<U>&) noexcept;

bool operator!=(const allocator<T>&, const allocator<U>&) noexcept;

// 20.7.10, raw storage iterator:

§ 20.7.2

541

c(cid:13) ISO/IEC

N4296

template <class OutputIterator, class T> class raw_storage_iterator;

// 20.7.11, temporary buﬀers:
template <class T>

pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;

template <class T>

void return_temporary_buffer(T* p);

// 20.7.12, specialized algorithms:
template <class T> T* addressof(T& r) noexcept;
template <class InputIterator, class ForwardIterator>

ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,

template <class InputIterator, class Size, class ForwardIterator>

ForwardIterator uninitialized_copy_n(InputIterator first, Size n,

ForwardIterator result);

template <class ForwardIterator, class T>

void uninitialized_fill(ForwardIterator first, ForwardIterator last,

ForwardIterator result);

const T& x);

template <class ForwardIterator, class Size, class T>

ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T& x);

// 20.8.1 class template unique_ptr:
template <class T> struct default_delete;
template <class T> struct default_delete<T[]>;
template <class T, class D = default_delete<T>> class unique_ptr;
template <class T, class D> class unique_ptr<T[], D>;

template <class T, class... Args> unique_ptr<T> make_unique(Args&&... args);
template <class T> unique_ptr<T> make_unique(size_t n);
template <class T, class... Args> unspecified

make_unique(Args&&...) = delete;

template <class T, class D> void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;

template <class T1, class D1, class T2, class D2>

bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

template <class T1, class D1, class T2, class D2>

bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

template <class T1, class D1, class T2, class D2>

bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

template <class T1, class D1, class T2, class D2>

bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

template <class T1, class D1, class T2, class D2>

bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

template <class T1, class D1, class T2, class D2>

bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

template <class T, class D>

template <class T, class D>

template <class T, class D>

template <class T, class D>

bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;

bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;

bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;

bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;

§ 20.7.2

542

c(cid:13) ISO/IEC

N4296

template <class T, class D>

template <class T, class D>

template <class T, class D>

template <class T, class D>

template <class T, class D>

template <class T, class D>

template <class T, class D>

template <class T, class D>

bool operator<(const unique_ptr<T, D>& x, nullptr_t);

bool operator<(nullptr_t, const unique_ptr<T, D>& y);

bool operator<=(const unique_ptr<T, D>& x, nullptr_t);

bool operator<=(nullptr_t, const unique_ptr<T, D>& y);

bool operator>(const unique_ptr<T, D>& x, nullptr_t);

bool operator>(nullptr_t, const unique_ptr<T, D>& y);

bool operator>=(const unique_ptr<T, D>& x, nullptr_t);

bool operator>=(nullptr_t, const unique_ptr<T, D>& y);

// 20.8.2.1, class bad_weak_ptr:
class bad_weak_ptr;

// 20.8.2.2, class template shared_ptr:
template<class T> class shared_ptr;

// 20.8.2.2.6, shared_ptr creation
template<class T, class... Args> shared_ptr<T> make_shared(Args&&... args);
template<class T, class A, class... Args>

shared_ptr<T> allocate_shared(const A& a, Args&&... args);

// 20.8.2.2.7, shared_ptr comparisons:
template<class T, class U>

bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;

bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;

template<class T, class U>

template<class T, class U>

template<class T, class U>

template<class T, class U>

template<class T, class U>

bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;

bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;

bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;

bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;

bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;

bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;

bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;

bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;

bool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;

§ 20.7.2

543

c(cid:13) ISO/IEC

N4296

bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;

bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;

bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;

bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;

bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;

// 20.8.2.2.8, shared_ptr specialized algorithms:
template<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;

// 20.8.2.2.9, shared_ptr casts:
template<class T, class U>

template<class T, class U>

template<class T, class U>

shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;

shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;

shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;

// 20.8.2.2.10, shared_ptr get_deleter:
template<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;

// 20.8.2.2.11, shared_ptr I/O:
template<class E, class T, class Y>

basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);

// 20.8.2.3, class template weak_ptr:
template<class T> class weak_ptr;

// 20.8.2.3.6, weak_ptr specialized algorithms:
template<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;

// 20.8.2.4, class template owner_less:
template<class T> class owner_less;

// 20.8.2.5, class template enable_shared_from_this:
template<class T> class enable_shared_from_this;

// 20.8.2.6, shared_ptr atomic access:
template<class T>

bool atomic_is_lock_free(const shared_ptr<T>* p);

shared_ptr<T> atomic_load(const shared_ptr<T>* p);

shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);

template<class T>

template<class T>

template<class T>

template<class T>

void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);

void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);

§ 20.7.2

544

c(cid:13) ISO/IEC

N4296

template<class T>

template<class T>

shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);

shared_ptr<T> atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r,

memory_order mo);

template<class T>

bool atomic_compare_exchange_weak(

shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);

template<class T>

template<class T>

bool atomic_compare_exchange_strong(

shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);

bool atomic_compare_exchange_weak_explicit(

shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
memory_order success, memory_order failure);

template<class T>

bool atomic_compare_exchange_strong_explicit(

shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
memory_order success, memory_order failure);

// 20.8.2.7 hash support
template <class T> struct hash;
template <class T, class D> struct hash<unique_ptr<T, D> >;
template <class T> struct hash<shared_ptr<T> >;

}

20.7.3 Pointer traits

[pointer.traits]
1 The class template pointer_traits supplies a uniform interface to certain attributes of pointer-like types.

namespace std {

template <class Ptr> struct pointer_traits {

typedef Ptr
typedef see below element_type;
typedef see below difference_type;

pointer;

template <class U> using rebind = see below ;

static pointer pointer_to(see below r);

};

template <class T> struct pointer_traits<T*> {

typedef T*
typedef T
typedef ptrdiff_t difference_type;

pointer;
element_type;

template <class U> using rebind = U*;

static pointer pointer_to(see below r) noexcept;

};

}

20.7.3.1 Pointer traits member types

[pointer.traits.types]

§ 20.7.3.1

545

c(cid:13) ISO/IEC

typedef see below element_type;

N4296

Type: Ptr::element_type if the qualiﬁed-id Ptr::element_type is valid and denotes a type (14.8.2);
otherwise, T if Ptr is a class template instantiation of the form SomePointer<T, Args>, where Args
is zero or more type arguments; otherwise, the specialization is ill-formed.

typedef see below difference_type;

Type: Ptr::difference_type if the qualiﬁed-id Ptr::difference_type is valid and denotes a type (14.8.2);
otherwise, std::ptrdiff_t.

template <class U> using rebind = see below ;

Alias template: Ptr::rebind<U> if the qualiﬁed-id Ptr::rebind<U> is valid and denotes a type (14.8.2);
otherwise, SomePointer<U, Args> if Ptr is a class template instantiation of the form SomePointer<T,
Args>, where Args is zero or more type arguments; otherwise, the instantiation of rebind is ill-formed.
[pointer.traits.functions]

20.7.3.2 Pointer traits member functions
static pointer pointer_traits::pointer_to(see below r);
static pointer pointer_traits<T*>::pointer_to(see below r) noexcept;

1

2

3

1

2

Remark: If element_type is (possibly cv-qualiﬁed) void, the type of r is unspeciﬁed; otherwise, it is
element_type&.
Returns: The ﬁrst member function returns a pointer to r obtained by calling Ptr::pointer_-
to(r) through which indirection is valid; an instantiation of this function is ill-formed if Ptr does
not have a matching pointer_to static member function. The second member function returns
std::addressof(r).
20.7.4 Pointer safety

[util.dynamic.safety]
1 A complete object is declared reachable while the number of calls to declare_reachable with an argument
referencing the object exceeds the number of calls to undeclare_reachable with an argument referencing
the object.

2

3

4

5

6

7

8

void declare_reachable(void* p);

Requires: p shall be a safely-derived pointer (3.7.4.3) or a null pointer value.
Eﬀects: If p is not null, the complete object referenced by p is subsequently declared reachable (3.7.4.3).
Throws: May throw std::bad_alloc if the system cannot allocate additional memory that may be
required to track objects declared reachable.

template <class T> T* undeclare_reachable(T* p);

Requires: If p is not null, the complete object referenced by p shall have been previously declared
reachable, and shall be live (3.8) from the time of the call until the last undeclare_reachable(p) call
on the object.
Returns: A safely derived copy of p which shall compare equal to p.
Throws: Nothing.
[ Note: It is expected that calls to declare_reachable(p) will consume a small amount of memory in
addition to that occupied by the referenced object until the matching call to undeclare_reachable(p)
is encountered. Long running programs should arrange that calls are matched. — end note ]

void declare_no_pointers(char* p, size_t n);

§ 20.7.4

546

9

10

11

12

13

14

15

16

1

2
(2.1)

(2.2)
3

4

c(cid:13) ISO/IEC

N4296

Requires: No bytes in the speciﬁed range are currently registered with declare_no_pointers(). If
the speciﬁed range is in an allocated object, then it must be entirely within a single allocated ob-
ject. The object must be live until the corresponding undeclare_no_pointers() call.
[ Note: In a
garbage-collecting implementation, the fact that a region in an object is registered with declare_no_-
pointers() should not prevent the object from being collected. — end note ]
Eﬀects: The n bytes starting at p no longer contain traceable pointer locations, independent of their
type. Hence indirection through a pointer located there is undeﬁned if the object it points to was
created by global operator new and not previously declared reachable. [ Note: This may be used to
inform a garbage collector or leak detector that this region of memory need not be traced. — end
note ]
Throws: Nothing.
[ Note: Under some conditions implementations may need to allocate memory. However, the request
can be ignored if memory allocation fails. — end note ]

void undeclare_no_pointers(char* p, size_t n);

Requires: The same range must previously have been passed to declare_no_pointers().
Eﬀects: Unregisters a range registered with declare_no_pointers() for destruction. It must be called
before the lifetime of the object ends.
Throws: Nothing.

pointer_safety get_pointer_safety() noexcept;

Returns: pointer_safety::strict if the implementation has strict pointer safety (3.7.4.3). It is im-
plementation deﬁned whether get_pointer_safety returns pointer_safety::relaxed or pointer_-
safety::preferred if the implementation has relaxed pointer safety.229

20.7.5 Align
void* align(std::size_t alignment, std::size_t size,

[ptr.align]

void*& ptr, std::size_t& space);
Eﬀects: If it is possible to ﬁt size bytes of storage aligned by alignment into the buﬀer pointed to by
ptr with length space, the function updates ptr to point to the ﬁrst possible address of such storage
and decreases space by the number of bytes used for alignment. Otherwise, the function does nothing.
Requires:
—
—
Returns: A null pointer if the requested aligned buﬀer would not ﬁt into the available space, otherwise
the adjusted value of ptr.
[ Note: The function updates its ptr and space arguments so that it can be called repeatedly with
possibly diﬀerent alignment and size arguments for the same buﬀer. — end note ]

alignment shall be a power of two
ptr shall point to contiguous storage of at least space bytes

20.7.6 Allocator argument tag
namespace std {

struct allocator_arg_t { };
constexpr allocator_arg_t allocator_arg{};

}

[allocator.tag]

229) pointer_safety::preferred might be returned to indicate that a leak detector is running so that the program can avoid
spurious leak reports.

§ 20.7.6

547

c(cid:13) ISO/IEC

N4296

1 The allocator_arg_t struct is an empty structure type used as a unique type to disambiguate constructor
and function overloading. Speciﬁcally, several types (see tuple 20.4) have constructors with allocator_-
arg_t as the ﬁrst argument, immediately followed by an argument of a type that satisﬁes the Allocator
requirements (17.6.3.5).
20.7.7 uses_allocator
20.7.7.1 uses_allocator trait
template <class T, class Alloc> struct uses_allocator;

[allocator.uses]
[allocator.uses.trait]

1

(1.1)

(1.2)

Remarks: automatically detects whether T has a nested allocator_type that is convertible from
Alloc. Meets the BinaryTypeTrait requirements (20.10.1). The implementation shall provide a def-
inition that is derived from true_type if the qualiﬁed-id T::allocator_type is valid and denotes
a type (14.8.2) and is_convertible<Alloc, T::allocator_type>::value != false, otherwise it
shall be derived from false_type. A program may specialize this template to derive from true_-
type for a user-deﬁned type T that does not have a nested allocator_type but nonetheless can be
constructed with an allocator where either:
—

the ﬁrst argument of a constructor has type allocator_arg_t and the second argument has type
Alloc or
the last argument of a constructor has type Alloc.

—

20.7.7.2 uses-allocator construction

[allocator.uses.construction]
1 Uses-allocator construction with allocator Alloc refers to the construction of an object obj of type T, using
constructor arguments v1, v2, ..., vN of types V1, V2, ..., VN, respectively, and an allocator alloc
of type Alloc, according to the following rules:

(1.1)

(1.2)

(1.3)

(1.4)

—

—

—

—

if uses_allocator<T, Alloc>::value is false and is_constructible<T, V1, V2, ..., VN>::value
is true, then obj is initialized as obj(v1, v2, ..., vN);
otherwise, if uses_allocator<T, Alloc>::value is true and is_constructible<T, allocator_-
arg_t, Alloc, V1, V2, ..., VN>::value is true, then obj is initialized as obj(allocator_arg,
alloc, v1, v2, ..., vN);
otherwise, if uses_allocator<T, Alloc>::value is true and is_constructible<T, V1, V2, ...,
VN, Alloc>::value is true, then obj is initialized as obj(v1, v2, ..., vN, alloc);
otherwise, the request for uses-allocator construction is ill-formed.
[ Note: An error will result if
uses_allocator<T, Alloc>::value is true but the speciﬁc constructor does not take an allocator.
This deﬁnition prevents a silent failure to pass the allocator to an element. — end note ]

20.7.8 Allocator traits

[allocator.traits]
1 The class template allocator_traits supplies a uniform interface to all allocator types. An allocator cannot
be a non-class type, however, even if allocator_traits supplies the entire required interface. [ Note: Thus,
it is always possible to create a derived class from an allocator. — end note ]

namespace std {

template <class Alloc> struct allocator_traits {

typedef Alloc allocator_type;

typedef typename Alloc::value_type value_type;

typedef see below pointer;
typedef see below const_pointer;
typedef see below void_pointer;

§ 20.7.8

548

c(cid:13) ISO/IEC

N4296

typedef see below const_void_pointer;

typedef see below difference_type;
typedef see below size_type;

typedef see below propagate_on_container_copy_assignment;
typedef see below propagate_on_container_move_assignment;
typedef see below propagate_on_container_swap;
typedef see below is_always_equal;

template <class T> using rebind_alloc = see below ;
template <class T> using rebind_traits = allocator_traits<rebind_alloc<T> >;

static pointer allocate(Alloc& a, size_type n);
static pointer allocate(Alloc& a, size_type n, const_void_pointer hint);

static void deallocate(Alloc& a, pointer p, size_type n);

template <class T, class... Args>

static void construct(Alloc& a, T* p, Args&&... args);

template <class T>

static void destroy(Alloc& a, T* p);

static size_type max_size(const Alloc& a) noexcept;

static Alloc select_on_container_copy_construction(const Alloc& rhs);

};

}

20.7.8.1 Allocator traits member types
typedef see below pointer;

[allocator.traits.types]

1

2

3

4

5

Type: Alloc::pointer if the qualiﬁed-id Alloc::pointer is valid and denotes a type (14.8.2); other-
wise, value_type*.

typedef see below const_pointer;

Type: Alloc::const_pointer if the qualiﬁed-id Alloc::const_pointer is valid and denotes a type (14.8.2);
otherwise, pointer_traits<pointer>::rebind<const value_type>.

typedef see below void_pointer;

Type: Alloc::void_pointer if the qualiﬁed-id Alloc::void_pointer is valid and denotes a type (14.8.2);
otherwise, pointer_traits<pointer>::rebind<void>.

typedef see below const_void_pointer;

Type: Alloc::const_void_pointer if the qualiﬁed-id Alloc::const_void_pointer is valid and de-
notes a type (14.8.2); otherwise, pointer_traits<pointer>::rebind<const void>.

typedef see below difference_type;

Type: Alloc::difference_type if the qualiﬁed-id Alloc::difference_type is valid and denotes a
type (14.8.2); otherwise, pointer_traits<pointer>::difference_type.

§ 20.7.8.1

549

c(cid:13) ISO/IEC

typedef see below size_type;

N4296

6

7

8

9

10

11

1

2

3

4

5

6

Type: Alloc::size_type if the qualiﬁed-id Alloc::size_type is valid and denotes a type (14.8.2);
otherwise, make_unsigned_t<difference_type>.

typedef see below propagate_on_container_copy_assignment;

Type: Alloc::propagate_on_container_copy_assignment if the qualiﬁed-id Alloc::propagate_-
on_container_copy_assignment is valid and denotes a type (14.8.2); otherwise false_type.

typedef see below propagate_on_container_move_assignment;

Type: Alloc::propagate_on_container_move_assignment if the qualiﬁed-id Alloc::propagate_-
on_container_move_assignment is valid and denotes a type (14.8.2); otherwise false_type.

typedef see below propagate_on_container_swap;

Type: Alloc::propagate_on_container_swap if the qualiﬁed-id Alloc::propagate_on_container_-
swap is valid and denotes a type (14.8.2); otherwise false_type.

typedef see below is_always_equal;

Type: Alloc::is_always_equal if the qualiﬁed-id Alloc::is_always_equal is valid and denotes a
type (14.8.2); otherwise is_empty<Alloc>::type.

template <class T> using rebind_alloc = see below ;

Alias template: Alloc::rebind<T>::other if the qualiﬁed-id Alloc::rebind<T>::other is valid and
denotes a type (14.8.2); otherwise, Alloc<T, Args> if Alloc is a class template instantiation of the
form Alloc<U, Args>, where Args is zero or more type arguments; otherwise, the instantiation of
rebind_alloc is ill-formed.

20.7.8.2 Allocator traits static member functions
static pointer allocate(Alloc& a, size_type n);

Returns: a.allocate(n).

[allocator.traits.members]

static pointer allocate(Alloc& a, size_type n, const_void_pointer hint);

Returns: a.allocate(n, hint) if that expression is well-formed; otherwise, a.allocate(n).

static void deallocate(Alloc& a, pointer p, size_type n);

Eﬀects: calls a.deallocate(p, n).
Throws: Nothing.

template <class T, class... Args>

static void construct(Alloc& a, T* p, Args&&... args);

Eﬀects: calls a.construct(p, std::forward<Args>(args)...) if that call is well-formed; otherwise,
invokes ::new (static_cast<void*>(p)) T(std::forward<Args>(args)...).

template <class T>

static void destroy(Alloc& a, T* p);

Eﬀects: calls a.destroy(p) if that call is well-formed; otherwise, invokes p->~T().

static size_type max_size(const Alloc& a) noexcept;

§ 20.7.8.2

550

c(cid:13) ISO/IEC

N4296

7

8

Returns: a.max_size() if that expression is well-formed; otherwise, numeric_limits<size_type>::
max().

static Alloc select_on_container_copy_construction(const Alloc& rhs);

Returns: rhs.select_on_container_copy_construction() if that expression is well-formed; other-
wise, rhs.

20.7.9 The default allocator

namespace std {

template <class T> class allocator;

[default.allocator]

// specialize for void:
template <> class allocator<void> {
public:

pointer;

typedef void*
typedef const void* const_pointer;
// reference-to-void members are impossible.
typedef void
template <class U> struct rebind { typedef allocator<U> other; };

value_type;

};

size_type;

template <class T> class allocator {
public:
typedef size_t
typedef ptrdiff_t difference_type;
typedef T*
typedef const T*
typedef T&
typedef const T&
typedef T
template <class U> struct rebind { typedef allocator<U> other; };
typedef true_type propagate_on_container_move_assignment;
typedef true_type is_always_equal;

pointer;
const_pointer;
reference;
const_reference;
value_type;

allocator() noexcept;
allocator(const allocator&) noexcept;
template <class U> allocator(const allocator<U>&) noexcept;
~allocator();

pointer address(reference x) const noexcept;
const_pointer address(const_reference x) const noexcept;

pointer allocate(

size_type, allocator<void>::const_pointer hint = 0);

void deallocate(pointer p, size_type n);
size_type max_size() const noexcept;

template<class U, class... Args>

void construct(U* p, Args&&... args);

template <class U>

void destroy(U* p);

};

}

§ 20.7.9

551

c(cid:13) ISO/IEC

N4296

20.7.9.1 allocator members

[allocator.members]
1 Except for the destructor, member functions of the default allocator shall not introduce data races (1.10)
as a result of concurrent calls to those member functions from diﬀerent threads. Calls to these functions
that allocate or deallocate a particular unit of storage shall occur in a single total order, and each such
deallocation call shall happen before the next allocation (if any) in this order.

2

3

4

5

6

7

8

9

10

11

12

13

1

2

pointer address(reference x) const noexcept;

Returns: The actual address of the object referenced by x, even in the presence of an overloaded
operator&.

const_pointer address(const_reference x) const noexcept;

Returns: The actual address of the object referenced by x, even in the presence of an overloaded
operator&.

pointer allocate(size_type n, allocator<void>::const_pointer hint = 0);

[ Note: In a container member function, the address of an adjacent element is often a good choice to
pass for the hint argument. — end note ]
Returns: A pointer to the initial element of an array of storage of size n * sizeof(T), aligned appropri-
ately for objects of type T. It is implementation-deﬁned whether over-aligned types are supported (3.11).
Remark: the storage is obtained by calling ::operator new(std::size_t) (18.6.1), but it is unspec-
iﬁed when or how often this function is called. The use of hint is unspeciﬁed, but intended as an aid
to locality if an implementation so desires.
Throws: bad_alloc if the storage cannot be obtained.

void deallocate(pointer p, size_type n);

Requires: p shall be a pointer value obtained from allocate(). n shall equal the value passed as the
ﬁrst argument to the invocation of allocate which returned p.
Eﬀects: Deallocates the storage referenced by p .
Remarks: Uses ::operator delete(void*, std::size_t) (18.6.1), but it is unspeciﬁed when this
function is called.

size_type max_size() const noexcept;

Returns: The largest value N for which the call allocate(N,0) might succeed.

template <class U, class... Args>

void construct(U* p, Args&&... args);

Eﬀects: ::new((void *)p) U(std::forward<Args>(args)...)

template <class U>

void destroy(U* p);
Eﬀects: p->~U()

20.7.9.2 allocator globals
template <class T1, class T2>

bool operator==(const allocator<T1>&, const allocator<T2>&) noexcept;

Returns: true.

template <class T1, class T2>

bool operator!=(const allocator<T1>&, const allocator<T2>&) noexcept;

Returns: false.

§ 20.7.9.2

[allocator.globals]

552

c(cid:13) ISO/IEC

N4296

20.7.10 Raw storage iterator

[storage.iterator]
1 raw_storage_iterator is provided to enable algorithms to store their results into uninitialized memory.
The template parameter OutputIterator is required to have its operator* return an object for which
operator& is deﬁned and returns a pointer to T, and is also required to satisfy the requirements of an output
iterator (24.2.4).

namespace std {

template <class OutputIterator, class T>
class raw_storage_iterator

: public iterator<output_iterator_tag,void,void,void,void> {

public:

explicit raw_storage_iterator(OutputIterator x);

raw_storage_iterator& operator*();
raw_storage_iterator& operator=(const T& element);
raw_storage_iterator& operator++();
raw_storage_iterator

operator++(int);

};

}

explicit raw_storage_iterator(OutputIterator x);

Eﬀects: Initializes the iterator to point to the same value to which x points.

raw_storage_iterator& operator*();

Returns: *this

raw_storage_iterator& operator=(const T& element);

Eﬀects: Constructs a value from element at the location to which the iterator points.
Returns: A reference to the iterator.

raw_storage_iterator& operator++();

Eﬀects: Pre-increment: advances the iterator and returns a reference to the updated iterator.

raw_storage_iterator operator++(int);

Eﬀects: Post-increment: advances the iterator and returns the old value of the iterator.

20.7.11 Temporary buﬀers
template <class T>

pair<T*, ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;

[temporary.buﬀer]

Eﬀects: Obtains a pointer to storage suﬃcient to store up to n adjacent T objects. It is implementation-
deﬁned whether over-aligned types are supported (3.11).
Returns: A pair containing the buﬀer’s address and capacity (in the units of sizeof(T)), or a pair
of 0 values if no storage can be obtained or if n <= 0.

template <class T> void return_temporary_buffer(T* p);

Eﬀects: Deallocates the buﬀer to which p points.
Requires: The buﬀer shall have been previously allocated by get_temporary_buffer.

§ 20.7.11

553

2

3

4

5

6

7

1

2

3

4

c(cid:13) ISO/IEC

N4296

20.7.12 Specialized algorithms

[specialized.algorithms]
1 All the iterators that are used as template parameters in the following algorithms are required to have their
operator* return an object for which operator& is deﬁned and returns a pointer to T. In the algorithm
uninitialized_copy, the template parameter InputIterator is required to satisfy the requirements of
an input iterator (24.2.3). In all of the following algorithms, the template parameter ForwardIterator is
required to satisfy the requirements of a forward iterator (24.2.5), and is required to have the property that
no exceptions are thrown from increment, assignment, comparison, or indirection through valid iterators. In
the following algorithms, if an exception is thrown there are no eﬀects.
20.7.12.1 addressof
template <class T> T* addressof(T& r) noexcept;

[specialized.addressof]

Returns: The actual address of the object or function referenced by r, even in the presence of an
overloaded operator&.

1

1

2

3

4

1

20.7.12.2 uninitialized_copy
template <class InputIterator, class ForwardIterator>

ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,

ForwardIterator result);

Eﬀects:

for (; first != last; ++result, ++first)

::new (static_cast<void*>(&*result))

typename iterator_traits<ForwardIterator>::value_type(*first);

Returns: result

template <class InputIterator, class Size, class ForwardIterator>

ForwardIterator uninitialized_copy_n(InputIterator first, Size n,

ForwardIterator result);

Eﬀects:

for ( ; n > 0; ++result, ++first, --n) {

::new (static_cast<void*>(&*result))

typename iterator_traits<ForwardIterator>::value_type(*first);

}

Returns: result

20.7.12.3 uninitialized_fill
template <class ForwardIterator, class T>

void uninitialized_fill(ForwardIterator first, ForwardIterator last,

const T& x);

[uninitialized.copy]

[uninitialized.ﬁll]

Eﬀects:

for (; first != last; ++first)

::new (static_cast<void*>(&*first))

typename iterator_traits<ForwardIterator>::value_type(x);

§ 20.7.12.3

554

c(cid:13) ISO/IEC

N4296

[uninitialized.ﬁll.n]

20.7.12.4 uninitialized_fill_n
template <class ForwardIterator, class Size, class T>

ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T& x);

1

Eﬀects:

for (; n--; ++first)

::new (static_cast<void*>(&*first))

typename iterator_traits<ForwardIterator>::value_type(x);

return first;

20.7.13 C library

1 Table 45 describes the header <cstdlib>.

[c.malloc]

Table 45 — Header <cstdlib> synopsis

Type

Functions:

Name(s)

calloc
free

malloc
realloc

2 The contents are the same as the Standard C library header <stdlib.h>, with the following changes:
3 The functions calloc(), malloc(), and realloc() do not attempt to allocate storage by calling ::operator

new() (18.6).

4 The function free() does not attempt to deallocate storage by calling ::operator delete().

See also: ISO C Clause 7.11.2.

5 Storage allocated directly with malloc(), calloc(), or realloc() is implicitly declared reachable (see 3.7.4.3)
on allocation, ceases to be declared reachable on deallocation, and need not cease to be declared reachable as
the result of an undeclare_reachable() call. [ Note: This allows existing C libraries to remain unaﬀected
by restrictions on pointers that are not safely derived, at the expense of providing far fewer garbage collec-
tion and leak detection options for malloc()-allocated objects. It also allows malloc() to be implemented
with a separate allocation arena, bypassing the normal declare_reachable() implementation. The above
functions should never intentionally be used as a replacement for declare_reachable(), and newly written
code is strongly encouraged to treat memory allocated with these functions as though it were allocated with
operator new. — end note ]

6 Table 46 describes the header <cstring>.

Table 46 — Header <cstring> synopsis

Type
Macro:
Type:
Functions:
memcpy

Name(s)

NULL
size_t
memchr
memmove

memcmp
memset

7 The contents are the same as the Standard C library header <string.h>, with the change to memchr()

speciﬁed in 21.8.
See also: ISO C Clause 7.11.2.

§ 20.7.13

555

c(cid:13) ISO/IEC

N4296

20.8 Smart pointers
20.8.1 Class template unique_ptr

[smartptr]
[unique.ptr]
1 A unique pointer is an object that owns another object and manages that other object through a pointer.
More precisely, a unique pointer is an object u that stores a pointer to a second object p and will dispose of
p when u is itself destroyed (e.g., when leaving block scope (6.7)). In this context, u is said to own p.

2 The mechanism by which u disposes of p is known as p’s associated deleter, a function object whose correct

invocation results in p’s appropriate disposition (typically its deletion).

3 Let the notation u.p denote the pointer stored by u, and let u.d denote the associated deleter. Upon request,
u can reset (replace) u.p and u.d with another pointer and deleter, but must properly dispose of its owned
object via the associated deleter before such replacement is considered completed.

4 Additionally, u can, upon request, transfer ownership to another unique pointer u2. Upon completion of

such a transfer, the following postconditions hold:

(4.1)

(4.2)

(4.3)

—
—
—

u2.p is equal to the pre-transfer u.p,
u.p is equal to nullptr, and
if the pre-transfer u.d maintained state, such state has been transferred to u2.d.

As in the case of a reset, u2 must properly dispose of its pre-transfer owned object via the pre-transfer
associated deleter before the ownership transfer is considered complete. [ Note: A deleter’s state need never
be copied, only moved or swapped as ownership is transferred. — end note ]

5 Each object of a type U instantiated from the unique_ptr template speciﬁed in this subclause has the strict
ownership semantics, speciﬁed above, of a unique pointer. In partial satisfaction of these semantics, each
such U is MoveConstructible and MoveAssignable, but is not CopyConstructible nor CopyAssignable.
The template parameter T of unique_ptr may be an incomplete type.
[ Note: The uses of unique_ptr include providing exception safety for dynamically allocated memory, passing
ownership of dynamically allocated memory to a function, and returning dynamically allocated memory from
a function. — end note ]

6

namespace std {

template<class T> struct default_delete;
template<class T> struct default_delete<T[]>;

template<class T, class D = default_delete<T>> class unique_ptr;
template<class T, class D> class unique_ptr<T[], D>;

template<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);
template<class T> unique_ptr<T> make_unique(size_t n);
template<class T, class... Args> unspecified

make_unique(Args&&...) = delete;

template<class T, class D> void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;

template<class T1, class D1, class T2, class D2>

bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

template<class T1, class D1, class T2, class D2>

bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

template<class T1, class D1, class T2, class D2>

bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

template<class T1, class D1, class T2, class D2>

bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

template<class T1, class D1, class T2, class D2>

§ 20.8.1

556

c(cid:13) ISO/IEC

N4296

bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

template<class T1, class D1, class T2, class D2>

bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;

bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;

bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;

bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;

template <class T, class D>

template <class T, class D>

template <class T, class D>

template <class T, class D>

template <class T, class D>

template <class T, class D>

template <class T, class D>

template <class T, class D>

template <class T, class D>

template <class T, class D>

template <class T, class D>

template <class T, class D>

bool operator<(const unique_ptr<T, D>& x, nullptr_t);

bool operator<(nullptr_t, const unique_ptr<T, D>& y);

bool operator<=(const unique_ptr<T, D>& x, nullptr_t);

bool operator<=(nullptr_t, const unique_ptr<T, D>& y);

bool operator>(const unique_ptr<T, D>& x, nullptr_t);

bool operator>(nullptr_t, const unique_ptr<T, D>& y);

bool operator>=(const unique_ptr<T, D>& x, nullptr_t);

bool operator>=(nullptr_t, const unique_ptr<T, D>& y);

}

20.8.1.1 Default deleters
20.8.1.1.1

[unique.ptr.dltr]
[unique.ptr.dltr.general]
1 The class template default_delete serves as the default deleter (destruction policy) for the class template

In general

unique_ptr.

2 The template parameter T of default_delete may be an incomplete type.

20.8.1.1.2 default_delete

[unique.ptr.dltr.dﬂt]

namespace std {

template <class T> struct default_delete {

constexpr default_delete() noexcept = default;
template <class U> default_delete(const default_delete<U>&) noexcept;
void operator()(T*) const;

};

}

template <class U> default_delete(const default_delete<U>& other) noexcept;

1

2

Eﬀects: Constructs a default_delete object from another default_delete<U> object.
Remarks: This constructor shall not participate in overload resolution unless U* is implicitly convertible
to T*.

void operator()(T* ptr) const;

§ 20.8.1.1.2

557

3

4

1

2

3

4

c(cid:13) ISO/IEC

N4296

Eﬀects: calls delete on ptr.
Remarks: If T is an incomplete type, the program is ill-formed.

20.8.1.1.3 default_delete<T[]>

[unique.ptr.dltr.dﬂt1]

namespace std {

template <class T> struct default_delete<T[]> {
constexpr default_delete() noexcept = default;
template <class U> default_delete(const default_delete<U[]>&) noexcept;
template <class U> void operator()(U* ptr) const;

};

}

template <class U> default_delete(const default_delete<U[]>& other) noexcept;

Eﬀects: constructs a default_delete object from another default_delete<U[]> object.
Remarks: This constructor shall not participate in overload resolution unless U(*)[] is convertible to
T(*)[].

template <class U> void operator()(U* ptr) const;

Eﬀects: calls delete[] on ptr.
Remarks: If U is an incomplete type, the program is ill-formed. This function shall not participate in
overload resolution unless U(*)[] is convertible to T(*)[].

20.8.1.2 unique_ptr for single objects

[unique.ptr.single]

namespace std {

template <class T, class D = default_delete<T>> class unique_ptr {
public:

typedef see below pointer;
typedef T element_type;
typedef D deleter_type;

// 20.8.1.2.1, constructors
constexpr unique_ptr() noexcept;
explicit unique_ptr(pointer p) noexcept;
unique_ptr(pointer p, see below d1) noexcept;
unique_ptr(pointer p, see below d2) noexcept;
unique_ptr(unique_ptr&& u) noexcept;
constexpr unique_ptr(nullptr_t) noexcept

: unique_ptr() { }

template <class U, class E>

unique_ptr(unique_ptr<U, E>&& u) noexcept;

// 20.8.1.2.2, destructor
~unique_ptr();

// 20.8.1.2.3, assignment
unique_ptr& operator=(unique_ptr&& u) noexcept;
template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
unique_ptr& operator=(nullptr_t) noexcept;

// 20.8.1.2.4, observers
add_lvalue_reference_t<T> operator*() const;
pointer operator->() const noexcept;

§ 20.8.1.2

558

c(cid:13) ISO/IEC

N4296

pointer get() const noexcept;
deleter_type& get_deleter() noexcept;
const deleter_type& get_deleter() const noexcept;
explicit operator bool() const noexcept;

// 20.8.1.2.5 modiﬁers
pointer release() noexcept;
void reset(pointer p = pointer()) noexcept;
void swap(unique_ptr& u) noexcept;

// disable copy from lvalue
unique_ptr(const unique_ptr&) = delete;
unique_ptr& operator=(const unique_ptr&) = delete;

};

}

2

3

1 The default type for the template parameter D is default_delete. A client-supplied template argument D
shall be a function object type (20.9), lvalue-reference to function, or lvalue-reference to function object type
for which, given a value d of type D and a value ptr of type unique_ptr<T, D>::pointer, the expression
d(ptr) is valid and has the eﬀect of disposing of the pointer as appropriate for that deleter.
If the deleter’s type D is not a reference type, D shall satisfy the requirements of Destructible (Table 24).
If the qualiﬁed-id remove_reference_t<D>::pointer is valid and denotes a type (14.8.2), then unique_-
ptr<T, D>::pointer shall be a synonym for remove_reference_t<D>::pointer. Otherwise unique_-
ptr<T, D>::pointer shall be a synonym for element_type*. The type unique_ptr<T, D>::pointer shall
satisfy the requirements of NullablePointer (17.6.3.3).
[ Example: Given an allocator type X (17.6.3.5) and letting A be a synonym for allocator_traits<X>, the
types A::pointer, A::const_pointer, A::void_pointer, and A::const_void_pointer may be used as
unique_ptr<T, D>::pointer. — end example ]
20.8.1.2.1 unique_ptr constructors
constexpr unique_ptr() noexcept;

[unique.ptr.single.ctor]

4

1

2

3

4

5

6

7

8

Requires: D shall satisfy the requirements of DefaultConstructible (Table 19), and that construction
shall not throw an exception.
Eﬀects: Constructs a unique_ptr object that owns nothing, value-initializing the stored pointer and
the stored deleter.
Postconditions: get() == nullptr. get_deleter() returns a reference to the stored deleter.
Remarks: If this constructor is instantiated with a pointer type or reference type for the template
argument D, the program is ill-formed.

explicit unique_ptr(pointer p) noexcept;

Requires: D shall satisfy the requirements of DefaultConstructible (Table 19), and that construction
shall not throw an exception.
Eﬀects: Constructs a unique_ptr which owns p, initializing the stored pointer with p and value-
initializing the stored deleter.
Postconditions: get() == p. get_deleter() returns a reference to the stored deleter.
Remarks: If this constructor is instantiated with a pointer type or reference type for the template
argument D, the program is ill-formed.

§ 20.8.1.2.1

559

c(cid:13) ISO/IEC

N4296

unique_ptr(pointer p, see below d1) noexcept;
unique_ptr(pointer p, see below d2) noexcept;

The signature of these constructors depends upon whether D is a reference type. If D is non-reference
type A, then the signatures are:

unique_ptr(pointer p, const A& d);
unique_ptr(pointer p, A&& d);

If D is an lvalue-reference type A&, then the signatures are:

unique_ptr(pointer p, A& d);
unique_ptr(pointer p, A&& d);

If D is an lvalue-reference type const A&, then the signatures are:

unique_ptr(pointer p, const A& d);
unique_ptr(pointer p, const A&& d);

Requires:
—

If D is not an lvalue-reference type then
—

—

If d is an lvalue or const rvalue then the ﬁrst constructor of this pair will be selected. D shall
satisfy the requirements of CopyConstructible (Table 21), and the copy constructor of D
shall not throw an exception. This unique_ptr will hold a copy of d.
Otherwise, d is a non-const rvalue and the second constructor of this pair will be selected. D
shall satisfy the requirements of MoveConstructible (Table 20), and the move constructor
of D shall not throw an exception. This unique_ptr will hold a value move constructed from
d.

9

10

11

12

(12.1)

(12.1.1)

(12.1.2)

(12.2)

—

Otherwise D is an lvalue-reference type. d shall be reference-compatible with one of the con-
structors. If d is an rvalue, it will bind to the second constructor of this pair and the program
is ill-formed.
[ Note: The diagnostic could be implemented using a static_assert which as-
sures that D is not a reference type. — end note ] Else d is an lvalue and will bind to the
ﬁrst constructor of this pair. The type which D references need not be CopyConstructible nor
MoveConstructible. This unique_ptr will hold a D which refers to the lvalue d. [ Note: D may
not be an rvalue-reference type. — end note ]

13

14

Eﬀects: Constructs a unique_ptr object which owns p, initializing the stored pointer with p and
initializing the deleter as described above.
Postconditions: get() == p. get_deleter() returns a reference to the stored deleter.
reference type then get_deleter() returns a reference to the lvalue d.
[ Example:

If D is a

D d;
unique_ptr<int, D> p1(new int, D());
unique_ptr<int, D> p2(new int, d);
unique_ptr<int, D&> p3(new int, d);
unique_ptr<int, const D&> p4(new int, D()); // error: rvalue deleter object combined

// D must be MoveConstructible
// D must be CopyConstructible
// p3 holds a reference to d

// with reference deleter type

— end example ]

unique_ptr(unique_ptr&& u) noexcept;

§ 20.8.1.2.1

560

c(cid:13) ISO/IEC

N4296

Requires: If D is not a reference type, D shall satisfy the requirements of MoveConstructible (Table 20).
Construction of the deleter from an rvalue of type D shall not throw an exception.
Eﬀects: Constructs a unique_ptr by transferring ownership from u to *this. If D is a reference type,
this deleter is copy constructed from u’s deleter; otherwise, this deleter is move constructed from u’s
deleter. [ Note: The deleter constructor can be implemented with std::forward<D>. — end note ]
Postconditions: get() yields the value u.get() yielded before the construction. get_deleter()
returns a reference to the stored deleter that was constructed from u.get_deleter().
If D is a
reference type then get_deleter() and u.get_deleter() both reference the same lvalue deleter.

template <class U, class E> unique_ptr(unique_ptr<U, E>&& u) noexcept;

Requires: If E is not a reference type, construction of the deleter from an rvalue of type E shall be
well formed and shall not throw an exception. Otherwise, E is a reference type and construction of the
deleter from an lvalue of type E shall be well formed and shall not throw an exception.
Remarks: This constructor shall not participate in overload resolution unless:
—
—
—

unique_ptr<U, E>::pointer is implicitly convertible to pointer,
U is not an array type, and
either D is a reference type and E is the same type as D, or D is not a reference type and E is
implicitly convertible to D.

Eﬀects: Constructs a unique_ptr by transferring ownership from u to *this. If E is a reference type,
this deleter is copy constructed from u’s deleter; otherwise, this deleter is move constructed from u’s
deleter. [ Note: The deleter constructor can be implemented with std::forward<E>. — end note ]
Postconditions: get() yields the value u.get() yielded before the construction. get_deleter()
returns a reference to the stored deleter that was constructed from u.get_deleter().

20.8.1.2.2 unique_ptr destructor
~unique_ptr();

[unique.ptr.single.dtor]

Requires: The expression get_deleter()(get()) shall be well formed, shall have well-deﬁned behav-
ior, and shall not throw exceptions. [ Note: The use of default_delete requires T to be a complete
type. — end note ]
Eﬀects: If get() == nullptr there are no eﬀects. Otherwise get_deleter()(get()).

20.8.1.2.3 unique_ptr assignment
unique_ptr& operator=(unique_ptr&& u) noexcept;

[unique.ptr.single.asgn]

Requires: If D is not a reference type, D shall satisfy the requirements of MoveAssignable (Table 22)
and assignment of the deleter from an rvalue of type D shall not throw an exception. Otherwise,
D is a reference type; remove_reference_t<D> shall satisfy the CopyAssignable requirements and
assignment of the deleter from an lvalue of type D shall not throw an exception.
Eﬀects: Transfers ownership from u to *this as if by calling reset(u.release()) followed by get_-
deleter() = std::forward<D>(u.get_deleter()).
Returns: *this.

template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;

Requires: If E is not a reference type, assignment of the deleter from an rvalue of type E shall be
well-formed and shall not throw an exception. Otherwise, E is a reference type and assignment of the
deleter from an lvalue of type E shall be well-formed and shall not throw an exception.
Remarks: This operator shall not participate in overload resolution unless:

§ 20.8.1.2.3

561

15

16

17

18

19
(19.1)

(19.2)

(19.3)

20

21

1

2

1

2

3

4

5

c(cid:13) ISO/IEC

N4296

unique_ptr<U, E>::pointer is implicitly convertible to pointer and
U is not an array type.

—
—
Eﬀects: Transfers ownership from u to *this as if by calling reset(u.release()) followed by get_-
deleter() = std::forward<E>(u.get_deleter()).
Returns: *this.

unique_ptr& operator=(nullptr_t) noexcept;

Eﬀects: reset().
Postcondition: get() == nullptr
Returns: *this.

20.8.1.2.4 unique_ptr observers
add_lvalue_reference_t<T> operator*() const;

Requires: get() != nullptr.
Returns: *get().

pointer operator->() const noexcept;

Requires: get() != nullptr.
Returns: get().
Note: use typically requires that T be a complete type.

pointer get() const noexcept;

Returns: The stored pointer.

deleter_type& get_deleter() noexcept;
const deleter_type& get_deleter() const noexcept;

Returns: A reference to the stored deleter.

explicit operator bool() const noexcept;

Returns: get() != nullptr.

20.8.1.2.5 unique_ptr modiﬁers
pointer release() noexcept;

[unique.ptr.single.observers]

[unique.ptr.single.modiﬁers]

Postcondition: get() == nullptr.
Returns: The value get() had at the start of the call to release.

void reset(pointer p = pointer()) noexcept;

Requires: The expression get_deleter()(get()) shall be well formed, shall have well-deﬁned behav-
ior, and shall not throw exceptions.
Eﬀects: assigns p to the stored pointer, and then if the old value of the stored pointer, old_p, was not
equal to nullptr, calls get_deleter()(old_p).
[ Note: The order of these operations is signiﬁcant
because the call to get_deleter() may destroy *this. — end note ]
Postconditions: get() == p.
destroys *this since this->get() is no longer a valid expression. — end note ]

[ Note: The postcondition does not hold if the call to get_deleter()

void swap(unique_ptr& u) noexcept;

Requires: get_deleter() shall be swappable (17.6.3.2) and shall not throw an exception under swap.
Eﬀects: Invokes swap on the stored pointers and on the stored deleters of *this and u.

§ 20.8.1.2.5

562

(5.1)
(5.2)
6

7

8

9

10

1

2

3

4

5

6

7

8

1

2

3

4

5

6

7

c(cid:13) ISO/IEC

N4296

20.8.1.3 unique_ptr for array objects with a runtime length

[unique.ptr.runtime]

namespace std {

template <class T, class D> class unique_ptr<T[], D> {
public:

typedef see below pointer;
typedef T element_type;
typedef D deleter_type;

// 20.8.1.3.1, constructors
constexpr unique_ptr() noexcept;
template <class U> explicit unique_ptr(U p) noexcept;
template <class U> unique_ptr(U p, see below d) noexcept;
template <class U> unique_ptr(U p, see below d) noexcept;
unique_ptr(unique_ptr&& u) noexcept;
template <class U, class E>

unique_ptr(unique_ptr<U, E>&& u) noexcept;

constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }

// destructor
~unique_ptr();

// assignment
unique_ptr& operator=(unique_ptr&& u) noexcept;
template <class U, class E>

unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;

unique_ptr& operator=(nullptr_t) noexcept;

// 20.8.1.3.3, observers
T& operator[](size_t i) const;
pointer get() const noexcept;
deleter_type& get_deleter() noexcept;
const deleter_type& get_deleter() const noexcept;
explicit operator bool() const noexcept;

// 20.8.1.3.4 modiﬁers
pointer release() noexcept;
template <class U> void reset(U p) noexcept;
void reset(nullptr_t = nullptr) noexcept;
void swap(unique_ptr& u) noexcept;

// disable copy from lvalue
unique_ptr(const unique_ptr&) = delete;
unique_ptr& operator=(const unique_ptr&) = delete;

};

}

1 A specialization for array types is provided with a slightly altered interface.

(1.1)

(1.2)

(1.3)

—

—
—

Conversions between diﬀerent types of unique_ptr<T[], D> that would be disallowed for the cor-
responding pointer-to-array types, and conversions to or from the non-array forms of unique_ptr,
produce an ill-formed program.
Pointers to types derived from T are rejected by the constructors, and by reset.
The observers operator* and operator-> are not provided.

§ 20.8.1.3

563

c(cid:13) ISO/IEC

N4296

(1.4)

(1.5)

—
—

The indexing observer operator[] is provided.
The default deleter will call delete[].

2 Descriptions are provided below only for members that diﬀer from the primary template.
3 The template argument T shall be a complete type.

20.8.1.3.1 unique_ptr constructors
template <class U> explicit unique_ptr(U p) noexcept;
template <class U> unique_ptr(U p, see below d) noexcept;
template <class U> unique_ptr(U p, see below d) noexcept;

[unique.ptr.runtime.ctor]

These constructors behave the same as the constructors that take a pointer parameter in the primary
template except that they shall not participate in overload resolution unless either
—
—

U is the same type as pointer, or
pointer is the same type as element_type*, U is a pointer type V*, and V(*)[] is convertible to
element_type(*)[].

template <class U, class E>

unique_ptr(unique_ptr<U, E>&& u) noexcept;

This constructor behaves the same as in the primary template, except that it shall not participate in
overload resolution unless all of the following conditions hold, where UP is unique_ptr<U, E>:
—
—
—
—
—

U is an array type, and
pointer is the same type as element_type*, and
UP::pointer is the same type as UP::element_type*, and
UP::element_type(*)[] is convertible to element_type(*)[], and
either D is a reference type and E is the same type as D, or D is not a reference type and E is
implicitly convertible to D.

[ Note: this replaces the overload-resolution speciﬁcation of the primary template — end note ]

20.8.1.3.2 unique_ptr assignment
template <class U, class E>

unique_ptr& operator=(unique_ptr<U,E>&& u)noexcept;

[unique.ptr.runtime.asgn]

This operator behaves the same as in the primary template, except that it shall not participate in
overload resolution unless all of the following conditions hold, where UP is unique_ptr<U, E>:
—
—
—
—
—

U is an array type, and
pointer is the same type as element_type*, and
UP::pointer is the same type as UP::element_type*, and
UP::element_type(*)[] is convertible to element_type(*)[], and
either D is a reference type and E is the same type as D, or D is not a reference type and E is
implicitly convertible to D.

[ Note: this replaces the overload-resolution speciﬁcation of the primary template — end note ]

1

(1.1)

(1.2)

2

(2.1)

(2.2)

(2.3)

(2.4)

(2.5)

1

(1.1)

(1.2)

(1.3)

(1.4)

(1.5)

20.8.1.3.3 unique_ptr observers
T& operator[](size_t i) const;

[unique.ptr.runtime.observers]

1

2

Requires: i < the number of elements in the array to which the stored pointer points.
Returns: get()[i].

§ 20.8.1.3.3

564

c(cid:13) ISO/IEC

20.8.1.3.4 unique_ptr modiﬁers
void reset(nullptr_t p = nullptr) noexcept;

Eﬀects: Equivalent to reset(pointer()).

template <class U> void reset(U p) noexcept;

N4296

[unique.ptr.runtime.modiﬁers]

This function behaves the same as the reset member of the primary template, except that it shall not
participate in overload resolution unless either
—
—

U is the same type as pointer, or
pointer is the same type as element_type*, U is a pointer type V*, and V(*)[] is convertible to
element_type(*)[].

20.8.1.4 unique_ptr creation
template <class T, class... Args> unique_ptr<T> make_unique(Args&&... args);

[unique.ptr.create]

Remarks: This function shall not participate in overload resolution unless T is not an array.
Returns: unique_ptr<T>(new T(std::forward<Args>(args)...)).

template <class T> unique_ptr<T> make_unique(size_t n);

Remarks: This function shall not participate in overload resolution unless T is an array of unknown
bound.
Returns: unique_ptr<T>(new remove_extent_t<T>[n]()).

template <class T, class... Args> unspecified

make_unique(Args&&...) = delete;

Remarks: This function shall not participate in overload resolution unless T is an array of known
bound.

20.8.1.5 unique_ptr specialized algorithms
template <class T, class D> void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;

[unique.ptr.special]

Eﬀects: Calls x.swap(y).

template <class T1, class D1, class T2, class D2>

bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

Returns: x.get() == y.get().

template <class T1, class D1, class T2, class D2>

bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

Returns: x.get() != y.get().

template <class T1, class D1, class T2, class D2>

bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

Requires: Let CT be common_type<unique_ptr<T1, D1>::pointer, unique_ptr<T2, D2>::poin-
ter>::type. Then the specialization less<CT> shall be a function object type (20.9) that induces a
strict weak ordering (25.4) on the pointer values.
Returns: less<CT>()(x.get(), y.get()).
Remarks: If unique_ptr<T1, D1>::pointer is not implicitly convertible to CT or unique_ptr<T2,
D2>::pointer is not implicitly convertible to CT, the program is ill-formed.

§ 20.8.1.5

565

1

2

(2.1)

(2.2)

1

2

3

4

5

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

c(cid:13) ISO/IEC

N4296

template <class T1, class D1, class T2, class D2>

bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

Returns: !(y < x).

template <class T1, class D1, class T2, class D2>

bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

Returns: y < x.

template <class T1, class D1, class T2, class D2>

bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

Returns: !(x < y).

template <class T, class D>

template <class T, class D>

bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;

bool operator==(nullptr_t, const unique_ptr<T, D>& x) noexcept;

Returns: !x.

template <class T, class D>

template <class T, class D>

bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;

bool operator!=(nullptr_t, const unique_ptr<T, D>& x) noexcept;

Returns: (bool)x.

template <class T, class D>

template <class T, class D>

bool operator<(const unique_ptr<T, D>& x, nullptr_t);

bool operator<(nullptr_t, const unique_ptr<T, D>& x);

Requires: The specialization less<unique_ptr<T, D>::pointer> shall be a function object type (20.9)
that induces a strict weak ordering (25.4) on the pointer values.
Returns: The ﬁrst function template returns less<unique_ptr<T, D>::pointer>()(x.get(),
nullptr). The second function template returns less<unique_ptr<T, D>::pointer>()(nullptr,
x.get()).

template <class T, class D>

template <class T, class D>

bool operator>(const unique_ptr<T, D>& x, nullptr_t);

bool operator>(nullptr_t, const unique_ptr<T, D>& x);

Returns: The ﬁrst function template returns nullptr < x. The second function template returns x <
nullptr.

template <class T, class D>

template <class T, class D>

bool operator<=(const unique_ptr<T, D>& x, nullptr_t);

bool operator<=(nullptr_t, const unique_ptr<T, D>& x);

Returns: The ﬁrst function template returns !(nullptr < x). The second function template returns
!(x < nullptr).

template <class T, class D>

template <class T, class D>

bool operator>=(const unique_ptr<T, D>& x, nullptr_t);

bool operator>=(nullptr_t, const unique_ptr<T, D>& x);

§ 20.8.1.5

566

c(cid:13) ISO/IEC

N4296

16

Returns: The ﬁrst function template returns !(x < nullptr). The second function template returns
!(nullptr < x).

20.8.2 Shared-ownership pointers
20.8.2.1 Class bad_weak_ptr

[util.smartptr]
[util.smartptr.weakptr]

class bad_weak_ptr: public std::exception {
public:

bad_weak_ptr() noexcept;

namespace std {

};

} // namespace std

1 An exception of type bad_weak_ptr is thrown by the shared_ptr constructor taking a weak_ptr.

bad_weak_ptr() noexcept;

2

Postconditions: what() returns an implementation-deﬁned NTBS.

20.8.2.2 Class template shared_ptr

[util.smartptr.shared]
1 The shared_ptr class template stores a pointer, usually obtained via new. shared_ptr implements semantics
of shared ownership; the last remaining owner of the pointer is responsible for destroying the object, or
otherwise releasing the resources associated with the stored pointer. A shared_ptr object is empty if it does
not own a pointer.
namespace std {

template<class T> class shared_ptr {
public:

typedef T element_type;

// 20.8.2.2.1, constructors:
constexpr shared_ptr() noexcept;
template<class Y> explicit shared_ptr(Y* p);
template<class Y, class D> shared_ptr(Y* p, D d);
template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);
template <class D> shared_ptr(nullptr_t p, D d);
template <class D, class A> shared_ptr(nullptr_t p, D d, A a);
template<class Y> shared_ptr(const shared_ptr<Y>& r, T* p) noexcept;
shared_ptr(const shared_ptr& r) noexcept;
template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;
shared_ptr(shared_ptr&& r) noexcept;
template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;
template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);
template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);
constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }

// 20.8.2.2.2, destructor:
~shared_ptr();

// 20.8.2.2.3, assignment:
shared_ptr& operator=(const shared_ptr& r) noexcept;
template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;
shared_ptr& operator=(shared_ptr&& r) noexcept;
template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r) noexcept;
template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);

§ 20.8.2.2

567

c(cid:13) ISO/IEC

N4296

// 20.8.2.2.4, modiﬁers:
void swap(shared_ptr& r) noexcept;
void reset() noexcept;
template<class Y> void reset(Y* p);
template<class Y, class D> void reset(Y* p, D d);
template<class Y, class D, class A> void reset(Y* p, D d, A a);

// 20.8.2.2.5, observers:
T* get() const noexcept;
T& operator*() const noexcept;
T* operator->() const noexcept;
long use_count() const noexcept;
bool unique() const noexcept;
explicit operator bool() const noexcept;
template<class U> bool owner_before(shared_ptr<U> const& b) const;
template<class U> bool owner_before(weak_ptr<U> const& b) const;

};

// 20.8.2.2.6, shared_ptr creation
template<class T, class... Args> shared_ptr<T> make_shared(Args&&... args);
template<class T, class A, class... Args>

shared_ptr<T> allocate_shared(const A& a, Args&&... args);

// 20.8.2.2.7, shared_ptr comparisons:
template<class T, class U>

template<class T, class U>

template<class T, class U>

bool operator==(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;

bool operator!=(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;

template<class T, class U>

template<class T, class U>

template<class T, class U>

bool operator<(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;

bool operator>(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;

bool operator<=(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;

bool operator>=(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

bool operator==(const shared_ptr<T>& a, nullptr_t) noexcept;

bool operator==(nullptr_t, const shared_ptr<T>& b) noexcept;

bool operator!=(const shared_ptr<T>& a, nullptr_t) noexcept;

bool operator!=(nullptr_t, const shared_ptr<T>& b) noexcept;

bool operator<(const shared_ptr<T>& a, nullptr_t) noexcept;

bool operator<(nullptr_t, const shared_ptr<T>& b) noexcept;

bool operator<=(const shared_ptr<T>& a, nullptr_t) noexcept;

bool operator<=(nullptr_t, const shared_ptr<T>& b) noexcept;

bool operator>(const shared_ptr<T>& a, nullptr_t) noexcept;

§ 20.8.2.2

568

c(cid:13) ISO/IEC

N4296

template <class T>

template <class T>

template <class T>

bool operator>(nullptr_t, const shared_ptr<T>& b) noexcept;

bool operator>=(const shared_ptr<T>& a, nullptr_t) noexcept;

bool operator>=(nullptr_t, const shared_ptr<T>& b) noexcept;

// 20.8.2.2.8, shared_ptr specialized algorithms:
template<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;

// 20.8.2.2.9, shared_ptr casts:
template<class T, class U>

template<class T, class U>

template<class T, class U>

shared_ptr<T> static_pointer_cast(const shared_ptr<U>& r) noexcept;

shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>& r) noexcept;

shared_ptr<T> const_pointer_cast(const shared_ptr<U>& r) noexcept;

// 20.8.2.2.10, shared_ptr get_deleter:
template<class D, class T> D* get_deleter(const shared_ptr<T>& p) noexcept;

// 20.8.2.2.11, shared_ptr I/O:
template<class E, class T, class Y>

} // namespace std

basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, const shared_ptr<Y>& p);

2 Specializations of shared_ptr shall be CopyConstructible, CopyAssignable, and LessThanComparable,
allowing their use in standard containers. Specializations of shared_ptr shall be convertible to bool,
allowing their use in boolean expressions and declarations in conditions. The template parameter T of
shared_ptr may be an incomplete type.
[ Example:

3

if(shared_ptr<X> px = dynamic_pointer_cast<X>(py)) {

// do something with px

}

— end example ]

4 For purposes of determining the presence of a data race, member functions shall access and modify only the
shared_ptr and weak_ptr objects themselves and not objects they refer to. Changes in use_count() do
not reﬂect modiﬁcations that can introduce data races.
20.8.2.2.1 shared_ptr constructors
constexpr shared_ptr() noexcept;

[util.smartptr.shared.const]

1

2

3

4

5

Eﬀects: Constructs an empty shared_ptr object.
Postconditions: use_count() == 0 && get() == nullptr.

template<class Y> explicit shared_ptr(Y* p);

Requires: p shall be convertible to T*. Y shall be a complete type. The expression delete p shall be
well formed, shall have well deﬁned behavior, and shall not throw exceptions.
Eﬀects: Constructs a shared_ptr object that owns the pointer p.
Postconditions: use_count() == 1 && get() == p.

§ 20.8.2.2.1

569

c(cid:13) ISO/IEC

N4296

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

Throws: bad_alloc, or an implementation-deﬁned exception when a resource other than memory
could not be obtained.
Exception safety: If an exception is thrown, delete p is called.

template<class Y, class D> shared_ptr(Y* p, D d);
template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);
template <class D> shared_ptr(nullptr_t p, D d);
template <class D, class A> shared_ptr(nullptr_t p, D d, A a);

Requires: p shall be convertible to T*. D shall be CopyConstructible. The copy constructor and
destructor of D shall not throw exceptions. The expression d(p) shall be well formed, shall have
well deﬁned behavior, and shall not throw exceptions. A shall be an allocator (17.6.3.5). The copy
constructor and destructor of A shall not throw exceptions.
Eﬀects: Constructs a shared_ptr object that owns the object p and the deleter d. The second and
fourth constructors shall use a copy of a to allocate memory for internal use.
Postconditions: use_count() == 1 && get() == p.
Throws: bad_alloc, or an implementation-deﬁned exception when a resource other than memory
could not be obtained.
Exception safety: If an exception is thrown, d(p) is called.

template<class Y> shared_ptr(const shared_ptr<Y>& r, T* p) noexcept;

Eﬀects: Constructs a shared_ptr instance that stores p and shares ownership with r.
Postconditions: get() == p && use_count() == r.use_count()
[ Note: To avoid the possibility of a dangling pointer, the user of this constructor must ensure that p
remains valid at least until the ownership group of r is destroyed. — end note ]
[ Note: This constructor allows creation of an empty shared_ptr instance with a non-null stored
pointer. — end note ]

shared_ptr(const shared_ptr& r) noexcept;
template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;

Remark: The second constructor shall not participate in overload resolution unless Y* is implicitly
convertible to T*.
Eﬀects: If r is empty, constructs an empty shared_ptr object; otherwise, constructs a shared_ptr
object that shares ownership with r.
Postconditions: get() == r.get() && use_count() == r.use_count().

shared_ptr(shared_ptr&& r) noexcept;
template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;

Remark: The second constructor shall not participate in overload resolution unless Y* is convertible
to T*.
Eﬀects: Move-constructs a shared_ptr instance from r.
Postconditions: *this shall contain the old value of r. r shall be empty. r.get() == nullptr.

template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);

§ 20.8.2.2.1

570

c(cid:13) ISO/IEC

N4296

Requires: Y* shall be convertible to T*.
Eﬀects: Constructs a shared_ptr object that shares ownership with r and stores a copy of the pointer
stored in r.
Postconditions: use_count() == r.use_count().
Throws: bad_weak_ptr when r.expired().
Exception safety: If an exception is thrown, the constructor has no eﬀect.

template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);

Remark: This constructor shall not participate in overload resolution unless unique_ptr<Y, D>::pointer
is convertible to T*.
Eﬀects: Equivalent to shared_ptr(r.release(), r.get_deleter()) when D is not a reference type,
otherwise shared_ptr(r.release(), ref(r.get_deleter())).
Exception safety: If an exception is thrown, the constructor has no eﬀect.

20.8.2.2.2 shared_ptr destructor
~shared_ptr();

[util.smartptr.shared.dest]

Eﬀects:
—

If *this is empty or shares ownership with another shared_ptr instance (use_count() > 1),
there are no side eﬀects.
Otherwise, if *this owns an object p and a deleter d, d(p) is called.
Otherwise, *this owns a pointer p, and delete p is called.

—
—

[ Note: Since the destruction of *this decreases the number of instances that share ownership with *this
by one, after *this has been destroyed all shared_ptr instances that shared ownership with *this will
report a use_count() that is one less than its previous value. — end note ]
20.8.2.2.3 shared_ptr assignment
shared_ptr& operator=(const shared_ptr& r) noexcept;
template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;

[util.smartptr.shared.assign]

Eﬀects: Equivalent to shared_ptr(r).swap(*this).
Returns: *this.
[ Note: The use count updates caused by the temporary object construction and destruction are not
observable side eﬀects, so the implementation may meet the eﬀects (and the implied guarantees) via
diﬀerent means, without creating a temporary. In particular, in the example:

shared_ptr<int> p(new int);
shared_ptr<void> q(p);
p = p;
q = p;

both assignments may be no-ops. — end note ]

shared_ptr& operator=(shared_ptr&& r) noexcept;
template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r) noexcept;
Eﬀects: Equivalent to shared_ptr(std::move(r)).swap(*this).
Returns: *this.

§ 20.8.2.2.3

571

23

24

25

26

27

28

29

30

1

(1.1)

(1.2)

(1.3)

2

1

2

3

4

5

c(cid:13) ISO/IEC

N4296

template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);

Eﬀects: Equivalent to shared_ptr(std::move(r)).swap(*this).
Returns: *this

20.8.2.2.4 shared_ptr modiﬁers
void swap(shared_ptr& r) noexcept;

Eﬀects: Exchanges the contents of *this and r.

void reset() noexcept;

Eﬀects: Equivalent to shared_ptr().swap(*this).

template<class Y> void reset(Y* p);

Eﬀects: Equivalent to shared_ptr(p).swap(*this).

template<class Y, class D> void reset(Y* p, D d);

Eﬀects: Equivalent to shared_ptr(p, d).swap(*this).

template<class Y, class D, class A> void reset(Y* p, D d, A a);

Eﬀects: Equivalent to shared_ptr(p, d, a).swap(*this).

20.8.2.2.5 shared_ptr observers
T* get() const noexcept;

Returns: the stored pointer.

T& operator*() const noexcept;

[util.smartptr.shared.mod]

[util.smartptr.shared.obs]

Requires: get() != 0.
Returns: *get().
Remarks: When T is void, it is unspeciﬁed whether this member function is declared. If it is declared,
it is unspeciﬁed what its return type is, except that the declaration (although not necessarily the
deﬁnition) of the function shall be well formed.

T* operator->() const noexcept;

Requires: get() != 0.
Returns: get().

long use_count() const noexcept;

Returns: the number of shared_ptr objects, *this included, that share ownership with *this, or 0
when *this is empty.
[ Note: use_count() is not necessarily eﬃcient. — end note ]

6

7

1

2

3

4

5

1

2

3

4

5

6

7

8

bool unique() const noexcept;

9

10

Returns: use_count() == 1.
[ Note: unique() may be faster than use_count(). If you are using unique() to implement copy on
write, do not rely on a speciﬁc value when get() == nullptr. — end note ]

§ 20.8.2.2.5

572

c(cid:13) ISO/IEC

N4296

explicit operator bool() const noexcept;

11

Returns: get() != 0.

template<class U> bool owner_before(shared_ptr<U> const& b) const;
template<class U> bool owner_before(weak_ptr<U> const& b) const;

12
(12.1)

(12.2)

1

2

3

4

5

6

7

1

2

3

4

Returns: An unspeciﬁed value such that
—
—

x.owner_before(y) deﬁnes a strict weak ordering as deﬁned in 25.4;
under the equivalence relation deﬁned by owner_before, !a.owner_before(b) && !b.owner_-
before(a), two shared_ptr or weak_ptr instances are equivalent if and only if they share own-
ership or are both empty.
20.8.2.2.6 shared_ptr creation
template<class T, class... Args> shared_ptr<T> make_shared(Args&&... args);
template<class T, class A, class... Args>

[util.smartptr.shared.create]

shared_ptr<T> allocate_shared(const A& a, Args&&... args);

Requires: The expression ::new (pv) T(std::forward<Args>(args)...), where pv has type void*
and points to storage suitable to hold an object of type T, shall be well formed. A shall be an alloca-
tor (17.6.3.5). The copy constructor and destructor of A shall not throw exceptions.
Eﬀects: Allocates memory suitable for an object of type T and constructs an object in that memory
via the placement new-expression ::new (pv) T(std::forward<Args>(args)...). The template
allocate_shared uses a copy of a to allocate memory. If an exception is thrown, the functions have
no eﬀect.
Returns: A shared_ptr instance that stores and owns the address of the newly constructed object of
type T.
Postconditions: get() != 0 && use_count() == 1
Throws: bad_alloc, or an exception thrown from A::allocate or from the constructor of T.
Remarks: Implementations should perform no more than one memory allocation. [ Note: This provides
eﬃciency equivalent to an intrusive smart pointer. — end note ]
[ Note: These functions will typically allocate more memory than sizeof(T) to allow for internal
bookkeeping structures such as the reference counts. — end note ]

[util.smartptr.shared.cmp]
20.8.2.2.7 shared_ptr comparison
template<class T, class U> bool operator==(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;

Returns: a.get() == b.get().

template<class T, class U> bool operator<(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
Returns: less<V>()(a.get(), b.get()), where V is the composite pointer type (Clause 5) of T* and
U*.
[ Note: Deﬁning a comparison operator allows shared_ptr objects to be used as keys in associative
containers. — end note ]

template <class T>

template <class T>

bool operator==(const shared_ptr<T>& a, nullptr_t) noexcept;

bool operator==(nullptr_t, const shared_ptr<T>& a) noexcept;

Returns: !a.

§ 20.8.2.2.7

573

c(cid:13) ISO/IEC

N4296

5

6

7

8

9

1

1

2

3

4

bool operator!=(const shared_ptr<T>& a, nullptr_t) noexcept;

bool operator!=(nullptr_t, const shared_ptr<T>& a) noexcept;

template <class T>

template <class T>

Returns: (bool)a.

template <class T>

template <class T>

bool operator<(const shared_ptr<T>& a, nullptr_t) noexcept;

bool operator<(nullptr_t, const shared_ptr<T>& a) noexcept;

Returns: The ﬁrst function template returns less<T*>()(a.get(), nullptr). The second function
template returns less<T*>()(nullptr, a.get()).

template <class T>

template <class T>

bool operator>(const shared_ptr<T>& a, nullptr_t) noexcept;

bool operator>(nullptr_t, const shared_ptr<T>& a) noexcept;

Returns: The ﬁrst function template returns nullptr < a. The second function template returns a <
nullptr.

template <class T>

template <class T>

bool operator<=(const shared_ptr<T>& a, nullptr_t) noexcept;

bool operator<=(nullptr_t, const shared_ptr<T>& a) noexcept;

Returns: The ﬁrst function template returns !(nullptr < a). The second function template returns
!(a < nullptr).

template <class T>

template <class T>

bool operator>=(const shared_ptr<T>& a, nullptr_t) noexcept;

bool operator>=(nullptr_t, const shared_ptr<T>& a) noexcept;

Returns: The ﬁrst function template returns !(a < nullptr). The second function template returns
!(nullptr < a).

20.8.2.2.8 shared_ptr specialized algorithms
template<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;

[util.smartptr.shared.spec]

Eﬀects: Equivalent to a.swap(b).

20.8.2.2.9 shared_ptr casts
template<class T, class U> shared_ptr<T> static_pointer_cast(const shared_ptr<U>& r) noexcept;

[util.smartptr.shared.cast]

Requires: The expression static_cast<T*>(r.get()) shall be well formed.
Returns: If r is empty, an empty shared_ptr<T>; otherwise, a shared_ptr<T> object that stores
static_cast<T*>(r.get()) and shares ownership with r.
Postconditions: w.get() == static_cast<T*>(r.get()) and w.use_count() == r.use_count(),
where w is the return value.
[ Note: The seemingly equivalent expression shared_ptr<T>(static_cast<T*>(r.get())) will even-
tually result in undeﬁned behavior, attempting to delete the same object twice. — end note ]

template<class T, class U> shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>& r) noexcept;

§ 20.8.2.2.9

574

c(cid:13) ISO/IEC

N4296

Requires: The expression dynamic_cast<T*>(r.get()) shall be well formed and shall have well deﬁned
behavior.
Returns:
—

When dynamic_cast<T*>(r.get()) returns a nonzero value, a shared_ptr<T> object that stores
a copy of it and shares ownership with r;
Otherwise, an empty shared_ptr<T> object.

—
Postcondition: w.get() == dynamic_cast<T*>(r.get()), where w is the return value.
[ Note: The seemingly equivalent expression shared_ptr<T>(dynamic_cast<T*>(r.get())) will even-
tually result in undeﬁned behavior, attempting to delete the same object twice. — end note ]

template<class T, class U> shared_ptr<T> const_pointer_cast(const shared_ptr<U>& r) noexcept;

Requires: The expression const_cast<T*>(r.get()) shall be well formed.
Returns: If r is empty, an empty shared_ptr<T>; otherwise, a shared_ptr<T> object that stores
const_cast<T*>(r.get()) and shares ownership with r.
Postconditions: w.get() == const_cast<T*>(r.get()) and w.use_count() == r.use_count(), where
w is the return value.
[ Note: The seemingly equivalent expression shared_ptr<T>(const_cast<T*>(r.get())) will even-
tually result in undeﬁned behavior, attempting to delete the same object twice. — end note ]

20.8.2.2.10 get_deleter
template<class D, class T> D* get_deleter(const shared_ptr<T>& p) noexcept;

[util.smartptr.getdeleter]

Returns: If p owns a deleter d of type cv-unqualiﬁed D, returns std:addressof(d); otherwise returns
nullptr. The returned pointer remains valid as long as there exists a shared_ptr instance that owns
d. [ Note: It is unspeciﬁed whether the pointer remains valid longer than that. This can happen if the
implementation doesn’t destroy the deleter until all weak_ptr instances that share ownership with p
have been destroyed. — end note ]

[util.smartptr.shared.io]

20.8.2.2.11 shared_ptr I/O
template<class E, class T, class Y>

Eﬀects: os << p.get();.
Returns: os.

basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);

5

6

(6.1)

(6.2)

7

8

9

10

11

12

1

1

2

20.8.2.3 Class template weak_ptr

[util.smartptr.weak]
1 The weak_ptr class template stores a weak reference to an object that is already managed by a shared_ptr.

To access the object, a weak_ptr can be converted to a shared_ptr using the member function lock.

namespace std {

template<class T> class weak_ptr {
public:

typedef T element_type;

// 20.8.2.3.1, constructors
constexpr weak_ptr() noexcept;
template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;
weak_ptr(weak_ptr const& r) noexcept;
template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;

§ 20.8.2.3

575

c(cid:13) ISO/IEC

N4296

weak_ptr(weak_ptr&& r) noexcept;
template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept;

// 20.8.2.3.2, destructor
~weak_ptr();

// 20.8.2.3.3, assignment
weak_ptr& operator=(weak_ptr const& r) noexcept;
template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;
template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;
weak_ptr& operator=(weak_ptr&& r) noexcept;
template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept;

// 20.8.2.3.4, modiﬁers
void swap(weak_ptr& r) noexcept;
void reset() noexcept;

// 20.8.2.3.5, observers
long use_count() const noexcept;
bool expired() const noexcept;
shared_ptr<T> lock() const noexcept;
template<class U> bool owner_before(shared_ptr<U> const& b) const;
template<class U> bool owner_before(weak_ptr<U> const& b) const;

};

// 20.8.2.3.6, specialized algorithms
template<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;

} // namespace std

2 Specializations of weak_ptr shall be CopyConstructible and CopyAssignable, allowing their use in stan-

dard containers. The template parameter T of weak_ptr may be an incomplete type.
20.8.2.3.1 weak_ptr constructors
constexpr weak_ptr() noexcept;

[util.smartptr.weak.const]

1

2

3

4

5

6

7

8

Eﬀects: Constructs an empty weak_ptr object.
Postconditions: use_count() == 0.

weak_ptr(const weak_ptr& r) noexcept;
template<class Y> weak_ptr(const weak_ptr<Y>& r) noexcept;
template<class Y> weak_ptr(const shared_ptr<Y>& r) noexcept;

Remark: The second and third constructors shall not participate in overload resolution unless Y* is
implicitly convertible to T*.
Eﬀects: If r is empty, constructs an empty weak_ptr object; otherwise, constructs a weak_ptr object
that shares ownership with r and stores a copy of the pointer stored in r.
Postconditions: use_count() == r.use_count().

weak_ptr(weak_ptr&& r) noexcept;
template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept;

Remark: The second constructor shall not participate in overload resolution unless Y* is implicitly
convertible to T*.
Eﬀects: Move-constructs a weak_ptr instance from r.
Postconditions: *this shall contain the old value of r. r shall be empty. r.use_count() == 0.

§ 20.8.2.3.1

576

c(cid:13) ISO/IEC

20.8.2.3.2 weak_ptr destructor
~weak_ptr();

N4296

[util.smartptr.weak.dest]

Eﬀects: Destroys this weak_ptr object but has no eﬀect on the object its stored pointer points to.

20.8.2.3.3 weak_ptr assignment
weak_ptr& operator=(const weak_ptr& r) noexcept;
template<class Y> weak_ptr& operator=(const weak_ptr<Y>& r) noexcept;
template<class Y> weak_ptr& operator=(const shared_ptr<Y>& r) noexcept;

[util.smartptr.weak.assign]

Eﬀects: Equivalent to weak_ptr(r).swap(*this).
Remarks: The implementation may meet the eﬀects (and the implied guarantees) via diﬀerent means,
without creating a temporary.
Returns: *this.

weak_ptr& operator=(weak_ptr&& r) noexcept;
template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept;
Eﬀects: Equivalent to weak_ptr(std::move(r)).swap(*this).
Returns: *this.

20.8.2.3.4 weak_ptr modiﬁers
void swap(weak_ptr& r) noexcept;

Eﬀects: Exchanges the contents of *this and r.

void reset() noexcept;

Eﬀects: Equivalent to weak_ptr().swap(*this).

20.8.2.3.5 weak_ptr observers
long use_count() const noexcept;

[util.smartptr.weak.mod]

[util.smartptr.weak.obs]

Returns: 0 if *this is empty; otherwise, the number of shared_ptr instances that share ownership
with *this.
[ Note: use_count() is not necessarily eﬃcient. — end note ]

bool expired() const noexcept;

Returns: use_count() == 0.
[ Note: expired() may be faster than use_count(). — end note ]

shared_ptr<T> lock() const noexcept;

Returns: expired() ? shared_ptr<T>() :

shared_ptr<T>(*this), executed atomically.

1

1

2

3

4

5

1

2

1

2

3

4

5

template<class U> bool owner_before(shared_ptr<U> const& b) const;
template<class U> bool owner_before(weak_ptr<U> const& b) const;

6
(6.1)

(6.2)

Returns: An unspeciﬁed value such that
—
—

x.owner_before(y) deﬁnes a strict weak ordering as deﬁned in 25.4;
under the equivalence relation deﬁned by owner_before, !a.owner_before(b) && !b.owner_-
before(a), two shared_ptr or weak_ptr instances are equivalent if and only if they share own-
ership or are both empty.

§ 20.8.2.3.5

577

c(cid:13) ISO/IEC

N4296

20.8.2.3.6 weak_ptr specialized algorithms
template<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;

[util.smartptr.weak.spec]

1

Eﬀects: Equivalent to a.swap(b).
20.8.2.4 Class template owner_less

[util.smartptr.ownerless]

1 The class template owner_less allows ownership-based mixed comparisons of shared and weak pointers.

namespace std {

template<class T> struct owner_less;

template<class T> struct owner_less<shared_ptr<T> > {

typedef bool result_type;
typedef shared_ptr<T> first_argument_type;
typedef shared_ptr<T> second_argument_type;
bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;
bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;
bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;

};

template<class T> struct owner_less<weak_ptr<T> > {

typedef bool result_type;
typedef weak_ptr<T> first_argument_type;
typedef weak_ptr<T> second_argument_type;
bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;
bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;
bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;

};

}

2 operator()(x,y) shall return x.owner_before(y). [ Note: Note that

(2.1)

(2.2)

—
—

operator() deﬁnes a strict weak ordering as deﬁned in 25.4;
under the equivalence relation deﬁned by operator(), !operator()(a, b) && !operator()(b, a),
two shared_ptr or weak_ptr instances are equivalent if and only if they share ownership or are both
empty.
— end note ]
20.8.2.5 Class template enable_shared_from_this

[util.smartptr.enab]
1 A class T can inherit from enable_shared_from_this<T> to inherit the shared_from_this member func-

tions that obtain a shared_ptr instance pointing to *this.
[ Example:

2

struct X: public enable_shared_from_this<X> {
};

int main() {

shared_ptr<X> p(new X);
shared_ptr<X> q = p->shared_from_this();
assert(p == q);
assert(!(p < q ) && !(q < p)); // p and q share ownership

}

— end example ]

§ 20.8.2.5

578

c(cid:13) ISO/IEC

N4296

namespace std {

template<class T> class enable_shared_from_this {
protected:

constexpr enable_shared_from_this() noexcept;
enable_shared_from_this(enable_shared_from_this const&) noexcept;
enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;
~enable_shared_from_this();

shared_ptr<T> shared_from_this();
shared_ptr<T const> shared_from_this() const;

public:

};

} // namespace std

3 The template parameter T of enable_shared_from_this may be an incomplete type.

constexpr enable_shared_from_this() noexcept;
enable_shared_from_this(const enable_shared_from_this<T>&) noexcept;

Eﬀects: Constructs an enable_shared_from_this<T> object.

enable_shared_from_this<T>& operator=(const enable_shared_from_this<T>&) noexcept;

Returns: *this.

~enable_shared_from_this();
Eﬀects: Destroys *this.

shared_ptr<T>
shared_ptr<T const> shared_from_this() const;

shared_from_this();

Requires: enable_shared_from_this<T> shall be an accessible base class of T. *this shall be a
subobject of an object t of type T. There shall be at least one shared_ptr instance p that owns &t.
Returns: A shared_ptr<T> object r that shares ownership with p.
Postconditions: r.get() == this.

4

5

6

7

8

9

10

[ Note: A possible implementation is shown below:

template<class T> class enable_shared_from_this {
private:

weak_ptr<T> __weak_this;

protected:

constexpr enable_shared_from_this() : __weak_this() { }
enable_shared_from_this(enable_shared_from_this const &) { }
enable_shared_from_this& operator=(enable_shared_from_this const &) { return *this; }
~enable_shared_from_this() { }

shared_ptr<T> shared_from_this() { return shared_ptr<T>(__weak_this); }
shared_ptr<T const> shared_from_this() const { return shared_ptr<T const>(__weak_this); }

public:

};

11 The shared_ptr constructors that create unique pointers can detect the presence of an enable_shared_-

from_this base and assign the newly created shared_ptr to its __weak_this member. — end note ]

§ 20.8.2.5

579

c(cid:13) ISO/IEC

N4296

20.8.2.6 shared_ptr atomic access

[util.smartptr.shared.atomic]
1 Concurrent access to a shared_ptr object from multiple threads does not introduce a data race if the access

is done exclusively via the functions in this section and the instance is passed as their ﬁrst argument.

2 The meaning of the arguments of type memory_order is explained in 29.3.

template<class T>

bool atomic_is_lock_free(const shared_ptr<T>* p);

Requires: p shall not be null.
Returns: true if atomic access to *p is lock-free, false otherwise.
Throws: Nothing.

template<class T>

shared_ptr<T> atomic_load(const shared_ptr<T>* p);

Requires: p shall not be null.
Returns: atomic_load_explicit(p, memory_order_seq_cst).
Throws: Nothing.

template<class T>

shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);

Requires: p shall not be null.
Requires: mo shall not be memory_order_release or memory_order_acq_rel.
Returns: *p.
Throws: Nothing.

template<class T>

void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);

Requires: p shall not be null.
Eﬀects: atomic_store_explicit(p, r, memory_order_seq_cst).
Throws: Nothing.

template<class T>

void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);

Requires: p shall not be null.
Requires: mo shall not be memory_order_acquire or memory_order_acq_rel.
Eﬀects: p->swap(r).
Throws: Nothing.

template<class T>

shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);

Requires: p shall not be null.
Returns: atomic_exchange_explicit(p, r, memory_order_seq_cst).
Throws: Nothing.

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

template<class T>

shared_ptr<T> atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r,

memory_order mo);

§ 20.8.2.6

580

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

1

2

c(cid:13) ISO/IEC

N4296

Requires: p shall not be null.
Eﬀects: p->swap(r).
Returns: The previous value of *p.
Throws: Nothing.

template<class T>

bool atomic_compare_exchange_weak(

shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
Requires: p shall not be null and v shall not be null.
Returns: atomic_compare_exchange_weak_explicit(p, v, w, memory_order_seq_cst, memory_-
order_seq_cst).
Throws: Nothing.

template<class T>

bool atomic_compare_exchange_strong(

shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
Returns: atomic_compare_exchange_strong_explicit(p, v, w, memory_order_seq_cst, memory_-
order_seq_cst).

template<class T>

bool atomic_compare_exchange_weak_explicit(

shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
memory_order success, memory_order failure);

template<class T>

bool atomic_compare_exchange_strong_explicit(

shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
memory_order success, memory_order failure);
Requires: p shall not be null and v shall not be null.
Requires: failure shall not be memory_order_release, memory_order_acq_rel, or stronger than
success.
Eﬀects: If *p is equivalent to *v, assigns w to *p and has synchronization semantics corresponding to
the value of success, otherwise assigns *p to *v and has synchronization semantics corresponding to
the value of failure.
Returns: true if *p was equivalent to *v, false otherwise.
Throws: Nothing.
Remarks:
ownership.
Remarks: the weak forms may fail spuriously. See 29.6.

two shared_ptr objects are equivalent if they store the same pointer value and share

20.8.2.7 Smart pointer hash support
template <class T, class D> struct hash<unique_ptr<T, D> >;

[util.smartptr.hash]

The template specialization shall meet the requirements of class template hash (20.9.13). For an
object p of type UP, where UP is unique_ptr<T, D>, hash<UP>()(p) shall evaluate to the same value
as hash<typename UP::pointer>()(p.get()).
Requires: The specialization hash<typename UP::pointer> shall be well-formed and well-deﬁned, and
shall meet the requirements of class template hash (20.9.13).

§ 20.8.2.7

581

c(cid:13) ISO/IEC

N4296

template <class T> struct hash<shared_ptr<T> >;

3

The template specialization shall meet the requirements of class template hash (20.9.13). For an
object p of type shared_ptr<T>, hash<shared_ptr<T> >()(p) shall evaluate to the same value as
hash<T*>()(p.get()).
20.9 Function objects

[function.objects]
1 A function object type is an object type (3.9) that can be the type of the postﬁx-expression in a function call
(5.2.2, 13.3.1.1).230 A function object is an object of a function object type. In the places where one would
expect to pass a pointer to a function to an algorithmic template (Clause 25), the interface is speciﬁed to
accept a function object. This not only makes algorithmic templates work with pointers to functions, but
also enables them to work with arbitrary function objects.

2 Header <functional> synopsis

namespace std {

// 20.9.3, invoke:
template <class F, class... Args> result_of_t<F&&(Args&&...)> invoke(F&& f, Args&&... args);

// 20.9.4, reference_wrapper:
template <class T> class reference_wrapper;

template <class T> reference_wrapper<T> ref(T&) noexcept;
template <class T> reference_wrapper<const T> cref(const T&) noexcept;
template <class T> void ref(const T&&) = delete;
template <class T> void cref(const T&&) = delete;

template <class T> reference_wrapper<T> ref(reference_wrapper<T>) noexcept;
template <class T> reference_wrapper<const T> cref(reference_wrapper<T>) noexcept;

// 20.9.5, arithmetic operations:
template <class T = void> struct plus;
template <class T = void> struct minus;
template <class T = void> struct multiplies;
template <class T = void> struct divides;
template <class T = void> struct modulus;
template <class T = void> struct negate;
template <> struct plus<void>;
template <> struct minus<void>;
template <> struct multiplies<void>;
template <> struct divides<void>;
template <> struct modulus<void>;
template <> struct negate<void>;

// 20.9.6, comparisons:
template <class T = void> struct equal_to;
template <class T = void> struct not_equal_to;
template <class T = void> struct greater;
template <class T = void> struct less;
template <class T = void> struct greater_equal;
template <class T = void> struct less_equal;
template <> struct equal_to<void>;
template <> struct not_equal_to<void>;

230) Such a type is a function pointer or a class type which has a member operator() or a class type which has a conversion
to a pointer to function.

§ 20.9

582

c(cid:13) ISO/IEC

N4296

template <> struct greater<void>;
template <> struct less<void>;
template <> struct greater_equal<void>;
template <> struct less_equal<void>;

// 20.9.7, logical operations:
template <class T = void> struct logical_and;
template <class T = void> struct logical_or;
template <class T = void> struct logical_not;
template <> struct logical_and<void>;
template <> struct logical_or<void>;
template <> struct logical_not<void>;

// 20.9.8, bitwise operations:
template <class T = void> struct bit_and;
template <class T = void> struct bit_or;
template <class T = void> struct bit_xor;
template <class T = void> struct bit_not;
template <> struct bit_and<void>;
template <> struct bit_or<void>;
template <> struct bit_xor<void>;
template <> struct bit_not<void>;

// 20.9.9, negators:
template <class Predicate> class unary_negate;
template <class Predicate>

constexpr unary_negate<Predicate> not1(const Predicate&);

template <class Predicate> class binary_negate;
template <class Predicate>

constexpr binary_negate<Predicate> not2(const Predicate&);

// 20.9.10, bind:
template<class T> struct is_bind_expression;
template<class T> struct is_placeholder;

template<class F, class... BoundArgs>

unspecified

bind(F&&, BoundArgs&&...);

template<class R, class F, class... BoundArgs>

unspecified

bind(F&&, BoundArgs&&...);

namespace placeholders {

// M is the implementation-deﬁned number of placeholders
extern unspecified
extern unspecified

_1;
_2;

.
.
.

extern unspecified

_M;

}

// 20.9.11, member function adaptors:
template<class R, class T> unspecified

mem_fn(R T::*);

// 20.9.12 polymorphic function wrappers:
class bad_function_call;

§ 20.9

583

c(cid:13) ISO/IEC

N4296

template<class> class function; // undeﬁned
template<class R, class... ArgTypes> class function<R(ArgTypes...)>;

template<class R, class... ArgTypes>

void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&);

template<class R, class... ArgTypes>

template<class R, class... ArgTypes>

bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;

bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;

template<class R, class... ArgTypes>

template<class R, class... ArgTypes>

bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;

bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;

// 20.9.13, hash function primary template:
template <class T> struct hash;

// Hash function specializations
template <> struct hash<bool>;
template <> struct hash<char>;
template <> struct hash<signed char>;
template <> struct hash<unsigned char>;
template <> struct hash<char16_t>;
template <> struct hash<char32_t>;
template <> struct hash<wchar_t>;
template <> struct hash<short>;
template <> struct hash<unsigned short>;
template <> struct hash<int>;
template <> struct hash<unsigned int>;
template <> struct hash<long>;
template <> struct hash<long long>;
template <> struct hash<unsigned long>;
template <> struct hash<unsigned long long>;

template <> struct hash<float>;
template <> struct hash<double>;
template <> struct hash<long double>;

template<class T> struct hash<T*>;

}

3

4

5

[ Example: If a C++ program wants to have a by-element addition of two vectors a and b containing double
and put the result into a, it can do:

transform(a.begin(), a.end(), b.begin(), a.begin(), plus<double>());

— end example ]
[ Example: To negate every element of a:

transform(a.begin(), a.end(), a.begin(), negate<double>());

— end example ]
[ Note: To enable adaptors and other components to manipulate function objects that take one or two
arguments many of the function objects in this clause correspondingly provide typedefs argument_type and

§ 20.9

584

c(cid:13) ISO/IEC

N4296

result_type for function objects that take one argument and first_argument_type, second_argument_-
type, and result_type for function objects that take two arguments. — end note ]
20.9.1 Deﬁnitions

[func.def]

1 The following deﬁnitions apply to this Clause:
2 A call signature is the name of a return type followed by a parenthesized comma-separated list of zero or

more argument types.

3 A callable type is a function object type (20.9) or a pointer to member.
4 A callable object is an object of a callable type.
5 A call wrapper type is a type that holds a callable object and supports a call operation that forwards to that

object.

6 A call wrapper is an object of a call wrapper type.
7 A target object is the callable object held by a call wrapper.

20.9.2 Requirements

1 Deﬁne INVOKE (f, t1, t2, ..., tN) as follows:

[func.require]

(1.1)

(1.2)

(1.3)

(1.4)

(1.5)

—

—

—

—

—

(t1.*f)(t2, ..., tN) when f is a pointer to a member function of a class T and t1 is an object of
type T or a reference to an object of type T or a reference to an object of a type derived from T;
((*t1).*f)(t2, ..., tN) when f is a pointer to a member function of a class T and t1 is not one of
the types described in the previous item;
t1.*f when N == 1 and f is a pointer to member data of a class T and t1 is an object of type T or a
reference to an object of type T or a reference to an object of a type derived from T;
(*t1).*f when N == 1 and f is a pointer to member data of a class T and t1 is not one of the types
described in the previous item;
f(t1, t2, ..., tN) in all other cases.

2 Deﬁne INVOKE (f, t1, t2, ..., tN, R) as INVOKE (f, t1, t2, ..., tN) implicitly converted to R.
3

If a call wrapper (20.9.1) has a weak result type the type of its member type result_type is based on the
type T of the wrapper’s target object (20.9.1):

(3.1)

(3.2)

(3.3)

(3.4)

—
—
—

—

if T is a pointer to function type, result_type shall be a synonym for the return type of T;
if T is a pointer to member function, result_type shall be a synonym for the return type of T;
if T is a class type and the qualiﬁed-id T::result_type is valid and denotes a type (14.8.2), then
result_type shall be a synonym for T::result_type;
otherwise result_type shall not be deﬁned.

4 Every call wrapper (20.9.1) shall be MoveConstructible. A simple call wrapper is a call wrapper that is
CopyConstructible and CopyAssignable and whose copy constructor, move constructor, and assignment
operator do not throw exceptions. A forwarding call wrapper is a call wrapper that can be called with
an arbitrary argument list and delivers the arguments to the wrapped callable object as references. This
forwarding step shall ensure that rvalue arguments are delivered as rvalue-references and lvalue arguments
are delivered as lvalue-references.
[ Note: In a typical implementation forwarding call wrappers have an
overloaded function call operator of the form

§ 20.9.2

585

N4296

[func.invoke]

[refwrap]

c(cid:13) ISO/IEC

template<class... UnBoundArgs>
R operator()(UnBoundArgs&&... unbound_args) cv-qual ;

— end note ]
20.9.3 Function template invoke
template <class F, class... Args>

result_of_t<F&&(Args&&...)> invoke(F&& f, Args&&... args);

1

Returns: INVOKE (std::forward<F>(f), std::forward<Args>(args)...) (20.9.2).

20.9.4 Class template reference_wrapper

namespace std {

template <class T> class reference_wrapper {
public :
// types
typedef T type;
typedef see below result_type;
typedef see below argument_type;
typedef see below first_argument_type;
typedef see below second_argument_type;

// not always deﬁned
// not always deﬁned
// not always deﬁned
// not always deﬁned

// construct/copy/destroy
reference_wrapper(T&) noexcept;
reference_wrapper(T&&) = delete;
reference_wrapper(const reference_wrapper& x) noexcept;

// do not bind to temporary objects

// assignment
reference_wrapper& operator=(const reference_wrapper& x) noexcept;

// access
operator T& () const noexcept;
T& get() const noexcept;

// invocation
template <class... ArgTypes>
result_of_t<T&(ArgTypes&&...)>
operator() (ArgTypes&&...) const;

};

}

1 reference_wrapper<T> is a CopyConstructible and CopyAssignable wrapper around a reference to an

object or function of type T.

2 reference_wrapper<T> shall be a trivially copyable type (3.9).
3 reference_wrapper<T> has a weak result type (20.9.2). If T is a function type, result_type shall be a

synonym for the return type of T.

4 The template specialization reference_wrapper<T> shall deﬁne a nested type named argument_type as a

synonym for T1 only if the type T is any of the following:

(4.1)

(4.2)

—
—

a function type or a pointer to function type taking one argument of type T1
a pointer to member function R T0::f cv (where cv represents the member function’s cv-qualiﬁers);
the type T1 is cv T0*

§ 20.9.4

586

c(cid:13) ISO/IEC

N4296

(4.3)

—

a class type where the qualiﬁed-id T::argument_type is valid and denotes a type (14.8.2); the type T1
is T::argument_type.

5 The template instantiation reference_wrapper<T> shall deﬁne two nested types named first_argument_-
type and second_argument_type as synonyms for T1 and T2, respectively, only if the type T is any of the
following:

(5.1)

(5.2)

(5.3)

—
—

—

a function type or a pointer to function type taking two arguments of types T1 and T2
a pointer to member function R T0::f(T2) cv (where cv represents the member function’s cv-qualiﬁers);
the type T1 is cv T0*
a class type where the qualiﬁed-ids T::first_argument_type and T::second_argument_type are
both valid and both denote types (14.8.2); the type T1 is T::first_argument_type and the type T2
is T::second_argument_type.

20.9.4.1 reference_wrapper construct/copy/destroy
reference_wrapper(T& t) noexcept;

[refwrap.const]

Eﬀects: Constructs a reference_wrapper object that stores a reference to t.

reference_wrapper(const reference_wrapper& x) noexcept;

Eﬀects: Constructs a reference_wrapper object that stores a reference to x.get().

1

2

1

1

2

1

2

1

2

20.9.4.2 reference_wrapper assignment
reference_wrapper& operator=(const reference_wrapper& x) noexcept;

Postconditions: *this stores a reference to x.get().

20.9.4.3 reference_wrapper access
operator T& () const noexcept;

Returns: The stored reference.

T& get() const noexcept;

Returns: The stored reference.

reference_wrapper invocation

20.9.4.4
template <class... ArgTypes>

[refwrap.assign]

[refwrap.access]

[refwrap.invoke]

result_of_t<T&(ArgTypes&&... )>

operator()(ArgTypes&&... args) const;
Returns: INVOKE (get(), std::forward<ArgTypes>(args)...). (20.9.2)
Remark: operator() is described for exposition only. Implementations are not required to provide an
actual reference_wrapper::operator(). Implementations are permitted to support reference_-
wrapper function invocation through multiple overloaded operators or through other means.

reference_wrapper helper functions

20.9.4.5
template <class T> reference_wrapper<T> ref(T& t) noexcept;

Returns: reference_wrapper<T>(t)

template <class T> reference_wrapper<T> ref(reference_wrapper<T> t) noexcept;

[refwrap.helpers]

Returns: ref(t.get())

§ 20.9.4.5

587

c(cid:13) ISO/IEC

N4296

template <class T> reference_wrapper<const T> cref(const T& t) noexcept;

Returns: reference_wrapper <const T>(t)

template <class T> reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;

Returns: cref(t.get());

3

4

20.9.5 Arithmetic operations

[arithmetic.operations]
1 The library provides basic function object classes for all of the arithmetic operators in the language (5.6,

5.7).

template <class T = void> struct plus {

constexpr T operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef T result_type;

operator() returns x + y.

template <class T = void> struct minus {

constexpr T operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef T result_type;

operator() returns x - y.

template <class T = void> struct multiplies {

constexpr T operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef T result_type;

};

operator() returns x * y.

template <class T = void> struct divides {

constexpr T operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef T result_type;

operator() returns x / y.

template <class T = void> struct modulus {

constexpr T operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef T result_type;

};

};

};

};

2

3

4

5

6

operator() returns x % y.

§ 20.9.5

588

c(cid:13) ISO/IEC

N4296

template <class T = void> struct negate {

constexpr T operator()(const T& x) const;
typedef T argument_type;
typedef T result_type;

};

operator() returns -x.

template <> struct plus<void> {

template <class T, class U> constexpr auto operator()(T&& t, U&& u) const

-> decltype(std::forward<T>(t) + std::forward<U>(u));

typedef unspecified

is_transparent;

};

operator() returns std::forward<T>(t) + std::forward<U>(u).

template <> struct minus<void> {

template <class T, class U> constexpr auto operator()(T&& t, U&& u) const

-> decltype(std::forward<T>(t) - std::forward<U>(u));

typedef unspecified

is_transparent;

};

operator() returns std::forward<T>(t) - std::forward<U>(u).

template <> struct multiplies<void> {

template <class T, class U> constexpr auto operator()(T&& t, U&& u) const

-> decltype(std::forward<T>(t) * std::forward<U>(u));

7

8

9

};

10

typedef unspecified

is_transparent;

operator() returns std::forward<T>(t) * std::forward<U>(u).

template <> struct divides<void> {

template <class T, class U> constexpr auto operator()(T&& t, U&& u) const

-> decltype(std::forward<T>(t) / std::forward<U>(u));

};

11

typedef unspecified

is_transparent;

operator() returns std::forward<T>(t) / std::forward<U>(u).

template <> struct modulus<void> {

template <class T, class U> constexpr auto operator()(T&& t, U&& u) const

-> decltype(std::forward<T>(t) % std::forward<U>(u));

};

12

typedef unspecified

is_transparent;

operator() returns std::forward<T>(t) % std::forward<U>(u).

template <> struct negate<void> {

template <class T> constexpr auto operator()(T&& t) const

-> decltype(-std::forward<T>(t));

};

13

typedef unspecified

is_transparent;

operator() returns -std::forward<T>(t).

§ 20.9.5

589

c(cid:13) ISO/IEC

N4296

20.9.6 Comparisons

[comparisons]
1 The library provides basic function object classes for all of the comparison operators in the language (5.9,

5.10).

template <class T = void> struct equal_to {

constexpr bool operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef bool result_type;

};

operator() returns x == y.

template <class T = void> struct not_equal_to {

constexpr bool operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef bool result_type;

};

operator() returns x != y.

template <class T = void> struct greater {

constexpr bool operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef bool result_type;

operator() returns x > y.

template <class T = void> struct less {

constexpr bool operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef bool result_type;

};

};

2

3

4

5

6

7

operator() returns x < y.

template <class T = void> struct greater_equal {

constexpr bool operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef bool result_type;

};

operator() returns x >= y.

template <class T = void> struct less_equal {

constexpr bool operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef bool result_type;

};

operator() returns x <= y.

§ 20.9.6

590

c(cid:13) ISO/IEC

N4296

template <> struct equal_to<void> {

template <class T, class U> constexpr auto operator()(T&& t, U&& u) const

-> decltype(std::forward<T>(t) == std::forward<U>(u));

typedef unspecified

is_transparent;

};

operator() returns std::forward<T>(t) == std::forward<U>(u).

template <> struct not_equal_to<void> {

template <class T, class U> constexpr auto operator()(T&& t, U&& u) const

-> decltype(std::forward<T>(t) != std::forward<U>(u));

typedef unspecified

is_transparent;

};

operator() returns std::forward<T>(t) != std::forward<U>(u).

8

9

template <> struct greater<void> {

template <class T, class U> constexpr auto operator()(T&& t, U&& u) const

-> decltype(std::forward<T>(t) > std::forward<U>(u));

};

10

typedef unspecified

is_transparent;

operator() returns std::forward<T>(t) > std::forward<U>(u).

template <> struct less<void> {

template <class T, class U> constexpr auto operator()(T&& t, U&& u) const

-> decltype(std::forward<T>(t) < std::forward<U>(u));

};

11

typedef unspecified

is_transparent;

operator() returns std::forward<T>(t) < std::forward<U>(u).

template <> struct greater_equal<void> {

template <class T, class U> constexpr auto operator()(T&& t, U&& u) const

-> decltype(std::forward<T>(t) >= std::forward<U>(u));

};

12

typedef unspecified

is_transparent;

operator() returns std::forward<T>(t) >= std::forward<U>(u).

template <> struct less_equal<void> {

template <class T, class U> constexpr auto operator()(T&& t, U&& u) const

-> decltype(std::forward<T>(t) <= std::forward<U>(u));

typedef unspecified

is_transparent;

};

operator() returns std::forward<T>(t) <= std::forward<U>(u).

13
14 For templates greater, less, greater_equal, and less_equal, the specializations for any pointer type

yield a total order, even if the built-in operators <, >, <=, >= do not.

§ 20.9.6

591

c(cid:13) ISO/IEC

N4296

20.9.7 Logical operations

[logical.operations]
1 The library provides basic function object classes for all of the logical operators in the language (5.14, 5.15,

5.3.1).

template <class T = void> struct logical_and {

constexpr bool operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef bool result_type;

operator() returns x && y.

template <class T = void> struct logical_or {

constexpr bool operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef bool result_type;

};

};

2

3

4

5

6

7

operator() returns x || y.

template <class T = void> struct logical_not {
constexpr bool operator()(const T& x) const;
typedef T argument_type;
typedef bool result_type;

};

operator() returns !x.

template <> struct logical_and<void> {

template <class T, class U> constexpr auto operator()(T&& t, U&& u) const

-> decltype(std::forward<T>(t) && std::forward<U>(u));

typedef unspecified

is_transparent;

};

operator() returns std::forward<T>(t) && std::forward<U>(u).

template <> struct logical_or<void> {

template <class T, class U> constexpr auto operator()(T&& t, U&& u) const

-> decltype(std::forward<T>(t) || std::forward<U>(u));

typedef unspecified

is_transparent;

};

operator() returns std::forward<T>(t) || std::forward<U>(u).

template <> struct logical_not<void> {

template <class T> constexpr auto operator()(T&& t) const

-> decltype(!std::forward<T>(t));

typedef unspecified

is_transparent;

};

operator() returns !std::forward<T>(t).

§ 20.9.7

592

c(cid:13) ISO/IEC

N4296

20.9.8 Bitwise operations

[bitwise.operations]
1 The library provides basic function object classes for all of the bitwise operators in the language (5.11, 5.13,

5.12, 5.3.1).

template <class T = void> struct bit_and {

constexpr T operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef T result_type;

operator() returns x & y.

template <class T = void> struct bit_or {

constexpr T operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef T result_type;

};

};

};

2

3

4

5

6

7

operator() returns x | y.

template <class T = void> struct bit_xor {

constexpr T operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef T result_type;

operator() returns x ˆ y.

template <class T = void> struct bit_not {
constexpr T operator()(const T& x) const;
typedef T argument_type;
typedef T result_type;

};

operator() returns ~x.

template <> struct bit_and<void> {

template <class T, class U> constexpr auto operator()(T&& t, U&& u) const

-> decltype(std::forward<T>(t) & std::forward<U>(u));

typedef unspecified

is_transparent;

};

operator() returns std::forward<T>(t) & std::forward<U>(u).

template <> struct bit_or<void> {

template <class T, class U> constexpr auto operator()(T&& t, U&& u) const

-> decltype(std::forward<T>(t) | std::forward<U>(u));

typedef unspecified

is_transparent;

};

operator() returns std::forward<T>(t) | std::forward<U>(u).

§ 20.9.8

593

c(cid:13) ISO/IEC

N4296

template <> struct bit_xor<void> {

template <class T, class U> constexpr auto operator()(T&& t, U&& u) const

-> decltype(std::forward<T>(t) ^ std::forward<U>(u));

typedef unspecified

is_transparent;

};

operator() returns std::forward<T>(t) ˆ std::forward<U>(u).

template <> struct bit_not<void> {

template <class T> constexpr auto operator()(T&& t) const

-> decltype(~std::forward<T>(t));

typedef unspecified

is_transparent;

};

operator() returns ~std::forward<T>(t).

20.9.9 Negators

[negators]
1 Negators not1 and not2 take a unary and a binary predicate, respectively, and return their comple-

ments (5.3.1).

8

9

2

3

4

5

template <class Predicate>

class unary_negate {

public:

constexpr explicit unary_negate(const Predicate& pred);
constexpr bool operator()(const typename Predicate::argument_type& x) const;
typedef typename Predicate::argument_type argument_type;
typedef bool result_type;

};

operator() returns !pred(x).

template <class Predicate>

constexpr unary_negate<Predicate> not1(const Predicate& pred);

Returns: unary_negate<Predicate>(pred).

template <class Predicate>

class binary_negate {
public:

constexpr explicit binary_negate(const Predicate& pred);
constexpr bool operator()(const typename Predicate::first_argument_type& x,

const typename Predicate::second_argument_type& y) const;

typedef typename Predicate::first_argument_type first_argument_type;
typedef typename Predicate::second_argument_type second_argument_type;
typedef bool result_type;
};

operator() returns !pred(x,y).

template <class Predicate>

constexpr binary_negate<Predicate> not2(const Predicate& pred);

Returns: binary_negate<Predicate>(pred).

20.9.10 Function object binders

1 This subclause describes a uniform mechanism for binding arguments of callable objects.

§ 20.9.10

[func.bind]

594

c(cid:13) ISO/IEC

N4296

20.9.10.1 Class template is_bind_expression

[func.bind.isbind]

namespace std {

template<class T> struct is_bind_expression; // see below

2

1 is_bind_expression can be used to detect function objects generated by bind. bind uses is_bind_-

expression to detect subexpressions.
Instantiations of the is_bind_expression template shall meet the UnaryTypeTrait requirements (20.10.1).
The implementation shall provide a deﬁnition that has a BaseCharacteristic of true_type if T is a type
returned from bind, otherwise it shall have a BaseCharacteristic of false_type. A program may specialize
this template for a user-deﬁned type T to have a BaseCharacteristic of true_type to indicate that T should
be treated as a subexpression in a bind call.
20.9.10.2 Class template is_placeholder

[func.bind.isplace]

namespace std {

template<class T> struct is_placeholder; // see below

1 is_placeholder can be used to detect the standard placeholders _1, _2, and so on. bind uses is_-

placeholder to detect placeholders.
Instantiations of the is_placeholder template shall meet the UnaryTypeTrait requirements (20.10.1). The
implementation shall provide a deﬁnition that has the BaseCharacteristic of integral_constant<int, J>
if T is the type of std::placeholders::_J, otherwise it shall have a BaseCharacteristic of integral_-
constant<int, 0>. A program may specialize this template for a user-deﬁned type T to have a BaseChar-
acteristic of integral_constant<int, N > with N > 0 to indicate that T should be treated as a placeholder
type.
20.9.10.3 Function template bind
In the text that follows, the following names have the following meanings:

[func.bind.bind]

}

}

2

1

(1.1)

(1.2)

(1.3)

(1.4)

(1.5)

(1.6)

(1.7)

(1.8)

2

3

—
—
—
—
—
—
—
—

FD is the type decay_t<F>,
fd is an lvalue of type FD constructed from std::forward<F>(f),
Ti is the ith type in the template parameter pack BoundArgs,
TiD is the type decay_t<Ti>,
ti is the ith argument in the function parameter pack bound_args,
tid is an lvalue of type TiD constructed from std::forward<Ti>(ti),
Uj is the jth deduced type of the UnBoundArgs&&... parameter of the forwarding call wrapper, and
uj is the jth argument associated with Uj.

template<class F, class... BoundArgs>

unspecified

bind(F&& f, BoundArgs&&... bound_args);

Requires: is_constructible<FD, F>::value shall be true. For each Ti in BoundArgs, is_cons-
tructible<TiD, Ti>::value shall be true. INVOKE (fd, w1, w2, ..., wN) (20.9.2) shall be a
valid expression for some values w1, w2, ..., wN, where N == sizeof...(bound_args).
Returns: A forwarding call wrapper g with a weak result type (20.9.2). The eﬀect of g(u1, u2, ...,
uM) shall be INVOKE (fd, std::forward<V1>(v1), std::forward<V2>(v2), ..., std::forward<VN>(vN),

§ 20.9.10.3

595

c(cid:13) ISO/IEC

N4296

result_of_t<FD cv & (V1, V2, ..., VN)>), where cv represents the cv-qualiﬁers of g and the val-
ues and types of the bound arguments v1, v2, ..., vN are determined as speciﬁed below. The copy
constructor and move constructor of the forwarding call wrapper shall throw an exception if and only
if the corresponding constructor of FD or of any of the types TiD throws an exception.
Throws: Nothing unless the construction of fd or of one of the values tid throws an exception.
Remarks: The return type shall satisfy the requirements of MoveConstructible. If all of FD and TiD
satisfy the requirements of CopyConstructible, then the return type shall satisfy the requirements
of CopyConstructible. [ Note: This implies that all of FD and TiD are MoveConstructible. — end
note ]

template<class R, class F, class... BoundArgs>

unspecified

bind(F&& f, BoundArgs&&... bound_args);

Requires: is_constructible<FD, F>::value shall be true. For each Ti in BoundArgs, is_con-
structible<TiD, Ti>::value shall be true. INVOKE (fd, w1, w2, ..., wN) shall be a valid ex-
pression for some values w1, w2, ..., wN, where N == sizeof...(bound_args).
Returns: A forwarding call wrapper g with a nested type result_type deﬁned as a synonym for R. The
eﬀect of g(u1, u2, ..., uM) shall be INVOKE (fd, std::forward<V1>(v1), std::forward<V2>(v2),
..., std::forward<VN>(vN), R), where the values and types of the bound arguments v1, v2, ...,
vN are determined as speciﬁed below. The copy constructor and move constructor of the forwarding
call wrapper shall throw an exception if and only if the corresponding constructor of FD or of any of
the types TiD throws an exception.
Throws: Nothing unless the construction of fd or of one of the values tid throws an exception.
Remarks: The return type shall satisfy the requirements of MoveConstructible. If all of FD and TiD
satisfy the requirements of CopyConstructible, then the return type shall satisfy the requirements
of CopyConstructible. [ Note: This implies that all of FD and TiD are MoveConstructible. — end
note ]

4

5

6

7

8

9

10 The values of the bound arguments v1, v2, ..., vN and their corresponding types V1, V2, ..., VN
depend on the types TiD derived from the call to bind and the cv-qualiﬁers cv of the call wrapper g as
follows:

(10.1)

(10.2)

(10.3)

(10.4)

—
—

—

—

if TiD is reference_wrapper<T>, the argument is tid.get() and its type Vi is T&;
if the value of is_bind_expression<TiD>::value is true, the argument is tid(std::forward<Uj>(
uj)...) and its type Vi is result_of_t<TiD cv & (Uj&&...)>&&;
if the value j of is_placeholder<TiD>::value is not zero, the argument is std::forward<Uj>(uj)
and its type Vi is Uj&&;
otherwise, the value is tid and its type Vi is TiD cv &.

20.9.10.4 Placeholders

[func.bind.place]

namespace std::placeholders {

// M is the implementation-deﬁned number of placeholders
extern unspecified
extern unspecified

_1;
_2;

.
.
.

extern unspecified _M;

}

§ 20.9.10.4

596

c(cid:13) ISO/IEC

N4296

1 All placeholder types shall be DefaultConstructible and CopyConstructible, and their default con-
structors and copy/move constructors shall not throw exceptions.
It is implementation-deﬁned whether
placeholder types are CopyAssignable. CopyAssignable placeholders’ copy assignment operators shall not
throw exceptions.
20.9.11 Function template mem_fn
template<class R, class T> unspecified

[func.memfn]

mem_fn(R T::* pm);

1

2

3

4

Returns: A simple call wrapper (20.9.1) fn such that the expression fn(t, a2, ..., aN) is equivalent
to INVOKE (pm, t, a2, ..., aN) (20.9.2). fn shall have a nested type result_type that is a synonym
for the return type of pm when pm is a pointer to member function.
The simple call wrapper shall deﬁne two nested types named argument_type and result_type as
synonyms for cv T* and Ret, respectively, when pm is a pointer to member function with cv-qualiﬁer
cv and taking no arguments, where Ret is pm’s return type.
The simple call wrapper shall deﬁne three nested types named first_argument_type, second_-
argument_type, and result_type as synonyms for cv T*, T1, and Ret, respectively, when pm is
a pointer to member function with cv-qualiﬁer cv and taking one argument of type T1, where Ret is
pm’s return type.
Throws: Nothing.

20.9.12 Polymorphic function wrappers

[func.wrap]

1 This subclause describes a polymorphic wrapper class that encapsulates arbitrary callable objects.

20.9.12.1 Class bad_function_call

[func.wrap.badcall]
1 An exception of type bad_function_call is thrown by function::operator() (20.9.12.2.4) when the

function wrapper object has no target.

class bad_function_call : public std::exception {
public:

// 20.9.12.1.1, constructor:
bad_function_call() noexcept;

namespace std {

};

} // namespace std

20.9.12.1.1 bad_function_call constructor
bad_function_call() noexcept;

1

2

Eﬀects: constructs a bad_function_call object.
Postconditions: what() returns an implementation-deﬁned NTBS.

20.9.12.2 Class template function

namespace std {

template<class> class function; // undeﬁned

[func.wrap.badcall.const]

[func.wrap.func]

template<class R, class... ArgTypes>
class function<R(ArgTypes...)> {
public:

typedef R result_type;
typedef T1 argument_type;

// only if sizeof...(ArgTypes) == 1 and
// the type in ArgTypes is T1

§ 20.9.12.2

597

c(cid:13) ISO/IEC

N4296

typedef T1 first_argument_type;

typedef T2 second_argument_type;

// only if sizeof...(ArgTypes) == 2 and
// ArgTypes contains T1 and T2
// only if sizeof...(ArgTypes) == 2 and
// ArgTypes contains T1 and T2

// 20.9.12.2.1, construct/copy/destroy:
function() noexcept;
function(nullptr_t) noexcept;
function(const function&);
function(function&&);
template<class F> function(F);
template<class A> function(allocator_arg_t, const A&) noexcept;
template<class A> function(allocator_arg_t, const A&,

nullptr_t) noexcept;

template<class A> function(allocator_arg_t, const A&,

template<class A> function(allocator_arg_t, const A&,

const function&);

function&&);

template<class F, class A> function(allocator_arg_t, const A&, F);

function& operator=(const function&);
function& operator=(function&&);
function& operator=(nullptr_t) noexcept;
template<class F> function& operator=(F&&);
template<class F> function& operator=(reference_wrapper<F>) noexcept;

~function();

// 20.9.12.2.2, function modiﬁers:
void swap(function&) noexcept;
template<class F, class A> void assign(F&&, const A&);

// 20.9.12.2.3, function capacity:
explicit operator bool() const noexcept;

// 20.9.12.2.4, function invocation:
R operator()(ArgTypes...) const;

// 20.9.12.2.5, function target access:
const std::type_info& target_type() const noexcept;
template<class T>
template<class T> const T* target() const noexcept;

T* target() noexcept;

};

// 20.9.12.2.6, Null pointer comparisons:
template <class R, class... ArgTypes>

bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;

template <class R, class... ArgTypes>

bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;

template <class R, class... ArgTypes>

bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;

§ 20.9.12.2

598

c(cid:13) ISO/IEC

N4296

template <class R, class... ArgTypes>

bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;

// 20.9.12.2.7, specialized algorithms:
template <class R, class... ArgTypes>

void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&);

template<class R, class... ArgTypes, class Alloc>

struct uses_allocator<function<R(ArgTypes...)>, Alloc>

: true_type { };

}

1 The function class template provides polymorphic wrappers that generalize the notion of a function pointer.
Wrappers can store, copy, and call arbitrary callable objects (20.9.1), given a call signature (20.9.1), allowing
functions to be ﬁrst-class objects.

2 A callable object f of type F is Callable for argument types ArgTypes and return type R if the expres-
sion INVOKE (f, declval<ArgTypes>()..., R), considered as an unevaluated operand (Clause 5), is well
formed (20.9.2).

3 The function class template is a call wrapper (20.9.1) whose call signature (20.9.1) is R(ArgTypes...).

20.9.12.2.1 function construct/copy/destroy

[func.wrap.func.con]
1 When any function constructor that takes a ﬁrst argument of type allocator_arg_t is invoked, the second
argument shall have a type that conforms to the requirements for Allocator (Table 17.6.3.5). A copy of the
allocator argument is used to allocate memory, if necessary, for the internal data structures of the constructed
function object.

2

3

4

5

6

function() noexcept;
template <class A> function(allocator_arg_t, const A& a) noexcept;

Postconditions: !*this.

function(nullptr_t) noexcept;
template <class A> function(allocator_arg_t, const A& a, nullptr_t) noexcept;

Postconditions: !*this.

function(const function& f);
template <class A> function(allocator_arg_t, const A& a, const function& f);

Postconditions: !*this if !f; otherwise, *this targets a copy of f.target().
Throws: shall not throw exceptions if f’s target is a callable object passed via reference_wrapper or
a function pointer. Otherwise, may throw bad_alloc or any exception thrown by the copy constructor
of the stored callable object. [ Note: Implementations are encouraged to avoid the use of dynamically
allocated memory for small callable objects, for example, where f’s target is an object holding only a
pointer or reference to an object and a member function pointer. — end note ]

function(function&& f);
template <class A> function(allocator_arg_t, const A& a, function&& f);

Eﬀects: If !f, *this has no target; otherwise, move-constructs the target of f into the target of *this,
leaving f in a valid state with an unspeciﬁed value.

template<class F> function(F f);
template <class F, class A> function(allocator_arg_t, const A& a, F f);

§ 20.9.12.2.1

599

7

8

9

(9.1)

(9.2)

(9.3)

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

c(cid:13) ISO/IEC

N4296

f is a null function pointer value.
f is a null member pointer value.
F is an instance of the function class template, and !f.

Requires: F shall be CopyConstructible.
Remarks: These constructors shall not participate in overload resolution unless f is Callable (20.9.12.2)
for argument types ArgTypes... and return type R.
Postconditions: !*this if any of the following hold:
—
—
—
Otherwise, *this targets a copy of f initialized with std::move(f).
[ Note: Implementations are
encouraged to avoid the use of dynamically allocated memory for small callable objects, for example,
where f’s target is an object holding only a pointer or reference to an object and a member function
pointer. — end note ]
Throws: shall not throw exceptions when f is a function pointer or a reference_wrapper<T> for some
T. Otherwise, may throw bad_alloc or any exception thrown by F’s copy or move constructor.

function& operator=(const function& f);
Eﬀects: function(f).swap(*this);
Returns: *this

function& operator=(function&& f);

Eﬀects: Replaces the target of *this with the target of f.
Returns: *this

function& operator=(nullptr_t) noexcept;

Eﬀects: If *this != nullptr, destroys the target of this.
Postconditions: !(*this).
Returns: *this

template<class F> function& operator=(F&& f);

Eﬀects: function(std::forward<F>(f)).swap(*this);
Returns: *this
Remarks: This assignment operator shall not participate in overload resolution unless declval<typename
decay<F>::type&>() is Callable (20.9.12.2) for argument types ArgTypes... and return type R.

template<class F> function& operator=(reference_wrapper<F> f) noexcept;

Eﬀects: function(f).swap(*this);
Returns: *this

~function();

Eﬀects: If *this != nullptr, destroys the target of this.

§ 20.9.12.2.1

600

c(cid:13) ISO/IEC

20.9.12.2.2 function modiﬁers
void swap(function& other) noexcept;

Eﬀects: interchanges the targets of *this and other.

template<class F, class A>

void assign(F&& f, const A& a);

N4296

[func.wrap.func.mod]

Eﬀects: function(allocator_arg, a, std::forward<F>(f)).swap(*this)

20.9.12.2.3 function capacity
explicit operator bool() const noexcept;

Returns: true if *this has a target, otherwise false.

20.9.12.2.4 function invocation
R operator()(ArgTypes... args) const

[func.wrap.func.cap]

[func.wrap.func.inv]

Eﬀects: INVOKE (f, std::forward<ArgTypes>(args)..., R) (20.9.2), where f is the target ob-
ject (20.9.1) of *this.
Returns: Nothing if R is void, otherwise the return value of INVOKE (f, std::forward<ArgTypes>(
args)..., R).
Throws: bad_function_call if !*this; otherwise, any exception thrown by the wrapped callable
object.
20.9.12.2.5
const std::type_info& target_type() const noexcept;

function target access

[func.wrap.func.targ]

Returns: If *this has a target of type T, typeid(T); otherwise, typeid(void).

template<class T>
template<class T> const T* target() const noexcept;

T* target() noexcept;

Requires: T shall be a type that is Callable (20.9.12.2) for parameter types ArgTypes and return type
R.
Returns: If target_type() == typeid(T) a pointer to the stored function target; otherwise a null
pointer.

20.9.12.2.6 null pointer comparison operators
template <class R, class... ArgTypes>

bool operator==(const function<R(ArgTypes...)>& f, nullptr_t) noexcept;

template <class R, class... ArgTypes>

bool operator==(nullptr_t, const function<R(ArgTypes...)>& f) noexcept;

[func.wrap.func.nullptr]

Returns: !f.

template <class R, class... ArgTypes>

template <class R, class... ArgTypes>

bool operator!=(const function<R(ArgTypes...)>& f, nullptr_t) noexcept;

bool operator!=(nullptr_t, const function<R(ArgTypes...)>& f) noexcept;

Returns:

(bool) f.

§ 20.9.12.2.6

601

1

2

1

1

2

3

1

2

3

1

2

c(cid:13) ISO/IEC

specialized algorithms
20.9.12.2.7
template<class R, class... ArgTypes>

void swap(function<R(ArgTypes...)>& f1, function<R(ArgTypes...)>& f2);

1

Eﬀects: f1.swap(f2);

N4296

[func.wrap.func.alg]

20.9.13 Class template hash

[unord.hash]
1 The unordered associative containers deﬁned in 23.5 use specializations of the class template hash as the
default hash function. For all object types Key for which there exists a specialization hash<Key>, and for all
enumeration types (7.2) Key, the instantiation hash<Key> shall:

(1.1)

(1.2)

(1.3)

(1.4)

(1.5)

—

—
—

—

—

satisfy the Hash requirements (17.6.3.4), with Key as the function call argument type, the Default-
Constructible requirements (Table 19), the CopyAssignable requirements (Table 23),
be swappable (17.6.3.2) for lvalues,
provide two nested types result_type and argument_type which shall be synonyms for size_t and
Key, respectively,
satisfy the requirement that if k1 == k2 is true, h(k1) == h(k2) is also true, where h is an object of
type hash<Key> and k1 and k2 are objects of type Key;
satisfy the requirement that the expression h(k), where h is an object of type hash<Key> and k is an
object of type Key, shall not throw an exception unless hash<Key> is a user-deﬁned specialization that
depends on at least one user-deﬁned type.

template <> struct hash<bool>;
template <> struct hash<char>;
template <> struct hash<signed char>;
template <> struct hash<unsigned char>;
template <> struct hash<char16_t>;
template <> struct hash<char32_t>;
template <> struct hash<wchar_t>;
template <> struct hash<short>;
template <> struct hash<unsigned short>;
template <> struct hash<int>;
template <> struct hash<unsigned int>;
template <> struct hash<long>;
template <> struct hash<unsigned long>;
template <> struct hash<long long>;
template <> struct hash<unsigned long long>;
template <> struct hash<float>;
template <> struct hash<double>;
template <> struct hash<long double>;
template <class T> struct hash<T*>;

2

The template specializations shall meet the requirements of class template hash (20.9.13).

20.10 Metaprogramming and type traits

[meta]
1 This subclause describes components used by C++ programs, particularly in templates, to support the
widest possible range of types, optimise template code usage, detect type related user errors, and perform
type inference and transformation at compile time.
It includes type classiﬁcation traits, type property
inspection traits, and type transformations. The type classiﬁcation traits describe a complete taxonomy
of all possible C++ types, and state where in that taxonomy a given type belongs. The type property
inspection traits allow important characteristics of types or of combinations of types to be inspected. The
type transformations allow certain properties of types to be manipulated.

§ 20.10

602

c(cid:13) ISO/IEC

N4296

20.10.1 Requirements

[meta.rqmts]
1 A UnaryTypeTrait describes a property of a type. It shall be a class template that takes one template type
argument and, optionally, additional arguments that help deﬁne the property being described. It shall be
DefaultConstructible, CopyConstructible, and publicly and unambiguously derived, directly or indi-
rectly, from its BaseCharacteristic, which is a specialization of the template integral_constant (20.10.3),
with the arguments to the template integral_constant determined by the requirements for the particular
property being described. The member names of the BaseCharacteristic shall not be hidden and shall be
unambiguously available in the UnaryTypeTrait.

2 A BinaryTypeTrait describes a relationship between two types. It shall be a class template that takes two
template type arguments and, optionally, additional arguments that help deﬁne the relationship being de-
scribed. It shall be DefaultConstructible, CopyConstructible, and publicly and unambiguously derived,
directly or indirectly, from its BaseCharacteristic, which is a specialization of the template integral_-
constant (20.10.3), with the arguments to the template integral_constant determined by the require-
ments for the particular relationship being described. The member names of the BaseCharacteristic shall
not be hidden and shall be unambiguously available in the BinaryTypeTrait.

3 A TransformationTrait modiﬁes a property of a type. It shall be a class template that takes one template
It shall deﬁne a

type argument and, optionally, additional arguments that help deﬁne the modiﬁcation.
publicly accessible nested type named type, which shall be a synonym for the modiﬁed type.
20.10.2 Header <type_traits> synopsis

[meta.type.synop]

namespace std {

// 20.10.3, helper class:
template <class T, T v> struct integral_constant;
typedef integral_constant<bool, true>
true_type;
typedef integral_constant<bool, false> false_type;

// 20.10.4.1, primary type categories:
template <class T> struct is_void;
template <class T> struct is_null_pointer;
template <class T> struct is_integral;
template <class T> struct is_floating_point;
template <class T> struct is_array;
template <class T> struct is_pointer;
template <class T> struct is_lvalue_reference;
template <class T> struct is_rvalue_reference;
template <class T> struct is_member_object_pointer;
template <class T> struct is_member_function_pointer;
template <class T> struct is_enum;
template <class T> struct is_union;
template <class T> struct is_class;
template <class T> struct is_function;

// 20.10.4.2, composite type categories:
template <class T> struct is_reference;
template <class T> struct is_arithmetic;
template <class T> struct is_fundamental;
template <class T> struct is_object;
template <class T> struct is_scalar;
template <class T> struct is_compound;
template <class T> struct is_member_pointer;

// 20.10.4.3, type properties:

§ 20.10.2

603

c(cid:13) ISO/IEC

N4296

template <class T> struct is_const;
template <class T> struct is_volatile;
template <class T> struct is_trivial;
template <class T> struct is_trivially_copyable;
template <class T> struct is_standard_layout;
template <class T> struct is_pod;
template <class T> struct is_literal_type;
template <class T> struct is_empty;
template <class T> struct is_polymorphic;
template <class T> struct is_abstract;
template <class T> struct is_final;

template <class T> struct is_signed;
template <class T> struct is_unsigned;

template <class T, class... Args> struct is_constructible;
template <class T> struct is_default_constructible;
template <class T> struct is_copy_constructible;
template <class T> struct is_move_constructible;

template <class T, class U> struct is_assignable;
template <class T> struct is_copy_assignable;
template <class T> struct is_move_assignable;

template <class T> struct is_destructible;

template <class T, class... Args> struct is_trivially_constructible;
template <class T> struct is_trivially_default_constructible;
template <class T> struct is_trivially_copy_constructible;
template <class T> struct is_trivially_move_constructible;

template <class T, class U> struct is_trivially_assignable;
template <class T> struct is_trivially_copy_assignable;
template <class T> struct is_trivially_move_assignable;
template <class T> struct is_trivially_destructible;

template <class T, class... Args> struct is_nothrow_constructible;
template <class T> struct is_nothrow_default_constructible;
template <class T> struct is_nothrow_copy_constructible;
template <class T> struct is_nothrow_move_constructible;

template <class T, class U> struct is_nothrow_assignable;
template <class T> struct
is_nothrow_copy_assignable;
template <class T> struct is_nothrow_move_assignable;

template <class T> struct is_nothrow_destructible;
template <class T> struct has_virtual_destructor;

// 20.10.5, type property queries:
template <class T> struct alignment_of;
template <class T> struct rank;
template <class T, unsigned I = 0> struct extent;

// 20.10.6, type relations:
template <class T, class U> struct is_same;

§ 20.10.2

604

c(cid:13) ISO/IEC

N4296

template <class Base, class Derived> struct is_base_of;
template <class From, class To> struct is_convertible;

// 20.10.7.1, const-volatile modiﬁcations:
template <class T> struct remove_const;
template <class T> struct remove_volatile;
template <class T> struct remove_cv;
template <class T> struct add_const;
template <class T> struct add_volatile;
template <class T> struct add_cv;

using remove_const_t

= typename remove_const<T>::type;

using remove_volatile_t = typename remove_volatile<T>::type;

template <class T>

template <class T>

template <class T>
using remove_cv_t
template <class T>
using add_const_t
template <class T>

using add_volatile_t

template <class T>

using add_cv_t

= typename remove_cv<T>::type;

= typename add_const<T>::type;

= typename add_volatile<T>::type;

= typename add_cv<T>::type;

// 20.10.7.2, reference modiﬁcations:
template <class T> struct remove_reference;
template <class T> struct add_lvalue_reference;
template <class T> struct add_rvalue_reference;

template <class T>

template <class T>

template <class T>

using remove_reference_t

= typename remove_reference<T>::type;

using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;

using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;

// 20.10.7.3, sign modiﬁcations:
template <class T> struct make_signed;
template <class T> struct make_unsigned;

template <class T>

template <class T>

using make_signed_t

= typename make_signed<T>::type;

using make_unsigned_t = typename make_unsigned<T>::type;

// 20.10.7.4, array modiﬁcations:
template <class T> struct remove_extent;
template <class T> struct remove_all_extents;

template <class T>

using remove_extent_t

template <class T>

= typename remove_extent<T>::type;

using remove_all_extents_t = typename remove_all_extents<T>::type;

// 20.10.7.5, pointer modiﬁcations:

§ 20.10.2

605

c(cid:13) ISO/IEC

N4296

template <class T> struct remove_pointer;
template <class T> struct add_pointer;

using remove_pointer_t = typename remove_pointer<T>::type;

= typename add_pointer<T>::type;

template <class T>

template <class T>

using add_pointer_t

// 20.10.7.6, other transformations:
template <std::size_t Len,

struct aligned_storage;

std::size_t Align = default-alignment>

// see 20.10.7.6

template <std::size_t Len, class... Types> struct aligned_union;
template <class T> struct decay;
template <bool, class T = void> struct enable_if;
template <bool, class T, class F> struct conditional;
template <class... T> struct common_type;
template <class T> struct underlying_type;
template <class> class result_of;
template <class F, class... ArgTypes> class result_of<F(ArgTypes...)>;

// not deﬁned

template <std::size_t Len,

std::size_t Align = default-alignment > // see 20.10.7.6

using aligned_storage_t = typename aligned_storage<Len,Align>::type;

template <std::size_t Len, class... Types>

using aligned_union_t

= typename aligned_union<Len,Types...>::type;

template <class T>

using decay_t

= typename decay<T>::type;

template <bool b, class T = void>

using enable_if_t

= typename enable_if<b,T>::type;

template <bool b, class T, class F>

= typename conditional<b,T,F>::type;

= typename common_type<T...>::type;

using conditional_t
template <class... T>
using common_type_t

template <class T>

template <class T>
using result_of_t
template <class...>

using void_t
} // namespace std

using underlying_type_t = typename underlying_type<T>::type;

= typename result_of<T>::type;

= void;

1 The behavior of a program that adds specializations for any of the class templates deﬁned in this subclause

is undeﬁned unless otherwise speciﬁed.
20.10.3 Helper classes

namespace std {

template <class T, T v>
struct integral_constant {

static constexpr T value = v;
typedef T value_type;
typedef integral_constant<T,v> type;
constexpr operator value_type() const noexcept { return value; }
constexpr value_type operator()() const noexcept { return value; }

};

[meta.help]

§ 20.10.3

606

c(cid:13) ISO/IEC

N4296

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

}

1 The class template integral_constant and its associated typedefs true_type and false_type are used as

base classes to deﬁne the interface for various type traits.
20.10.4 Unary type traits

[meta.unary]

[meta.unary.cat]

1 This sub-clause contains templates that may be used to query the properties of a type at compile time.
2 Each of these templates shall be a UnaryTypeTrait (20.10.1) with a BaseCharacteristic of true_type if the

corresponding condition is true, otherwise false_type.
20.10.4.1 Primary type categories

1 The primary type categories correspond to the descriptions given in section 3.9 of the C++ standard.
2 For any given type T, the result of applying one of these templates to T and to cv-qualiﬁed T shall yield the

same result.
[ Note: For any given type T, exactly one of the primary type categories has a value member that evaluates
to true. — end note ]

3

Table 47 — Primary type category predicates

Template

template <class T>
struct is_void;
template <class T>
struct is_null_pointer;
template <class T>
struct is_integral;
template <class T>
struct is_floating_point;
template <class T>
struct is_array;

template <class T>
struct is_pointer;

template <class T>
struct is_lvalue_reference;
template <class T>
struct is_rvalue_reference;
template <class T>
struct is_member_object_pointer;
template <class T>
struct
is_member_function_pointer;
template <class T>
struct is_enum;
template <class T>
struct is_union;

Condition

Comments

Class template
array (23.3.2) is not an
array type.
Includes pointers to
functions but not pointers
to non-static members.

T is void

T is std::nullptr_t (3.9.1)

T is an integral type (3.9.1)

T is a ﬂoating point
type (3.9.1)
T is an array type (3.9.2) of
known or unknown extent

T is a pointer type (3.9.2)

T is an lvalue reference
type (8.3.2)
T is an rvalue reference
type (8.3.2)
T is a pointer to non-static
data member
T is a pointer to non-static
member function

T is an enumeration
type (3.9.2)
T is a union type (3.9.2)

§ 20.10.4.1

607

c(cid:13) ISO/IEC

N4296

Table 47 — Primary type category predicates (continued)

Template

template <class T>
struct is_class;
template <class T>
struct is_function;

Condition

T is a class type but not a
union type (3.9.2)
T is a function type (3.9.2)

Comments

20.10.4.2 Composite type traits

[meta.unary.comp]
1 These templates provide convenient compositions of the primary type categories, corresponding to the de-

scriptions given in section 3.9.

2 For any given type T, the result of applying one of these templates to T, and to cv-qualiﬁed T shall yield the

same result.

Table 48 — Composite type category predicates

Comments

Template

template <class T>
struct is_reference;
template <class T>
struct is_arithmetic;
template <class T>
struct is_fundamental;
template <class T>
struct is_object;
template <class T>
struct is_scalar;
template <class T>
struct is_compound;
template <class T>
struct is_member_pointer;

Condition

T is an lvalue reference or
an rvalue reference
T is an arithmetic
type (3.9.1)
T is a fundamental
type (3.9.1)
T is an object type (3.9)

T is a scalar type (3.9)

T is a compound
type (3.9.2)
T is a pointer to non-static
data member or non-static
member function

20.10.4.3 Type properties

[meta.unary.prop]

It is unspeciﬁed whether the library deﬁnes any full or partial specializations of any of these templates.

1 These templates provide access to some of the more important properties of types.
2
3 For all of the class templates X declared in this Clause, instantiating that template with a template-argument
that is a class template specialization may result in the implicit instantiation of the template argument if
and only if the semantics of X require that the argument must be a complete type.

Table 49 — Type property predicates

Template

template <class T>
struct is_const;
template <class T>
struct is_volatile;

Condition

T is const-qualiﬁed (3.9.3)

T is
volatile-qualiﬁed (3.9.3)

Preconditions

§ 20.10.4.3

608

c(cid:13) ISO/IEC

N4296

Table 49 — Type property predicates (continued)

Template

template <class T>
struct is_trivial;

Condition

T is a trivial type (3.9)

template <class T>
struct is_trivially_copyable;

T is a trivially copyable
type (3.9)

template <class T>
struct is_standard_layout;

T is a standard-layout
type (3.9)

template <class T>
struct is_pod;

template <class T>
struct is_literal_type;

template <class T>
struct is_empty;

template <class T>
struct is_polymorphic;

template <class T>
struct is_abstract;

template <class T>
struct is_final;

T is a POD type (3.9)

T is a literal type (3.9)

T is a class type, but not a
union type, with no
non-static data members
other than bit-ﬁelds of
length 0, no virtual
member functions, no
virtual base classes, and
no base class B for which
is_empty<B>::value is
false.
T is a polymorphic
class (10.3)

T is an abstract
class (10.4)

T is a class type marked
with the class-virt-speciﬁer
final (Clause 9). [ Note:
A union is a class type
that can be marked with
final. — end note ]

Preconditions

remove_all_extents_-
t<T> shall be a complete
type or (possibly
cv-qualiﬁed) void.
remove_all_extents_-
t<T> shall be a complete
type or (possibly
cv-qualiﬁed) void.
remove_all_extents_-
t<T> shall be a complete
type or (possibly
cv-qualiﬁed) void.
remove_all_extents_-
t<T> shall be a complete
type or (possibly
cv-qualiﬁed) void.
remove_all_extents_-
t<T> shall be a complete
type or (possibly
cv-qualiﬁed) void.
If T is a non-union class
type, T shall be a complete
type.

If T is a non-union class
type, T shall be a complete
type.
If T is a non-union class
type, T shall be a complete
type.
If T is a class type, T shall
be a complete type.

§ 20.10.4.3

609

c(cid:13) ISO/IEC

N4296

Table 49 — Type property predicates (continued)

Template

Condition

Preconditions

template <class T>
struct is_signed;

template <class T>
struct is_unsigned;

template <class T, class...
struct is_constructible;

Args>

template <class T>
struct is_default_constructible;

template <class T>
struct is_copy_constructible;

template <class T>
struct is_move_constructible;

If is_-
arithmetic<T>::value is
true, the same result as
integral_-
constant<bool, T(-1) <
T(0)>::value; otherwise,
false
If is_-
arithmetic<T>::value is
true, the same result as
integral_-
constant<bool, T(0) <
T(-1)>::value;
otherwise, false
see below

is_-
constructible<T>::value
is true.

For a referenceable type T,
the same result as
is_constructible<T,
const T&>::value,
otherwise false.
For a referenceable type T,
the same result as
is_constructible<T,
T&&>::value, otherwise
false.

T and all types in the
parameter pack Args shall
be complete types,
(possibly cv-qualiﬁed)
void, or arrays of
unknown bound.
T shall be a complete type,
(possibly cv-qualiﬁed)
void, or an array of
unknown bound.
T shall be a complete type,
(possibly cv-qualiﬁed)
void, or an array of
unknown bound.

T shall be a complete type,
(possibly cv-qualiﬁed)
void, or an array of
unknown bound.

§ 20.10.4.3

610

c(cid:13) ISO/IEC

N4296

Table 49 — Type property predicates (continued)

Template

template <class T, class U>
struct is_assignable;

template <class T>
struct is_copy_assignable;

template <class T>
struct is_move_assignable;

Condition

The expression
declval<T>() =
declval<U>() is
well-formed when treated
as an unevaluated operand
(Clause 5). Access
checking is performed as if
in a context unrelated to T
and U. Only the validity of
the immediate context of
the assignment expression
is considered. [ Note: The
compilation of the
expression can result in
side eﬀects such as the
instantiation of class
template specializations
and function template
specializations, the
generation of
implicitly-deﬁned
functions, and so on. Such
side eﬀects are not in the
“immediate context” and
can result in the program
being ill-formed. — end
note ]
For a referenceable type T,
the same result as
is_assignable<T&,
const T&>::value,
otherwise false.
For a referenceable type T,
the same result as
is_assignable<T&,
T&&>::value, otherwise
false.

Preconditions

T and U shall be complete
types, (possibly
cv-qualiﬁed) void, or
arrays of unknown bound.

T shall be a complete type,
(possibly cv-qualiﬁed)
void, or an array of
unknown bound.

T shall be a complete type,
(possibly cv-qualiﬁed)
void, or an array of
unknown bound.

§ 20.10.4.3

611

c(cid:13) ISO/IEC

N4296

Table 49 — Type property predicates (continued)

Template

template <class T>
struct is_destructible;

template <class T, class...
struct
is_trivially_constructible;

Args>

template <class T>
struct
is_trivially_default_constructible;

template <class T>
struct
is_trivially_copy_constructible;

template <class T>
struct
is_trivially_move_constructible;

Condition

For reference types, is_-
destructible<T>::value
is true.
For incomplete types and
function types, is_-
destructible<T>::value
is false.
For object types and given
U equal to remove_all_-
extents_t<T>, if the
expression
std::declval<U&>().~U()
is well-formed when
treated as an unevaluated
operand (Clause 5),
then is_-
destructible<T>::value
is true, otherwise it is
false.
is_constructible<T,
Args...>::value is true
and the variable deﬁnition
for is_constructible, as
deﬁned below, is known to
call no operation that is
not trivial ( 3.9, 12).
is_trivially_-
constructible<T>::value
is true.

For a referenceable type T,
the same result as
is_trivially_-
constructible<T, const
T&>::value, otherwise
false.
For a referenceable type T,
the same result as
is_trivially_-
constructible<T,
T&&>::value, otherwise
false.

Preconditions

T shall be a complete type,
(possibly cv-qualiﬁed)
void, or an array of
unknown bound.

T and all types in the
parameter pack Args shall
be complete types,
(possibly cv-qualiﬁed)
void, or arrays of
unknown bound.

T shall be a complete type,
(possibly cv-qualiﬁed)
void, or an array of
unknown bound.
T shall be a complete type,
(possibly cv-qualiﬁed)
void, or an array of
unknown bound.

T shall be a complete type,
(possibly cv-qualiﬁed)
void, or an array of
unknown bound.

§ 20.10.4.3

612

c(cid:13) ISO/IEC

N4296

Table 49 — Type property predicates (continued)

Template

template <class T, class U>
struct is_trivially_assignable;

template <class T>
struct
is_trivially_copy_assignable;

template <class T>
struct
is_trivially_move_assignable;

template <class T>
struct is_trivially_destructible;

template <class T, class...
struct is_nothrow_constructible;

Args>

template <class T>
struct
is_nothrow_default_constructible;

template <class T>
struct
is_nothrow_copy_constructible;

template <class T>
struct
is_nothrow_move_constructible;

Condition
is_assignable<T,
U>::value is true and the
assignment, as deﬁned by
is_assignable, is known
to call no operation that is
not trivial (3.9, 12).
For a referenceable type T,
the same result as
is_trivially_-
assignable<T&, const
T&>::value, otherwise
false.
For a referenceable type T,
the same result as
is_trivially_-
assignable<T&,
T&&>::value, otherwise
false.
is_-
destructible<T>::value
is true and the indicated
destructor is known to be
trivial.
is_constructible<T,
Args...>::value is true
and the variable deﬁnition
for is_constructible, as
deﬁned below, is known
not to throw any
exceptions (5.3.7).
is_nothrow_-
constructible<T>::value
is true.

For a referenceable type T,
the same result as
is_nothrow_-
constructible<T, const
T&>::value, otherwise
false.
For a referenceable type T,
the same result as
is_nothrow_-
constructible<T,
T&&>::value, otherwise
false.

Preconditions

T and U shall be complete
types, (possibly
cv-qualiﬁed) void, or
arrays of unknown bound.

T shall be a complete type,
(possibly cv-qualiﬁed)
void, or an array of
unknown bound.

T shall be a complete type,
(possibly cv-qualiﬁed)
void, or an array of
unknown bound.

T shall be a complete type,
(possibly cv-qualiﬁed)
void, or an array of
unknown bound.

T and all types in the
parameter pack Args shall
be complete types,
(possibly cv-qualiﬁed)
void, or arrays of
unknown bound.

T shall be a complete type,
(possibly cv-qualiﬁed)
void, or an array of
unknown bound.
T shall be a complete type,
(possibly cv-qualiﬁed)
void, or an array of
unknown bound.

T shall be a complete type,
(possibly cv-qualiﬁed)
void, or an array of
unknown bound.

§ 20.10.4.3

613

c(cid:13) ISO/IEC

N4296

Table 49 — Type property predicates (continued)

Template

template <class T, class U>
struct is_nothrow_assignable;

template <class T>
struct is_nothrow_copy_assignable;

template <class T>
struct is_nothrow_move_assignable;

template <class T>
struct is_nothrow_destructible;

template <class T>
struct has_virtual_destructor;

Condition
is_assignable<T,
U>::value is true and
the assignment is known
not to throw any
exceptions (5.3.7).
For a referenceable type T,
the same result as is_-
nothrow_assignable<T&,
const T&>::value,
otherwise false.
For a referenceable type T,
the same result as is_-
nothrow_assignable<T&,
T&&>::value, otherwise
false.
is_-
destructible<T>::value
is true and the indicated
destructor is known not to
throw any
exceptions (5.3.7).
T has a virtual
destructor (12.4)

Preconditions

T and U shall be complete
types, (possibly
cv-qualiﬁed) void, or
arrays of unknown bound.

T shall be a complete type,
(possibly cv-qualiﬁed)
void, or an array of
unknown bound.

T shall be a complete type,
(possibly cv-qualiﬁed)
void, or an array of
unknown bound.

T shall be a complete type,
(possibly cv-qualiﬁed)
void, or an array of
unknown bound.

If T is a non-union class
type, T shall be a complete
type.

4

[ Example:

is_const<const volatile int>::value
is_const<const int*>::value
is_const<const int&>::value
is_const<int[3]>::value
is_const<const int[3]>::value

// true
// false
// false
// false
// true

5

6

— end example ]
[ Example:

remove_const_t<const volatile int> // volatile int
remove_const_t<const int* const>
remove_const_t<const int&>
remove_const_t<const int[3]>

// const int*
// const int&
// int[3]

— end example ]
[ Example:
// Given:
struct P final { };
union U1 { };
union U2 final { };

§ 20.10.4.3

614

c(cid:13) ISO/IEC

N4296

// the following assertions hold:
static_assert(!is_final<int>::value, "Error!");
static_assert( is_final<P>::value, "Error!");
static_assert(!is_final<U1>::value, "Error!");
static_assert( is_final<U2>::value, "Error!");

— end example ]

7 Given the following function declaration:

template <class T>

add_rvalue_reference_t<T> create() noexcept;

the predicate condition for a template specialization is_constructible<T, Args...> shall be satisﬁed if
and only if the following variable deﬁnition would be well-formed for some invented variable t:

T t(create<Args>()...);

[ Note: These tokens are never interpreted as a function declaration. — end note ] Access checking is
performed as if in a context unrelated to T and any of the Args. Only the validity of the immediate context
of the variable initialization is considered.
[ Note: The evaluation of the initialization can result in side
eﬀects such as the instantiation of class template specializations and function template specializations, the
generation of implicitly-deﬁned functions, and so on. Such side eﬀects are not in the “immediate context”
and can result in the program being ill-formed. — end note ]
20.10.5 Type property queries

[meta.unary.prop.query]

1 This sub-clause contains templates that may be used to query properties of types at compile time.

Template
template <class T>
struct alignment_of;
template <class T>
struct rank;
template <class T,
unsigned I = 0>
struct extent;

Table 50 — Type property queries

Value

alignof(T).
Requires:alignof(T) shall be a valid expression (5.3.6)
If T names an array type, an integer value representing the number of
dimensions of T; otherwise, 0.
If T is not an array type, or if it has rank less than or equal to I, or if I
is 0 and T has type “array of unknown bound of U”, then 0; otherwise,
the bound (8.3.4) of the I’th dimension of T, where indexing of I is
zero-based

2 Each of these templates shall be a UnaryTypeTrait (20.10.1) with a BaseCharacteristic of integral_-

constant<size_t, Value>.
[ Example:

3

4

// the following assertions hold:
assert(rank<int>::value == 0);
assert(rank<int[2]>::value == 1);
assert(rank<int[][4]>::value == 2);

— end example ]
[ Example:

// the following assertions hold:
assert(extent<int>::value == 0);

§ 20.10.5

615

c(cid:13) ISO/IEC

N4296

assert(extent<int[2]>::value == 2);
assert(extent<int[2][4]>::value == 2);
assert(extent<int[][4]>::value == 0);
assert((extent<int, 1>::value) == 0);
assert((extent<int[2], 1>::value) == 0);
assert((extent<int[2][4], 1>::value) == 4);
assert((extent<int[][4], 1>::value) == 4);

— end example ]
20.10.6 Relationships between types

[meta.rel]
1 This sub-clause contains templates that may be used to query relationships between types at compile time.
2 Each of these templates shall be a BinaryTypeTrait (20.10.1) with a BaseCharacteristic of true_type if the

corresponding condition is true, otherwise false_type.

Table 51 — Type relationship predicates

Template

template <class T, class U>
struct is_same;

template <class Base, class
Derived>
struct is_base_of;

template <class From, class To>
struct is_convertible;

3

[ Example:

struct B {};
struct B1 : B {};
struct B2 : B {};
struct D : private B1, private B2 {};

is_base_of<B, D>::value
is_base_of<const B, D>::value
is_base_of<B, const D>::value
is_base_of<B, const B>::value
is_base_of<D, B>::value
is_base_of<B&, D&>::value
is_base_of<B[3], D[3]>::value
is_base_of<int, int>::value

// true
// true
// true
// true
// false
// false
// false
// false

— end example ]

§ 20.10.6

Condition

T and U name the same
type with the same
cv-qualiﬁcations
Base is a base class of
Derived (Clause 10)
without regard to
cv-qualiﬁers or Base
and Derived are not
unions and name the
same class type
without regard to
cv-qualiﬁers
see below

Comments

If Base and Derived are
non-union class types and are
diﬀerent types (ignoring possible
cv-qualiﬁers) then Derived shall
be a complete type. [ Note: Base
classes that are private,
protected, or ambiguous are,
nonetheless, base classes. — end
note ]
From and To shall be complete
types, arrays of unknown bound,
or (possibly cv-qualiﬁed) void
types.

616

c(cid:13) ISO/IEC

N4296

4 Given the following function declaration:

template <class T>

add_rvalue_reference_t<T> create() noexcept;

the predicate condition for a template specialization is_convertible<From, To> shall be satisﬁed if and
only if the return expression in the following code would be well-formed, including any implicit conversions
to the return type of the function:

To test() {

return create<From>();

}

[ Note: This requirement gives well deﬁned results for reference types, void types, array types, and function
types. — end note ] Access checking is performed as if in a context unrelated to To and From. Only the validity
of the immediate context of the expression of the return-statement (including conversions to the return type)
is considered.
[ Note: The evaluation of the conversion can result in side eﬀects such as the instantiation
of class template specializations and function template specializations, the generation of implicitly-deﬁned
functions, and so on. Such side eﬀects are not in the “immediate context” and can result in the program
being ill-formed. — end note ]
20.10.7 Transformations between types

[meta.trans]
1 This sub-clause contains templates that may be used to transform one type to another following some

predeﬁned rule.

2 Each of the templates in this subclause shall be a TransformationTrait (20.10.1).

20.10.7.1 Const-volatile modiﬁcations

[meta.trans.cv]

Template
template <class T>
struct remove_const;

template <class T>
struct remove_volatile;

template <class T>
struct remove_cv;

template <class T>
struct add_const;
template <class T>
struct add_volatile;
template <class T>
struct add_cv;

§ 20.10.7.1

Table 52 — Const-volatile modiﬁcations

Comments

The member typedef type shall name the same type as T except that
any top-level const-qualiﬁer has been removed.
[ Example:remove_const_t<const volatile int> evaluates to
volatile int, whereas remove_const_t<const int*> evaluates to
const int*. — end example ]
The member typedef type shall name the same type as T except that
any top-level volatile-qualiﬁer has been removed.
[ Example:remove_volatile_t<const volatile int> evaluates to
const int, whereas remove_volatile_t<volatile int*> evaluates to
volatile int*. — end example ]
The member typedef type shall be the same as T except that any
top-level cv-qualiﬁer has been removed. [ Example:remove_cv_t<const
volatile int> evaluates to int, whereas remove_cv_t<const
volatile int*> evaluates to const volatile int*. — end example ]
If T is a reference, function, or top-level const-qualiﬁed type, then type
shall name the same type as T, otherwise T const.
If T is a reference, function, or top-level volatile-qualiﬁed type, then
type shall name the same type as T, otherwise T volatile.
The member typedef type shall name the same type as
add_const_t<add_volatile_t<T>>.

617

c(cid:13) ISO/IEC

20.10.7.2 Reference modiﬁcations

N4296

[meta.trans.ref]

Template
template <class T>
struct remove_reference;
template <class T>
struct
add_lvalue_reference;
template <class T>
struct
add_rvalue_reference;

Table 53 — Reference modiﬁcations

Comments

If T has type “reference to T1” then the member typedef type shall
name T1; otherwise, type shall name T.
If T names an object or function type then the member typedef type
shall name T&; otherwise, if T names a type “rvalue reference to T1” then
the member typedef type shall name T1&; otherwise, type shall name T.
If T names an object or function type then the member typedef type
shall name T&&; otherwise, type shall name T. [ Note: This rule reﬂects
the semantics of reference collapsing (8.3.2). For example, when a type T
names a type T1&, the type add_rvalue_reference_t<T> is not an
rvalue reference. — end note ]

20.10.7.3 Sign modiﬁcations

[meta.trans.sign]

Template
template <class T>
struct make_signed;

template <class T>
struct make_unsigned;

Table 54 — Sign modiﬁcations

Comments

If T names a (possibly cv-qualiﬁed) signed integer type (3.9.1) then the
member typedef type shall name the type T; otherwise, if T names a
(possibly cv-qualiﬁed) unsigned integer type then type shall name the
corresponding signed integer type, with the same cv-qualiﬁers as T;
otherwise, type shall name the signed integer type with smallest
rank (4.13) for which sizeof(T) == sizeof(type), with the same
cv-qualiﬁers as T.
Requires:T shall be a (possibly cv-qualiﬁed) integral type or enumeration
but not a bool type.
If T names a (possibly cv-qualiﬁed) unsigned integer type (3.9.1) then
the member typedef type shall name the type T; otherwise, if T names a
(possibly cv-qualiﬁed) signed integer type then type shall name the
corresponding unsigned integer type, with the same cv-qualiﬁers as T;
otherwise, type shall name the unsigned integer type with smallest
rank (4.13) for which sizeof(T) == sizeof(type), with the same
cv-qualiﬁers as T.
Requires:T shall be a (possibly cv-qualiﬁed) integral type or enumeration
but not a bool type.

§ 20.10.7.3

618

c(cid:13) ISO/IEC

20.10.7.4 Array modiﬁcations

N4296

[meta.trans.arr]

Template
template <class T>
struct remove_extent;

template <class T>
struct remove_all_extents;

Table 55 — Array modiﬁcations

Comments

If T names a type “array of U”, the member typedef type shall be U,
otherwise T. [ Note: For multidimensional arrays, only the ﬁrst array
dimension is removed. For a type “array of const U”, the resulting type
is const U. — end note ]
If T is “multi-dimensional array of U”, the resulting member typedef
type is U, otherwise T.

1

[Example

// the following assertions hold:
assert((is_same<remove_extent_t<int>, int>::value));
assert((is_same<remove_extent_t<int[2]>, int>::value));
assert((is_same<remove_extent_t<int[2][3]>, int[3]>::value));
assert((is_same<remove_extent_t<int[][3]>, int[3]>::value));

— end example ]
[Example

2

// the following assertions hold:
assert((is_same<remove_all_extents_t<int>, int>::value));
assert((is_same<remove_all_extents_t<int[2]>, int>::value));
assert((is_same<remove_all_extents_t<int[2][3]>, int>::value));
assert((is_same<remove_all_extents_t<int[][3]>, int>::value));

— end example ]
20.10.7.5 Pointer modiﬁcations

[meta.trans.ptr]

Template
template <class T>
struct remove_pointer;
template <class T>
struct add_pointer;

Table 56 — Pointer modiﬁcations

Comments

If T has type “(possibly cv-qualiﬁed) pointer to T1” then the member
typedef type shall name T1; otherwise, it shall name T.
The member typedef type shall name the same type as
remove_reference_t<T>*.

§ 20.10.7.5

619

c(cid:13) ISO/IEC

20.10.7.6 Other transformations

N4296

[meta.trans.other]

Table 57 — Other transformations

Template

template <std::size_t Len,
std::size_t Align
= default-alignment >
struct aligned_storage;

Condition

Len shall not be zero. Align
shall be equal to
alignof(T) for some type T
or to default-alignment.

template <std::size_t Len,
class... Types>
struct aligned_union;

At least one type is
provided.

template <class T> struct
decay;

template <bool B, class T =
void> struct enable_if;

template <bool B, class T,
class F> struct conditional;

Comments

The value of default-alignment shall
be the most stringent alignment
requirement for any C++ object type
whose size is no greater than
Len (3.9). The member typedef type
shall be a POD type suitable for use
as uninitialized storage for any object
whose size is at most Len and whose
alignment is a divisor of Align.
The member typedef type shall be a
POD type suitable for use as
uninitialized storage for any object
whose type is listed in Types; its size
shall be at least Len. The static
member alignment_value shall be an
integral constant of type std::size_t
whose value is the strictest alignment
of all types listed in Types.
Let U be remove_reference_t<T>. If
is_array<U>::value is true, the
member typedef type shall equal
remove_extent_t<U>*. If
is_function<U>::value is true, the
member typedef type shall equal
add_pointer_t<U>. Otherwise the
member typedef type equals
remove_cv_t<U>. [ Note: This
behavior is similar to the
lvalue-to-rvalue (4.1),
array-to-pointer (4.2), and
function-to-pointer (4.3) conversions
applied when an lvalue expression is
used as an rvalue, but also strips
cv-qualiﬁers from class types in order
to more closely model by-value
argument passing. — end note ]
If B is true, the member typedef type
shall equal T; otherwise, there shall be
no member type.
If B is true, the member typedef type
shall equal T. If B is false, the
member typedef type shall equal F.

§ 20.10.7.6

620

c(cid:13) ISO/IEC

N4296

Table 57 — Other transformations (continued)

Condition

Comments

Template
template <class...
struct common_type;

T>

The member typedef type shall be
deﬁned or omitted as speciﬁed below.
If it is omitted, there shall be no
member type. All types in the
parameter pack T shall be complete or
(possibly cv) void. A program may
specialize this trait if at least one
template parameter in the
specialization is a user-deﬁned type.
[ Note: Such specializations are needed
when only explicit conversions are
desired among the template
arguments. — end note ]
The member typedef type shall name
the underlying type of T.
If the expression
INVOKE (declval<Fn>(),
declval<ArgTypes>()...) is well
formed when treated as an
unevaluated operand (Clause 5), the
member typedef type shall name the
type
decltype(INVOKE (declval<Fn>(),
declval<ArgTypes>()...));
otherwise, there shall be no member
type. Access checking is performed as
if in a context unrelated to Fn and
ArgTypes. Only the validity of the
immediate context of the expression is
considered. [ Note: The compilation of
the expression can result in side
eﬀects such as the instantiation of
class template specializations and
function template specializations, the
generation of implicitly-deﬁned
functions, and so on. Such side eﬀects
are not in the “immediate context”
and can result in the program being
ill-formed. — end note ]

template <class T>
struct underlying_type;
template <class Fn,
class... ArgTypes> struct
result_of<Fn(ArgTypes...)>;

T shall be a complete
enumeration type (7.2)
Fn and all types in the
parameter pack ArgTypes
shall be complete types,
(possibly cv-qualiﬁed) void,
or arrays of unknown bound.

1

[ Note: A typical implementation would deﬁne aligned_storage as:

template <std::size_t Len, std::size_t Alignment>
struct aligned_storage {

typedef struct {

alignas(Alignment) unsigned char __data[Len];

} type;

};

§ 20.10.7.6

621

c(cid:13) ISO/IEC

N4296

— end note ]
It is implementation-deﬁned whether any extended alignment is supported (3.11).

2
3 For the common_type trait applied to a parameter pack T of types, the member type shall be either deﬁned

or not present as follows:

(3.1)

(3.2)

(3.3)

—
—

—

If sizeof...(T) is zero, there shall be no member type.
If sizeof...(T) is one, let T0 denote the sole type in the pack T. The member typedef type shall
denote the same type as decay_t<T0>.
If sizeof...(T) is greater than one, let T1, T2, and R, respectively, denote the ﬁrst, second, and (pack
of) remaining types comprising T. [ Note: sizeof...(R) may be zero. — end note ] Let C denote the
type, if any, of an unevaluated conditional expression (5.16) whose ﬁrst operand is an arbitrary value
of type bool, whose second operand is an xvalue of type T1, and whose third operand is an xvalue of
type T2. If there is such a type C, the member typedef type shall denote the same type, if any, as
common_type_t<C,R...>. Otherwise, there shall be no member type.

4

[ Example: Given these deﬁnitions:

typedef bool (&PF1)();
typedef short (*PF2)(long);

struct S {

operator PF2() const;
double operator()(char, int&);
void fn(long) const;
char data;

};

typedef void (S::*PMF)(long) const;
typedef char S::*PMD;

the following assertions will hold:

static_assert(is_same<result_of_t<S(int)>, short>::value, "Error!");
static_assert(is_same<result_of_t<S&(unsigned char, int&)>, double>::value, "Error!");
static_assert(is_same<result_of_t<PF1()>, bool>::value, "Error!");
static_assert(is_same<result_of_t<PMF(unique_ptr<S>, int)>, void>::value, "Error!");
static_assert(is_same<result_of_t<PMD(S)>, char&&>::value, "Error!");
static_assert(is_same<result_of_t<PMD(const S*)>, const char&>::value, "Error!");

— end example ]
20.11 Compile-time rational arithmetic
20.11.1 In general

[ratio]
[ratio.general]
1 This subclause describes the ratio library. It provides a class template ratio which exactly represents any
ﬁnite rational number with a numerator and denominator representable by compile-time constants of type
intmax_t.

2 Throughout this subclause, the names of template parameters are used to express type requirements. If
a template parameter is named R1 or R2, and the template argument is not a specialization of the ratio
template, the program is ill-formed.

§ 20.11.1

622

N4296

[ratio.syn]

c(cid:13) ISO/IEC

20.11.2 Header <ratio> synopsis

namespace std {

// 20.11.3, class template ratio
template <intmax_t N, intmax_t D = 1> class ratio;

// 20.11.4, ratio arithmetic
template <class R1, class R2> using ratio_add = see below ;
template <class R1, class R2> using ratio_subtract = see below ;
template <class R1, class R2> using ratio_multiply = see below ;
template <class R1, class R2> using ratio_divide = see below ;

// 20.11.5, ratio comparison
template <class R1, class R2> struct ratio_equal;
template <class R1, class R2> struct ratio_not_equal;
template <class R1, class R2> struct ratio_less;
template <class R1, class R2> struct ratio_less_equal;
template <class R1, class R2> struct ratio_greater;
template <class R1, class R2> struct ratio_greater_equal;

// 20.11.6, convenience SI typedefs
typedef ratio<1, 1’000’000’000’000’000’000’000’000> yocto; // see below
1’000’000’000’000’000’000’000> zepto; // see below
typedef ratio<1,
typedef ratio<1,
typedef ratio<1,
typedef ratio<1,
typedef ratio<1,
typedef ratio<1,
typedef ratio<1,
typedef ratio<1,
typedef ratio<1,
typedef ratio<
typedef ratio<
typedef ratio<
typedef ratio<
typedef ratio<
typedef ratio<
typedef ratio<
typedef ratio<
1’000’000’000’000’000’000’000, 1> zetta; // see below
typedef ratio<
typedef ratio<1’000’000’000’000’000’000’000’000, 1> yotta; // see below

1’000’000’000’000’000’000> atto;
1’000’000’000’000’000> femto;
1’000’000’000’000> pico;
1’000’000’000> nano;
1’000’000> micro;
1’000> milli;
100> centi;
10> deci;
10, 1> deca;
100, 1> hecto;
1’000, 1> kilo;
1’000’000, 1> mega;
1’000’000’000, 1> giga;
1’000’000’000’000, 1> tera;
1’000’000’000’000’000, 1> peta;
1’000’000’000’000’000’000, 1> exa;

}

20.11.3 Class template ratio

[ratio.ratio]

namespace std {

template <intmax_t N, intmax_t D = 1>
class ratio {
public:

static constexpr intmax_t num;
static constexpr intmax_t den;
typedef ratio<num, den> type;

};

}

1

If the template argument D is zero or the absolute values of either of the template arguments N and D is not
representable by type intmax_t, the program is ill-formed.
[ Note: These rules ensure that inﬁnite ratios

§ 20.11.3

623

c(cid:13) ISO/IEC

N4296

are avoided and that for any negative input, there exists a representable value of its absolute value which is
positive. In a two’s complement representation, this excludes the most negative value. — end note ]

2 The static data members num and den shall have the following values, where gcd represents the greatest

common divisor of the absolute values of N and D:

(2.1)

(2.2)

—
—

num shall have the value sign(N) * sign(D) * abs(N) / gcd.
den shall have the value abs(D) / gcd.

20.11.4 Arithmetic on ratios

[ratio.arithmetic]
1 Each of the alias templates ratio_add, ratio_subtract, ratio_multiply, and ratio_divide denotes the
result of an arithmetic computation on two ratios R1 and R2. With X and Y computed (in the absence of
arithmetic overﬂow) as speciﬁed by Table 58, each alias denotes a ratio<U, V> such that U is the same as
ratio<X, Y>::num and V is the same as ratio<X, Y>::den.
If it is not possible to represent U or V with intmax_t, the program is ill-formed. Otherwise, an implemen-
tation should yield correct values of U and V. If it is not possible to represent X or Y with intmax_t, the
program is ill-formed unless the implementation yields correct values of U and V.

2

Table 58 — Expressions used to perform ratio arithmetic
Type

Value of X

Value of Y

ratio_add<R1, R2>

ratio_subtract<R1, R2>

ratio_multiply<R1, R2>
ratio_divide<R1, R2>

R1::num * R2::den +
R2::num * R1::den
R1::num * R2::den -
R2::num * R1::den
R1::num * R2::num
R1::num * R2::den

R1::den * R2::den

R1::den * R2::den

R1::den * R2::den
R1::den * R2::num

3

[ Example:

static_assert(ratio_add<ratio<1,3>, ratio<1,6>>::num == 1, "1/3+1/6 == 1/2");
static_assert(ratio_add<ratio<1,3>, ratio<1,6>>::den == 2, "1/3+1/6 == 1/2");
static_assert(ratio_multiply<ratio<1,3>, ratio<3,2>>::num == 1, "1/3*3/2 == 1/2");
static_assert(ratio_multiply<ratio<1,3>, ratio<3,2>>::den == 2, "1/3*3/2 == 1/2");

// The following cases may cause the program to be ill-formed under some implementations

static_assert(ratio_add<ratio<1,INT_MAX>, ratio<1,INT_MAX>>::num == 2,

static_assert(ratio_add<ratio<1,INT_MAX>, ratio<1,INT_MAX>>::den == INT_MAX,

"1/MAX+1/MAX == 2/MAX");

"1/MAX+1/MAX == 2/MAX");

"1/MAX * MAX/2 == 1/2");

"1/MAX * MAX/2 == 1/2");

static_assert(ratio_multiply<ratio<1,INT_MAX>, ratio<INT_MAX,2>>::num == 1,

static_assert(ratio_multiply<ratio<1,INT_MAX>, ratio<INT_MAX,2>>::den == 2,

— end example ]
20.11.5 Comparison of ratios
template <class R1, class R2> struct ratio_equal

: integral_constant<bool, see below > { };

[ratio.comparison]

1

If R1::num == R2::num and R1::den == R2::den, ratio_equal<R1, R2> shall be derived from
integral_constant<bool, true>; otherwise it shall be derived from integral_constant<bool,
false>.

§ 20.11.5

624

c(cid:13) ISO/IEC

N4296

template <class R1, class R2> struct ratio_not_equal

: integral_constant<bool, !ratio_equal<R1, R2>::value> { };

template <class R1, class R2> struct ratio_less

: integral_constant<bool, see below > { };

2

If R1::num * R2::den < R2::num * R1::den, ratio_less<R1, R2> shall be derived from integral_-
constant<bool, true>; otherwise it shall be derived from integral_constant<bool, false>. Im-
plementations may use other algorithms to compute this relationship to avoid overﬂow. If overﬂow
occurs, the program is ill-formed.

template <class R1, class R2> struct ratio_less_equal

: integral_constant<bool, !ratio_less<R2, R1>::value> { };

template <class R1, class R2> struct ratio_greater

: integral_constant<bool, ratio_less<R2, R1>::value> { };

template <class R1, class R2> struct ratio_greater_equal

: integral_constant<bool, !ratio_less<R1, R2>::value> { };

20.11.6 SI types for ratio

[ratio.si]
1 For each of the typedefs yocto, zepto, zetta, and yotta, if both of the constants used in its speciﬁcation
are representable by intmax_t, the typedef shall be deﬁned; if either of the constants is not representable
by intmax_t, the typedef shall not be deﬁned.
20.12 Time utilities
20.12.1 In general

[time]
[time.general]
1 This subclause describes the chrono library (20.12.2) and various C functions (20.12.8) that provide generally

useful time utilities.
20.12.2 Header <chrono> synopsis

[time.syn]

namespace std {
namespace chrono {

// 20.12.5, class template duration
template <class Rep, class Period = ratio<1> > class duration;

// 20.12.6, class template time_point
template <class Clock, class Duration = typename Clock::duration> class time_point;

} // namespace chrono

// 20.12.4.3 common_type specializations
template <class Rep1, class Period1, class Rep2, class Period2>

struct common_type<chrono::duration<Rep1, Period1>, chrono::duration<Rep2, Period2>>;

template <class Clock, class Duration1, class Duration2>

struct common_type<chrono::time_point<Clock, Duration1>, chrono::time_point<Clock, Duration2>>;

namespace chrono {

// 20.12.4, customization traits
template <class Rep> struct treat_as_floating_point;
template <class Rep> struct duration_values;

§ 20.12.2

625

c(cid:13) ISO/IEC

N4296

// 20.12.5.5, duration arithmetic
template <class Rep1, class Period1, class Rep2, class Period2>

common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
constexpr operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

template <class Rep1, class Period1, class Rep2, class Period2>

common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
constexpr operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

template <class Rep1, class Period, class Rep2>

duration<common_type_t<Rep1, Rep2>, Period>
constexpr operator*(const duration<Rep1, Period>& d, const Rep2& s);

template <class Rep1, class Rep2, class Period>

duration<common_type_t<Rep1, Rep2>, Period>
constexpr operator*(const Rep1& s, const duration<Rep2, Period>& d);

template <class Rep1, class Period, class Rep2>

duration<common_type_t<Rep1, Rep2>, Period>
constexpr operator/(const duration<Rep1, Period>& d, const Rep2& s);

template <class Rep1, class Period1, class Rep2, class Period2>

common_type_t<Rep1, Rep2>
constexpr operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

template <class Rep1, class Period, class Rep2>

duration<common_type_t<Rep1, Rep2>, Period>
constexpr operator%(const duration<Rep1, Period>& d, const Rep2& s);

template <class Rep1, class Period1, class Rep2, class Period2>

common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
constexpr operator%(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

// 20.12.5.6, duration comparisons
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator==(const duration<Rep1, Period1>& lhs,
const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator!=(const duration<Rep1, Period1>& lhs,
const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator< (const duration<Rep1, Period1>& lhs,
const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator<=(const duration<Rep1, Period1>& lhs,
const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator> (const duration<Rep1, Period1>& lhs,
const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator>=(const duration<Rep1, Period1>& lhs,
const duration<Rep2, Period2>& rhs);

// 20.12.5.7, duration_cast
template <class ToDuration, class Rep, class Period>

constexpr ToDuration duration_cast(const duration<Rep, Period>& d);

// convenience typedefs
typedef duration<signed integer type of at least 64 bits,
typedef duration<signed integer type of at least 55 bits,
typedef duration<signed integer type of at least 45 bits,

nano> nanoseconds;
micro> microseconds;
milli> milliseconds;

§ 20.12.2

626

c(cid:13) ISO/IEC

N4296

typedef duration<signed integer type of at least 35 bits
typedef duration<signed integer type of at least 29 bits, ratio<
typedef duration<signed integer type of at least 23 bits, ratio<3600>> hours;

> seconds;
60>> minutes;

// 20.12.6.5, time_point arithmetic
template <class Clock, class Duration1, class Rep2, class Period2>

constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>
operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);

template <class Rep1, class Period1, class Clock, class Duration2>

constexpr time_point<Clock, common_type_t<duration<Rep1, Period1>, Duration2>>
operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);

template <class Clock, class Duration1, class Rep2, class Period2>

constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>
operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);

template <class Clock, class Duration1, class Duration2>

constexpr common_type_t<Duration1, Duration2>
operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

// 20.12.6.6 time_point comparisons
template <class Clock, class Duration1, class Duration2>

constexpr bool operator==(const time_point<Clock, Duration1>& lhs,
const time_point<Clock, Duration2>& rhs);

template <class Clock, class Duration1, class Duration2>

constexpr bool operator!=(const time_point<Clock, Duration1>& lhs,
const time_point<Clock, Duration2>& rhs);

template <class Clock, class Duration1, class Duration2>

constexpr bool operator< (const time_point<Clock, Duration1>& lhs,
const time_point<Clock, Duration2>& rhs);

template <class Clock, class Duration1, class Duration2>

constexpr bool operator<=(const time_point<Clock, Duration1>& lhs,
const time_point<Clock, Duration2>& rhs);

template <class Clock, class Duration1, class Duration2>

constexpr bool operator> (const time_point<Clock, Duration1>& lhs,
const time_point<Clock, Duration2>& rhs);

template <class Clock, class Duration1, class Duration2>

constexpr bool operator>=(const time_point<Clock, Duration1>& lhs,
const time_point<Clock, Duration2>& rhs);

// 20.12.6.7, time_point_cast
template <class ToDuration, class Clock, class Duration>

constexpr time_point<Clock, ToDuration>
time_point_cast(const time_point<Clock, Duration>& t);

// 20.12.7, clocks
class system_clock;
class steady_clock;
class high_resolution_clock;

} // namespace chrono

inline namespace literals {
inline namespace chrono_literals {

// 20.12.5.8, suﬃxes for duration literals
constexpr chrono::hours

operator "" h(unsigned long long);

§ 20.12.2

627

c(cid:13) ISO/IEC

N4296

constexpr chrono::duration<unspecified , ratio<3600,1>> operator "" h(long double);
constexpr chrono::minutes
constexpr chrono::duration<unspecified , ratio<60,1>>
constexpr chrono::seconds
constexpr chrono::duration<unspecified >
constexpr chrono::milliseconds
constexpr chrono::duration<unspecified , milli>
constexpr chrono::microseconds
constexpr chrono::duration<unspecified , micro>
constexpr chrono::nanoseconds
constexpr chrono::duration<unspecified , nano>

operator "" min(unsigned long long);
operator "" min(long double);
operator "" s(unsigned long long);
operator "" s(long double);
operator "" ms(unsigned long long);
operator "" ms(long double);
operator "" us(unsigned long long);
operator "" us(long double);
operator "" ns(unsigned long long);
operator "" ns(long double);

} // namespace chrono_literals
} // namespace literals

namespace chrono {

using namespace literals::chrono_literals;

} // namespace chrono

} // namespace std

20.12.3 Clock requirements

[time.clock.req]
1 A clock is a bundle consisting of a duration, a time_point, and a function now() to get the current time_-
point. The origin of the clock’s time_point is referred to as the clock’s epoch. A clock shall meet the
requirements in Table 59.
In Table 59 C1 and C2 denote clock types. t1 and t2 are values returned by C1::now() where the call
returning t1 happens before (1.10) the call returning t2 and both of these calls occur before C1::time_-
point::max(). [ Note: this means C1 did not wrap around between t1 and t2. — end note ]

2

Expression

C1::rep

C1::period

C1::duration

C1::time_point

C1::is_steady

Table 59 — Clock requirements

Return type

An arithmetic type or a class
emulating an arithmetic type
a specialization of ratio

chrono::duration<C1::rep,
C1::period>
chrono::time_point<C1> or
chrono::time_point<C2,
C1::duration>
const bool

C1::now()

C1::time_point

Operational semantics

The representation type of
C1::duration.
The tick period of the clock in
seconds.
The duration type of the
clock.
The time_point type of the
clock. C1 and C2 shall refer to
the same epoch.
true if t1 <= t2 is always
true and the time between
clock ticks is constant,
otherwise false.
Returns a time_point object
representing the current point
in time.

§ 20.12.3

628

c(cid:13) ISO/IEC

N4296

3

[ Note: The relative diﬀerence in durations between those reported by a given clock and the SI deﬁnition is
a measure of the quality of implementation. — end note ]

—
—

4 A type TC meets the TrivialClock requirements if:
TC satisﬁes the Clock requirements (20.12.3),
the types TC::rep, TC::duration, and TC::time_point satisfy the requirements of EqualityCom-
parable (Table 17), LessThanComparable (Table 18), DefaultConstructible (Table 19), CopyCon-
structible (Table 21), CopyAssignable (Table 23), Destructible (Table 24), and the requirements
of numeric types (26.2). [ Note: this means, in particular, that operations on these types will not throw
exceptions. — end note ]
lvalues of the types TC::rep, TC::duration, and TC::time_point are swappable (17.6.3.2),
the function TC::now() does not throw exceptions, and
the type TC::time_point::clock meets the TrivialClock requirements, recursively.

—
—
—

(4.1)

(4.2)

(4.3)

(4.4)

(4.5)

20.12.4 Time-related traits
20.12.4.1 treat_as_floating_point
template <class Rep> struct treat_as_floating_point

: is_floating_point<Rep> { };

[time.traits]
[time.traits.is_fp]

1 The duration template uses the treat_as_floating_point trait to help determine if a duration object can
be converted to another duration with a diﬀerent tick period. If treat_as_floating_point<Rep>::value
is true, then implicit conversions are allowed among durations. Otherwise, the implicit convertibility
depends on the tick periods of the durations. [ Note: The intention of this trait is to indicate whether a
given class behaves like a ﬂoating-point type, and thus allows division of one value by another with acceptable
loss of precision. If treat_as_floating_point<Rep>::value is false, Rep will be treated as if it behaved
like an integral type for the purpose of these conversions. — end note ]
20.12.4.2 duration_values
template <class Rep>
struct duration_values {
public:

[time.traits.duration_values]

static constexpr Rep zero();
static constexpr Rep min();
static constexpr Rep max();

};

1 The duration template uses the duration_values trait to construct special values of the durations repre-
sentation (Rep). This is done because the representation might be a class type with behavior which requires
some other implementation to return these special values. In that case, the author of that class type should
specialize duration_values to return the indicated values.

static constexpr Rep zero();

Returns: Rep(0).
meaning, such as an uninitialized value. — end note ]
Remark: The value returned shall be the additive identity.

[ Note: Rep(0) is speciﬁed instead of Rep() because Rep() may have some other

static constexpr Rep min();

Returns: numeric_limits<Rep>::lowest().
Remark: The value returned shall compare less than or equal to zero().

2

3

4

5

§ 20.12.4.2

629

c(cid:13) ISO/IEC

N4296

static constexpr Rep max();

6

7

Returns: numeric_limits<Rep>::max().
Remark: The value returned shall compare greater than zero().

20.12.4.3 Specializations of common_type
template <class Rep1, class Period1, class Rep2, class Period2>
struct common_type<chrono::duration<Rep1, Period1>, chrono::duration<Rep2, Period2>> {

typedef chrono::duration<common_type_t<Rep1, Rep2>, see below > type;

[time.traits.specializations]

};

1 The period of the duration indicated by this specialization of common_type shall be the greatest com-
mon divisor of Period1 and Period2.
[ Note: This can be computed by forming a ratio of the greatest
common divisor of Period1::num and Period2::num and the least common multiple of Period1::den and
Period2::den. — end note ]
[ Note: The typedef name type is a synonym for the duration with the largest tick period possible where
both duration arguments will convert to it without requiring a division operation. The representation of
this type is intended to be able to hold any value resulting from this conversion with no truncation error,
although ﬂoating-point durations may have round-oﬀ errors. — end note ]

2

template <class Clock, class Duration1, class Duration2>
struct common_type<chrono::time_point<Clock, Duration1>, chrono::time_point<Clock, Duration2>> {

typedef chrono::time_point<Clock, common_type_t<Duration1, Duration2>> type;

};

3 The common type of two time_point types is a time_point with the same clock as the two types and the

common type of their two durations.
20.12.5 Class template duration

[time.duration]
1 A duration type measures time between two points in time (time_points). A duration has a representation
which holds a count of ticks and a tick period. The tick period is the amount of time which occurs from one
tick to the next, in units of seconds. It is expressed as a rational constant using the template ratio.

template <class Rep, class Period = ratio<1>>
class duration {
public:

typedef Rep
typedef Period period;

rep;

rep rep_;

// exposition only

private:

public:

// 20.12.5.1, construct/copy/destroy:
constexpr duration() = default;
template <class Rep2>

constexpr explicit duration(const Rep2& r);

template <class Rep2, class Period2>

constexpr duration(const duration<Rep2, Period2>& d);

~duration() = default;
duration(const duration&) = default;
duration& operator=(const duration&) = default;

// 20.12.5.2, observer:
constexpr rep count() const;

// 20.12.5.3, arithmetic:

§ 20.12.5

630

c(cid:13) ISO/IEC

N4296

operator+() const;
operator-() const;

constexpr duration
constexpr duration
duration& operator++();
duration operator++(int);
duration& operator--();
duration operator--(int);

duration& operator+=(const duration& d);
duration& operator-=(const duration& d);

duration& operator*=(const rep& rhs);
duration& operator/=(const rep& rhs);
duration& operator%=(const rep& rhs);
duration& operator%=(const duration& rhs);

// 20.12.5.4, special values:
static constexpr duration zero();
static constexpr duration min();
static constexpr duration max();

};

2

3

4

5

6

7

If duration is instantiated with a duration type for the template argument Rep, the

Requires: Rep shall be an arithmetic type or a class emulating an arithmetic type.
Remarks:
program is ill-formed.
Remarks: If Period is not a specialization of ratio, the program is ill-formed.
Remarks: If Period::num is not positive, the program is ill-formed.
Requires: Members of duration shall not throw exceptions other than those thrown by the indicated
operations on their representations.
Remarks: The defaulted copy constructor of duration shall be a constexpr function if and only if
the required initialization of the member rep_ for copy and move, respectively, would satisfy the
requirements for a constexpr function.

[ Example:

duration<long, ratio<60>> d0;
duration<long long, milli> d1;
duration<double, ratio<1, 30>>

// holds a count of minutes using a long
// holds a count of milliseconds using a long long
30 of a second

d2; // holds a count with a tick period of 1

// (30 Hz) using a double

— end example ]
20.12.5.1 duration constructors
template <class Rep2>

constexpr explicit duration(const Rep2& r);

[time.duration.cons]

1

(1.1)

(1.2)

Remarks: This constructor shall not participate in overload resolution unless Rep2 is implicitly con-
vertible to rep and
—
—
[ Example:

treat_as_floating_point<rep>::value is true or
treat_as_floating_point<Rep2>::value is false.

§ 20.12.5.1

631

c(cid:13) ISO/IEC

N4296

duration<int, milli> d(3);
duration<int, milli> d(3.5);

// OK
// error

— end example ]
Eﬀects: Constructs an object of type duration.
Postcondition: count() == static_cast<rep>(r).

template <class Rep2, class Period2>

constexpr duration(const duration<Rep2, Period2>& d);

Remarks: This constructor shall not participate in overload resolution unless no overﬂow is induced in
the conversion and treat_as_floating_point<rep>::value is true or both ratio_divide<Period2,
period>::den is 1 and treat_as_floating_point<Rep2>::value is false. [ Note: This requirement
prevents implicit truncation error when converting between integral-based duration types. Such a con-
struction could easily lead to confusion about the value of the duration. — end note ] [ Example:

duration<int, milli> ms(3);
duration<int, micro> us = ms;
duration<int, milli> ms2 = us;

// OK
// error

— end example ]
Eﬀects: Constructs an object of type duration, constructing rep_ from
duration_cast<duration>(d).count().

20.12.5.2 duration observer
constexpr rep count() const;

Returns: rep_.

20.12.5.3 duration arithmetic
constexpr duration operator+() const;

Returns: *this.

constexpr duration operator-() const;

Returns: duration(-rep_);.

duration& operator++();

Eﬀects: ++rep_.
Returns: *this.

duration operator++(int);

Returns: duration(rep_++);.

duration& operator--();

Eﬀects: --rep_.
Returns: *this.

duration operator--(int);

Returns: duration(rep_--);.

§ 20.12.5.3

[time.duration.observer]

[time.duration.arithmetic]

632

2

3

4

5

1

1

2

3

4

5

6

7

8

c(cid:13) ISO/IEC

N4296

9

10

11

12

13

14

15

16

17

18

19

20

1

2

3

1

2

duration& operator+=(const duration& d);

Eﬀects: rep_ += d.count().
Returns: *this.

duration& operator-=(const duration& d);

Eﬀects: rep_ -= d.count().
Returns: *this.

duration& operator*=(const rep& rhs);

Eﬀects: rep_ *= rhs.
Returns: *this.

duration& operator/=(const rep& rhs);

Eﬀects: rep_ /= rhs.
Returns: *this.

duration& operator%=(const rep& rhs);

Eﬀects: rep_ %= rhs.
Returns: *this.

duration& operator%=(const duration& rhs);

Eﬀects: rep_ %= rhs.count().
Returns: *this.

20.12.5.4 duration special values
static constexpr duration zero();

[time.duration.special]

Returns: duration(duration_values<rep>::zero()).

static constexpr duration min();

Returns: duration(duration_values<rep>::min()).

static constexpr duration max();

Returns: duration(duration_values<rep>::max()).

20.12.5.5 duration non-member arithmetic
[time.duration.nonmember]
In the function descriptions that follow, CD represents the return type of the function. CR(A,B) represents
common_type_t<A, B>.

template <class Rep1, class Period1, class Rep2, class Period2>

constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

Returns: CD(CD(lhs).count() + CD(rhs).count()).

template <class Rep1, class Period1, class Rep2, class Period2>

constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

§ 20.12.5.5

633

3

4

5

6

7

8

9

10

11

12

13

1

2

c(cid:13) ISO/IEC

N4296

Returns: CD(CD(lhs).count() - CD(rhs).count()).

template <class Rep1, class Period, class Rep2>

constexpr duration<common_type_t<Rep1, Rep2>, Period>
operator*(const duration<Rep1, Period>& d, const Rep2& s);

Remarks: This operator shall not participate in overload resolution unless Rep2 is implicitly convertible
to CR(Rep1, Rep2).
Returns: CD(CD(d).count() * s).

template <class Rep1, class Rep2, class Period>

constexpr duration<common_type_t<Rep1, Rep2>, Period>
operator*(const Rep1& s, const duration<Rep2, Period>& d);

Remarks: This operator shall not participate in overload resolution unless Rep1 is implicitly convertible
to CR(Rep1, Rep2).
Returns: d * s.

template <class Rep1, class Period, class Rep2>

constexpr duration<common_type_t<Rep1, Rep2>, Period>
operator/(const duration<Rep1, Period>& d, const Rep2& s);

Remarks: This operator shall not participate in overload resolution unless Rep2 is implicitly convertible
to CR(Rep1, Rep2) and Rep2 is not an instantiation of duration.
Returns: CD(CD(d).count() / s).

template <class Rep1, class Period1, class Rep2, class Period2>

constexpr common_type_t<Rep1, Rep2>
operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

Returns: CD(lhs).count() / CD(rhs).count().

template <class Rep1, class Period, class Rep2>

constexpr duration<common_type_t<Rep1, Rep2>, Period>
operator%(const duration<Rep1, Period>& d, const Rep2& s);

Remarks: This operator shall not participate in overload resolution unless Rep2 is implicitly convertible
to CR(Rep1, Rep2) and Rep2 is not an instantiation of duration.
Returns: CD(CD(d).count() % s).

template <class Rep1, class Period1, class Rep2, class Period2>

constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
operator%(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

Returns: CD(CD(lhs).count() % CD(rhs).count()).

20.12.5.6 duration comparisons
[time.duration.comparisons]
In the function descriptions that follow, CT represents common_type_t<A, B>, where A and B are the types
of the two arguments to the function.

template <class Rep1, class Period1, class Rep2, class Period2>

constexpr bool operator==(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

Returns: CT(lhs).count() == CT(rhs).count().

template <class Rep1, class Period1, class Rep2, class Period2>

constexpr bool operator!=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

§ 20.12.5.6

634

c(cid:13) ISO/IEC

Returns: !(lhs == rhs).

N4296

template <class Rep1, class Period1, class Rep2, class Period2>

constexpr bool operator<(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

Returns: CT(lhs).count() < CT(rhs).count().

template <class Rep1, class Period1, class Rep2, class Period2>

constexpr bool operator<=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

Returns: !(rhs < lhs).

template <class Rep1, class Period1, class Rep2, class Period2>

constexpr bool operator>(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

Returns: rhs < lhs.

template <class Rep1, class Period1, class Rep2, class Period2>

constexpr bool operator>=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

Returns: !(lhs < rhs).

20.12.5.7 duration_cast
template <class ToDuration, class Rep, class Period>

constexpr ToDuration duration_cast(const duration<Rep, Period>& d);

[time.duration.cast]

Remarks: This function shall not participate in overload resolution unless ToDuration is an instanti-
ation of duration.
Returns: Let CF be ratio_divide<Period, typename ToDuration::period>, and CR be common_-
type< typename ToDuration::rep, Rep, intmax_t>::type.
—

If CF::num == 1 and CF::den == 1, returns

ToDuration(static_cast<typename ToDuration::rep>(d.count()))

—

—

otherwise, if CF::num != 1 and CF::den == 1, returns
ToDuration(static_cast<typename ToDuration::rep>(

static_cast<CR>(d.count()) * static_cast<CR>(CF::num)))

otherwise, if CF::num == 1 and CF::den != 1, returns
ToDuration(static_cast<typename ToDuration::rep>(

static_cast<CR>(d.count()) / static_cast<CR>(CF::den)))

3

4

5

6

7

1

2

(2.1)

(2.2)

(2.3)

(2.4)

—

otherwise, returns

ToDuration(static_cast<typename ToDuration::rep>(

static_cast<CR>(d.count()) * static_cast<CR>(CF::num) / static_cast<CR>(CF::den)))

Notes: This function does not use any implicit conversions; all conversions are done with static_cast.
It avoids multiplications and divisions when it is known at compile time that one or more arguments
is 1. Intermediate computations are carried out in the widest representation and only converted to the
destination representation at the ﬁnal step.

§ 20.12.5.7

635

c(cid:13) ISO/IEC

N4296

20.12.5.8 Suﬃxes for duration literals

[time.duration.literals]
1 This section describes literal suﬃxes for constructing duration literals. The suﬃxes h, min, s, ms, us, ns
denote duration values of the corresponding types hours, minutes, seconds, milliseconds, microseconds,
and nanoseconds respectively if they are applied to integral literals.
If any of these suﬃxes are applied to a ﬂoating point literal the result is a chrono::duration literal with
an unspeciﬁed ﬂoating point representation.
If any of these suﬃxes are applied to an integer literal and the resulting chrono::duration value cannot be
represented in the result type because of overﬂow, the program is ill-formed.
[ Example: The following code shows some duration literals.

4

2

3

using namespace std::chrono_literals;
auto constexpr aday=24h;
auto constexpr lesson=45min;
auto constexpr halfanhour=0.5h;

— end example ]

5

6

7

8

9

10

11

constexpr chrono::hours
constexpr chrono::duration<unspecified , ratio<3600,1>> operator "" h(long double hours);

operator "" h(unsigned long long hours);

Returns: A duration literal representing hours hours.

constexpr chrono::minutes
constexpr chrono::duration<unspecified , ratio<60,1>> operator "" min(long double minutes);

operator "" min(unsigned long long minutes);

Returns: A duration literal representing minutes minutes.

constexpr chrono::seconds
constexpr chrono::duration<unspecified > operator "" s(long double sec);

operator "" s(unsigned long long sec);

Returns: A duration literal representing sec seconds.
[ Note: The same suﬃx s is used for basic_string but there is no conﬂict, since duration suﬃxes
apply to numbers and string literal suﬃxes apply to character array literals. — end note ]

constexpr chrono::milliseconds
constexpr chrono::duration<unspecified , milli> operator "" ms(long double msec);

operator "" ms(unsigned long long msec);

Returns: A duration literal representing msec milliseconds.

constexpr chrono::microseconds
constexpr chrono::duration<unspecified , micro> operator "" us(long double usec);

operator "" us(unsigned long long usec);

Returns: A duration literal representing usec microseconds.

constexpr chrono::nanoseconds
constexpr chrono::duration<unspecified , nano> operator "" ns(long double nsec);

operator "" ns(unsigned long long nsec);

Returns: A duration literal representing nsec nanoseconds.

20.12.6 Class template time_point

[time.point]

template <class Clock, class Duration = typename Clock::duration>
class time_point {
public:

typedef Clock
typedef Duration
typedef typename duration::rep

clock;
duration;
rep;

§ 20.12.6

636

c(cid:13) ISO/IEC

N4296

typedef typename duration::period period;

duration d_; // exposition only

private:

public:

// 20.12.6.1, construct:
constexpr time_point();
constexpr explicit time_point(const duration& d); // same as time_point() + d
template <class Duration2>

// has value epoch

constexpr time_point(const time_point<clock, Duration2>& t);

// 20.12.6.2, observer:
constexpr duration time_since_epoch() const;

// 20.12.6.3, arithmetic:
time_point& operator+=(const duration& d);
time_point& operator-=(const duration& d);

// 20.12.6.4, special values:
static constexpr time_point min();
static constexpr time_point max();

};

1 Clock shall meet the Clock requirements (20.12.7).
2

If Duration is not an instance of duration, the program is ill-formed.
20.12.6.1 time_point constructors
constexpr time_point();

[time.point.cons]

1

2

3

4

1

1

2

Eﬀects: Constructs an object of type time_point, initializing d_ with duration::zero(). Such a
time_point object represents the epoch.

constexpr explicit time_point(const duration& d);

Eﬀects: Constructs an object of type time_point, initializing d_ with d. Such a time_point object
represents the epoch + d.

template <class Duration2>

constexpr time_point(const time_point<clock, Duration2>& t);

Remarks: This constructor shall not participate in overload resolution unless Duration2 is implicitly
convertible to duration.
Eﬀects: Constructs an object of type time_point, initializing d_ with t.time_since_epoch().

20.12.6.2 time_point observer
constexpr duration time_since_epoch() const;

Returns: d_.

20.12.6.3 time_point arithmetic
time_point& operator+=(const duration& d);

Eﬀects: d_ += d.
Returns: *this.

§ 20.12.6.3

[time.point.observer]

[time.point.arithmetic]

637

c(cid:13) ISO/IEC

N4296

time_point& operator-=(const duration& d);

Eﬀects: d_ -= d.
Returns: *this.

20.12.6.4 time_point special values
static constexpr time_point min();

Returns: time_point(duration::min()).

static constexpr time_point max();

Returns: time_point(duration::max()).

20.12.6.5 time_point non-member arithmetic
template <class Clock, class Duration1, class Rep2, class Period2>

constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>
operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
Returns: CT(lhs.time_since_epoch() + rhs), where CT is the type of the return value.

[time.point.special]

[time.point.nonmember]

template <class Rep1, class Period1, class Clock, class Duration2>

constexpr time_point<Clock, common_type_t<duration<Rep1, Period1>, Duration2>>
operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);

Returns: rhs + lhs.

template <class Clock, class Duration1, class Rep2, class Period2>

constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>
operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);

Returns: lhs + (-rhs).

template <class Clock, class Duration1, class Duration2>

constexpr common_type_t<Duration1, Duration2>
operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

Returns: lhs.time_since_epoch() - rhs.time_since_epoch().

20.12.6.6 time_point comparisons
template <class Clock, class Duration1, class Duration2>

[time.point.comparisons]

constexpr bool operator==(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

Returns: lhs.time_since_epoch() == rhs.time_since_epoch().

template <class Clock, class Duration1, class Duration2>

constexpr bool operator!=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

Returns: !(lhs == rhs).

template <class Clock, class Duration1, class Duration2>

constexpr bool operator<(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

Returns: lhs.time_since_epoch() < rhs.time_since_epoch().

template <class Clock, class Duration1, class Duration2>

constexpr bool operator<=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

Returns: !(rhs < lhs).

§ 20.12.6.6

638

3

4

1

2

1

2

3

4

1

2

3

4

c(cid:13) ISO/IEC

N4296

template <class Clock, class Duration1, class Duration2>

constexpr bool operator>(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

Returns: rhs < lhs.

template <class Clock, class Duration1, class Duration2>

constexpr bool operator>=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

Returns: !(lhs < rhs).
20.12.6.7 time_point_cast
template <class ToDuration, class Clock, class Duration>

constexpr time_point<Clock, ToDuration>
time_point_cast(const time_point<Clock, Duration>& t);

[time.point.cast]

Remarks: This function shall not participate in overload resolution unless ToDuration is an instanti-
ation of duration.
Returns: time_point<Clock, ToDuration>(duration_cast<ToDuration>(t.time_since_epoch())).

5

6

1

2

20.12.7 Clocks

[time.clock]

1 The types deﬁned in this subclause shall satisfy the TrivialClock requirements (20.12.3).

20.12.7.1 Class system_clock

[time.clock.system]

1 Objects of class system_clock represent wall clock time from the system-wide realtime clock.

class system_clock {
public:

typedef see below
typedef ratio<unspecified , unspecified >
typedef chrono::duration<rep, period>
typedef chrono::time_point<system_clock>
static constexpr bool is_steady =

rep;
period;
duration;
time_point;

unspecified ;

static time_point now() noexcept;

// Map to C API
static time_t
static time_point

};

to_time_t
from_time_t(time_t t) noexcept;

(const time_point& t) noexcept;

2

3

4

typedef unspecified

system_clock::rep;

Requires: system_clock::duration::min() < system_clock::duration::zero() shall be true.
[ Note: This implies that rep is a signed type. — end note ]

static time_t to_time_t(const time_point& t) noexcept;

Returns: A time_t object that represents the same point in time as t when both values are restricted
to the coarser of the precisions of time_t and time_point.
It is implementation deﬁned whether
values are rounded or truncated to the required precision.

static time_point from_time_t(time_t t) noexcept;

Returns: A time_point object that represents the same point in time as t when both values are
restricted to the coarser of the precisions of time_t and time_point. It is implementation deﬁned
whether values are rounded or truncated to the required precision.

§ 20.12.7.1

639

c(cid:13) ISO/IEC

N4296

20.12.7.2 Class steady_clock

[time.clock.steady]
1 Objects of class steady_clock represent clocks for which values of time_point never decrease as physical
time advances and for which values of time_point advance at a steady rate relative to real time. That is,
the clock may not be adjusted.

class steady_clock {
public:

typedef unspecified
typedef ratio<unspecified , unspecified >
typedef chrono::duration<rep, period>
typedef chrono::time_point<unspecified , duration>
static constexpr bool is_steady =

true;

rep;
period;
duration;
time_point;

static time_point now() noexcept;

};

20.12.7.3 Class high_resolution_clock

[time.clock.hires]
1 Objects of class high_resolution_clock represent clocks with the shortest tick period. high_resolution_-

clock may be a synonym for system_clock or steady_clock.

class high_resolution_clock {
public:

typedef unspecified
typedef ratio<unspecified , unspecified >
typedef chrono::duration<rep, period>
typedef chrono::time_point<unspecified , duration> time_point;
static constexpr bool is_steady =
unspecified ;

rep;
period;
duration;

static time_point now() noexcept;

};

20.12.8 Date and time functions

1 Table 60 describes the header <ctime>.

[date.time]

Table 60 — Header <ctime> synopsis

Name(s)

CLOCKS_PER_SEC
clock_t

time_t

NULL
size_t
tm

clock
gmtime

difftime
mktime

localtime
time

strftime

Type
Macros:
Types:
Struct:
Functions:
asctime
ctime

2 The contents are the same as the Standard C library header <time.h>.231 The functions asctime, ctime,

gmtime, and localtime are not required to avoid data races (17.6.5.9).
See also: ISO C Clause 7.12, Amendment 1 Clause 4.6.4.
20.13 Class template scoped_allocator_adaptor
20.13.1 Header <scoped_allocator> synopsis
231) strftime supports the C conversion speciﬁers C, D, e, F, g, G, h, r, R, t, T, u, V, and z, and the modiﬁers E and O.

[allocator.adaptor]
[allocator.adaptor.syn]

§ 20.13.1

640

c(cid:13) ISO/IEC

N4296

// scoped allocator adaptor
template <class OuterAlloc, class... InnerAlloc>

class scoped_allocator_adaptor;

template <class OuterA1, class OuterA2, class... InnerAllocs>

bool operator==(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,

const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;

template <class OuterA1, class OuterA2, class... InnerAllocs>

bool operator!=(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,

const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;

1 The class template scoped_allocator_adaptor is an allocator template that speciﬁes the memory resource
(the outer allocator) to be used by a container (as any other allocator does) and also speciﬁes an inner
allocator resource to be passed to the constructor of every element within the container. This adaptor is
instantiated with one outer and zero or more inner allocator types. If instantiated with only one alloca-
tor type, the inner allocator becomes the scoped_allocator_adaptor itself, thus using the same allocator
resource for the container and every element within the container and, if the elements themselves are con-
tainers, each of their elements recursively. If instantiated with more than one allocator, the ﬁrst allocator
is the outer allocator for use by the container, the second allocator is passed to the constructors of the
container’s elements, and, if the elements themselves are containers, the third allocator is passed to the
elements’ elements, and so on. If containers are nested to a depth greater than the number of allocators, the
last allocator is used repeatedly, as in the single-allocator case, for any remaining recursions.
[ Note: The
scoped_allocator_adaptor is derived from the outer allocator type so it can be substituted for the outer
allocator type in most expressions. — end note ]

namespace std {

template <class OuterAlloc, class... InnerAllocs>

class scoped_allocator_adaptor : public OuterAlloc {

private:

public:

typedef allocator_traits<OuterAlloc> OuterTraits; // exposition only
// exposition only
scoped_allocator_adaptor<InnerAllocs...> inner;

typedef OuterAlloc outer_allocator_type;
typedef see below inner_allocator_type;

typedef typename OuterTraits::value_type value_type;
typedef typename OuterTraits::size_type size_type;
typedef typename OuterTraits::difference_type difference_type;
typedef typename OuterTraits::pointer pointer;
typedef typename OuterTraits::const_pointer const_pointer;
typedef typename OuterTraits::void_pointer void_pointer;
typedef typename OuterTraits::const_void_pointer const_void_pointer;

typedef see below propagate_on_container_copy_assignment;
typedef see below propagate_on_container_move_assignment;
typedef see below propagate_on_container_swap;
typedef see below is_always_equal;

template <class Tp>

struct rebind {

};

typedef scoped_allocator_adaptor<

OuterTraits::template rebind_alloc<Tp>, InnerAllocs...> other;

scoped_allocator_adaptor();
template <class OuterA2>

§ 20.13.1

641

c(cid:13) ISO/IEC

N4296

scoped_allocator_adaptor(OuterA2&& outerAlloc,

const InnerAllocs&... innerAllocs) noexcept;

scoped_allocator_adaptor(const scoped_allocator_adaptor& other) noexcept;
scoped_allocator_adaptor(scoped_allocator_adaptor&& other) noexcept;

template <class OuterA2>

scoped_allocator_adaptor(

template <class OuterA2>

scoped_allocator_adaptor(

const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& other) noexcept;

scoped_allocator_adaptor<OuterA2, InnerAllocs...>&& other) noexcept;

~scoped_allocator_adaptor();

inner_allocator_type& inner_allocator() noexcept;
const inner_allocator_type& inner_allocator() const noexcept;
outer_allocator_type& outer_allocator() noexcept;
const outer_allocator_type& outer_allocator() const noexcept;

pointer allocate(size_type n);
pointer allocate(size_type n, const_void_pointer hint);
void deallocate(pointer p, size_type n);
size_type max_size() const;

template <class T, class... Args>

void construct(T* p, Args&&... args);

template <class T1, class T2, class... Args1, class... Args2>

void construct(pair<T1, T2>* p, piecewise_construct_t,
tuple<Args1...> x, tuple<Args2...> y);

template <class T1, class T2>

void construct(pair<T1, T2>* p);

template <class T1, class T2, class U, class V>
void construct(pair<T1, T2>* p, U&& x, V&& y);
template <class T1, class T2, class U, class V>

void construct(pair<T1, T2>* p, const pair<U, V>& x);

template <class T1, class T2, class U, class V>

void construct(pair<T1, T2>* p, pair<U, V>&& x);

template <class T>

void destroy(T* p);

scoped_allocator_adaptor select_on_container_copy_construction() const;

};

template <class OuterA1, class OuterA2, class... InnerAllocs>

bool operator==(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,

const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;

template <class OuterA1, class OuterA2, class... InnerAllocs>

bool operator!=(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,

const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;

}

20.13.2 Scoped allocator adaptor member types

[allocator.adaptor.types]

§ 20.13.2

642

c(cid:13) ISO/IEC

N4296

typedef see below inner_allocator_type;

Type: scoped_allocator_adaptor<OuterAlloc> if sizeof...(InnerAllocs) is zero; otherwise,
scoped_allocator_adaptor<InnerAllocs...>.

typedef see below propagate_on_container_copy_assignment;

Type: true_type if allocator_traits<A>::propagate_on_container_copy_assignment::value is
true for any A in the set of OuterAlloc and InnerAllocs...; otherwise, false_type.

typedef see below propagate_on_container_move_assignment;

Type: true_type if allocator_traits<A>::propagate_on_container_move_assignment::value is
true for any A in the set of OuterAlloc and InnerAllocs...; otherwise, false_type.

typedef see below propagate_on_container_swap;

Type: true_type if allocator_traits<A>::propagate_on_container_swap::value is true for any
A in the set of OuterAlloc and InnerAllocs...; otherwise, false_type.

typedef see below is_always_equal;

Type: true_type if allocator_traits<A>::is_always_equal::value is true for every A in the set
of OuterAlloc and InnerAllocs...; otherwise, false_type.

20.13.3 Scoped allocator adaptor constructors
scoped_allocator_adaptor();

[allocator.adaptor.cnstr]

Eﬀects: value-initializes the OuterAlloc base class and the inner allocator object.

template <class OuterA2>

scoped_allocator_adaptor(OuterA2&& outerAlloc,

const InnerAllocs&... innerAllocs) noexcept;

Requires: OuterAlloc shall be constructible from OuterA2.
Eﬀects: initializes the OuterAlloc base class with std::forward<OuterA2>(outerAlloc) and inner
with innerAllocs... (hence recursively initializing each allocator within the adaptor with the corre-
sponding allocator from the argument list).

scoped_allocator_adaptor(const scoped_allocator_adaptor& other) noexcept;

Eﬀects: initializes each allocator within the adaptor with the corresponding allocator from other.

scoped_allocator_adaptor(scoped_allocator_adaptor&& other) noexcept;

Eﬀects: move constructs each allocator within the adaptor with the corresponding allocator from
other.

template <class OuterA2>

scoped_allocator_adaptor(const scoped_allocator_adaptor<OuterA2,

InnerAllocs...>& other) noexcept;

Requires: OuterAlloc shall be constructible from OuterA2.
Eﬀects: initializes each allocator within the adaptor with the corresponding allocator from other.

template <class OuterA2>

scoped_allocator_adaptor(scoped_allocator_adaptor<OuterA2,

InnerAllocs...>&& other) noexcept;

Requires: OuterAlloc shall be constructible from OuterA2.
Eﬀects:
other.

initializes each allocator within the adaptor with the corresponding allocator rvalue from

§ 20.13.3

643

1

2

3

4

5

1

2

3

4

5

6

7

8

9

1

2

3

4

5

6

7

8

9
(9.1)

(9.2)

(9.3)

(9.4)

c(cid:13) ISO/IEC

N4296

[allocator.adaptor.members]
20.13.4 Scoped allocator adaptor members
In the construct member functions, OUTERMOST(x) is x if x does not have an outer_allocator() mem-
ber function and
OUTERMOST(x.outer_allocator()) otherwise; OUTERMOST_ALLOC_TRAITS(x) is
allocator_traits<decltype(OUTERMOST (x))>. [ Note: OUTERMOST(x) and
OUTERMOST_ALLOC_TRAITS(x) are recursive operations.
outer_allocator() to ensure that the recursion terminates. It will terminate for all instantiations of
scoped_allocator_adaptor. — end note ]

It is incumbent upon the deﬁnition of

inner_allocator_type& inner_allocator() noexcept;
const inner_allocator_type& inner_allocator() const noexcept;

Returns: *this if sizeof...(InnerAllocs) is zero; otherwise, inner.

outer_allocator_type& outer_allocator() noexcept;
Returns: static_cast<OuterAlloc&>(*this).

const outer_allocator_type& outer_allocator() const noexcept;

Returns: static_cast<const OuterAlloc&>(*this).

pointer allocate(size_type n);

Returns: allocator_traits<OuterAlloc>::allocate(outer_allocator(), n).

pointer allocate(size_type n, const_void_pointer hint);

Returns: allocator_traits<OuterAlloc>::allocate(outer_allocator(), n, hint).

void deallocate(pointer p, size_type n) noexcept;

Eﬀects: allocator_traits<OuterAlloc>::deallocate(outer_allocator(), p, n);

size_type max_size() const;

Returns: allocator_traits<OuterAlloc>::max_size(outer_allocator()).

template <class T, class... Args>

void construct(T* p, Args&&... args);

Eﬀects:
—

—

—

—

§ 20.13.4

If uses_allocator<T, inner_allocator_type>::value is false and is_constructible<T,
Args...>::value is true, calls OUTERMOST_ALLOC_TRAITS(*this)::construct(
OUTERMOST (*this), p, std::forward<Args>(args)...).
Otherwise, if uses_allocator<T, inner_allocator_type>::value is true and is_construc-
tible<T, allocator_arg_t, inner_allocator_type, Args...>::value is true, calls OUT-
ERMOST_ALLOC_TRAITS(*this)::construct(OUTERMOST (*this), p, allocator_arg,
inner_allocator(), std::forward<Args>(args)...).
Otherwise, if uses_allocator<T, inner_allocator_type>::value is true and is_construct-
ible<T, Args..., inner_allocator_type>::value is true, calls OUTERMOST_ALLOC_-
TRAITS(*this):: construct(OUTERMOST (*this), p, std::forward<Args>(args)...,
inner_allocator()).
Otherwise, the program is ill-formed.
[ Note: An error will result if uses_allocator evaluates
to true but the speciﬁc constructor does not take an allocator. This deﬁnition prevents a silent
failure to pass an inner allocator to a contained element. — end note ]

644

c(cid:13) ISO/IEC

N4296

template <class T1, class T2, class... Args1, class... Args2>

void construct(pair<T1, T2>* p,piecewise_construct_t,
tuple<Args1...> x, tuple<Args2...> y);

Requires: all of the types in Args1 and Args2 shall be CopyConstructible (Table 21).
Eﬀects: Constructs a tuple object xprime from x by the following rules:
—

If uses_allocator<T1, inner_allocator_type>::value is false and is_constructible<T1,
Args1...>::value is true, then xprime is x.
Otherwise, if uses_allocator<T1, inner_allocator_type>::value is true and is_construct-
ible<T1, allocator_arg_t, inner_allocator_type, Args1...>::value is true, then xprime
is tuple_cat(tuple<allocator_arg_t, inner_allocator_type&>( allocator_arg, inner_-
allocator()), std::move(x)).
Otherwise, if uses_allocator<T1, inner_allocator_type>::value is true and is_construct-
ible<T1, Args1..., inner_allocator_type>::value is true, then xprime is tuple_cat(std::move(x),
tuple<inner_allocator_type&>(inner_allocator())).
Otherwise, the program is ill-formed.

—
and constructs a tuple object yprime from y by the following rules:
—

If uses_allocator<T2, inner_allocator_type>::value is false and is_constructible<T2,
Args2...>::value is true, then yprime is y.
Otherwise, if uses_allocator<T2, inner_allocator_type>::value is true and is_construct-
ible<T2, allocator_arg_t, inner_allocator_type, Args2...>::value is true, then yprime
is tuple_cat(tuple<allocator_arg_t, inner_allocator_type&>( allocator_arg, inner_-
allocator()), std::move(y)).
Otherwise, if uses_allocator<T2, inner_allocator_type>::value is true and is_construct-
ible<T2, Args2..., inner_allocator_type>::value is true, then yprime is tuple_cat(std::move(y),
tuple<inner_allocator_type&>(inner_allocator())).
Otherwise, the program is ill-formed.

—
then calls OUTERMOST_ALLOC_TRAITS (*this)::construct(OUTERMOST (*this), p,
piecewise_construct, std::move(xprime), std::move(yprime)).

template <class T1, class T2>

void construct(pair<T1, T2>* p);

Eﬀects: Equivalent to this->construct(p, piecewise_construct, tuple<>(), tuple<>()).

template <class T1, class T2, class U, class V>
void construct(pair<T1, T2>* p, U&& x, V&& y);

Eﬀects: Equivalent to this->construct(p, piecewise_construct, forward_as_tuple(std::for-
ward<U>(x)), forward_as_tuple(std::forward<V>(y))).

template <class T1, class T2, class U, class V>

void construct(pair<T1, T2>* p, const pair<U, V>& x);

Eﬀects: Equivalent to this->construct(p, piecewise_construct, forward_as_tuple(x.first),
forward_as_tuple(x.second)).

template <class T1, class T2, class U, class V>

void construct(pair<T1, T2>* p, pair<U, V>&& x);

Eﬀects: Equivalent to this->construct(p, piecewise_construct, forward_as_tuple(std::for-
ward<U>(x.first)), forward_as_tuple(std::forward<V>(x.second))).

§ 20.13.4

645

—

—

—

—

10

11
(11.1)

(11.2)

(11.3)

(11.4)

(11.5)

(11.6)

(11.7)

(11.8)

12

13

14

15

16

17

1

2

c(cid:13) ISO/IEC

template <class T>

void destroy(T* p);

N4296

Eﬀects: calls OUTERMOST_ALLOC_TRAITS (*this)::destroy(OUTERMOST (*this), p).

scoped_allocator_adaptor select_on_container_copy_construction() const;

Returns: A new scoped_allocator_adaptor object where each allocator A in the adaptor is initialized
from the result of calling allocator_traits<A>::select_on_container_copy_construction() on
the corresponding allocator in *this.

20.13.5 Scoped allocator operators
template <class OuterA1, class OuterA2, class... InnerAllocs>

[scoped.adaptor.operators]

bool operator==(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,

const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;

Returns: a.outer_allocator() == b.outer_allocator() if sizeof...(InnerAllocs) is zero; oth-
erwise, a.outer_allocator() == b.outer_allocator() && a.inner_allocator() == b.inner_-
allocator().

template <class OuterA1, class OuterA2, class... InnerAllocs>

bool operator!=(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,

const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;

Returns: !(a == b).

20.14 Class type_index
20.14.1 Header <typeindex> synopsis

[type.index]
[type.index.synopsis]

namespace std {

class type_index;
template <class T> struct hash;
template<> struct hash<type_index>;

}

20.14.2 type_index overview

[type.index.overview]

namespace std {

class type_index {
public:

type_index(const type_info& rhs) noexcept;
bool operator==(const type_index& rhs) const noexcept;
bool operator!=(const type_index& rhs) const noexcept;
bool operator< (const type_index& rhs) const noexcept;
bool operator<= (const type_index& rhs) const noexcept;
bool operator> (const type_index& rhs) const noexcept;
bool operator>= (const type_index& rhs) const noexcept;
size_t hash_code() const noexcept;
const char* name() const noexcept;

private:

const type_info* target;
// Note that the use of a pointer here, rather than a reference,
// means that the default copy/move constructor and assignment
// operators will be provided and work as expected.

// exposition only

};

}

§ 20.14.2

646

c(cid:13) ISO/IEC

N4296

1 The class type_index provides a simple wrapper for type_info which can be used as an index type in

associative containers (23.4) and in unordered associative containers (23.5).
20.14.3 type_index members
type_index(const type_info& rhs) noexcept;

[type.index.members]

1

2

3

4

5

6

7

8

9

1

Eﬀects: constructs a type_index object, the equivalent of target = &rhs.

bool operator==(const type_index& rhs) const noexcept;

Returns: *target == *rhs.target

bool operator!=(const type_index& rhs) const noexcept;

Returns: *target != *rhs.target

bool operator<(const type_index& rhs) const noexcept;

Returns: target->before(*rhs.target)

bool operator<=(const type_index& rhs) const noexcept;

Returns: !rhs.target->before(*target)

bool operator>(const type_index& rhs) const noexcept;

Returns: rhs.target->before(*target)

bool operator>=(const type_index& rhs) const noexcept;

Returns: !target->before(*rhs.target)

size_t hash_code() const noexcept;
Returns: target->hash_code()

const char* name() const noexcept;

Returns: target->name()

20.14.4 Hash support
template <> struct hash<type_index>;

[type.index.hash]

The template specialization shall meet the requirements of class template hash (20.9.13). For an
object index of type type_index, hash<type_index>()(index) shall evaluate to the same result as
index.hash_code().

§ 20.14.4

647

c(cid:13) ISO/IEC

N4296

21 Strings library
21.1 General

[strings]
[strings.general]
1 This Clause describes components for manipulating sequences of any non-array POD (3.9) type. In this
Clause such types are called char-like types , and objects of char-like types are called char-like objects or
simply characters.

2 The following subclauses describe a character traits class, a string class, and null-terminated sequence

utilities, as summarized in Table 61.

Table 61 — Strings library summary

Subclause

21.2 Character traits
21.3

String classes

21.8 Null-terminated sequence utilities

Header(s)
<string>
<string>
<cctype>
<cwctype>
<cstring>
<cwchar>
<cstdlib>
<cuchar>

21.2 Character traits

[char.traits]
1 This subclause deﬁnes requirements on classes representing character traits, and deﬁnes a class template

char_traits<charT>, along with four specializations, char_traits<char>, char_traits<char16_t>,
char_traits<char32_t>, and char_traits<wchar_t>, that satisfy those requirements.

2 Most classes speciﬁed in Clauses 21.3 and 27 need a set of related types and functions to complete the
deﬁnition of their semantics. These types and functions are provided as a set of member typedefs and
functions in the template parameter ‘traits’ used by each such template. This subclause deﬁnes the semantics
of these members.

3 To specialize those templates to generate a string or iostream class to handle a particular character container
type CharT, that and its related character traits class Traits are passed as a pair of parameters to the string
or iostream template as parameters charT and traits. Traits::char_type shall be the same as CharT.

4 This subclause speciﬁes a struct template, char_traits<charT>, and four explicit specializations of it,
char_traits<char>, char_traits<char16_t>, char_traits<char32_t>, and char_traits<wchar_t>, all
of which appear in the header <string> and satisfy the requirements below.
21.2.1 Character traits requirements
[char.traits.require]
In Table 62, X denotes a Traits class deﬁning types and functions for the character container type CharT;
c and d denote values of type CharT; p and q denote values of type const CharT*; s denotes a value of
type CharT*; n, i and j denote values of type std::size_t; e and f denote values of type X::int_type;
pos denotes a value of type X::pos_type; state denotes a value of type X::state_type; and r denotes an
lvalue of type CharT. Operations on Traits shall not throw exceptions.

1

§ 21.2.1

648

c(cid:13) ISO/IEC

Table 62 — Character traits requirements

Expression

Return type

X::char_type
X::int_type
X::off_type
X::pos_type
X::state_type
X::eq(c,d)

X::lt(c,d)

X::compare(p,q,n)

charT

bool

bool

int

X::length(p)

std::size_t

X::find(p,n,c)

const X::char_type*

X::move(s,p,n)

X::char_type*

X::copy(s,p,n)

X::char_type*

X::assign(r,d)
X::assign(s,n,c)

(not used)
X::char_type*

X::not_eof(e)

int_type

X::to_char_type(e)

X::char_type

Assertion/note

pre-/post-condition

(described in 21.2.2)
(described in 21.2.2)
(described in 21.2.2)
(described in 21.2.2)
(described in 21.2.2)
yields: whether c is to be
treated as equal to d.
yields: whether c is to be
treated as less than d.
yields: 0 if for each i in [0,n),
X::eq(p[i],q[i]) is true; else,
a negative value if, for some j
in [0,n), X::lt(p[j],q[j]) is
true and for each i in [0,j)
X::eq(p[i],q[i]) is true; else
a positive value.
yields: the smallest i such that
X::eq(p[i],charT()) is true.
yields: the smallest q in
[p,p+n) such that
X::eq(*q,c) is true, zero
otherwise.
for each i in [0,n), performs
X::assign(s[i],p[i]).
Copies correctly even where the
ranges [p,p+n) and [s,s+n)
overlap. yields: s.
pre: p not in [s,s+n). yields:
s. for each i in [0,n), performs
X::assign(s[i],p[i]).
assigns r=d.
for each i in [0,n), performs
X::assign(s[i],c). yields: s.
yields: e if
X::eq_int_type(e,X::eof())
is false, otherwise a value f
such that
X::eq_int_type(f,X::eof())
is false.
yields: if for some c,
X::eq_int_type(e,X::to_-
int_type(c)) is true, c; else
some unspeciﬁed value.

N4296

Complexity

compile-time
compile-time
compile-time
compile-time
compile-time
constant

constant

linear

linear

linear

linear

linear

constant
linear

constant

constant

§ 21.2.1

649

c(cid:13) ISO/IEC

Table 62 — Character traits requirements (continued)

Expression

Return type

X::to_int_type(c)

X::int_type

X::eq_int_type(e,f)

bool

X::eof()

X::int_type

Assertion/note

pre-/post-condition

yields: some value e,
constrained by the deﬁnitions of
to_char_type and
eq_int_type.
yields: for all c and d,
X::eq(c,d) is equal to
X::eq_int_type(X::to_int_-
type(c),
X::to_int_type(d));
otherwise, yields true if e and f
are both copies of X::eof();
otherwise, yields false if one of
e and f is a copy of X::eof()
and the other is not; otherwise
the value is unspeciﬁed.
yields: a value e such that
X::eq_int_type(e,X::to_-
int_type(c)) is false for all
values c.

N4296

Complexity

constant

constant

constant

2 The struct template

template<class charT> struct char_traits;

1

2

3

4

shall be provided in the header <string> as a basis for explicit specializations.
21.2.2
traits typedefs
typedef CHAR_T char_type;

[char.traits.typedefs]

The type char_type is used to refer to the character container type in the implementation of the
library classes deﬁned in 21.3 and Clause 27.

typedef INT_T int_type;

Requires: For a certain character container type char_type, a related container type INT_T shall be a
type or class which can represent all of the valid characters converted from the corresponding char_-
type values, as well as an end-of-ﬁle value, eof(). The type int_type represents a character container
type which can hold end-of-ﬁle to be used as a return type of the iostream class member functions.232

typedef implementation-defined off_type;
typedef implementation-defined pos_type;

Requires: Requirements for off_type and pos_type are described in 27.2.2 and 27.3.

typedef STATE_T state_type;

Requires: state_type shall meet the requirements of CopyAssignable (Table 23), CopyConstructible
(Table 21), and DefaultConstructible (Table 19) types.

232) If eof() can be held in char_type then some iostreams operations may give surprising results.

§ 21.2.2

650

c(cid:13) ISO/IEC

N4296

21.2.3 char_traits specializations

[char.traits.specializations]

namespace std {

template<> struct char_traits<char>;
template<> struct char_traits<char16_t>;
template<> struct char_traits<char32_t>;
template<> struct char_traits<wchar_t>;

}

1 The header <string> shall deﬁne four specializations of the template struct char_traits: char_traits<

char>, char_traits<char16_t>, char_traits<char32_t>, and char_traits<wchar_t>.

2 The requirements for the members of these specializations are given in Clause 21.2.1.

21.2.3.1 struct char_traits<char>

[char.traits.specializations.char]

namespace std {

template<> struct char_traits<char> {

typedef char
typedef int
typedef streamoff
typedef streampos
typedef mbstate_t

char_type;
int_type;
off_type;
pos_type;
state_type;

static void assign(char_type& c1, const char_type& c2) noexcept;
static constexpr bool eq(char_type c1, char_type c2) noexcept;
static constexpr bool lt(char_type c1, char_type c2) noexcept;

static int compare(const char_type* s1, const char_type* s2, size_t n);
static size_t length(const char_type* s);
static const char_type* find(const char_type* s, size_t n,

const char_type& a);

static char_type* move(char_type* s1, const char_type* s2, size_t n);
static char_type* copy(char_type* s1, const char_type* s2, size_t n);
static char_type* assign(char_type* s, size_t n, char_type a);

static constexpr int_type not_eof(int_type c) noexcept;
static constexpr char_type to_char_type(int_type c) noexcept;
static constexpr int_type to_int_type(char_type c) noexcept;
static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
static constexpr int_type eof() noexcept;

};

}

1 The deﬁned types for int_type, pos_type, off_type, and state_type shall be int, streampos, streamoff,

and mbstate_t respectively.

2 The type streampos shall be an implementation-deﬁned type that satisﬁes the requirements for pos_type

in 27.2.2 and 27.3.

3 The type streamoff shall be an implementation-deﬁned type that satisﬁes the requirements for off_type

in 27.2.2 and 27.3.

4 The type mbstate_t is deﬁned in <cwchar> and can represent any of the conversion states that can occur

in an implementation-deﬁned set of supported multibyte character encoding rules.

5 The two-argument member assign shall be deﬁned identically to the built-in operator =. The two-argument
members eq and lt shall be deﬁned identically to the built-in operators == and < for type unsigned char.

§ 21.2.3.1

651

c(cid:13) ISO/IEC

N4296

6 The member eof() shall return EOF.

21.2.3.2 struct char_traits<char16_t>

[char.traits.specializations.char16_t]

namespace std {

template<> struct char_traits<char16_t> {

typedef char16_t
typedef uint_least16_t
typedef streamoff
typedef u16streampos
typedef mbstate_t

char_type;
int_type;
off_type;
pos_type;
state_type;

static void assign(char_type& c1, const char_type& c2) noexcept;
static constexpr bool eq(char_type c1, char_type c2) noexcept;
static constexpr bool lt(char_type c1, char_type c2) noexcept;

static int compare(const char_type* s1, const char_type* s2, size_t n);
static size_t length(const char_type* s);
static const char_type* find(const char_type* s, size_t n,

static char_type* move(char_type* s1, const char_type* s2, size_t n);
static char_type* copy(char_type* s1, const char_type* s2, size_t n);
static char_type* assign(char_type* s, size_t n, char_type a);

const char_type& a);

static constexpr int_type not_eof(int_type c) noexcept;
static constexpr char_type to_char_type(int_type c) noexcept;
static constexpr int_type to_int_type(char_type c) noexcept;
static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
static constexpr int_type eof() noexcept;

};

}

1 The type u16streampos shall be an implementation-deﬁned type that satisﬁes the requirements for pos_type

in 27.2.2 and 27.3.

2 The two-argument members assign, eq, and lt shall be deﬁned identically to the built-in operators =, ==,

and < respectively.

3 The member eof() shall return an implementation-deﬁned constant that cannot appear as a valid UTF-16

code unit.
21.2.3.3 struct char_traits<char32_t>

[char.traits.specializations.char32_t]

namespace std {

template<> struct char_traits<char32_t> {

typedef char32_t
typedef uint_least32_t
typedef streamoff
typedef u32streampos
typedef mbstate_t

char_type;
int_type;
off_type;
pos_type;
state_type;

static void assign(char_type& c1, const char_type& c2) noexcept;
static constexpr bool eq(char_type c1, char_type c2) noexcept;
static constexpr bool lt(char_type c1, char_type c2) noexcept;

static int compare(const char_type* s1, const char_type* s2, size_t n);
static size_t length(const char_type* s);
static const char_type* find(const char_type* s, size_t n,

§ 21.2.3.3

652

c(cid:13) ISO/IEC

N4296

const char_type& a);

static char_type* move(char_type* s1, const char_type* s2, size_t n);
static char_type* copy(char_type* s1, const char_type* s2, size_t n);
static char_type* assign(char_type* s, size_t n, char_type a);

static constexpr int_type not_eof(int_type c) noexcept;
static constexpr char_type to_char_type(int_type c) noexcept;
static constexpr int_type to_int_type(char_type c) noexcept;
static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
static constexpr int_type eof() noexcept;

};

}

1 The type u32streampos shall be an implementation-deﬁned type that satisﬁes the requirements for pos_type

in 27.2.2 and 27.3.

2 The two-argument members assign, eq, and lt shall be deﬁned identically to the built-in operators =, ==,

and < respectively.

3 The member eof() shall return an implementation-deﬁned constant that cannot appear as a Unicode code

point.
21.2.3.4 struct char_traits<wchar_t>

[char.traits.specializations.wchar.t]

namespace std {

template<> struct char_traits<wchar_t> {

typedef wchar_t
typedef wint_t
typedef streamoff
typedef wstreampos
typedef mbstate_t

char_type;
int_type;
off_type;
pos_type;
state_type;

static void assign(char_type& c1, const char_type& c2) noexcept;
static constexpr bool eq(char_type c1, char_type c2) noexcept;
static constexpr bool lt(char_type c1, char_type c2) noexcept;

static int compare(const char_type* s1, const char_type* s2, size_t n);
static size_t length(const char_type* s);
static const char_type* find(const char_type* s, size_t n,

const char_type& a);

static char_type* move(char_type* s1, const char_type* s2, size_t n);
static char_type* copy(char_type* s1, const char_type* s2, size_t n);
static char_type* assign(char_type* s, size_t n, char_type a);

static constexpr int_type not_eof(int_type c) noexcept;
static constexpr char_type to_char_type(int_type c) noexcept;
static constexpr int_type to_int_type(char_type c) noexcept;
static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
static constexpr int_type eof() noexcept;

};

}

1 The deﬁned types for int_type, pos_type, and state_type shall be wint_t, wstreampos, and mbstate_t

respectively.

2 The type wstreampos shall be an implementation-deﬁned type that satisﬁes the requirements for pos_type

in 27.2.2 and 27.3.

§ 21.2.3.4

653

c(cid:13) ISO/IEC

N4296

3 The type mbstate_t is deﬁned in <cwchar> and can represent any of the conversion states that can occur

in an implementation-deﬁned set of supported multibyte character encoding rules.

4 The two-argument members assign, eq, and lt shall be deﬁned identically to the built-in operators =, ==,

and < respectively.

5 The member eof() shall return WEOF.

21.3 String classes

[string.classes]
1 The header <string> deﬁnes the basic_string class template for manipulating varying-length sequences
of char-like objects and four typedefs, string, u16string, u32string, and wstring, that name the special-
izations basic_string<char>, basic_string<char16_t>, basic_string<char32_t>, and basic_string<
wchar_t>, respectively.
Header <string> synopsis

#include <initializer_list>

namespace std {

// 21.2, character traits:
template<class charT> struct char_traits;
template <> struct char_traits<char>;
template <> struct char_traits<char16_t>;
template <> struct char_traits<char32_t>;
template <> struct char_traits<wchar_t>;

// 21.4, basic_string:
template<class charT, class traits = char_traits<charT>,

class Allocator = allocator<charT> >

class basic_string;

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(const basic_string<charT,traits,Allocator>& lhs,
const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(basic_string<charT,traits,Allocator>&& lhs,

const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(const basic_string<charT,traits,Allocator>& lhs,

basic_string<charT,traits,Allocator>&& rhs);

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(basic_string<charT,traits,Allocator>&& lhs,
basic_string<charT,traits,Allocator>&& rhs);

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(const charT* lhs,

template<class charT, class traits, class Allocator>

const basic_string<charT,traits,Allocator>& rhs);

basic_string<charT,traits,Allocator>

operator+(const charT* lhs,

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>&& rhs);

§ 21.3

654

c(cid:13) ISO/IEC

N4296

basic_string<charT,traits,Allocator>

operator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(charT lhs, basic_string<charT,traits,Allocator>&& rhs);

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(const basic_string<charT,traits,Allocator>& lhs,

const charT* rhs);

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(basic_string<charT,traits,Allocator>&& lhs,

const charT* rhs);

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(const basic_string<charT,traits,Allocator>& lhs, charT rhs);

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(basic_string<charT,traits,Allocator>&& lhs, charT rhs);

template<class charT, class traits, class Allocator>

bool operator==(const basic_string<charT,traits,Allocator>& lhs,

const basic_string<charT,traits,Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>

bool operator==(const charT* lhs,

const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>

bool operator==(const basic_string<charT,traits,Allocator>& lhs,

const charT* rhs);

template<class charT, class traits, class Allocator>

bool operator!=(const basic_string<charT,traits,Allocator>& lhs,

const basic_string<charT,traits,Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>

bool operator!=(const charT* lhs,

const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>

bool operator!=(const basic_string<charT,traits,Allocator>& lhs,

const charT* rhs);

template<class charT, class traits, class Allocator>

bool operator< (const basic_string<charT,traits,Allocator>& lhs,

const basic_string<charT,traits,Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>

bool operator< (const basic_string<charT,traits,Allocator>& lhs,

const charT* rhs);

template<class charT, class traits, class Allocator>

bool operator< (const charT* lhs,

const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>

bool operator> (const basic_string<charT,traits,Allocator>& lhs,

const basic_string<charT,traits,Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>

bool operator> (const basic_string<charT,traits,Allocator>& lhs,

template<class charT, class traits, class Allocator>

const charT* rhs);

§ 21.3

655

c(cid:13) ISO/IEC

N4296

bool operator> (const charT* lhs,

const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>

bool operator<=(const basic_string<charT,traits,Allocator>& lhs,

const basic_string<charT,traits,Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>

bool operator<=(const basic_string<charT,traits,Allocator>& lhs,

const charT* rhs);

template<class charT, class traits, class Allocator>

bool operator<=(const charT* lhs,

const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>

bool operator>=(const basic_string<charT,traits,Allocator>& lhs,

const basic_string<charT,traits,Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>

bool operator>=(const basic_string<charT,traits,Allocator>& lhs,

const charT* rhs);

template<class charT, class traits, class Allocator>

bool operator>=(const charT* lhs,

const basic_string<charT,traits,Allocator>& rhs);

// 21.4.8.8, swap:
template<class charT, class traits, class Allocator>

void swap(basic_string<charT,traits,Allocator>& lhs,
basic_string<charT,traits,Allocator>& rhs)

noexcept(noexcept(lhs.swap(rhs)));

// 21.4.8.9, inserters and extractors:
template<class charT, class traits, class Allocator>

basic_istream<charT,traits>&

operator>>(basic_istream<charT,traits>& is,

basic_string<charT,traits,Allocator>& str);

template<class charT, class traits, class Allocator>

basic_ostream<charT, traits>&

operator<<(basic_ostream<charT, traits>& os,

const basic_string<charT,traits,Allocator>& str);

template<class charT, class traits, class Allocator>

basic_istream<charT,traits>&

getline(basic_istream<charT,traits>& is,

basic_string<charT,traits,Allocator>& str,
charT delim);

template<class charT, class traits, class Allocator>

basic_istream<charT,traits>&

getline(basic_istream<charT,traits>&& is,

basic_string<charT,traits,Allocator>& str,
charT delim);

template<class charT, class traits, class Allocator>

basic_istream<charT,traits>&

getline(basic_istream<charT,traits>& is,

basic_string<charT,traits,Allocator>& str);

template<class charT, class traits, class Allocator>

basic_istream<charT,traits>&

getline(basic_istream<charT,traits>&& is,

basic_string<charT,traits,Allocator>& str);

§ 21.3

656

c(cid:13) ISO/IEC

N4296

// basic_string typedef names
typedef basic_string<char> string;
typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;
typedef basic_string<wchar_t> wstring;

// 21.5, numeric conversions:
int stoi(const string& str, size_t* idx = 0, int base = 10);
long stol(const string& str, size_t* idx = 0, int base = 10);
unsigned long stoul(const string& str, size_t* idx = 0, int base = 10);
long long stoll(const string& str, size_t* idx = 0, int base = 10);
unsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);
float stof(const string& str, size_t* idx = 0);
double stod(const string& str, size_t* idx = 0);
long double stold(const string& str, size_t* idx = 0);
string to_string(int val);
string to_string(unsigned val);
string to_string(long val);
string to_string(unsigned long val);
string to_string(long long val);
string to_string(unsigned long long val);
string to_string(float val);
string to_string(double val);
string to_string(long double val);

int stoi(const wstring& str, size_t* idx = 0, int base = 10);
long stol(const wstring& str, size_t* idx = 0, int base = 10);
unsigned long stoul(const wstring& str, size_t* idx = 0, int base = 10);
long long stoll(const wstring& str, size_t* idx = 0, int base = 10);
unsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);
float stof(const wstring& str, size_t* idx = 0);
double stod(const wstring& str, size_t* idx = 0);
long double stold(const wstring& str, size_t* idx = 0);
wstring to_wstring(int val);
wstring to_wstring(unsigned val);
wstring to_wstring(long val);
wstring to_wstring(unsigned long val);
wstring to_wstring(long long val);
wstring to_wstring(unsigned long long val);
wstring to_wstring(float val);
wstring to_wstring(double val);
wstring to_wstring(long double val);

// 21.6, hash support:
template <class T> struct hash;
template <> struct hash<string>;
template <> struct hash<u16string>;
template <> struct hash<u32string>;
template <> struct hash<wstring>;

inline namespace literals {
inline namespace string_literals {

// 21.7, suﬃx for basic_string literals:

§ 21.3

657

c(cid:13) ISO/IEC

N4296

operator "" s(const char* str, size_t len);

string
u16string operator "" s(const char16_t* str, size_t len);
u32string operator "" s(const char32_t* str, size_t len);
wstring
operator "" s(const wchar_t* str, size_t len);

}
}
}

21.4 Class template basic_string

[basic.string]
1 The class template basic_string describes objects that can store a sequence consisting of a varying number
of arbitrary char-like objects with the ﬁrst element of the sequence at position zero. Such a sequence is also
called a “string” if the type of the char-like objects that it holds is clear from context. In the rest of this
Clause, the type of the char-like objects held in a basic_string object is designated by charT.

2 The member functions of basic_string use an object of the Allocator class passed as a template parameter

to allocate and free storage for the contained char-like objects.233

3 A basic_string is a contiguous container (23.2.1).
4
5 The functions described in this Clause can report two kinds of errors, each associated with an exception

In all cases, size() <= capacity().

(5.1)

(5.2)

a length error is associated with exceptions of type length_error (19.2.4);
an out-of-range error is associated with exceptions of type out_of_range (19.2.5).

type:
—
—
namespace std {

template<class charT, class traits = char_traits<charT>,

class Allocator = allocator<charT> >

class basic_string {
public:

traits

// types:
typedef
typedef typename traits::char_type
typedef
typedef typename allocator_traits<Allocator>::size_type
typedef typename allocator_traits<Allocator>::difference_type

Allocator

traits_type;
value_type;
allocator_type;
size_type;
difference_type;

typedef value_type& reference;
typedef const value_type&
typedef typename allocator_traits<Allocator>::pointer
typedef typename allocator_traits<Allocator>::const_pointer

const_reference;

pointer;
const_pointer;

typedef implementation-defined
typedef implementation-defined
typedef std::reverse_iterator<iterator> reverse_iterator;
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
static const size_type npos = -1;

// See 23.2
iterator;
const_iterator; // See 23.2

// 21.4.2, construct/copy/destroy:
basic_string() noexcept : basic_string(Allocator()) { }
explicit basic_string(const Allocator& a) noexcept;

233) Allocator::value_type must name the same type as charT (21.4.1).

§ 21.4

658

c(cid:13) ISO/IEC

N4296

basic_string(const basic_string& str);
basic_string(basic_string&& str) noexcept;
basic_string(const basic_string& str, size_type pos, size_type n = npos,

const Allocator& a = Allocator());

basic_string(const charT* s,

size_type n, const Allocator& a = Allocator());

basic_string(const charT* s, const Allocator& a = Allocator());
basic_string(size_type n, charT c, const Allocator& a = Allocator());
template<class InputIterator>

basic_string(InputIterator begin, InputIterator end,

const Allocator& a = Allocator());

basic_string(initializer_list<charT>, const Allocator& = Allocator());
basic_string(const basic_string&, const Allocator&);
basic_string(basic_string&&, const Allocator&);

~basic_string();
basic_string& operator=(const basic_string& str);
basic_string& operator=(basic_string&& str)

basic_string& operator=(const charT* s);
basic_string& operator=(charT c);
basic_string& operator=(initializer_list<charT>);

noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||

allocator_traits<Allocator>::is_always_equal::value);

// 21.4.3, iterators:
iterator
const_iterator begin() const noexcept;
iterator
const_iterator end() const noexcept;

begin() noexcept;

end() noexcept;

reverse_iterator
const_reverse_iterator rbegin() const noexcept;
reverse_iterator
const_reverse_iterator rend() const noexcept;

rbegin() noexcept;

rend() noexcept;

const_iterator
const_iterator
const_reverse_iterator crbegin() const noexcept;
const_reverse_iterator crend() const noexcept;

cbegin() const noexcept;
cend() const noexcept;

// 21.4.4, capacity:
size_type size() const noexcept;
size_type length() const noexcept;
size_type max_size() const noexcept;
void resize(size_type n, charT c);
void resize(size_type n);
size_type capacity() const noexcept;
void reserve(size_type res_arg = 0);
void shrink_to_fit();
void clear() noexcept;
bool empty() const noexcept;

// 21.4.5, element access:
const_reference operator[](size_type pos) const;
reference

operator[](size_type pos);

§ 21.4

659

c(cid:13) ISO/IEC

N4296

const_reference at(size_type n) const;
reference

at(size_type n);

const charT& front() const;
charT& front();
const charT& back() const;
charT& back();

// 21.4.6, modiﬁers:
basic_string& operator+=(const basic_string& str);
basic_string& operator+=(const charT* s);
basic_string& operator+=(charT c);
basic_string& operator+=(initializer_list<charT>);
basic_string& append(const basic_string& str);
basic_string& append(const basic_string& str, size_type pos,

size_type n = npos);

basic_string& append(const charT* s, size_type n);
basic_string& append(const charT* s);
basic_string& append(size_type n, charT c);
template<class InputIterator>

basic_string& append(InputIterator first, InputIterator last);

basic_string& append(initializer_list<charT>);
void push_back(charT c);

basic_string& assign(const basic_string& str);
basic_string& assign(basic_string&& str) noexcept;
basic_string& assign(const basic_string& str, size_type pos,

size_type n = npos);

basic_string& assign(const charT* s, size_type n);
basic_string& assign(const charT* s);
basic_string& assign(size_type n, charT c);
template<class InputIterator>

basic_string& assign(InputIterator first, InputIterator last);

basic_string& assign(initializer_list<charT>);

basic_string& insert(size_type pos1, const basic_string& str);
basic_string& insert(size_type pos1, const basic_string& str,

size_type pos2, size_type n = npos);

basic_string& insert(size_type pos, const charT* s, size_type n);
basic_string& insert(size_type pos, const charT* s);
basic_string& insert(size_type pos, size_type n, charT c);
iterator insert(const_iterator p, charT c);
iterator insert(const_iterator p, size_type n, charT c);
template<class InputIterator>

iterator insert(const_iterator p, InputIterator first, InputIterator last);

iterator insert(const_iterator p, initializer_list<charT>);

basic_string& erase(size_type pos = 0, size_type n = npos);
iterator erase(const_iterator p);
iterator erase(const_iterator first, const_iterator last);

void pop_back();

basic_string& replace(size_type pos1, size_type n1,

const basic_string& str);

§ 21.4

660

c(cid:13) ISO/IEC

N4296

basic_string& replace(size_type pos1, size_type n1,

const basic_string& str,
size_type pos2, size_type n2 = npos);

basic_string& replace(size_type pos, size_type n1, const charT* s,

basic_string& replace(size_type pos, size_type n1, const charT* s);
basic_string& replace(size_type pos, size_type n1, size_type n2,

size_type n2);

charT c);

size_type n);

basic_string& replace(const_iterator i1, const_iterator i2,

const basic_string& str);

basic_string& replace(const_iterator i1, const_iterator i2, const charT* s,

basic_string& replace(const_iterator i1, const_iterator i2, const charT* s);
basic_string& replace(const_iterator i1, const_iterator i2,

size_type n, charT c);

template<class InputIterator>

basic_string& replace(const_iterator i1, const_iterator i2,
InputIterator j1, InputIterator j2);

basic_string& replace(const_iterator, const_iterator, initializer_list<charT>);

size_type copy(charT* s, size_type n, size_type pos = 0) const;
void swap(basic_string& str)

noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||

allocator_traits<Allocator>::is_always_equal::value);

// 21.4.7, string operations:
const charT* c_str() const noexcept;
const charT* data() const noexcept;
allocator_type get_allocator() const noexcept;

size_type find (const basic_string& str, size_type pos = 0) const noexcept;
size_type find (const charT* s, size_type pos, size_type n) const;
size_type find (const charT* s, size_type pos = 0) const;
size_type find (charT c, size_type pos = 0) const;
size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;
size_type rfind(const charT* s, size_type pos, size_type n) const;
size_type rfind(const charT* s, size_type pos = npos) const;
size_type rfind(charT c, size_type pos = npos) const;

size_type find_first_of(const basic_string& str,

size_type find_first_of(const charT* s,

size_type pos = 0) const noexcept;

size_type pos, size_type n) const;

size_type find_first_of(const charT* s, size_type pos = 0) const;
size_type find_first_of(charT c, size_type pos = 0) const;
size_type find_last_of (const basic_string& str,

size_type pos = npos) const noexcept;

size_type find_last_of (const charT* s,

size_type find_last_of (const charT* s, size_type pos = npos) const;
size_type find_last_of (charT c, size_type pos = npos) const;

size_type pos, size_type n) const;

size_type find_first_not_of(const basic_string& str,

size_type pos = 0) const noexcept;

§ 21.4

661

c(cid:13) ISO/IEC

N4296

size_type find_first_not_of(const charT* s, size_type pos,

size_type n) const;

size_type find_first_not_of(const charT* s, size_type pos = 0) const;
size_type find_first_not_of(charT c, size_type pos = 0) const;
size_type find_last_not_of (const basic_string& str,

size_type pos = npos) const noexcept;

size_type find_last_not_of (const charT* s, size_type pos,

size_type find_last_not_of (const charT* s,

size_type n) const;

size_type find_last_not_of (charT c, size_type pos = npos) const;

size_type pos = npos) const;

basic_string substr(size_type pos = 0, size_type n = npos) const;
int compare(const basic_string& str) const noexcept;
int compare(size_type pos1, size_type n1,

const basic_string& str) const;

int compare(size_type pos1, size_type n1,

const basic_string& str,
size_type pos2, size_type n2 = npos) const;

int compare(const charT* s) const;
int compare(size_type pos1, size_type n1,

const charT* s) const;

int compare(size_type pos1, size_type n1,

const charT* s, size_type n2) const;

};

}

1

2

3

21.4.1 basic_string general requirements
[string.require]
If any operation would cause size() to exceed max_size(), that operation shall throw an exception object
of type length_error.
If any member function or operator of basic_string throws an exception, that function or operator shall
have no other eﬀect.
In every specialization basic_string<charT, traits, Allocator>, the type allocator_traits<All-
ocator>::value_type shall name the same type as charT. Every object of type basic_string<charT,
traits, Allocator> shall use an object of type Allocator to allocate and free storage for the contained
charT objects as needed. The Allocator object used shall be obtained as described in 23.2.1.

4 References, pointers, and iterators referring to the elements of a basic_string sequence may be invalidated

by the following uses of that basic_string object:

(4.1)

(4.2)

1

—

—

as an argument to any standard library function taking a reference to non-const basic_string as an
argument.234
Calling non-const member functions, except operator[], at, front, back, begin, rbegin, end, and
rend.

21.4.2 basic_string constructors and assignment operators
explicit basic_string(const Allocator& a) noexcept;

[string.cons]

Eﬀects: Constructs an object of class basic_string. The postconditions of this function are indicated
in Table 63.
example,

functions swap() (21.4.8.8),

operator>>() (21.4.8.9),

and

234) For
getline() (21.4.8.9), or as an argument to basic_string::swap()

as an argument

to non-member

§ 21.4.2

662

c(cid:13) ISO/IEC

N4296

Table 63 — basic_string(const Allocator&) eﬀects

Element
data()

size()
capacity()

Value

a non-null pointer that is copyable and can have 0
added to it
0
an unspeciﬁed value

basic_string(const basic_string& str);
basic_string(basic_string&& str) noexcept;

Eﬀects: Constructs an object of class basic_string as indicated in Table 64. In the second form, str
is left in a valid state with an unspeciﬁed value.

Table 64 — basic_string(const basic_string&) eﬀects
Element
data()

Value

points at the ﬁrst element of an allocated copy
of the array whose ﬁrst element is pointed at by
str.data()
str.size()
a value at least as large as size()

size()
capacity()

basic_string(const basic_string& str,

size_type pos, size_type n = npos,
const Allocator& a = Allocator());

Requires: pos <= str.size()
Throws: out_of_range if pos > str.size().
Eﬀects: Constructs an object of class basic_string and determines the eﬀective length rlen of the
initial string value as the smaller of n and str.size() - pos, as indicated in Table 65.

Table 65 — basic_string(const basic_string&, size_type, size_type, const Allocator&) eﬀects

Element
data()

size()
capacity()

Value

points at the ﬁrst element of an allocated copy of
rlen consecutive elements of the string controlled
by str beginning at position pos
rlen
a value at least as large as size()

basic_string(const charT* s, size_type n,

const Allocator& a = Allocator());

Requires: s points to an array of at least n elements of charT.
Eﬀects: Constructs an object of class basic_string and determines its initial string value from the
array of charT of length n whose ﬁrst element is designated by s, as indicated in Table 66.

basic_string(const charT* s, const Allocator& a = Allocator());

§ 21.4.2

663

2

3

4

5

6

7

c(cid:13) ISO/IEC

N4296

Table 66 — basic_string(const charT*, size_type, const Allocator&) eﬀects

Element
data()

size()
capacity()

Value

points at the ﬁrst element of an allocated copy of
the array whose ﬁrst element is pointed at by s
n
a value at least as large as size()

Requires: s points to an array of at least traits::length(s) + 1 elements of charT.
Eﬀects: Constructs an object of class basic_string and determines its initial string value from the
array of charT of length traits::length(s) whose ﬁrst element is designated by s, as indicated in
Table 67.

Table 67 — basic_string(const charT*, const Allocator&) eﬀects

Element
data()

size()
capacity()

Value

points at the ﬁrst element of an allocated copy of
the array whose ﬁrst element is pointed at by s
traits::length(s)
a value at least as large as size()

Remarks: Uses traits::length().

basic_string(size_type n, charT c, const Allocator& a = Allocator());

Requires: n < npos
Eﬀects: Constructs an object of class basic_string and determines its initial string value by repeating
the char-like object c for all n elements, as indicated in Table 68.

Table 68 — basic_string(size_t, charT, const Allocator&) eﬀects

Element
data()

size()
capacity()

Value

points at the ﬁrst element of an allocated array of
n elements, each storing the initial value c
n
a value at least as large as size()

template<class InputIterator>

basic_string(InputIterator begin, InputIterator end,

const Allocator& a = Allocator());

Eﬀects: If InputIterator is an integral type, equivalent to

basic_string(static_cast<size_type>(begin), static_cast<value_type>(end), a)

Otherwise constructs a string from the values in the range [begin, end), as indicated in the Sequence
Requirements table (see 23.2.3).

basic_string(initializer_list<charT> il, const Allocator& a = Allocator());

Eﬀects: Same as basic_string(il.begin(), il.end(), a).

§ 21.4.2

664

8

9

10

11

12

13

14

15

c(cid:13) ISO/IEC

N4296

basic_string(const basic_string& str, const Allocator& alloc);
basic_string(basic_string&& str, const Allocator& alloc);

16

Eﬀects: Constructs an object of class basic_string as indicated in Table 69. The stored allocator is
constructed from alloc. In the second form, str is left in a valid state with an unspeciﬁed value.

17

18

19

20

21

22

23

Table 69 — basic_string(const basic_string&, const Allocator&) and

basic_string(basic_string&&, const Allocator&) eﬀects
Element

Value

data()

size()
capacity()
get_allocator()

points at the ﬁrst element of an allocated copy of
the array whose ﬁrst element is pointed at by the
original value of str.data().
the original value of str.size()
a value at least as large as size()
alloc

Throws: The second form throws nothing if alloc == str.get_allocator().

basic_string& operator=(const basic_string& str);

Eﬀects: If *this and str are not the same object, modiﬁes *this as shown in Table 70.
If *this and str are the same object, the member has no eﬀect.
Returns: *this

Table 70 — operator=(const basic_string&) eﬀects

Element
data()

size()
capacity()

Value

points at the ﬁrst element of an allocated copy
of the array whose ﬁrst element is pointed at by
str.data()
str.size()
a value at least as large as size()

basic_string& operator=(basic_string&& str)

noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||

allocator_traits<Allocator>::is_always_equal::value);

Eﬀects: If *this and str are not the same object, modiﬁes *this as shown in Table 71.
valid implementation is swap(str). — end note ]
If *this and str are the same object, the member has no eﬀect.
Returns: *this

[ Note: A

Table 71 — operator=(basic_string&&) eﬀects

Element
data()

size()
capacity()

Value

points at the array whose ﬁrst element was pointed
at by str.data()
previous value of str.size()
a value at least as large as size()

§ 21.4.2

665

c(cid:13) ISO/IEC

N4296

24

25

26

27

28

1

2

3

4

1

2

3

4

5

basic_string& operator=(const charT* s);
Returns: *this = basic_string(s).
Remarks: Uses traits::length().

basic_string& operator=(charT c);

Returns: *this = basic_string(1,c).

basic_string& operator=(initializer_list<charT> il);

Eﬀects: *this = basic_string(il).
Returns: *this.

21.4.3 basic_string iterator support
iterator
const_iterator begin() const noexcept;
const_iterator cbegin() const noexcept;

begin() noexcept;

Returns: An iterator referring to the ﬁrst character in the string.

iterator
const_iterator end() const noexcept;
const_iterator cend() const noexcept;

end() noexcept;

Returns: An iterator which is the past-the-end value.

reverse_iterator
const_reverse_iterator rbegin() const noexcept;
const_reverse_iterator crbegin() const noexcept;

rbegin() noexcept;

[string.iterators]

Returns: An iterator which is semantically equivalent to reverse_iterator(end()).

reverse_iterator
const_reverse_iterator rend() const noexcept;
const_reverse_iterator crend() const noexcept;

rend() noexcept;

Returns: An iterator which is semantically equivalent to reverse_iterator(begin()).

21.4.4 basic_string capacity
size_type size() const noexcept;

Returns: A count of the number of char-like objects currently in the string.
Complexity: Constant time.

[string.capacity]

size_type length() const noexcept;

Returns: size().

size_type max_size() const noexcept;

Returns: The size of the largest possible string.
Complexity: Constant time.

void resize(size_type n, charT c);

§ 21.4.4

666

c(cid:13) ISO/IEC

N4296

6

7

8
(8.1)

(8.2)

9

10

11

12

13

14

15

Requires: n <= max_size()
Throws: length_error if n > max_size().
Eﬀects: Alters the length of the string designated by *this as follows:
—

—

If n <= size(), the function replaces the string designated by *this with a string of length n
whose elements are a copy of the initial elements of the original string designated by *this.
If n > size(), the function replaces the string designated by *this with a string of length n
whose ﬁrst size() elements are a copy of the original string designated by *this, and whose
remaining elements are all initialized to c.

void resize(size_type n);

Eﬀects: resize(n,charT()).

size_type capacity() const noexcept;

Returns: The size of the allocated storage in the string.

void reserve(size_type res_arg=0);

The member function reserve() is a directive that informs a basic_string object of a planned change
in size, so that it can manage the storage allocation accordingly.
Eﬀects: After reserve(), capacity() is greater or equal to the argument of reserve. [ Note: Calling
reserve() with a res_arg argument less than capacity() is in eﬀect a non-binding shrink request.
A call with res_arg <= size() is in eﬀect a non-binding shrink-to-ﬁt request. — end note ]
Throws: length_error if res_arg > max_size().235

void shrink_to_fit();

Remarks: shrink_to_fit is a non-binding request to reduce capacity() to size().
request is non-binding to allow latitude for implementation-speciﬁc optimizations. — end note ]

[ Note: The

void clear() noexcept;

Eﬀects: Behaves as if the function calls:

erase(begin(), end());

bool empty() const noexcept;
Returns: size() == 0.

16

21.4.5 basic_string element access
const_reference operator[](size_type pos) const;
reference

operator[](size_type pos);

[string.access]

1

2

3

4

Requires: pos <= size().
Returns: *(begin() + pos) if pos < size(). Otherwise, returns a reference to an object of type
charT with value charT(), where modifying the object leads to undeﬁned behavior.
Throws: Nothing.
Complexity: Constant time.

235) reserve() uses allocator_traits<Allocator>::allocate() which may throw an appropriate exception.

§ 21.4.5

667

c(cid:13) ISO/IEC

N4296

5

6

7

8

9

10

1

2

3

4

5

6

7

8

1

2

const_reference at(size_type pos) const;
reference

at(size_type pos);

Throws: out_of_range if pos >= size().
Returns: operator[](pos).

const charT& front() const;
charT& front();

Requires: !empty()
Eﬀects: Equivalent to operator[](0).

const charT& back() const;
charT& back();

Requires: !empty()
Eﬀects: Equivalent to operator[](size() - 1).

21.4.6 basic_string modiﬁers
21.4.6.1 basic_string::operator+=
basic_string&

operator+=(const basic_string& str);

Eﬀects: Calls append(str).
Returns: *this.

basic_string& operator+=(const charT* s);

Eﬀects: Calls append(s).
Returns: *this.

basic_string& operator+=(charT c);

Eﬀects: Calls push_back(c);
Returns: *this.

[string.modiﬁers]
[string::op+=]

basic_string& operator+=(initializer_list<charT> il);

Eﬀects: Calls append(il).
Returns: *this.

21.4.6.2 basic_string::append
basic_string&

append(const basic_string& str);

Eﬀects: Calls append(str.data(), str.size()).
Returns: *this.

basic_string&

append(const basic_string& str, size_type pos, size_type n = npos);

[string::append]

§ 21.4.6.2

668

c(cid:13) ISO/IEC

N4296

Requires: pos <= str.size()
Throws: out_of_range if pos > str.size().
Eﬀects: Determines the eﬀective length rlen of the string to append as the smaller of n and str.size()
- pos and calls append(str.data() + pos, rlen).
Returns: *this.

basic_string&

append(const charT* s, size_type n);

Requires: s points to an array of at least n elements of charT.
Throws: length_error if size() + n > max_size().
Eﬀects: The function replaces the string controlled by *this with a string of length size() + n
whose ﬁrst size() elements are a copy of the original string controlled by *this and whose remaining
elements are a copy of the initial n elements of s.
Returns: *this.

basic_string& append(const charT* s);

Requires: s points to an array of at least traits::length(s) + 1 elements of charT.
Eﬀects: Calls append(s, traits::length(s)).
Returns: *this.

basic_string& append(size_type n, charT c);

Eﬀects: Equivalent to append(basic_string(n, c)).
Returns: *this.

template<class InputIterator>

basic_string& append(InputIterator first, InputIterator last);

Requires: [first,last) is a valid range.
Eﬀects: Equivalent to append(basic_string(first, last)).
Returns: *this.

basic_string& append(initializer_list<charT> il);

Eﬀects: Calls append(il.begin(), il.size()).
Returns: *this.

void push_back(charT c);

Eﬀects: Equivalent to append(static_cast<size_type>(1), c).

21.4.6.3 basic_string::assign
basic_string& assign(const basic_string& str);

Eﬀects: Equivalent to assign(str, 0, npos).
Returns: *this.

basic_string& assign(basic_string&& str) noexcept;

[string::assign]

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

1

2

§ 21.4.6.3

669

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

c(cid:13) ISO/IEC

N4296

Eﬀects: The function replaces the string controlled by *this with a string of length str.size() whose
elements are a copy of the string controlled by str. [ Note: A valid implementation is swap(str). —
end note ]
Returns: *this.

basic_string&

assign(const basic_string& str, size_type pos,

size_type n = npos);

Requires: pos <= str.size()
Throws: out_of_range if pos > str.size().
Eﬀects: Determines the eﬀective length rlen of the string to assign as the smaller of n and str.size()
- pos and calls assign(str.data() + pos rlen).
Returns: *this.

basic_string& assign(const charT* s, size_type n);

Requires: s points to an array of at least n elements of charT.
Throws: length_error if n > max_size().
Eﬀects: Replaces the string controlled by *this with a string of length n whose elements are a copy
of those pointed to by s.
Returns: *this.

basic_string& assign(const charT* s);

Requires: s points to an array of at least traits::length(s) + 1 elements of charT.
Eﬀects: Calls assign(s, traits::length(s)).
Returns: *this.

basic_string& assign(initializer_list<charT> il);

Eﬀects: Calls assign(il.begin(), il.size()).
*this.

basic_string& assign(size_type n, charT c);

Eﬀects: Equivalent to assign(basic_string(n, c)).
Returns: *this.

template<class InputIterator>

basic_string& assign(InputIterator first, InputIterator last);
Eﬀects: Equivalent to assign(basic_string(first, last)).
Returns: *this.

§ 21.4.6.3

670

c(cid:13) ISO/IEC

21.4.6.4 basic_string::insert
basic_string&

insert(size_type pos1,

const basic_string& str);

Requires: pos <= size().
Throws: out_of_range if pos > size().
Eﬀects: Calls insert(pos, str.data(), str.size()).
Returns: *this.

N4296

[string::insert]

basic_string&

insert(size_type pos1,

const basic_string& str,
size_type pos2, size_type n = npos);

Requires: pos1 <= size() and pos2 <= str.size()
Throws: out_of_range if pos1 > size() or pos2 > str.size().
Eﬀects: Determines the eﬀective length rlen of the string to insert as the smaller of n and str.size()
- pos2 and calls insert(pos1, str.data() + pos2, rlen).
Returns: *this.

basic_string&

insert(size_type pos, const charT* s, size_type n);

Requires: s points to an array of at least n elements of charT and pos <= size().
Throws: out_of_range if pos > size() or length_error if size() + n > max_size().
Eﬀects: Replaces the string controlled by *this with a string of length size() + n whose ﬁrst pos
elements are a copy of the initial elements of the original string controlled by *this and whose next
n elements are a copy of the elements in s and whose remaining elements are a copy of the remaining
elements of the original string controlled by *this.
Returns: *this.

basic_string&

insert(size_type pos, const charT* s);

Requires: pos <= size() and s points to an array of at least traits::length(s) + 1 elements of
charT.
Eﬀects: Equivalent to insert(pos, s, traits::length(s)).
Returns: *this.

basic_string&

insert(size_type pos, size_type n, charT c);

Eﬀects: Equivalent to insert(pos, basic_string(n, c)).
Returns: *this.

iterator insert(const_iterator p, charT c);
Requires: p is a valid iterator on *this.
Eﬀects: inserts a copy of c before the character referred to by p.
Returns: An iterator which refers to the copy of the inserted character.

§ 21.4.6.4

671

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

c(cid:13) ISO/IEC

N4296

iterator insert(const_iterator p, size_type n, charT c);

Requires: p is a valid iterator on *this.
Eﬀects: inserts n copies of c before the character referred to by p.
Returns: An iterator which refers to the copy of the ﬁrst inserted character, or p if n == 0.

template<class InputIterator>

iterator insert(const_iterator p, InputIterator first, InputIterator last);

Requires: p is a valid iterator on *this. [first,last) is a valid range.
Eﬀects: Equivalent to insert(p - begin(), basic_string(first, last)).
Returns: An iterator which refers to the copy of the ﬁrst inserted character, or p if first == last.

iterator insert(const_iterator p, initializer_list<charT> il);

Eﬀects: insert(p, il.begin(), il.end()).
Returns: An iterator which refers to the copy of the ﬁrst inserted character, or p if i1 is empty.

21.4.6.5 basic_string::erase
basic_string& erase(size_type pos = 0, size_type n = npos);

[string::erase]

Requires: pos <= size()
Throws: out_of_range if pos > size().
Eﬀects: Determines the eﬀective length xlen of the string to be removed as the smaller of n and
size() - pos.
The function then replaces the string controlled by *this with a string of length size() - xlen
whose ﬁrst pos elements are a copy of the initial elements of the original string controlled by *this,
and whose remaining elements are a copy of the elements of the original string controlled by *this
beginning at position pos + xlen.
Returns: *this.

iterator erase(const_iterator p);

Throws: Nothing.
Eﬀects: removes the character referred to by p.
Returns: An iterator which points to the element immediately following p prior to the element being
erased. If no such element exists, end() is returned.

iterator erase(const_iterator first, const_iterator last);

Requires: first and last are valid iterators on *this, deﬁning a range [first,last).
Throws: Nothing.
Eﬀects: removes the characters in the range [first,last).
Returns: An iterator which points to the element pointed to by last prior to the other elements being
erased. If no such element exists, end() is returned.

void pop_back();

Requires: !empty()
Throws: Nothing.
Eﬀects: Equivalent to erase(size() - 1, 1).

§ 21.4.6.5

672

21

22

23

24

25

26

27

28

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

c(cid:13) ISO/IEC

21.4.6.6 basic_string::replace
basic_string&

replace(size_type pos1, size_type n1,

const basic_string& str);

Requires: pos1 <= size().
Throws: out_of_range if pos1 > size().
Eﬀects: Calls replace(pos1, n1, str.data(), str.size()).
Returns: *this.

N4296

[string::replace]

basic_string&

replace(size_type pos1, size_type n1,

const basic_string& str,
size_type pos2, size_type n2 = npos);

Requires: pos1 <= size() and pos2 <= str.size().
Throws: out_of_range if pos1 > size() or pos2 > str.size().
Eﬀects: Determines the eﬀective length rlen of the string to be inserted as the smaller of n2 and
str.size() - pos2 and calls replace(pos1, n1, str.data() + pos2, rlen).
Returns: *this.

basic_string&

replace(size_type pos1, size_type n1, const charT* s, size_type n2);

Requires: pos1 <= size() and s points to an array of at least n2 elements of charT.
Throws: out_of_range if pos1 > size() or length_error if the length of the resulting string would
exceed max_size() (see below).
Eﬀects: Determines the eﬀective length xlen of the string to be removed as the smaller of n1 and
size() - pos1. If size() - xlen >= max_size() - n2 throws length_error. Otherwise, the func-
tion replaces the string controlled by *this with a string of length size() - xlen + n2 whose ﬁrst
pos1 elements are a copy of the initial elements of the original string controlled by *this, whose next
n2 elements are a copy of the initial n2 elements of s, and whose remaining elements are a copy of the
elements of the original string controlled by *this beginning at position pos + xlen.
Returns: *this.

basic_string&

replace(size_type pos, size_type n, const charT* s);

Requires: pos <= size() and s points to an array of at least traits::length(s) + 1 elements of
charT.
Eﬀects: Calls replace(pos, n, s, traits::length(s)).
Returns: *this.

basic_string&

replace(size_type pos1, size_type n1,

size_type n2, charT c);

Eﬀects: Equivalent to replace(pos1, n1, basic_string(n2, c)).
Returns: *this.

basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);

§ 21.4.6.6

673

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

c(cid:13) ISO/IEC

N4296

Requires: [begin(),i1) and [i1,i2) are valid ranges.
Eﬀects: Calls replace(i1 - begin(), i2 - i1, str).
Returns: *this.

basic_string&

replace(const_iterator i1, const_iterator i2, const charT* s, size_type n);

Requires: [begin(),i1) and [i1,i2) are valid ranges and s points to an array of at least n elements
of charT.
Eﬀects: Calls replace(i1 - begin(), i2 - i1, s, n).
Returns: *this.

basic_string& replace(const_iterator i1, const_iterator i2, const charT* s);

Requires: [begin(),i1) and [i1,i2) are valid ranges and s points to an array of at least traits::
length(s) + 1 elements of charT.
Eﬀects: Calls replace(i1 - begin(), i2 - i1, s, traits::length(s)).
Returns: *this.

basic_string& replace(const_iterator i1, const_iterator i2, size_type n,

charT c);

Requires: [begin(),i1) and [i1,i2) are valid ranges.
Eﬀects: Calls replace(i1 - begin(), i2 - i1, basic_string(n, c)).
Returns: *this.

template<class InputIterator>

basic_string& replace(const_iterator i1, const_iterator i2,
InputIterator j1, InputIterator j2);

Requires: [begin(),i1), [i1,i2) and [j1,j2) are valid ranges.
Eﬀects: Calls replace(i1 - begin(), i2 - i1, basic_string(j1, j2)).
Returns: *this.

basic_string& replace(const_iterator i1, const_iterator i2,

initializer_list<charT> il);

Requires: [begin(),i1) and [i1,i2) are valid ranges.
Eﬀects: Calls replace(i1 - begin(), i2 - i1, il.begin(), il.size()).
Returns: *this.

21.4.6.7 basic_string::copy
size_type copy(charT* s, size_type n, size_type pos = 0) const;

[string::copy]

Requires: pos <= size()
Throws: out_of_range if pos > size().
Eﬀects: Determines the eﬀective length rlen of the string to copy as the smaller of n and size() -
pos. s shall designate an array of at least rlen elements.
The function then replaces the string designated by s with a string of length rlen whose elements are
a copy of the string controlled by *this beginning at position pos.
The function does not append a null object to the string designated by s.
Returns: rlen.

§ 21.4.6.7

674

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

1

2

3

4

c(cid:13) ISO/IEC

21.4.6.8 basic_string::swap
void swap(basic_string& s)

noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||

allocator_traits<Allocator>::is_always_equal::value);

N4296

[string::swap]

1

2

3

1

2

3

4

1

(1.1)

(1.2)
2

3

4

5

6

7

Postcondition: *this contains the same sequence of characters that was in s, s contains the same
sequence of characters that was in *this.
Throws: Nothing.
Complexity: Constant time.

21.4.7 basic_string string operations
21.4.7.1 basic_string accessors
const charT* c_str() const noexcept;
const charT* data() const noexcept;

[string.ops]
[string.accessors]

Returns: A pointer p such that p + i == &operator[](i) for each i in [0,size()].
Complexity: Constant time.
Requires: The program shall not alter any of the values stored in the character array.

allocator_type get_allocator() const noexcept;

Returns: A copy of the Allocator object used to construct the string or, if that allocator has been
replaced, a copy of the most recent replacement.

21.4.7.2 basic_string::find
size_type find(const basic_string& str,

size_type pos = 0) const noexcept;

[string::ﬁnd]

Eﬀects: Determines the lowest position xpos, if possible, such that both of the following conditions
obtain:
—
—
Returns: xpos if the function can determine such a value for xpos. Otherwise, returns npos.
Remarks: Uses traits::eq().

pos <= xpos and xpos + str.size() <= size();
traits::eq(at(xpos+I), str.at(I)) for all elements I of the string controlled by str.

size_type find(const charT* s, size_type pos, size_type n) const;

Returns: find(basic_string(s,n),pos).

size_type find(const charT* s, size_type pos = 0) const;

Requires: s points to an array of at least traits::length(s) + 1 elements of charT.
Returns: find(basic_string(s), pos).

size_type find(charT c, size_type pos = 0) const;

Returns: find(basic_string(1,c), pos).

§ 21.4.7.2

675

1

(1.1)

(1.2)
2

3

4

5

6

7

1

(1.1)

(1.2)
2

3

4

5

6

7

c(cid:13) ISO/IEC

21.4.7.3 basic_string::rfind
size_type rfind(const basic_string& str,

size_type pos = npos) const noexcept;

N4296

[string::rﬁnd]

Eﬀects: Determines the highest position xpos, if possible, such that both of the following conditions
obtain:
—
—
Returns: xpos if the function can determine such a value for xpos. Otherwise, returns npos.
Remarks: Uses traits::eq().

xpos <= pos and xpos + str.size() <= size();
traits::eq(at(xpos+I), str.at(I)) for all elements I of the string controlled by str.

size_type rfind(const charT* s, size_type pos, size_type n) const;

Returns: rfind(basic_string(s, n), pos).

size_type rfind(const charT* s, size_type pos = npos) const;

Requires: s points to an array of at least traits::length(s) + 1 elements of charT.
Returns: rfind(basic_string(s), pos).

size_type rfind(charT c, size_type pos = npos) const;

Returns: rfind(basic_string(1,c),pos).

21.4.7.4 basic_string::find_first_of
size_type

find_first_of(const basic_string& str,

size_type pos = 0) const noexcept;

[string::ﬁnd.ﬁrst.of]

Eﬀects: Determines the lowest position xpos, if possible, such that both of the following conditions
obtain:
pos <= xpos and xpos < size();
—
traits::eq(at(xpos), str.at(I)) for some element I of the string controlled by str.
—
Returns: xpos if the function can determine such a value for xpos. Otherwise, returns npos.
Remarks: Uses traits::eq().

size_type

find_first_of(const charT* s, size_type pos, size_type n) const;

Returns: find_first_of(basic_string(s, n), pos).

size_type find_first_of(const charT* s, size_type pos = 0) const;

Requires: s points to an array of at least traits::length(s) + 1 elements of charT.
Returns: find_first_of(basic_string(s), pos).

size_type find_first_of(charT c, size_type pos = 0) const;

Returns: find_first_of(basic_string(1,c), pos).

§ 21.4.7.4

676

c(cid:13) ISO/IEC

21.4.7.5 basic_string::find_last_of
size_type

find_last_of(const basic_string& str,

size_type pos = npos) const noexcept;

N4296

[string::ﬁnd.last.of]

Eﬀects: Determines the highest position xpos, if possible, such that both of the following conditions
obtain:
xpos <= pos and xpos < size();
—
traits::eq(at(xpos), str.at(I)) for some element I of the string controlled by str.
—
Returns: xpos if the function can determine such a value for xpos. Otherwise, returns npos.
Remarks: Uses traits::eq().

size_type find_last_of(const charT* s, size_type pos, size_type n) const;

Returns: find_last_of(basic_string(s, n), pos).

size_type find_last_of(const charT* s, size_type pos = npos) const;

Requires: s points to an array of at least traits::length(s) + 1 elements of charT.
Returns: find_last_of(basic_string(s), pos).

size_type find_last_of(charT c, size_type pos = npos) const;

Returns: find_last_of(basic_string(1,c),pos).

21.4.7.6 basic_string::find_first_not_of
size_type

find_first_not_of(const basic_string& str,

size_type pos = 0) const noexcept;

[string::ﬁnd.ﬁrst.not.of]

Eﬀects: Determines the lowest position xpos, if possible, such that both of the following conditions
obtain:
pos <= xpos and xpos < size();
—
traits::eq(at(xpos), str.at(I)) for no element I of the string controlled by str.
—
Returns: xpos if the function can determine such a value for xpos. Otherwise, returns npos.
Remarks: Uses traits::eq().

size_type

find_first_not_of(const charT* s, size_type pos, size_type n) const;

Returns: find_first_not_of(basic_string(s, n), pos).

size_type find_first_not_of(const charT* s, size_type pos = 0) const;

Requires: s points to an array of at least traits::length(s) + 1 elements of charT.
Returns: find_first_not_of(basic_string(s), pos).

size_type find_first_not_of(charT c, size_type pos = 0) const;
Returns: find_first_not_of(basic_string(1, c), pos).

§ 21.4.7.6

677

1

(1.1)

(1.2)
2

3

4

5

6

7

1

(1.1)

(1.2)
2

3

4

5

6

7

c(cid:13) ISO/IEC

21.4.7.7 basic_string::find_last_not_of
size_type

find_last_not_of(const basic_string& str,

size_type pos = npos) const noexcept;

N4296

[string::ﬁnd.last.not.of]

1

(1.1)

(1.2)
2

3

4

5

6

7

1

2

3

4

1

2

Eﬀects: Determines the highest position xpos, if possible, such that both of the following conditions
obtain:
xpos <= pos and xpos < size();
—
traits::eq(at(xpos), str.at(I)) for no element I of the string controlled by str.
—
Returns: xpos if the function can determine such a value for xpos. Otherwise, returns npos.
Remarks: Uses traits::eq().

size_type find_last_not_of(const charT* s, size_type pos,

size_type n) const;

Returns: find_last_not_of(basic_string(s, n), pos).

size_type find_last_not_of(const charT* s, size_type pos = npos) const;

Requires: s points to an array of at least traits::length(s) + 1 elements of charT.
Returns: find_last_not_of(basic_string(s), pos).

size_type find_last_not_of(charT c, size_type pos = npos) const;

Returns: find_last_not_of(basic_string(1, c), pos).

21.4.7.8 basic_string::substr
basic_string substr(size_type pos = 0, size_type n = npos) const;

[string::substr]

Requires: pos <= size()
Throws: out_of_range if pos > size().
Eﬀects: Determines the eﬀective length rlen of the string to copy as the smaller of n and size() -
pos.
Returns: basic_string(data()+pos,rlen).

21.4.7.9 basic_string::compare
int compare(const basic_string& str) const noexcept;

[string::compare]

Eﬀects: Determines the eﬀective length rlen of the strings to compare as the smallest of size()
and str.size(). The function then compares the two strings by calling traits::compare(data(),
str.data(), rlen).
Returns: The nonzero result if the result of the comparison is nonzero. Otherwise, returns a value as
indicated in Table 72.

Table 72 — compare() results
Condition

Return Value

str.size()
size() <
size() == str.size()
size() >
str.size()

< 0
0
> 0

§ 21.4.7.9

678

c(cid:13) ISO/IEC

N4296

int compare(size_type pos1, size_type n1,

const basic_string& str) const;

Returns: basic_string(*this,pos1,n1).compare(str).

int compare(size_type pos1, size_type n1,

const basic_string& str,
size_type pos2, size_type n2 = npos) const;

Returns: basic_string(*this, pos1, n1).compare(basic_string(str, pos2, n2)).

int compare(const charT* s) const;

Returns: compare(basic_string(s)).

int compare(size_type pos, size_type n1,

const charT* s) const;

Returns: basic_string(*this, pos, n1).compare(basic_string(s)).

int compare(size_type pos, size_type n1,

const charT* s, size_type n2) const;

Returns: basic_string(*this, pos, n1).compare(basic_string(s, n2)).

21.4.8 basic_string non-member functions
21.4.8.1 operator+
template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(const basic_string<charT,traits,Allocator>& lhs,
const basic_string<charT,traits,Allocator>& rhs);

Returns: basic_string<charT,traits,Allocator>(lhs).append(rhs)

[string.nonmembers]
[string::op+]

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(basic_string<charT,traits,Allocator>&& lhs,

const basic_string<charT,traits,Allocator>& rhs);

Returns: std::move(lhs.append(rhs))

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(const basic_string<charT,traits,Allocator>& lhs,

basic_string<charT,traits,Allocator>&& rhs);

Returns: std::move(rhs.insert(0, lhs))

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(basic_string<charT,traits,Allocator>&& lhs,
basic_string<charT,traits,Allocator>&& rhs);

Returns: std::move(lhs.append(rhs)) [ Note: Or equivalently std::move(rhs.insert(0, lhs))
— end note ]

3

4

5

6

7

1

2

3

4

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(const charT* lhs,

const basic_string<charT,traits,Allocator>& rhs);

§ 21.4.8.1

679

5

6

7

8

9

10

11

12

13

14

15

16

c(cid:13) ISO/IEC

N4296

Returns: basic_string<charT,traits,Allocator>(lhs) + rhs.
Remarks: Uses traits::length().

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(const charT* lhs,

basic_string<charT,traits,Allocator>&& rhs);

Returns: std::move(rhs.insert(0, lhs)).
Remarks: Uses traits::length().

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(charT lhs,

const basic_string<charT,traits,Allocator>& rhs);

Returns: basic_string<charT,traits,Allocator>(1,lhs) + rhs.

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(charT lhs,

basic_string<charT,traits,Allocator>&& rhs);

Returns: std::move(rhs.insert(0, 1, lhs)).

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(const basic_string<charT,traits,Allocator>& lhs,

const charT* rhs);

Returns: lhs + basic_string<charT,traits,Allocator>(rhs).
Remarks: Uses traits::length().

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(basic_string<charT,traits,Allocator>&& lhs,

const charT* rhs);

Returns: std::move(lhs.append(rhs)).
Remarks: Uses traits::length().

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(const basic_string<charT,traits,Allocator>& lhs,

charT rhs);

Returns: lhs + basic_string<charT,traits,Allocator>(1,rhs).

template<class charT, class traits, class Allocator>

basic_string<charT,traits,Allocator>

operator+(basic_string<charT,traits,Allocator>&& lhs,

charT rhs);

Returns: std::move(lhs.append(1, rhs)).

§ 21.4.8.1

680

c(cid:13) ISO/IEC

21.4.8.2 operator==
template<class charT, class traits, class Allocator>

bool operator==(const basic_string<charT,traits,Allocator>& lhs,

const basic_string<charT,traits,Allocator>& rhs) noexcept;

N4296

[string::operator==]

1

2

3

4

1

2

3

4

1

2

3

Returns: lhs.compare(rhs) == 0.

template<class charT, class traits, class Allocator>

bool operator==(const charT* lhs,

const basic_string<charT,traits,Allocator>& rhs);

Returns: rhs == lhs.

template<class charT, class traits, class Allocator>

bool operator==(const basic_string<charT,traits,Allocator>& lhs,

const charT* rhs);

Requires: rhs points to an array of at least traits::length(rhs) + 1 elements of charT.
Returns: lhs.compare(rhs) == 0.

21.4.8.3 operator!=
template<class charT, class traits, class Allocator>

bool operator!=(const basic_string<charT,traits,Allocator>& lhs,

const basic_string<charT,traits,Allocator>& rhs) noexcept;

[string::op!=]

Returns: !(lhs == rhs).

template<class charT, class traits, class Allocator>

bool operator!=(const charT* lhs,

const basic_string<charT,traits,Allocator>& rhs);

Returns: rhs != lhs.

template<class charT, class traits, class Allocator>

bool operator!=(const basic_string<charT,traits,Allocator>& lhs,

const charT* rhs);

Requires: rhs points to an array of at least traits::length(rhs) + 1 elements of charT.
Returns: lhs.compare(rhs) != 0.

21.4.8.4 operator<
template<class charT, class traits, class Allocator>

bool operator< (const basic_string<charT,traits,Allocator>& lhs,

const basic_string<charT,traits,Allocator>& rhs) noexcept;

[string::op<]

Returns: lhs.compare(rhs) < 0.

template<class charT, class traits, class Allocator>

bool operator< (const charT* lhs,

const basic_string<charT,traits,Allocator>& rhs);

Returns: rhs.compare(lhs) > 0.

template<class charT, class traits, class Allocator>

bool operator< (const basic_string<charT,traits,Allocator>& lhs,

const charT* rhs);
Returns: lhs.compare(rhs) < 0.

§ 21.4.8.4

681

c(cid:13) ISO/IEC

21.4.8.5 operator>
template<class charT, class traits, class Allocator>

bool operator> (const basic_string<charT,traits,Allocator>& lhs,

const basic_string<charT,traits,Allocator>& rhs) noexcept;

Returns: lhs.compare(rhs) > 0.

template<class charT, class traits, class Allocator>

bool operator> (const charT* lhs,

const basic_string<charT,traits,Allocator>& rhs);

Returns: rhs.compare(lhs) < 0.

template<class charT, class traits, class Allocator>

bool operator> (const basic_string<charT,traits,Allocator>& lhs,

const charT* rhs);
Returns: lhs.compare(rhs) > 0.

21.4.8.6 operator<=
template<class charT, class traits, class Allocator>

bool operator<=(const basic_string<charT,traits,Allocator>& lhs,

const basic_string<charT,traits,Allocator>& rhs) noexcept;

Returns: lhs.compare(rhs) <= 0.

template<class charT, class traits, class Allocator>

bool operator<=(const charT* lhs,

const basic_string<charT,traits,Allocator>& rhs);

Returns: rhs.compare(lhs) >= 0.

template<class charT, class traits, class Allocator>

bool operator<=(const basic_string<charT,traits,Allocator>& lhs,

const charT* rhs);

Returns: lhs.compare(rhs) <= 0.

21.4.8.7 operator>=
template<class charT, class traits, class Allocator>

bool operator>=(const basic_string<charT,traits,Allocator>& lhs,

const basic_string<charT,traits,Allocator>& rhs) noexcept;

N4296

[string::op>]

[string::op<=]

[string::op>=]

Returns: lhs.compare(rhs) >= 0.

template<class charT, class traits, class Allocator>

bool operator>=(const charT* lhs,

const basic_string<charT,traits,Allocator>& rhs);

Returns: rhs.compare(lhs) <= 0.

template<class charT, class traits, class Allocator>

bool operator>=(const basic_string<charT,traits,Allocator>& lhs,

const charT* rhs);

Returns: lhs.compare(rhs) >= 0.

§ 21.4.8.7

682

1

2

3

1

2

3

1

2

3

c(cid:13) ISO/IEC

21.4.8.8 swap
template<class charT, class traits, class Allocator>

void swap(basic_string<charT,traits,Allocator>& lhs,
basic_string<charT,traits,Allocator>& rhs)

noexcept(noexcept(lhs.swap(rhs)));
Eﬀects: Equivalent to lhs.swap(rhs);

Inserters and extractors

21.4.8.9
template<class charT, class traits, class Allocator>

basic_istream<charT,traits>&

operator>>(basic_istream<charT,traits>& is,

basic_string<charT,traits,Allocator>& str);

N4296

[string.special]

[string.io]

Eﬀects: Behaves as a formatted input function (27.7.2.2.1). After constructing a sentry object, if the
sentry converts to true, calls str.erase() and then extracts characters from is and appends them to
str as if by calling str.append(1,c). If is.width() is greater than zero, the maximum number n
of characters appended is is.width(); otherwise n is str.max_size(). Characters are extracted and
appended until any of the following occurs:
—
—
—
After the last character (if any) is extracted, is.width(0) is called and the sentry object k is de-
stroyed.
If the function extracts no characters, it calls is.setstate(ios::failbit), which may throw ios_-
base::failure (27.5.5.4).
Returns: is

n characters are stored;
end-of-ﬁle occurs on the input sequence;
isspace(c,is.getloc()) is true for the next available input character c.

template<class charT, class traits, class Allocator>

basic_ostream<charT, traits>&

operator<<(basic_ostream<charT, traits>& os,

const basic_string<charT,traits,Allocator>& str);

Eﬀects: Behaves as a formatted output function (27.7.3.6.1) of os. Forms a character sequence seq,
initially consisting of the elements deﬁned by the range [str.begin(), str.end()). Determines
padding for seq as described in 27.7.3.6.1. Then inserts seq as if by calling os.rdbuf()->sputn(seq,
n), where n is the larger of os.width() and str.size(); then calls os.width(0).
Returns: os

template<class charT, class traits, class Allocator>

basic_istream<charT,traits>&

getline(basic_istream<charT,traits>& is,

basic_string<charT,traits,Allocator>& str,
charT delim);

template<class charT, class traits, class Allocator>

basic_istream<charT,traits>&

getline(basic_istream<charT,traits>&& is,

basic_string<charT,traits,Allocator>& str,
charT delim);

Eﬀects: Behaves as an unformatted input function (27.7.2.3), except that it does not aﬀect the value
returned by subsequent calls to basic_istream<>::gcount(). After constructing a sentry object,
if the sentry converts to true, calls str.erase() and then extracts characters from is and appends
them to str as if by calling str.append(1, c) until any of the following occurs:

§ 21.4.8.9

683

1

1

(1.1)
(1.2)
(1.3)
2

3

4

5

6

7

c(cid:13) ISO/IEC

N4296

(7.1)

(7.2)

(7.3)

8

9

10

—

—

—

end-of-ﬁle occurs on the input sequence (in which case, the getline function calls is.setstate(
ios_base::eofbit)).
traits::eq(c, delim) for the next available input character c (in which case, c is extracted but
not appended) (27.5.5.4)
str.max_size() characters are stored (in which case, the function calls is.setstate(ios_base
::failbit)) (27.5.5.4)

The conditions are tested in the order shown. In any case, after the last character is extracted, the
sentry object k is destroyed.
If the function extracts no characters, it calls is.setstate(ios_base::failbit) which may throw
ios_base::failure (27.5.5.4).
Returns: is.

template<class charT, class traits, class Allocator>

basic_istream<charT,traits>&

getline(basic_istream<charT,traits>& is,

basic_string<charT,traits,Allocator>& str);

template<class charT, class traits, class Allocator>

basic_istream<charT,traits>&

getline(basic_istream<charT,traits>&& is,

basic_string<charT,traits,Allocator>& str);

11

Returns: getline(is,str,is.widen(’\n’))

21.5 Numeric conversions
int stoi(const string& str, size_t* idx = 0, int base = 10);
long stol(const string& str, size_t* idx = 0, int base = 10);
unsigned long stoul(const string& str, size_t* idx = 0, int base = 10);
long long stoll(const string& str, size_t* idx = 0, int base = 10);
unsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);

[string.conversions]

1

2

3

4

5

the ﬁrst two functions call strtol(str.c_str(), ptr, base), and the last three func-
Eﬀects:
tions call strtoul(str.c_str(), ptr, base), strtoll(str.c_str(), ptr, base), and strtoull(
str.c_str(), ptr, base), respectively. Each function returns the converted result, if any. The ar-
gument ptr designates a pointer to an object internal to the function that is used to determine what
to store at *idx. If the function does not throw an exception and idx != 0, the function stores in
*idx the index of the ﬁrst unconverted element of str.
Returns: The converted result.
Throws: invalid_argument if strtol, strtoul, strtoll, or strtoull reports that no conversion
could be performed. Throws out_of_range if strtol, strtoul, strtoll or strtoull sets errno to
ERANGE, or if the converted value is outside the range of representable values for the return type.

float stof(const string& str, size_t* idx = 0);
double stod(const string& str, size_t* idx = 0);
long double stold(const string& str, size_t* idx = 0);

Eﬀects: the ﬁrst two functions call strtod(str.c_str(), ptr) and the third function calls strtold(
str.c_str(), ptr). Each function returns the converted result, if any. The argument ptr designates
a pointer to an object internal to the function that is used to determine what to store at *idx. If the
function does not throw an exception and idx != 0, the function stores in *idx the index of the ﬁrst
unconverted element of str.
Returns: The converted result.

§ 21.5

684

6

7

8

9

10

11

12

13

c(cid:13) ISO/IEC

N4296

Throws: invalid_argument if strtod or strtold reports that no conversion could be performed.
Throws out_of_range if strtod or strtold sets errno to ERANGE or if the converted value is outside
the range of representable values for the return type.

string to_string(int val);
string to_string(unsigned val);
string to_string(long val);
string to_string(unsigned long val);
string to_string(long long val);
string to_string(unsigned long long val);
string to_string(float val);
string to_string(double val);
string to_string(long double val);

Returns: Each function returns a string object holding the character representation of the value of
its argument that would be generated by calling sprintf(buf, fmt, val) with a format speciﬁer of
"%d", "%u", "%ld", "%lu", "%lld", "%llu", "%f", "%f", or "%Lf", respectively, where buf designates
an internal character buﬀer of suﬃcient size.

int stoi(const wstring& str, size_t* idx = 0, int base = 10);
long stol(const wstring& str, size_t* idx = 0, int base = 10);
unsigned long stoul(const wstring& str, size_t* idx = 0, int base = 10);
long long stoll(const wstring& str, size_t* idx = 0, int base = 10);
unsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);

the ﬁrst two functions call wcstol(str.c_str(), ptr, base), and the last three func-
Eﬀects:
tions call wcstoul(str.c_str(), ptr, base), wcstoll(str.c_str(), ptr, base), and wcstoull(
str.c_str(), ptr, base), respectively. Each function returns the converted result, if any. The ar-
gument ptr designates a pointer to an object internal to the function that is used to determine what
to store at *idx. If the function does not throw an exception and idx != 0, the function stores in
*idx the index of the ﬁrst unconverted element of str.
Returns: The converted result.
Throws: invalid_argument if wcstol, wcstoul, wcstoll, or wcstoull reports that no conversion
could be performed. Throws out_of_range if the converted value is outside the range of representable
values for the return type.

float stof(const wstring& str, size_t* idx = 0);
double stod(const wstring& str, size_t* idx = 0);
long double stold(const wstring& str, size_t* idx = 0);

Eﬀects: the ﬁrst two functions call wcstod(str.c_str(), ptr) and the third function calls wcstold(
str.c_str(), ptr). Each function returns the converted result, if any. The argument ptr designates
a pointer to an object internal to the function that is used to determine what to store at *idx. If the
function does not throw an exception and idx != 0, the function stores in *idx the index of the ﬁrst
unconverted element of str.
Returns: The converted result.
Throws: invalid_argument if wcstod or wcstold reports that no conversion could be performed.
Throws out_of_range if wcstod or wcstold sets errno to ERANGE.

wstring to_wstring(int val);
wstring to_wstring(unsigned val);
wstring to_wstring(long val);
wstring to_wstring(unsigned long val);
wstring to_wstring(long long val);

§ 21.5

685

c(cid:13) ISO/IEC

N4296

wstring to_wstring(unsigned long long val);
wstring to_wstring(float val);
wstring to_wstring(double val);
wstring to_wstring(long double val);

Returns: Each function returns a wstring object holding the character representation of the value of
its argument that would be generated by calling swprintf(buf, buffsz, fmt, val) with a format
speciﬁer of L"%d", L"%u", L"%ld", L"%lu", L"%lld", L"%llu", L"%f", L"%f", or L"%Lf", respectively,
where buf designates an internal character buﬀer of suﬃcient size buffsz.

21.6 Hash support
template <> struct hash<string>;
template <> struct hash<u16string>;
template <> struct hash<u32string>;
template <> struct hash<wstring>;

[basic.string.hash]

The template specializations shall meet the requirements of class template hash (20.9.13).

[basic.string.literals]

21.7 Suﬃx for basic_string literals
string operator "" s(const char* str, size_t len);

Returns: string{str,len}

u16string operator "" s(const char16_t* str, size_t len);

Returns: u16string{str,len}

u32string operator "" s(const char32_t* str, size_t len);

Returns: u32string{str,len}

wstring operator "" s(const wchar_t* str, size_t len);

Returns: wstring{str,len}

[ Note: The same suﬃx s is used for chrono::duration literals denoting seconds but there is no conﬂict,
since duration suﬃxes apply to numbers and string literal suﬃxes apply to character array literals. — end
note ]
21.8 Null-terminated sequence utilities

[c.strings]
1 Tables 74, 75, 76, 77, 78, and 79 describe headers <cctype>, <cwctype>, <cstring>, <cwchar>, <cstdlib>

14

1

1

2

3

4

5

(character conversions), and <cuchar>, respectively.

2 The contents of these headers shall be the same as the Standard C Library headers <ctype.h>, <wctype.h>,
<string.h>, <wchar.h>, and <stdlib.h> and the C Unicode TR header <uchar.h>, respectively, with the
following modiﬁcations:

3 The headers shall not deﬁne the types char16_t, char32_t, and wchar_t (2.11).
4 The function signature strchr(const char*, int) shall be replaced by the two declarations:

const char* strchr(const char* s, int c);
char* s, int c);

char* strchr(

both of which shall have the same behavior as the original declaration.

5 The function signature strpbrk(const char*, const char*) shall be replaced by the two declarations:

const char* strpbrk(const char* s1, const char* s2);
char* s1, const char* s2);

char* strpbrk(

§ 21.8

686

c(cid:13) ISO/IEC

N4296

both of which shall have the same behavior as the original declaration.

6 The function signature strrchr(const char*, int) shall be replaced by the two declarations:

const char* strrchr(const char* s, int c);
char* s, int c);

char* strrchr(

both of which shall have the same behavior as the original declaration.

7 The function signature strstr(const char*, const char*) shall be replaced by the two declarations:

const char* strstr(const char* s1, const char* s2);
char* s1, const char* s2);

char* strstr(

both of which shall have the same behavior as the original declaration.

8 The function signature memchr(const void*, int, size_t) shall be replaced by the two declarations:

const void* memchr(const void* s, int c, size_t n);
void* s, int c, size_t n);

void* memchr(

both of which shall have the same behavior as the original declaration.

9 The function signature wcschr(const wchar_t*, wchar_t) shall be replaced by the two declarations:

const wchar_t* wcschr(const wchar_t* s, wchar_t c);
wchar_t* s, wchar_t c);

wchar_t* wcschr(

both of which shall have the same behavior as the original declaration.

10 The function signature wcspbrk(const wchar_t*, const wchar_t*) shall be replaced by the two declara-

tions:

const wchar_t* wcspbrk(const wchar_t* s1, const wchar_t* s2);
wchar_t* s1, const wchar_t* s2);

wchar_t* wcspbrk(

both of which shall have the same behavior as the original declaration.

11 The function signature wcsrchr(const wchar_t*, wchar_t) shall be replaced by the two declarations:

const wchar_t* wcsrchr(const wchar_t* s, wchar_t c);
wchar_t* s, wchar_t c);

wchar_t* wcsrchr(

both of which shall have the same behavior as the original declaration.

12 The function signature wcsstr(const wchar_t*, const wchar_t*) shall be replaced by the two declara-

tions:

const wchar_t* wcsstr(const wchar_t* s1, const wchar_t* s2);
wchar_t* s1, const wchar_t* s2);

wchar_t* wcsstr(

both of which shall have the same behavior as the original declaration.

13 The function signature wmemchr(const wwchar_t*, int, size_t) shall be replaced by the two declara-

tions:

const wchar_t* wmemchr(const wchar_t* s, wchar_t c, size_t n);
wchar_t* s, wchar_t c, size_t n);

wchar_t* wmemchr(

both of which shall have the same behavior as the original declaration.

14 The functions strerror and strtok are not required to avoid data races (17.6.5.9).
15 Calling the functions listed in Table 73 with an mbstate_t* argument of NULL may introduce a data

race (17.6.5.9) with other calls to these functions with an mbstate_t* argument of NULL.
See also: ISO C 7.3, 7.10.7, 7.10.8, and 7.11. Amendment 1 4.4, 4.5, and 4.6.

§ 21.8

687

c(cid:13) ISO/IEC

N4296

Table 73 — Potential mbstate_t data races

mbrlen
wcsrtomb

mbrtowc
wctomb

mbsrtowc

mbtowc

wcrtomb

Type
Functions:
isalnum
tolower
toupper

Type

Macro:
Types:
Functions:
iswalnum
iswalpha
iswblank
iswcntrl

Type

Macro:
Type:
Functions:
memchr
memcmp
memcpy
memmove
memset

Table 74 — Header <cctype> synopsis

Name(s)

isblank
isalpha
iscntrl

isdigit
isgraph
islower

isprint
ispunct
isspace

isupper
isxdigit

Table 75 — Header <cwctype> synopsis

Name(s)

WEOF
wctrans_t

iswctype
iswdigit
iswgraph
iswlower

wctype_t

iswprint
iswpunct
iswspace
iswupper

wint_t

iswxdigit
towctrans
towlower
towupper

wctrans
wctype

Table 76 — Header <cstring> synopsis

Name(s)

NULL <cstring>
size_t <cstring>

strcat
strchr
strcmp
strcoll
strcpy

strcspn
strerror
strlen
strncat
strncmp

strncpy
strpbrk
strrchr
strspn
strstr

strtok
strxfrm

§ 21.8

688

c(cid:13) ISO/IEC

N4296

Type
Macros:
Types:
Functions:
btowc
fgetwc
fgetws
fputwc
fputws
fwide
fwprintf
fwscanf
getwchar
getwc
mbrlen
mbrtowc

Table 77 — Header <cwchar> synopsis

Name(s)

NULL
mbstate_t

mbsinit
mbsrtowcs
putwchar
putwc
swprintf
swscanf
ungetwc
vfwprintf
vfwscanf
vswprintf
vswscanf
vwprintf

WCHAR_MAX
wint_t

vwscanf
wcrtomb
wcscat
wcschr
wcscmp
wcscoll
wcscpy
wcscspn
wcsftime
wcslen
wcsncat
wcsncmp

WCHAR_MIN
size_t

wcsncpy
wcspbrk
wcsrchr
wcsrtombs
wcsspn
wcsstr
wcstod
wcstof
wcstok
wcstold
wcstoll
wcstol

WEOF
tm

wcstoull
wcstoul
wcsxfrm
wctob
wmemchr
wmemcmp
wmemcpy
wmemmove
wmemset
wprintf
wscanf

Type

Macros:
Functions:
atof
atoi
atol
atoll

Table 78 — Header <cstdlib> synopsis

Name(s)

MB_CUR_MAX

mblen
mbtowc
mbstowcs
strtod

strtof
strtol
strtold
strtoll

strtoul
strtoull
wctomb
wcstombs

Type

Macros:

Functions:

Table 79 — Header <cuchar> synopsis

Name(s)

__STDC_UTF_16__
__STDC_UTF_32__
mbrtoc16
mbrtoc32

c16rtomb
c32rtomb

§ 21.8

689

c(cid:13) ISO/IEC

N4296

22 Localization library
22.1 General

[localization]
[localization.general]
1 This Clause describes components that C++ programs may use to encapsulate (and therefore be more
portable when confronting) cultural diﬀerences. The locale facility includes internationalization support for
character classiﬁcation and string collation, numeric, monetary, and date/time formatting and parsing, and
message retrieval.

2 The following subclauses describe components for locales themselves, the standard facets, and facilities from

the ISO C library, as summarized in Table 80.

Table 80 — Localization library summary

Subclause

22.3 Locales
22.4
22.5
22.6 C library locales

Standard locale Categories
Standard code conversion facets

Header(s)
<locale>

<codecvt>
<clocale>

22.2 Header <locale> synopsis

[locale.syn]

namespace std {

// 22.3.1, locale:
class locale;
template <class Facet> const Facet& use_facet(const locale&);
template <class Facet> bool

has_facet(const locale&) noexcept;

// 22.3.3, convenience interfaces:
template <class charT> bool isspace (charT c, const locale& loc);
template <class charT> bool isprint (charT c, const locale& loc);
template <class charT> bool iscntrl (charT c, const locale& loc);
template <class charT> bool isupper (charT c, const locale& loc);
template <class charT> bool islower (charT c, const locale& loc);
template <class charT> bool isalpha (charT c, const locale& loc);
template <class charT> bool isdigit (charT c, const locale& loc);
template <class charT> bool ispunct (charT c, const locale& loc);
template <class charT> bool isxdigit(charT c, const locale& loc);
template <class charT> bool isalnum (charT c, const locale& loc);
template <class charT> bool isgraph (charT c, const locale& loc);
template <class charT> bool isblank (charT c, const locale& loc);
template <class charT> charT toupper(charT c, const locale& loc);
template <class charT> charT tolower(charT c, const locale& loc);
template <class Codecvt, class Elem = wchar_t,

class Wide_alloc = std::allocator<Elem>,
class Byte_alloc = std::allocator<char> > class wstring_convert;

template <class Codecvt, class Elem = wchar_t,

class Tr = char_traits<Elem>> class wbuffer_convert;

// 22.4.1, ctype:
class ctype_base;

§ 22.2

690

c(cid:13) ISO/IEC

N4296

template <class charT> class ctype;
template <>
class ctype<char>;
template <class charT> class ctype_byname;
class codecvt_base;
template <class internT, class externT, class stateT> class codecvt;
template <class internT, class externT, class stateT> class codecvt_byname;

// specialization

// 22.4.2, numeric:
template <class charT, class InputIterator = istreambuf_iterator<charT> >
class num_get;
template <class charT, class OutputIterator = ostreambuf_iterator<charT> > class num_put;
template <class charT> class numpunct;
template <class charT> class numpunct_byname;

// 22.4.4, collation:
template <class charT> class collate;
template <class charT> class collate_byname;

// 22.4.5, date and time:
class time_base;
template <class charT, class InputIterator = istreambuf_iterator<charT> >

template <class charT, class InputIterator = istreambuf_iterator<charT> >

class time_get;

class time_get_byname;

class time_put;

template <class charT, class OutputIterator = ostreambuf_iterator<charT> >

template <class charT, class OutputIterator = ostreambuf_iterator<charT> >

class time_put_byname;

// 22.4.6, money:
class money_base;
template <class charT, class InputIterator = istreambuf_iterator<charT> >
class money_get;
template <class charT, class OutputIterator = ostreambuf_iterator<charT> > class money_put;
template <class charT, bool Intl = false> class moneypunct;
template <class charT, bool Intl = false> class moneypunct_byname;

// 22.4.7, message retrieval:
class messages_base;
template <class charT> class messages;
template <class charT> class messages_byname;

}

1 The header <locale> deﬁnes classes and declares functions that encapsulate and manipulate the information

peculiar to a locale.236
22.3 Locales
22.3.1 Class locale

namespace std {
class locale {
public:

// types:
class facet;
class id;
typedef int category;

236) In this subclause, the type name struct tm is an incomplete type that is deﬁned in <ctime>.

§ 22.3.1

[locales]
[locale]

691

c(cid:13) ISO/IEC

N4296

static const category

// values assigned here are for exposition only

= 0,
= 0x010, ctype

none
collate
monetary = 0x040, numeric
time
all = collate | ctype | monetary | numeric | time

= 0x020,
= 0x080,
= 0x100, messages = 0x200,

| messages;

// construct/copy/destroy:
locale() noexcept;
locale(const locale& other) noexcept;
explicit locale(const char* std_name);
explicit locale(const string& std_name);
locale(const locale& other, const char* std_name, category);
locale(const locale& other, const string& std_name, category);
template <class Facet> locale(const locale& other, Facet* f);
locale(const locale& other, const locale& one, category);
~locale();
const locale& operator=(const locale& other) noexcept;
template <class Facet> locale combine(const locale& other) const;

// not virtual

// locale operations:
basic_string<char>

name() const;

bool operator==(const locale& other) const;
bool operator!=(const locale& other) const;

template <class charT, class traits, class Allocator>

bool operator()(const basic_string<charT,traits,Allocator>& s1,

const basic_string<charT,traits,Allocator>& s2) const;

// global locale objects:
static
locale
static const locale& classic();

global(const locale&);

};

}

1 Class locale implements a type-safe polymorphic set of facets, indexed by facet type. In other words, a
facet has a dual role: in one sense, it’s just a class interface; at the same time, it’s an index into a locale’s
set of facets.

2 Access to the facets of a locale is via two function templates, use_facet<> and has_facet<>.
3

[ Example: An iostream operator<< might be implemented as:237

template <class charT, class traits>
basic_ostream<charT,traits>&
operator<< (basic_ostream<charT,traits>& s, Date d) {

typename basic_ostream<charT,traits>::sentry cerberos(s);
if (cerberos) {

ios_base::iostate err = ios_base::iostate::goodbit;
tm tmbuf; d.extract(tmbuf);
use_facet< time_put<charT,ostreambuf_iterator<charT,traits> > >(

s.getloc()).put(s, s, s.fill(), err, &tmbuf, ’x’);

s.setstate(err);

// might throw

}

237) Note that in the call to put the stream is implicitly converted to an ostreambuf_iterator<charT,traits>.

§ 22.3.1

692

c(cid:13) ISO/IEC

return s;

}

N4296

— end example ]
In the call to use_facet<Facet>(loc), the type argument chooses a facet, making available all members
of the named type. If Facet is not present in a locale, it throws the standard exception bad_cast. A C++
program can check if a locale implements a particular facet with the function template has_facet<Facet>().
User-deﬁned facets may be installed in a locale, and used identically as may standard facets (22.4.8).
[ Note: All locale semantics are accessed via use_facet<> and has_facet<>, except that:

4

5

(5.1)

(5.2)

—

—

A member operator template operator()(const basic_string<C, T, A>&, const basic_string<
C, T, A>&) is provided so that a locale may be used as a predicate argument to the standard collec-
tions, to collate strings.
Convenient global interfaces are provided for traditional ctype functions such as isdigit() and
isspace(), so that given a locale object loc a C++ program can call isspace(c,loc). (This eases
upgrading existing extractors (27.7.2.2).) — end note ]

6 Once a facet reference is obtained from a locale object by calling use_facet<>, that reference remains usable,
and the results from member functions of it may be cached and re-used, as long as some locale object refers
to that facet.
In successive calls to a locale facet member function on a facet object installed in the same locale, the
returned result shall be identical.

7

8 A locale constructed from a name string (such as "POSIX"), or from parts of two named locales, has a
name; all others do not. Named locales may be compared for equality; an unnamed locale is equal only to
(copies of) itself. For an unnamed locale, locale::name() returns the string "*".

9 Whether there is one global locale object for the entire program or one global locale object per thread is
implementation-deﬁned. Implementations should provide one global locale object per thread. If there is a
single global locale object for the entire program, implementations are not required to avoid data races on
it (17.6.5.9).
22.3.1.1 locale types
22.3.1.1.1 Type locale::category
typedef int category;

[locale.types]
[locale.category]

1 Valid category values include the locale member bitmask elements collate, ctype, monetary, numeric,
time, and messages, each of which represents a single locale category. In addition, locale member bitmask
constant none is deﬁned as zero and represents no category. And locale member bitmask constant all is
deﬁned such that the expression

(collate | ctype | monetary | numeric | time | messages | all) == all

is true, and represents the union of all categories. Further, the expression (X | Y), where X and Y each
represent a single category, represents the union of the two categories.

2 locale member functions expecting a category argument require one of the category values deﬁned above,
or the union of two or more such values. Such a category value identiﬁes a set of locale categories. Each
locale category, in turn, identiﬁes a set of locale facets, including at least those shown in Table 81.

3 For any locale loc either constructed, or returned by locale::classic(), and any facet Facet shown in
Table 81, has_facet<Facet>(loc) is true. Each locale member function which takes a locale::category
argument operates on the corresponding set of facets.

§ 22.3.1.1.1

693

c(cid:13) ISO/IEC

N4296

Category
collate
ctype

monetary

numeric

time

messages

Table 81 — Locale category facets

Includes facets
collate<char>, collate<wchar_t>
ctype<char>, ctype<wchar_t>
codecvt<char,char,mbstate_t>
codecvt<char16_t,char,mbstate_t>
codecvt<char32_t,char,mbstate_t>
codecvt<wchar_t,char,mbstate_t>
moneypunct<char>, moneypunct<wchar_t>
moneypunct<char,true>, moneypunct<wchar_t,true>
money_get<char>, money_get<wchar_t>
money_put<char>, money_put<wchar_t>
numpunct<char>, numpunct<wchar_t>
num_get<char>, num_get<wchar_t>
num_put<char>, num_put<wchar_t>
time_get<char>, time_get<wchar_t>
time_put<char>, time_put<wchar_t>
messages<char>, messages<wchar_t>

4 An implementation is required to provide those specializations for facet templates identiﬁed as members of

a category, and for those shown in Table 82.

6

5 The provided implementation of members of facets num_get<charT> and num_put<charT> calls use_fac-
et <F> (l) only for facet F of types numpunct<charT> and ctype<charT>, and for locale l the value obtained
by calling member getloc() on the ios_base& argument to these functions.
In declarations of facets, a template parameter with name InputIterator or OutputIterator indicates
the set of all possible specializations on parameters that satisfy the requirements of an Input Iterator or an
Output Iterator, respectively (24.2). A template parameter with name C represents the set of types containing
char, wchar_t, and any other implementation-deﬁned character types that satisfy the requirements for a
character on which any of the iostream components can be instantiated. A template parameter with name
International represents the set of all possible specializations on a bool parameter.
22.3.1.1.2 Class locale::facet

[locale.facet]

namespace std {

class locale::facet {
protected:

explicit facet(size_t refs = 0);
virtual ~facet();
facet(const facet&) = delete;
void operator=(const facet&) = delete;

};

}

1 Template parameters in this Clause which are required to be facets are those named Facet in declarations. A
program that passes a type that is not a facet, or a type that refers to a volatile-qualiﬁed facet, as an (explicit
or deduced) template parameter to a locale function expecting a facet, is ill-formed. A const-qualiﬁed facet
is a valid template argument to any locale function that expects a Facet template parameter.

2 The refs argument to the constructor is used for lifetime management.

(2.1)

—

For refs == 0, the implementation performs delete static_cast<locale::facet*>(f) (where f is
a pointer to the facet) when the last locale object containing the facet is destroyed; for refs == 1,

§ 22.3.1.1.2

694

c(cid:13) ISO/IEC

N4296

Category
collate
ctype

monetary

numeric

time

messages

Table 82 — Required specializations

Includes facets

collate_byname<char>, collate_byname<wchar_t>
ctype_byname<char>, ctype_byname<wchar_t>
codecvt_byname<char,char,mbstate_t>
codecvt_byname<char16_t,char,mbstate_t>
codecvt_byname<char32_t,char,mbstate_t>
codecvt_byname<wchar_t,char,mbstate_t>
moneypunct_byname<char,International>
moneypunct_byname<wchar_t,International>
money_get<C,InputIterator>
money_put<C,OutputIterator>
numpunct_byname<char>, numpunct_byname<wchar_t>
num_get<C,InputIterator>, num_put<C,OutputIterator>
time_get<char,InputIterator>
time_get_byname<char,InputIterator>
time_get<wchar_t,InputIterator>
time_get_byname<wchar_t,InputIterator>
time_put<char,OutputIterator>
time_put_byname<char,OutputIterator>
time_put<wchar_t,OutputIterator>
time_put_byname<wchar_t,OutputIterator>
messages_byname<char>, messages_byname<wchar_t>

the implementation never destroys the facet.

3 Constructors of all facets deﬁned in this Clause take such an argument and pass it along to their facet
base class constructor. All one-argument constructors deﬁned in this Clause are explicit, preventing their
participation in automatic conversions.

4 For some standard facets a standard “. . ._byname” class, derived from it, implements the virtual function
semantics equivalent to that facet of the locale constructed by locale(const char*) with the same name.
Each such facet provides a constructor that takes a const char* argument, which names the locale, and a
refs argument, which is passed to the base class constructor. Each such facet also provides a constructor
that takes a string argument str and a refs argument, which has the same eﬀect as calling the ﬁrst
constructor with the two arguments str.c_str() and refs. If there is no “. . ._byname” version of a facet,
the base class implements named locale semantics itself by reference to other facets.
22.3.1.1.3 Class locale::id

[locale.id]

namespace std {

class locale::id {
public:
id();
void operator=(const id&) = delete;
id(const id&) = delete;

};

}

1 The class locale::id provides identiﬁcation of a locale facet interface, used as an index for lookup and to

encapsulate initialization.

§ 22.3.1.1.3

695

2

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

c(cid:13) ISO/IEC

N4296

[ Note: Because facets are used by iostreams, potentially while static constructors are running, their ini-
tialization cannot depend on programmed static initialization. One initialization strategy is for locale to
initialize each facet’s id member the ﬁrst time an instance of the facet is installed into a locale. This depends
only on static storage being zero before constructors run (3.6.2). — end note ]
22.3.1.2 locale constructors and destructor
locale() noexcept;

[locale.cons]

Default constructor: a snapshot of the current global locale.
Eﬀects: Constructs a copy of the argument last passed to locale::global(locale&), if it has been
called; else, the resulting facets have virtual function semantics identical to those of locale::classic().
[ Note: This constructor is commonly used as the default value for arguments of functions that take a
const locale& argument. — end note ]

locale(const locale& other) noexcept;

Eﬀects: Constructs a locale which is a copy of other.

explicit locale(const char* std_name);

Eﬀects: Constructs a locale using standard C locale names, e.g., "POSIX". The resulting locale imple-
ments semantics deﬁned to be associated with that name.
Throws: runtime_error if the argument is not valid, or is null.
Remarks: The set of valid string argument values is "C", "", and any implementation-deﬁned values.

explicit locale(const string& std_name);

Eﬀects: The same as locale(std_name.c_str()).

locale(const locale& other, const char* std_name, category);

Eﬀects: Constructs a locale as a copy of other except for the facets identiﬁed by the category
argument, which instead implement the same semantics as locale(std_name).
Throws: runtime_error if the argument is not valid, or is null.
Remarks: The locale has a name if and only if other has a name.

locale(const locale& other, const string& std_name, category cat);
Eﬀects: The same as locale(other, std_name.c_str(), cat).

template <class Facet> locale(const locale& other, Facet* f);

Eﬀects: Constructs a locale incorporating all facets from the ﬁrst argument except that of type Facet,
and installs the second argument as the remaining facet. If f is null, the resulting object is a copy of
other.
Remarks: The resulting locale has no name.

locale(const locale& other, const locale& one, category cats);

Eﬀects: Constructs a locale incorporating all facets from the ﬁrst argument except those that imple-
ment cats, which are instead incorporated from the second argument.
Remarks: The resulting locale has a name if and only if the ﬁrst two arguments have names.

const locale& operator=(const locale& other) noexcept;

§ 22.3.1.2

696

16

17

18

1

2

3

4

5

1

2

3

4

5

6

c(cid:13) ISO/IEC

N4296

Eﬀects: Creates a copy of other, replacing the current value.
Returns: *this

~locale();

A non-virtual destructor that throws no exceptions.

22.3.1.3 locale members
template <class Facet> locale combine(const locale& other) const;

[locale.members]

Eﬀects: Constructs a locale incorporating all facets from *this except for that one facet of other that
is identiﬁed by Facet.
Returns: The newly created locale.
Throws: runtime_error if has_facet<Facet>(other) is false.
Remarks: The resulting locale has no name.

basic_string<char> name() const;

Returns: The name of *this, if it has one; otherwise, the string "*".
If *this has a name, then
locale(name().c_str()) is equivalent to *this. Details of the contents of the resulting string are
otherwise implementation-deﬁned.

22.3.1.4 locale operators
bool operator==(const locale& other) const;

[locale.operators]

Returns: true if both arguments are the same locale, or one is a copy of the other, or each has a name
and the names are identical; false otherwise.

bool operator!=(const locale& other) const;

Returns: The result of the expression: !(*this == other).

template <class charT, class traits, class Allocator>

bool operator()(const basic_string<charT,traits,Allocator>& s1,

const basic_string<charT,traits,Allocator>& s2) const;
Eﬀects: Compares two strings according to the collate<charT> facet.
Remarks: This member operator template (and therefore locale itself) satisﬁes requirements for a
comparator predicate template argument (Clause 25) applied to strings.
Returns: The result of the following expression:
use_facet< collate<charT> >(*this).compare

(s1.data(), s1.data()+s1.size(), s2.data(), s2.data()+s2.size()) < 0;

[ Example: A vector of strings v can be collated according to collation rules in locale loc simply
by (25.4.1, 23.3.6):

std::sort(v.begin(), v.end(), loc);

— end example ]

§ 22.3.1.4

697

c(cid:13) ISO/IEC

N4296

22.3.1.5 locale static members
static locale global(const locale& loc);
Sets the global locale to its argument.
Eﬀects: Causes future calls to the constructor locale() to return a copy of the argument.
argument has a name, does

[locale.statics]

If the

std::setlocale(LC_ALL, loc.name().c_str());

otherwise, the eﬀect on the C locale, if any, is implementation-deﬁned. No library function other
than locale::global() shall aﬀect the value returned by locale().
[ Note: See 22.6 for data race
considerations when setlocale is invoked. — end note ]
Returns: The previous value of locale().

static const locale& classic();

The "C" locale.
Returns: A locale that implements the classic "C" locale semantics, equivalent to the value locale("C").
Remarks: This locale, its facets, and their member functions, do not change with time.

22.3.2 locale globals
template <class Facet> const Facet& use_facet(const locale& loc);

[locale.global.templates]

Requires: Facet is a facet class whose deﬁnition contains the public static member id as deﬁned
in 22.3.1.1.2.
Returns: A reference to the corresponding facet of loc, if present.
Throws: bad_cast if has_facet<Facet>(loc) is false.
Remarks: The reference returned remains valid at least as long as any copy of loc exists.

template <class Facet> bool has_facet(const locale& loc) noexcept;

Returns: True if the facet requested is present in loc; otherwise false.

1

2

3

4

5

6

1

2

3

4

5

[locale.convenience]
[classiﬁcation]

22.3.3 Convenience interfaces
22.3.3.1 Character classiﬁcation
template <class charT> bool isspace (charT c, const locale& loc);
template <class charT> bool isprint (charT c, const locale& loc);
template <class charT> bool iscntrl (charT c, const locale& loc);
template <class charT> bool isupper (charT c, const locale& loc);
template <class charT> bool islower (charT c, const locale& loc);
template <class charT> bool isalpha (charT c, const locale& loc);
template <class charT> bool isdigit (charT c, const locale& loc);
template <class charT> bool ispunct (charT c, const locale& loc);
template <class charT> bool isxdigit(charT c, const locale& loc);
template <class charT> bool isalnum (charT c, const locale& loc);
template <class charT> bool isgraph (charT c, const locale& loc);
template <class charT> bool isblank (charT c, const locale& loc);

1 Each of these functions isF returns the result of the expression:

use_facet< ctype<charT> >(loc).is(ctype_base::F, c)

§ 22.3.3.1

698

c(cid:13) ISO/IEC

N4296

where F is the ctype_base::mask value corresponding to that function (22.4.1).238
22.3.3.2 Conversions
22.3.3.2.1 Character conversions
template <class charT> charT toupper(charT c, const locale& loc);

[conversions]
[conversions.character]

1

2

Returns: use_facet<ctype<charT> >(loc).toupper(c).

template <class charT> charT tolower(charT c, const locale& loc);

Returns: use_facet<ctype<charT> >(loc).tolower(c).

22.3.3.2.2 string conversions

[conversions.string]
1 Class template wstring_convert performs conversions between a wide string and a byte string. It lets you
specify a code conversion facet (like class template codecvt) to perform the conversions, without aﬀecting
any streams or locales. [ Example: If you want to use the code conversion facet codecvt_utf8 to output to
cout a UTF-8 multibyte sequence corresponding to a wide string, but you don’t want to alter the locale for
cout, you can write something like:

wstring_convert<std::codecvt_utf8<wchar_t>> myconv;
std::string mbstring = myconv.to_bytes(L"Hello\n");
std::cout << mbstring;

— end example ]

2 Class template wstring_convert synopsis

namespace std {
template<class Codecvt, class Elem = wchar_t,
class Wide_alloc = std::allocator<Elem>,
class Byte_alloc = std::allocator<char> > class wstring_convert {

public:

typedef std::basic_string<char, char_traits<char>, Byte_alloc> byte_string;
typedef std::basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;
typedef typename Codecvt::state_type state_type;
typedef typename wide_string::traits_type::int_type int_type;

explicit wstring_convert(Codecvt* pcvt = new Codecvt);
wstring_convert(Codecvt* pcvt, state_type state);
explicit wstring_convert(const byte_string& byte_err,

const wide_string& wide_err = wide_string());

~wstring_convert();

wstring_convert(const wstring_convert&) = delete;
wstring_convert& operator=(const wstring_convert&) = delete;

wide_string from_bytes(char byte);
wide_string from_bytes(const char* ptr);
wide_string from_bytes(const byte_string& str);
wide_string from_bytes(const char* first, const char* last);

byte_string to_bytes(Elem wchar);
byte_string to_bytes(const Elem* wptr);
byte_string to_bytes(const wide_string& wstr);
byte_string to_bytes(const Elem* first, const Elem* last);

238) When used in a loop, it is faster to cache the ctype<> facet and use it directly, or use the vector form of ctype<>::is.

§ 22.3.3.2.2

699

c(cid:13) ISO/IEC

N4296

size_t converted() const noexcept;
state_type state() const;

private:

byte_string byte_err_string;
wide_string wide_err_string;
Codecvt* cvtptr;
state_type cvtstate;
size_t cvtcount;

// exposition only
// exposition only
// exposition only
// exposition only
// exposition only

};

}

3 The class template describes an object that controls conversions between wide string objects of class

std::basic_string<Elem, char_traits<Elem>, Wide_alloc> and byte string objects of class std::
basic_string<char, char_traits<char>, Byte_alloc>. The class template deﬁnes the types wide_-
string and byte_string as synonyms for these two types. Conversion between a sequence of Elem val-
ues (stored in a wide_string object) and multibyte sequences (stored in a byte_string object) is per-
formed by an object of class Codecvt, which meets the requirements of the standard code-conversion facet
std::codecvt<Elem, char, std::mbstate_t>.

4 An object of this class template stores:

(4.1)

(4.2)

(4.3)

(4.4)

(4.5)

5

6

7

8
(8.1)

(8.2)
9

—
—
—

—
—

byte_err_string — a byte string to display on errors
wide_err_string — a wide string to display on errors
cvtptr — a pointer to the allocated conversion object (which is freed when the wstring_convert
object is destroyed)
cvtstate — a conversion state object
cvtcount — a conversion count

typedef std::basic_string<char, char_traits<char>, Byte_alloc> byte_string;

The type shall be a synonym for std::basic_string<char, char_traits<char>, Byte_alloc>

size_t converted() const noexcept;

Returns: cvtcount.

wide_string from_bytes(char byte);
wide_string from_bytes(const char* ptr);
wide_string from_bytes(const byte_string& str);
wide_string from_bytes(const char* first, const char* last);

Eﬀects: The ﬁrst member function shall convert the single-element sequence byte to a wide string.
The second member function shall convert the null-terminated sequence beginning at ptr to a wide
string. The third member function shall convert the sequence stored in str to a wide string. The fourth
member function shall convert the sequence deﬁned by the range [first,last) to a wide string.
In all cases:
—

If the cvtstate object was not constructed with an explicit value, it shall be set to its default value
(the initial conversion state) before the conversion begins. Otherwise it shall be left unchanged.
The number of input elements successfully converted shall be stored in cvtcount.

—
Returns: If no conversion error occurs, the member function shall return the converted wide string.
Otherwise, if the object was constructed with a wide-error string, the member function shall return
the wide-error string. Otherwise, the member function throws an object of class std::range_error.

§ 22.3.3.2.2

700

c(cid:13) ISO/IEC

N4296

typedef typename wide_string::traits_type::int_type int_type;

The type shall be a synonym for wide_string::traits_type::int_type.

state_type state() const;

returns cvtstate.

typedef typename Codecvt::state_type state_type;

The type shall be a synonym for Codecvt::state_type.

byte_string to_bytes(Elem wchar);
byte_string to_bytes(const Elem* wptr);
byte_string to_bytes(const wide_string& wstr);
byte_string to_bytes(const Elem* first, const Elem* last);

Eﬀects: The ﬁrst member function shall convert the single-element sequence wchar to a byte string.
The second member function shall convert the null-terminated sequence beginning at wptr to a byte
string. The third member function shall convert the sequence stored in wstr to a byte string. The
fourth member function shall convert the sequence deﬁned by the range [first,last) to a byte string.
In all cases:
—

If the cvtstate object was not constructed with an explicit value, it shall be set to its default value
(the initial conversion state) before the conversion begins. Otherwise it shall be left unchanged.
The number of input elements successfully converted shall be stored in cvtcount.

—
Returns: If no conversion error occurs, the member function shall return the converted byte string.
Otherwise, if the object was constructed with a byte-error string, the member function shall return the
byte-error string. Otherwise, the member function shall throw an object of class std::range_error.

typedef std::basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;

The type shall be a synonym for std::basic_string<Elem, char_traits<Elem>, Wide_alloc>.

explicit wstring_convert(Codecvt* pcvt = new Codecvt);
wstring_convert(Codecvt* pcvt, state_type state);
explicit wstring_convert(const byte_string& byte_err,

const wide_string& wide_err = wide_string());
Requires: For the ﬁrst and second constructors, pcvt != nullptr.
Eﬀects: The ﬁrst constructor shall store pcvt in cvtptr and default values in cvtstate, byte_-
err_string, and wide_err_string. The second constructor shall store pcvt in cvtptr, state in
cvtstate, and default values in byte_err_string and wide_err_string; moreover the stored state
shall be retained between calls to from_bytes and to_bytes. The third constructor shall store new
Codecvt in cvtptr, state_type() in cvtstate, byte_err in byte_err_string, and wide_err in
wide_err_string.

10

11

12

13
(13.1)

(13.2)
14

15

16

17

~wstring_convert();

18

Eﬀects: The destructor shall delete cvtptr.

§ 22.3.3.2.2

701

c(cid:13) ISO/IEC

N4296

22.3.3.2.3 Buﬀer conversions

[conversions.buﬀer]
1 Class template wbuffer_convert looks like a wide stream buﬀer, but performs all its I/O through an
underlying byte stream buﬀer that you specify when you construct it. Like class template wstring_convert,
it lets you specify a code conversion facet to perform the conversions, without aﬀecting any streams or locales.

2 Class template wbuffer_convert synopsis

namespace std {
template<class Codecvt,

class Elem = wchar_t,
class Tr = std::char_traits<Elem> >

class wbuffer_convert

: public std::basic_streambuf<Elem, Tr> {

public:

typedef typename Codecvt::state_type state_type;

explicit wbuffer_convert(std::streambuf* bytebuf = 0,
Codecvt* pcvt = new Codecvt,
state_type state = state_type());

~wbuffer_convert();

wbuffer_convert(const wbuffer_convert&) = delete;
wbuffer_convert& operator=(const wbuffer_convert&) = delete;

std::streambuf* rdbuf() const;
std::streambuf* rdbuf(std::streambuf* bytebuf);

state_type state() const;

private:

std::streambuf* bufptr;
Codecvt* cvtptr;
state_type cvtstate;

};

}

// exposition only
// exposition only
// exposition only

3 The class template describes a stream buﬀer that controls the transmission of elements of type Elem, whose
character traits are described by the class Tr, to and from a byte stream buﬀer of type std::streambuf.
Conversion between a sequence of Elem values and multibyte sequences is performed by an object of class
Codecvt, which shall meet the requirements of the standard code-conversion facet std::codecvt<Elem,
char, std::mbstate_t>.

4 An object of this class template stores:

(4.1)

(4.2)

(4.3)

—
—

—

bufptr — a pointer to its underlying byte stream buﬀer
cvtptr — a pointer to the allocated conversion object (which is freed when the wbuffer_convert
object is destroyed)
cvtstate — a conversion state object

state_type state() const;
Returns: cvtstate.

5

std::streambuf* rdbuf() const;

§ 22.3.3.2.3

702

c(cid:13) ISO/IEC

Returns: bufptr.

std::streambuf* rdbuf(std::streambuf* bytebuf);

Eﬀects: stores bytebuf in bufptr.
Returns: The previous value of bufptr.

typedef typename Codecvt::state_type state_type;

The type shall be a synonym for Codecvt::state_type.

N4296

explicit wbuffer_convert(std::streambuf* bytebuf = 0,

Codecvt* pcvt = new Codecvt, state_type state = state_type());
Requires: pcvt != nullptr.
Eﬀects: The constructor constructs a stream buﬀer object, initializes bufptr to bytebuf, initializes
cvtptr to pcvt, and initializes cvtstate to state.

~wbuffer_convert();

Eﬀects: The destructor shall delete cvtptr.

6

7

8

9

10

11

12

22.4 Standard locale categories

[locale.categories]
1 Each of the standard categories includes a family of facets. Some of these implement formatting or parsing of
a datum, for use by standard or users’ iostream operators << and >>, as members put() and get(), respec-
tively. Each such member function takes an ios_base& argument whose members flags(), precision(),
and width(), specify the format of the corresponding datum (27.5.3). Those functions which need to use
other facets call its member getloc() to retrieve the locale imbued there. Formatting facets use the character
argument fill to ﬁll out the speciﬁed width where necessary.

2 The put() members make no provision for error reporting. (Any failures of the OutputIterator argument
must be extracted from the returned iterator.) The get() members take an ios_base::iostate& argument
whose value they ignore, but set to ios_base::failbit in case of a parse error.

3 Within this clause it is unspeciﬁed whether one virtual function calls another virtual function.

22.4.1 The ctype category

[category.ctype]

namespace std {

class ctype_base {
public:

typedef T mask;

// numeric values are for exposition only.
static const mask space = 1 << 0;
static const mask print = 1 << 1;
static const mask cntrl = 1 << 2;
static const mask upper = 1 << 3;
static const mask lower = 1 << 4;
static const mask alpha = 1 << 5;
static const mask digit = 1 << 6;
static const mask punct = 1 << 7;
static const mask xdigit = 1 << 8;
static const mask blank = 1 << 9;
static const mask alnum = alpha | digit;
static const mask graph = alnum | punct;

};

}

§ 22.4.1

703

c(cid:13) ISO/IEC

1 The type mask is a bitmask type (17.5.2.1.3).

22.4.1.1 Class template ctype

N4296

[locale.ctype]

namespace std {

template <class charT>
class ctype : public locale::facet, public ctype_base {
public:

typedef charT char_type;

explicit ctype(size_t refs = 0);

is(mask m, charT c) const;

bool
const charT* is(const charT* low, const charT* high, mask* vec) const;
const charT* scan_is(mask m,

const charT* low, const charT* high) const;

const charT* scan_not(mask m,

const charT* low, const charT* high) const;

toupper(charT c) const;

charT
const charT* toupper(charT* low, const charT* high) const;
charT
const charT* tolower(charT* low, const charT* high) const;

tolower(charT c) const;

charT
const char*
char
const charT* narrow(const charT* low, const charT*, char dfault,

widen(char c) const;
widen(const char* low, const char* high, charT* to) const;
narrow(charT c, char dfault) const;

char* to) const;

static locale::id id;

protected:
~ctype();
virtual bool
virtual const charT* do_is(const charT* low, const charT* high,

do_is(mask m, charT c) const;

virtual const charT* do_scan_is(mask m,

mask* vec) const;

virtual const charT* do_scan_not(mask m,

const charT* low, const charT* high) const;

const charT* low, const charT* high) const;

do_toupper(charT) const;

virtual charT
virtual const charT* do_toupper(charT* low, const charT* high) const;
virtual charT
virtual const charT* do_tolower(charT* low, const charT* high) const;
virtual charT
virtual const char*

do_widen(char) const;
do_widen(const char* low, const char* high,

do_tolower(charT) const;

virtual char
virtual const charT* do_narrow(const charT* low, const charT* high,

do_narrow(charT, char dfault) const;

char dfault, char* dest) const;

charT* dest) const;

};

}

1 Class ctype encapsulates the C library <cctype> features. istream members are required to use ctype<>

for character classing during input parsing.

2 The specializations required in Table 81 (22.3.1.1.1), namely ctype<char> and ctype<wchar_t>, implement

§ 22.4.1.1

704

c(cid:13) ISO/IEC

character classing appropriate to the implementation’s native character set.
22.4.1.1.1 ctype members
bool
const charT* is(const charT* low, const charT* high,

is(mask m, charT c) const;

mask* vec) const;

Returns: do_is(m,c) or do_is(low,high,vec)

const charT* scan_is(mask m,

const charT* low, const charT* high) const;

Returns: do_scan_is(m,low,high)

const charT* scan_not(mask m,

const charT* low, const charT* high) const;

Returns: do_scan_not(m,low,high)

charT
const charT* toupper(charT* low, const charT* high) const;

toupper(charT) const;

Returns: do_toupper(c) or do_toupper(low,high)

charT
const charT* tolower(charT* low, const charT* high) const;

tolower(charT c) const;

Returns: do_tolower(c) or do_tolower(low,high)

charT
const char* widen(const char* low, const char* high, charT* to) const;

widen(char c) const;

Returns: do_widen(c) or do_widen(low,high,to)

char
const charT* narrow(const charT* low, const charT*, char dfault,

narrow(charT c, char dfault) const;

char* to) const;

Returns: do_narrow(c,dfault) or do_narrow(low,high,dfault,to)

22.4.1.1.2 ctype virtual functions
bool
const charT* do_is(const charT* low, const charT* high,

do_is(mask m, charT c) const;

mask* vec) const;

N4296

[locale.ctype.members]

[locale.ctype.virtuals]

Eﬀects: Classiﬁes a character or sequence of characters. For each argument character, identiﬁes a
value M of type ctype_base::mask. The second form identiﬁes a value M of type ctype_base::mask
for each *p where (low<=p && p<high), and places it into vec[p-low].
Returns: The ﬁrst form returns the result of the expression (M & m) != 0; i.e., true if the character
has the characteristics speciﬁed. The second form returns high.

const charT* do_scan_is(mask m,

const charT* low, const charT* high) const;

Eﬀects: Locates a character in a buﬀer that conforms to a classiﬁcation m.
Returns: The smallest pointer p in the range [low, high) such that is(m,*p) would return true;
otherwise, returns high.

§ 22.4.1.1.2

705

1

2

3

4

5

6

7

1

2

3

4

5

6

7

8

9

10

11

12

13

c(cid:13) ISO/IEC

N4296

const charT* do_scan_not(mask m,

const charT* low, const charT* high) const;

Eﬀects: Locates a character in a buﬀer that fails to conform to a classiﬁcation m.
Returns: The smallest pointer p, if any, in the range [low,high) such that is(m,*p) would return
false; otherwise, returns high.

charT
const charT* do_toupper(charT* low, const charT* high) const;

do_toupper(charT c) const;

Eﬀects: Converts a character or characters to upper case. The second form replaces each character *p
in the range [low,high) for which a corresponding upper-case character exists, with that character.
Returns: The ﬁrst form returns the corresponding upper-case character if it is known to exist, or its
argument if not. The second form returns high.

charT
const charT* do_tolower(charT* low, const charT* high) const;

do_tolower(charT c) const;

Eﬀects: Converts a character or characters to lower case. The second form replaces each character *p in
the range [low,high) and for which a corresponding lower-case character exists, with that character.
Returns: The ﬁrst form returns the corresponding lower-case character if it is known to exist, or its
argument if not. The second form returns high.

charT
const char*

do_widen(char c) const;
do_widen(const char* low, const char* high,

charT* dest) const;

Eﬀects: Applies the simplest reasonable transformation from a char value or sequence of char values
to the corresponding charT value or values.239 The only characters for which unique transformations
are required are those in the basic source character set (2.3).
For any named ctype category with a ctype<charT> facet ctc and valid ctype_base::mask value M,
(ctc.is(M, c) || !is(M, do_widen(c)) ) is true.240
The second form transforms each character *p in the range [low,high), placing the result in dest[p-low].
Returns: The ﬁrst form returns the transformed value. The second form returns high.

char
const charT* do_narrow(const charT* low, const charT* high,

do_narrow(charT c, char dfault) const;

char dfault, char* dest) const;

Eﬀects: Applies the simplest reasonable transformation from a charT value or sequence of charT values
to the corresponding char value or values.
For any character c in the basic source character set (2.3) the transformation is such that

do_widen(do_narrow(c,0)) == c

For any named ctype category with a ctype<char> facet ctc however, and ctype_base::mask value
M,

(is(M,c) || !ctc.is(M, do_narrow(c,dfault)) )

239) The char argument of do_widen is intended to accept values derived from character literals for conversion to the locale’s
encoding.
240) In other words, the transformed character is not a member of any character classiﬁcation that c is not also a member of.

§ 22.4.1.1.2

706

c(cid:13) ISO/IEC

N4296

is true (unless do_narrow returns dfault). In addition, for any digit character c, the expression (do_-
narrow(c, dfault) - ’0’) evaluates to the digit value of the character. The second form transforms
each character *p in the range [low,high), placing the result (or dfault if no simple transformation
is readily available) in dest[p-low].
Returns: The ﬁrst form returns the transformed value; or dfault if no mapping is readily available.
The second form returns high.

14

22.4.1.2 Class template ctype_byname

[locale.ctype.byname]

namespace std {

template <class charT>
class ctype_byname : public ctype<charT> {
public:

typedef typename ctype<charT>::mask mask;
explicit ctype_byname(const char*, size_t refs = 0);
explicit ctype_byname(const string&, size_t refs = 0);

protected:
~ctype_byname();
};

}

22.4.1.3 ctype specializations

[facet.ctype.special]

namespace std {

template <> class ctype<char>

: public locale::facet, public ctype_base {

public:

typedef char char_type;

explicit ctype(const mask* tab = 0, bool del = false,

size_t refs = 0);

bool is(mask m, char c) const;
const char* is(const char* low, const char* high, mask* vec) const;
const char* scan_is (mask m,

const char* low, const char* high) const;

const char* scan_not(mask m,

const char* low, const char* high) const;

toupper(char c) const;

char
const char* toupper(char* low, const char* high) const;
char
const char* tolower(char* low, const char* high) const;

tolower(char c) const;

widen(char c) const;

char
const char* widen(const char* low, const char* high, char* to) const;
char
const char* narrow(const char* low, const char* high, char dfault,

narrow(char c, char dfault) const;

char* to) const;

static locale::id id;
static const size_t table_size = implementation-defined ;

const mask* table() const noexcept;
static const mask* classic_table() noexcept;

§ 22.4.1.3

707

c(cid:13) ISO/IEC

N4296

protected:
~ctype();
virtual char
virtual const char* do_toupper(char* low, const char* high) const;
virtual char
virtual const char* do_tolower(char* low, const char* high) const;

do_tolower(char c) const;

do_toupper(char c) const;

do_widen(char c) const;

virtual char
virtual const char* do_widen(const char* low,
const char* high,
char* to) const;

do_narrow(char c, char dfault) const;

virtual char
virtual const char* do_narrow(const char* low,
const char* high,
char dfault, char* to) const;

};

}

1 A specialization ctype<char> is provided so that the member functions on type char can be implemented

inline.241 The implementation-deﬁned value of member table_size is at least 256.
22.4.1.3.1 ctype<char> destructor
~ctype();

[facet.ctype.char.dtor]

1

1

2

3

4

5

6

Eﬀects: If the constructor’s ﬁrst argument was nonzero, and its second argument was true, does delete
[] table().

[facet.ctype.char.members]
22.4.1.3.2 ctype<char> members
In the following member descriptions, for unsigned char values v where v >= table_size, table()[v]
is assumed to have an implementation-speciﬁc value (possibly diﬀerent for each such value v) without
performing the array lookup.

explicit ctype(const mask* tbl = 0, bool del = false,

size_t refs = 0);

Requires: tbl either 0 or an array of at least table_size elements.
Eﬀects: Passes its refs argument to its base class constructor.

bool
const char* is(const char* low, const char* high,

is(mask m, char c) const;

mask* vec) const;

Eﬀects: The second form, for all *p in the range [low,high), assigns into vec[p-low] the value
table()[ (unsigned char)*p].
Returns: The ﬁrst form returns table()[(unsigned char)c] & m; the second form returns high.

const char* scan_is(mask m,

const char* low, const char* high) const;
Returns: The smallest p in the range [low,high) such that

table()[(unsigned char) *p] & m

is true.

241) Only the char (not unsigned char and signed char) form is provided. The specialization is speciﬁed in the standard,
and not left as an implementation detail, because it aﬀects the derivation interface for ctype<char>.

§ 22.4.1.3.2

708

7

8

9

10

11

12

1

c(cid:13) ISO/IEC

N4296

const char* scan_not(mask m,

const char* low, const char* high) const;
Returns: The smallest p in the range [low,high) such that

table()[(unsigned char) *p] & m

is false.

char
const char* toupper(char* low, const char* high) const;

toupper(char c) const;

Returns: do_toupper(c) or do_toupper(low,high), respectively.

char
const char* tolower(char* low, const char* high) const;

tolower(char c) const;

Returns: do_tolower(c) or do_tolower(low,high), respectively.

widen(char c) const;

char
const char* widen(const char* low, const char* high,

char* to) const;
Returns: do_widen(c) or do_widen(low, high, to), respectively.

char
const char* narrow(const char* low, const char* high,

narrow(char c, char dfault) const;

char dfault, char* to) const;

Returns: do_narrow(c, dfault) or do_narrow(low, high, dfault, to), respectively.

const mask* table() const noexcept;

Returns: The ﬁrst constructor argument, if it was non-zero, otherwise classic_table().

22.4.1.3.3 ctype<char> static members
static const mask* classic_table() noexcept;

[facet.ctype.char.statics]

Returns: A pointer to the initial element of an array of size table_size which represents the classiﬁ-
cations of characters in the "C" locale.

22.4.1.3.4 ctype<char> virtual functions

[facet.ctype.char.virtuals]

do_toupper(char) const;

char
const char* do_toupper(char* low, const char* high) const;
char
const char* do_tolower(char* low, const char* high) const;

do_tolower(char) const;

do_widen(char c) const;

virtual char
virtual const char* do_widen(const char* low,
const char* high,
char* to) const;

do_narrow(char c, char dfault) const;

virtual char
virtual const char* do_narrow(const char* low,
const char* high,
char dfault, char* to) const;

These functions are described identically as those members of the same name in the ctype class tem-
plate (22.4.1.1.1).
22.4.1.4 Class template codecvt

[locale.codecvt]

§ 22.4.1.4

709

c(cid:13) ISO/IEC

N4296

namespace std {

class codecvt_base {
public:

};

enum result { ok, partial, error, noconv };

template <class internT, class externT, class stateT>
class codecvt : public locale::facet, public codecvt_base {
public:

typedef internT
typedef externT
typedef stateT state_type;

intern_type;
extern_type;

explicit codecvt(size_t refs = 0);

result out(stateT& state,

result unshift(stateT& state,
to,

externT*
result in(stateT& state,

const internT* from, const internT* from_end, const internT*& from_next,
externT*

externT* to_end, externT*& to_next) const;

to,

externT* to_end, externT*& to_next) const;

const externT* from, const externT* from_end, const externT*& from_next,
internT*

internT* to_end, internT*& to_next) const;

to,

int encoding() const noexcept;
bool always_noconv() const noexcept;
int length(stateT&, const externT* from, const externT* end,

size_t max) const;

int max_length() const noexcept;

static locale::id id;

protected:

~codecvt();
virtual result do_out(stateT& state,

const internT* from, const internT* from_end, const internT*& from_next,
externT* to,
virtual result do_in(stateT& state,

externT* to_end, externT*& to_next) const;

const externT* from, const externT* from_end, const externT*& from_next,
internT* to,

internT* to_end, internT*& to_next) const;

virtual result do_unshift(stateT& state,

externT* to,

externT* to_end, externT*& to_next) const;

virtual int do_encoding() const noexcept;
virtual bool do_always_noconv() const noexcept;
virtual int do_length(stateT&, const externT* from,

virtual int do_max_length() const noexcept;

const externT* end, size_t max) const;

};

}

1 The class codecvt<internT,externT,stateT> is for use when converting from one character encoding to
another, such as from wide characters to multibyte characters or between wide character encodings such as
Unicode and EUC.

2 The stateT argument selects the pair of character encodings being mapped between.

§ 22.4.1.4

710

c(cid:13) ISO/IEC

N4296

3 The specializations required in Table 81 (22.3.1.1.1) convert the implementation-deﬁned native character
set. codecvt<char, char, mbstate_t> implements a degenerate conversion; it does not convert at all. The
specialization codecvt<char16_t, char, mbstate_t> converts between the UTF-16 and UTF-8 encoding
forms, and the specialization codecvt <char32_t, char, mbstate_t> converts between the UTF-32 and
UTF-8 encoding forms. codecvt<wchar_t,char,mbstate_t> converts between the native character sets for
narrow and wide characters. Specializations on mbstate_t perform conversion between encodings known to
the library implementer. Other encodings can be converted by specializing on a user-deﬁned stateT type.
Objects of type stateT can contain any state that is useful to communicate to or from the specialized do_in
or do_out members.
22.4.1.4.1 codecvt members
result out(stateT& state,

[locale.codecvt.members]

const internT* from, const internT* from_end, const internT*& from_next,

externT* to, externT* to_end, externT*& to_next) const;

1

2

3

4

5

6

7

1

Returns: do_out(state, from, from_end, from_next, to, to_end, to_next)

result unshift(stateT& state,

externT* to, externT* to_end, externT*& to_next) const;

Returns: do_unshift(state, to, to_end, to_next)

result in(stateT& state,

const externT* from, const externT* from_end, const externT*& from_next,

internT* to, internT* to_end, internT*& to_next) const;

Returns: do_in(state, from, from_end, from_next, to, to_end, to_next)

int encoding() const noexcept;
Returns: do_encoding()

bool always_noconv() const noexcept;

Returns: do_always_noconv()

int length(stateT& state, const externT* from, const externT* from_end,

size_t max) const;

Returns: do_length(state, from,from_end,max)

int max_length() const noexcept;
Returns: do_max_length()

22.4.1.4.2 codecvt virtual functions
result do_out(stateT& state,

const internT* from, const internT* from_end, const internT*& from_next,
externT* to, externT* to_end, externT*& to_next) const;

[locale.codecvt.virtuals]

result do_in(stateT& state,

const externT* from, const externT* from_end, const externT*& from_next,

internT* to, internT* to_end, internT*& to_next) const;

Requires: (from<=from_end && to<=to_end) well-deﬁned and true; state initialized, if at the be-
ginning of a sequence, or else equal to the result of converting the preceding characters in the sequence.

§ 22.4.1.4.2

711

2

3

4

5

6

c(cid:13) ISO/IEC

N4296

Eﬀects: Translates characters in the source range [from,from_end), placing the results in sequential
positions starting at destination to. Converts no more than (from_end-from) source elements, and
stores no more than (to_end-to) destination elements.
Stops if it encounters a character it cannot convert.
It always leaves the from_next and to_next
pointers pointing one beyond the last element successfully converted.
If returns noconv, internT
and externT are the same type and the converted sequence is identical to the input sequence [from,
from_next). to_next is set equal to to, the value of state is unchanged, and there are no changes
to the values in [to, to_end).
A codecvt facet that is used by basic_filebuf (27.9) shall have the property that if

do_out(state, from, from_end, from_next, to, to_end, to_next)

would return ok, where from != from_end, then

do_out(state, from, from + 1, from_next, to, to_end, to_next)

shall also return ok, and that if

do_in(state, from, from_end, from_next, to, to_end, to_next)

would return ok, where to != to_end, then

do_in(state, from, from_end, from_next, to, to + 1, to_next)

shall also return ok.242 [ Note: As a result of operations on state, it can return ok or partial and
set from_next == from and to_next != to. — end note ]
Remarks: Its operations on state are unspeciﬁed. [ Note: This argument can be used, for example, to
maintain shift state, to specify conversion options (such as count only), or to identify a cache of seek
oﬀsets. — end note ]
Returns: An enumeration value, as summarized in Table 83.

Value
ok
partial
error

noconv

Table 83 — do_in/do_out result values

Meaning

completed the conversion
not all source characters converted
encountered a character in [from,from_end) that
it could not convert
internT and externT are the same type, and in-
put sequence is identical to converted sequence

A return value of partial, if (from_next==from_end), indicates that either the destination sequence
has not absorbed all the available destination elements, or that additional source elements are needed
before another destination element can be produced.

result do_unshift(stateT& state,

externT* to, externT* to_end, externT*& to_next) const;

Requires: (to <= to_end) well deﬁned and true; state initialized, if at the beginning of a sequence,
or else equal to the result of converting the preceding characters in the sequence.

242) Informally, this means that basic_filebuf assumes that the mappings from internal to external characters is 1 to N: a
codecvt facet that is used by basic_filebuf must be able to translate characters one internal character at a time.

§ 22.4.1.4.2

712

7

8

9

10

11

12

13

14

c(cid:13) ISO/IEC

N4296

Eﬀects: Places characters starting at to that should be appended to terminate a sequence when the
current stateT is given by state.243 Stores no more than (to_end-to) destination elements, and
leaves the to_next pointer pointing one beyond the last element successfully stored.
Returns: An enumeration value, as summarized in Table 84.

Table 84 — do_unshift result values

Meaning

completed the sequence
space for more than to_end-to destination elements
was needed to terminate a sequence given the value of
state
an unspeciﬁed error has occurred
no termination is needed for this state_type

Value
ok
partial

error
noconv

int do_encoding() const noexcept;

Returns:-1 if the encoding of the externT sequence is state-dependent; else the constant number of
externT characters needed to produce an internal character; or 0 if this number is not a constant.244

bool do_always_noconv() const noexcept;

Returns: true if do_in() and do_out() return noconv for all valid argument values. codecvt<char,
char, mbstate_t> returns true.

int do_length(stateT& state, const externT* from, const externT* from_end,

size_t max) const;

Requires: (from<=from_end) well-deﬁned and true; state initialized, if at the beginning of a sequence,
or else equal to the result of converting the preceding characters in the sequence.
Eﬀects: The eﬀect on the state argument is “as if” it called do_in(state, from, from_end, from,
to, to+max, to) for to pointing to a buﬀer of at least max elements.
Returns: (from_next-from) where from_next is the largest value in the range [from,from_end] such
that the sequence of values in the range [from,from_next) represents max or fewer valid complete
characters of type internT. The specialization codecvt<char, char, mbstate_t>, returns the lesser
of max and (from_end-from).

int do_max_length() const noexcept;

Returns: The maximum value that do_length(state, from, from_end, 1) can return for any
valid range [from, from_end) and stateT value state. The specialization codecvt<char, char,
mbstate_t>::do_max_length() returns 1.

22.4.1.5 Class template codecvt_byname

[locale.codecvt.byname]

namespace std {

template <class internT, class externT, class stateT>
class codecvt_byname : public codecvt<internT, externT, stateT> {
public:

243) Typically these will be characters to return the state to stateT()
244) If encoding() yields -1, then more than max_length() externT elements may be consumed when producing a single
internT character, and additional externT elements may appear at the end of a sequence after those that yield the ﬁnal
internT character.

§ 22.4.1.5

713

c(cid:13) ISO/IEC

N4296

explicit codecvt_byname(const char*, size_t refs = 0);
explicit codecvt_byname(const string&, size_t refs = 0);

protected:

~codecvt_byname();

};

}

22.4.2 The numeric category

[category.numeric]
1 The classes num_get<> and num_put<> handle numeric formatting and parsing. Virtual functions are pro-
Implementations may (but are not required to) delegate extraction of

vided for several numeric types.
smaller types to extractors for larger types.245

2 All speciﬁcations of member functions for num_put and num_get in the subclauses of 22.4.2 only apply to the
specializations required in Tables 81 and 82 (22.3.1.1.1), namely num_get<char>, num_get<wchar_t>, num_-
get<C, InputIterator>, num_put<char>, num_put<wchar_t>, and num_put<C,OutputIterator>. These
specializations refer to the ios_base& argument for formatting speciﬁcations (22.4), and to its imbued locale
for the numpunct<> facet to identify all numeric punctuation preferences, and also for the ctype<> facet to
perform character classiﬁcation.

3 Extractor and inserter members of the standard iostreams use num_get<> and num_put<> member functions

for formatting and parsing numeric values (27.7.2.2.1, 27.7.3.6.1).
22.4.2.1 Class template num_get

[locale.num.get]

namespace std {

template <class charT, class InputIterator = istreambuf_iterator<charT> >
class num_get : public locale::facet {
public:

typedef charT
typedef InputIterator

char_type;
iter_type;

explicit num_get(size_t refs = 0);

iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, bool& v) const;
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, long& v) const;
iter_type get(iter_type in, iter_type end, ios_base&,

iter_type get(iter_type in, iter_type end, ios_base&,

ios_base::iostate& err, long long& v) const;

ios_base::iostate& err, unsigned short& v) const;

iter_type get(iter_type in, iter_type end, ios_base&,

ios_base::iostate& err, unsigned int& v) const;

iter_type get(iter_type in, iter_type end, ios_base&,

iter_type get(iter_type in, iter_type end, ios_base&,

ios_base::iostate& err, unsigned long& v) const;

ios_base::iostate& err, unsigned long long& v) const;

iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, float& v) const;
iter_type get(iter_type in, iter_type end, ios_base&,

iter_type get(iter_type in, iter_type end, ios_base&,

ios_base::iostate& err, double& v) const;

ios_base::iostate& err, long double& v) const;

245) Parsing "-1" correctly into, e.g., an unsigned short requires that the corresponding member get() at least extract the
sign before delegating.

§ 22.4.2.1

714

c(cid:13) ISO/IEC

N4296

iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, void*& v) const;

static locale::id id;

protected:

~num_get();
virtual iter_type do_get(iter_type, iter_type, ios_base&,

virtual iter_type do_get(iter_type, iter_type, ios_base&,

ios_base::iostate& err, bool& v) const;

virtual iter_type do_get(iter_type, iter_type, ios_base&,

ios_base::iostate& err, long& v) const;

virtual iter_type do_get(iter_type, iter_type, ios_base&,

ios_base::iostate& err, long long& v) const;

ios_base::iostate& err, unsigned short& v) const;

virtual iter_type do_get(iter_type, iter_type, ios_base&,

virtual iter_type do_get(iter_type, iter_type, ios_base&,

ios_base::iostate& err, unsigned int& v) const;

virtual iter_type do_get(iter_type, iter_type, ios_base&,

ios_base::iostate& err, unsigned long& v) const;

ios_base::iostate& err, unsigned long long& v) const;

virtual iter_type do_get(iter_type, iter_type, ios_base&,

virtual iter_type do_get(iter_type, iter_type, ios_base&,

ios_base::iostate& err, float& v) const;

ios_base::iostate& err, double& v) const;

virtual iter_type do_get(iter_type, iter_type, ios_base&,

virtual iter_type do_get(iter_type, iter_type, ios_base&,

ios_base::iostate& err, void*& v) const;

ios_base::iostate& err, long double& v) const;

};

}

1 The facet num_get is used to parse numeric values from an input sequence such as an istream.

[facet.num.get.members]

22.4.2.1.1 num_get members
iter_type get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, bool& val) const;

iter_type get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, long& val) const;

iter_type get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, long long& val) const;

iter_type get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, unsigned short& val) const;

iter_type get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, unsigned int& val) const;

iter_type get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, unsigned long& val) const;

iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, unsigned long long& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, float& val) const;

iter_type get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, double& val) const;

iter_type get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, long double& val) const;

§ 22.4.2.1.1

715

c(cid:13) ISO/IEC

N4296

iter_type get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, void*& val) const;

1

Returns: do_get(in, end, str, err, val).

[facet.num.get.virtuals]

22.4.2.1.2 num_get virtual functions
iter_type do_get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, long& val) const;

iter_type do_get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, long long& val) const;

iter_type do_get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, unsigned short& val) const;

iter_type do_get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, unsigned int& val) const;

iter_type do_get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, unsigned long& val) const;

iter_type do_get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, unsigned long long& val) const;

iter_type do_get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, float& val) const;

iter_type do_get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, double& val) const;

iter_type do_get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, long double& val) const;

iter_type do_get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, void*& val) const;

1

2
(2.1)

(2.2)

(2.3)
3

Eﬀects: Reads characters from in, interpreting them according to str.flags(), use_facet<ctype<
charT> >(loc), and use_facet< numpunct<charT> >(loc), where loc is str.getloc().
The details of this operation occur in three stages
—
—

Stage 1: Determine a conversion speciﬁer
Stage 2: Extract characters from in and determine a corresponding char value for the format
expected by the conversion speciﬁcation determined in stage 1.
Stage 3: Store results

—
The details of the stages are presented below.
Stage 1: The function initializes local variables via

fmtflags flags = str .flags();
fmtflags basefield = (flags & ios_base::basefield);
fmtflags uppercase = (flags & ios_base::uppercase);
fmtflags boolalpha = (flags & ios_base::boolalpha);

For conversion to an integral type, the function determines the integral conversion speciﬁer as
indicated in Table 85. The table is ordered. That is, the ﬁrst line whose condition is true applies.

Table 85 — Integer conversions

State

stdio equivalent

basefield == oct
basefield == hex
basefield == 0
signed integral type
unsigned integral type

%o
%X
%i
%d
%u

§ 22.4.2.1.2

716

c(cid:13) ISO/IEC

N4296

For conversions to a ﬂoating type the speciﬁer is %g.
For conversions to void* the speciﬁer is %p.
A length modiﬁer is added to the conversion speciﬁcation, if needed, as indicated in Table 86.

Table 86 — Length modiﬁer

Type

Length modiﬁer

short
unsigned short
long
unsigned long
long long
unsigned long long
double
long double

h
h
l
l
ll
ll
l
L

Stage 2: If in==end then stage 2 terminates. Otherwise a charT is taken from in and local variables

are initialized as if by

char_type ct = *in ;
char c = src[find(atoms, atoms + sizeof(src) - 1, ct) - atoms];
if (ct ==
c = ’.’;
bool discard =

use_facet<numpunct<charT> >(loc).decimal_point())

ct == use_facet<numpunct<charT> >(loc).thousands_sep()
&& use_facet<numpunct<charT> >(loc).grouping().length() != 0;

where the values src and atoms are deﬁned as if by:

static const char src[] = "0123456789abcdefxABCDEFX+-";
char_type atoms[sizeof(src)];
use_facet<ctype<charT> >(loc).widen(src, src + sizeof(src), atoms);

for this value of loc.
If discard is true, then if ’.’ has not yet been accumulated, then the position of the character
is remembered, but the character is otherwise ignored. Otherwise, if ’.’ has already been
accumulated, the character is discarded and Stage 2 terminates. If it is not discarded, then a
check is made to determine if c is allowed as the next character of an input ﬁeld of the conversion
speciﬁer returned by Stage 1. If so, it is accumulated.
If the character is either discarded or accumulated then in is advanced by ++in and processing
returns to the beginning of stage 2.

Stage 3: The sequence of chars accumulated in stage 2 (the ﬁeld) is converted to a numeric value

For a signed integer value, the function strtoll.
For an unsigned integer value, the function strtoull.
For a ﬂoating-point value, the function strtold.

by the rules of one of the functions declared in the header <cstdlib>:
—
—
—
The numeric value to be stored can be one of:
—

zero, if the conversion function fails to convert the entire ﬁeld. ios_base::failbit is assigned
to err.
the most positive representable value, if the ﬁeld represents a value too large positive to be
represented in val. ios_base::failbit is assigned to err.

(3.1)
(3.2)
(3.3)

(3.4)

(3.5)

—

§ 22.4.2.1.2

717

(3.6)

(3.7)

4

5

6

7

8

9

c(cid:13) ISO/IEC

—

N4296

the most negative representable value or zero for an unsigned integer type, if the ﬁeld repre-
sents a value too large negative to be represented in val. ios_base::failbit is assigned to
err.
the converted value, otherwise.

—
The resultant numeric value is stored in val.

Digit grouping is checked. That is, the positions of discarded separators is examined for consis-
tency with use_facet<numpunct<charT> >(loc).grouping(). If they are not consistent then ios_-
base::failbit is assigned to err.
In any case, if stage 2 processing was terminated by the test for in==end then err |=ios_base::eofbit
is performed.

iter_type do_get(iter_type in, iter_type end, ios_base& str,

ios_base::iostate& err, bool& val) const;

If (str.flags()&ios_base::boolalpha)==0 then input proceeds as it would for a long
Eﬀects:
except that if a value is being stored into val, the value is determined according to the following: If
the value to be stored is 0 then false is stored. If the value is 1 then true is stored. Otherwise true
is stored and ios_base::failbit is assigned to err.
Otherwise target sequences are determined “as if” by calling the members falsename() and truename()
of the facet obtained by use_facet<numpunct<charT> >(str.getloc()). Successive characters in the
range [in,end) (see 23.2.3) are obtained and matched against corresponding positions in the target
sequences only as necessary to identify a unique match. The input iterator in is compared to end
only when necessary to obtain a character. If a target sequence is uniquely matched, val is set to the
corresponding value. Otherwise false is stored and ios_base::failbit is assigned to err.
The in iterator is always left pointing one position beyond the last character successfully matched.
If val is set, then err is set to str.goodbit; or to str.eofbit if, when seeking another character
to match, it is found that (in == end).
If val is not set, then err is set to str.failbit; or to
(str.failbit|str.eofbit) if the reason for the failure was that (in == end). [ Example: For targets
true: "a" and false: "abb", the input sequence "a" yields val == true and err == str.eofbit;
the input sequence "abc" yields err = str.failbit, with in ending at the ’c’ element. For targets
true: "1" and false: "0", the input sequence "1" yields val == true and err == str.goodbit.
For empty targets (""), any input sequence yields err == str.failbit. — end example ]
Returns: in.

22.4.2.2 Class template num_put

[locale.nm.put]

namespace std {

template <class charT, class OutputIterator = ostreambuf_iterator<charT> >
class num_put : public locale::facet {
public:

typedef charT
typedef OutputIterator

char_type;
iter_type;

explicit num_put(size_t refs = 0);

iter_type put(iter_type s, ios_base& f, char_type fill, bool v) const;
iter_type put(iter_type s, ios_base& f, char_type fill, long v) const;
iter_type put(iter_type s, ios_base& f, char_type fill, long long v) const;
iter_type put(iter_type s, ios_base& f, char_type fill,

unsigned long v) const;

iter_type put(iter_type s, ios_base& f, char_type fill,

unsigned long long v) const;

§ 22.4.2.2

718

c(cid:13) ISO/IEC

N4296

iter_type put(iter_type s, ios_base& f, char_type fill,

iter_type put(iter_type s, ios_base& f, char_type fill,

iter_type put(iter_type s, ios_base& f, char_type fill,

double v) const;

long double v) const;

const void* v) const;

static locale::id id;

protected:

~num_put();
virtual iter_type do_put(iter_type, ios_base&, char_type fill,

virtual iter_type do_put(iter_type, ios_base&, char_type fill,

virtual iter_type do_put(iter_type, ios_base&, char_type fill,

virtual iter_type do_put(iter_type, ios_base&, char_type fill,

bool v) const;

long v) const;

long long v) const;

unsigned long) const;

virtual iter_type do_put(iter_type, ios_base&, char_type fill,

virtual iter_type do_put(iter_type, ios_base&, char_type fill,

unsigned long long) const;

virtual iter_type do_put(iter_type, ios_base&, char_type fill,

virtual iter_type do_put(iter_type, ios_base&, char_type fill,

double v) const;

long double v) const;

const void* v) const;

};

}

1 The facet num_put is used to format numeric values to a character sequence such as an ostream.

[facet.num.put.members]

22.4.2.2.1 num_put members
iter_type put(iter_type out, ios_base& str, char_type fill,

iter_type put(iter_type out, ios_base& str, char_type fill,

bool val) const;

long val) const;

iter_type put(iter_type out, ios_base& str, char_type fill,

iter_type put(iter_type out, ios_base& str, char_type fill,

long long val) const;

unsigned long val) const;

iter_type put(iter_type out, ios_base& str, char_type fill,

unsigned long long val) const;

iter_type put(iter_type out, ios_base& str, char_type fill,

iter_type put(iter_type out, ios_base& str, char_type fill,

iter_type put(iter_type out, ios_base& str, char_type fill,

double val) const;

long double val) const;

const void* val) const;

1

Returns: do_put(out, str, fill, val).

22.4.2.2.2 num_put virtual functions
iter_type do_put(iter_type out, ios_base& str, char_type fill,

long val) const;

[facet.num.put.virtuals]

§ 22.4.2.2.2

719

c(cid:13) ISO/IEC

N4296

iter_type do_put(iter_type out, ios_base& str, char_type fill,

iter_type do_put(iter_type out, ios_base& str, char_type fill,

long long val) const;

unsigned long val) const;

iter_type do_put(iter_type out, ios_base& str, char_type fill,

unsigned long long val) const;

iter_type do_put(iter_type out, ios_base& str, char_type fill,

iter_type do_put(iter_type out, ios_base& str, char_type fill,

iter_type do_put(iter_type out, ios_base& str, char_type fill,

double val) const;

long double val) const;

const void* val) const;

1

2
(2.1)

(2.2)

(2.3)

(2.4)
3

4

5

Eﬀects: Writes characters to the sequence out, formatting val as desired. In the following description,
a local variable initialized with
locale loc = str.getloc();

The details of this operation occur in several stages:
—

Stage 1: Determine a printf conversion speciﬁer spec and determining the characters that would
be printed by printf (27.9.2) given this conversion speciﬁer for

printf(spec, val )

—

assuming that the current locale is the "C" locale.
Stage 2: Adjust the representation by converting each char determined by stage 1 to a charT using
a conversion and values returned by members of use_facet< numpunct<charT> >(str.getloc())
Stage 3: Determine where padding is required.
Stage 4: Insert the sequence into the out.

—
—
Detailed descriptions of each stage follow.
Returns: out.

Stage 1: The ﬁrst action of stage 1 is to determine a conversion speciﬁer. The tables that describe

this determination use the following local variables

fmtflags flags = str.flags() ;
(flags & (ios_base::basefield));
fmtflags basefield =
fmtflags uppercase =
(flags & (ios_base::uppercase));
fmtflags floatfield = (flags & (ios_base::floatfield));
fmtflags showpos =
fmtflags showbase =

(flags & (ios_base::showpos));
(flags & (ios_base::showbase));

All tables used in describing stage 1 are ordered. That is, the ﬁrst line whose condition is true
applies. A line without a condition is the default behavior when none of the earlier lines apply.
For conversion from an integral type other than a character type, the function determines the
integral conversion speciﬁer as indicated in Table 87.
For conversion from a ﬂoating-point type, the function determines the ﬂoating-point conversion
speciﬁer as indicated in Table 88.
For conversions from an integral or ﬂoating-point type a length modiﬁer is added to the conversion
speciﬁer as indicated in Table 89.
The conversion speciﬁer has the following optional additional qualiﬁers prepended as indicated in
Table 90.

§ 22.4.2.2.2

720

c(cid:13) ISO/IEC

N4296

Table 87 — Integer conversions

State

stdio equivalent

basefield == ios_base::oct
(basefield == ios_base::hex) && !uppercase
(basefield == ios_base::hex)
for a signed integral type
for an unsigned integral type

%o
%x
%X
%d
%u

Table 88 — Floating-point conversions

State

stdio equivalent

floatfield == ios_base::fixed
floatfield == ios_base::scientific && !uppercase
floatfield == ios_base::scientific
floatfield == (ios_base::fixed | ios_base::scientific) && !uppercase
floatfield == (ios_base::fixed | ios_base::scientific)
!uppercase
otherwise

%f
%e
%E
%a
%A
%g
%G

Table 89 — Length modiﬁer

Type

Length modiﬁer

long
long long
unsigned long
unsigned long long
long double
otherwise

l
ll
l
ll
L

none

For conversion from a ﬂoating-point type, if floatfield != (ios_base::fixed | ios_base::
scientific), str.precision() is speciﬁed as precision in the conversion speciﬁcation. Other-
wise, no precision is speciﬁed.
For conversion from void* the speciﬁer is %p.
The representations at the end of stage 1 consists of the char’s that would be printed by a call
of printf(s, val) where s is the conversion speciﬁer determined above.

Stage 2: Any character c other than a decimal point(.)

facet<ctype<charT> >(loc).widen( c )
A local variable punct is initialized via

is converted to a charT via use_-

const numpunct<charT>& punct = use_facet< numpunct<charT> >(str.getloc());

For arithmetic types, punct.thousands_sep() characters are inserted into the sequence as deter-
mined by the value returned by punct.do_grouping() using the method described in 22.4.3.1.2

Table 90 — Numeric conversions

State

stdio equivalent

Type(s)
an integral type

a ﬂoating-point type

flags & showpos
flags & showbase
flags & showpos
flags & showpoint

+
#
+
#

§ 22.4.2.2.2

721

c(cid:13) ISO/IEC

N4296

Decimal point characters(.) are replaced by punct.decimal_point()

Stage 3: A local variable is initialized as

fmtflags adjustfield=

(flags & (ios_base::adjustfield));

The location of any padding246 is determined according to Table 91.

Table 91 — Fill padding
State

adjustfield == ios_base::left
adjustfield == ios_base::right
adjustfield == internal and a sign occurs in
the representation
adjustfield == internal and representation
after stage 1 began with 0x or 0X
otherwise

Location

pad after
pad before
pad after the sign

pad after x or X

pad before

If str.width() is nonzero and the number of charT’s in the sequence after stage 2 is less than
str.width(), then enough fill characters are added to the sequence at the position indicated
for padding to bring the length of the sequence to str.width().
str.width(0) is called.

Stage 4: The sequence of charT’s at the end of stage 3 are output via

*out++ = c

iter_type do_put(iter_type out, ios_base& str, char_type fill,

bool val) const;

6

Returns: If (str.flags() & ios_base::boolalpha) == 0 returns do_put(out, str, fill,
(int)val), otherwise obtains a string s as if by

string_type s =

val ? use_facet<numpunct<charT>>(loc).truename()
: use_facet<numpunct<charT>>(loc).falsename();

and then inserts each character c of s into out via *out++ = c and returns out.

22.4.3 The numeric punctuation facet
22.4.3.1 Class template numpunct

[facet.numpunct]
[locale.numpunct]

namespace std {

template <class charT>
class numpunct : public locale::facet {
public:

typedef charT
typedef basic_string<charT> string_type;

char_type;

explicit numpunct(size_t refs = 0);

char_type
char_type
string

decimal_point()
thousands_sep()
grouping()

const;
const;
const;

246) The conversion speciﬁcation #o generates a leading 0 which is not a padding character.

§ 22.4.3.1

722

c(cid:13) ISO/IEC

N4296

string_type
string_type

truename()
falsename()

const;
const;

static locale::id id;

protected:
~numpunct();
virtual char_type
virtual char_type
virtual string
virtual string_type
virtual string_type

};

}

// virtual

do_decimal_point() const;
do_thousands_sep() const;
do_grouping()
const;
const;
do_truename()
do_falsename()
const;

// for bool
// for bool

1 numpunct<> speciﬁes numeric punctuation. The specializations required in Table 81 (22.3.1.1.1), namely
numpunct<wchar_t> and numpunct<char>, provide classic "C" numeric formats, i.e., they contain informa-
tion equivalent to that contained in the "C" locale or their wide character counterparts as if obtained by a
call to widen.

2 The syntax for number formats is as follows, where digit represents the radix set speciﬁed by the fmtflags
argument value, and thousands-sep and decimal-point are the results of corresponding numpunct<charT>
members. Integer values have the format:

::= [sign] units
integer
sign
::= plusminus
plusminus ::= ’+’ | ’-’
units
digits

::= digits [thousands-sep units]
::= digit [digits]

and ﬂoating-point values have:

floatval ::= [sign] units [decimal-point [digits]] [e [sign] digits] |

decimal-point

digits

[e [sign] digits]

e

[sign]

::= ’e’ | ’E’

where the number of digits between thousands-seps is as speciﬁed by do_grouping(). For parsing, if the
digits portion contains no thousands-separators, no grouping constraint is applied.
22.4.3.1.1 numpunct members
char_type decimal_point() const;

[facet.numpunct.members]

1

2

3

4

Returns: do_decimal_point()

char_type thousands_sep() const;

Returns: do_thousands_sep()

string grouping()

const;

Returns: do_grouping()

string_type truename()
const;
string_type falsename() const;

Returns: do_truename() or do_falsename(), respectively.

§ 22.4.3.1.1

723

c(cid:13) ISO/IEC

22.4.3.1.2 numpunct virtual functions
char_type do_decimal_point() const;

N4296

[facet.numpunct.virtuals]

1

2

3

4

5

6

Returns: A character for use as the decimal radix separator. The required specializations return ’.’
or L’.’.

char_type do_thousands_sep() const;

Returns: A character for use as the digit group separator. The required specializations return ’,’ or
L’,’.

string do_grouping() const;

Returns: A basic_string<char> vec used as a vector of integer values, in which each element vec[i]
represents the number of digits247 in the group at position i, starting with position 0 as the rightmost
group.
if (i<0 || vec[i]<=0 ||
vec[i]==CHAR_MAX), the size of the digit group is unlimited.
The required specializations return the empty string, indicating no grouping.

If vec.size() <= i, the number is the same as group (i-1);

string_type do_truename()
const;
string_type do_falsename() const;

Returns: A string representing the name of the boolean value true or false, respectively.
In the base class implementation these names are "true" and "false", or L"true" and L"false".

22.4.3.2 Class template numpunct_byname

[locale.numpunct.byname]

namespace std {

template <class charT>
class numpunct_byname : public numpunct<charT> {
// this class is specialized for char and wchar_t.
public:

typedef charT
typedef basic_string<charT>
explicit numpunct_byname(const char*, size_t refs = 0);
explicit numpunct_byname(const string&, size_t refs = 0);

char_type;
string_type;

protected:
~numpunct_byname();
};

}

22.4.4 The collate category
22.4.4.1 Class template collate

[category.collate]
[locale.collate]

namespace std {

template <class charT>
class collate : public locale::facet {
public:

typedef charT
typedef basic_string<charT> string_type;

char_type;

explicit collate(size_t refs = 0);

247) Thus, the string "\003" speciﬁes groups of 3 digits each, and "3" probably indicates groups of 51 (!) digits each, because
51 is the ASCII value of "3".

§ 22.4.4.1

724

c(cid:13) ISO/IEC

N4296

int compare(const charT* low1, const charT* high1,

const charT* low2, const charT* high2) const;

string_type transform(const charT* low, const charT* high) const;
long hash(const charT* low, const charT* high) const;

static locale::id id;

protected:

~collate();
virtual int do_compare(const charT* low1, const charT* high1,

virtual string_type do_transform(const charT* low, const charT* high) const;
virtual long do_hash (const charT* low, const charT* high) const;

const charT* low2, const charT* high2) const;

};

}

1 The class collate<charT> provides features for use in the collation (comparison) and hashing of strings.
A locale member function template, operator(), uses the collate facet to allow a locale to act directly
as the predicate argument for standard algorithms (Clause 25) and containers operating on strings. The
specializations required in Table 81 (22.3.1.1.1), namely collate<char> and collate<wchar_t>, apply
lexicographic ordering (25.4.8).

2 Each function compares a string of characters *p in the range [low,high).

1

2

3

1

2

22.4.4.1.1 collate members
int compare(const charT* low1, const charT* high1,

const charT* low2, const charT* high2) const;

Returns: do_compare(low1, high1, low2, high2)

string_type transform(const charT* low, const charT* high) const;

Returns: do_transform(low, high)

long hash(const charT* low, const charT* high) const;

Returns: do_hash(low, high)

22.4.4.1.2 collate virtual functions
int do_compare(const charT* low1, const charT* high1,

const charT* low2, const charT* high2) const;

[locale.collate.members]

[locale.collate.virtuals]

Returns: 1 if the ﬁrst string is greater than the second, -1 if less, zero otherwise. The specializa-
tions required in Table 81 (22.3.1.1.1), namely collate<char> and collate<wchar_t>, implement a
lexicographical comparison (25.4.8).

string_type do_transform(const charT* low, const charT* high) const;

Returns: A basic_string<charT> value that, compared lexicographically with the result of calling
transform() on another string, yields the same result as calling do_compare() on the same two
strings.248

long do_hash(const charT* low, const charT* high) const;

248) This function is useful when one string is being compared to many other strings.

§ 22.4.4.1.2

725

c(cid:13) ISO/IEC

N4296

3

Returns: An integer value equal to the result of calling hash() on any other string for which do_-
compare() returns 0 (equal) when passed the two strings.
[ Note: The probability that the result
equals that for another string which does not compare equal should be very small, approaching
(1.0/numeric_limits<unsigned long>::max()). — end note ]

22.4.4.2 Class template collate_byname

[locale.collate.byname]

namespace std {

template <class charT>
class collate_byname : public collate<charT> {
public:

typedef basic_string<charT> string_type;
explicit collate_byname(const char*, size_t refs = 0);
explicit collate_byname(const string&, size_t refs = 0);

protected:

~collate_byname();

};

}

22.4.5 The time category

[category.time]
1 Templates time_get<charT,InputIterator> and time_put<charT,OutputIterator> provide date and
time formatting and parsing. All speciﬁcations of member functions for time_put and time_get in the
subclauses of 22.4.5 only apply to the specializations required in Tables 81 and 82 (22.3.1.1.1). Their
members use their ios_base&, ios_base::iostate&, and fill arguments as described in (22.4), and the
ctype<> facet, to determine formatting details.
22.4.5.1 Class template time_get

[locale.time.get]

namespace std {

class time_base {
public:

};

enum dateorder { no_order, dmy, mdy, ymd, ydm };

template <class charT, class InputIterator = istreambuf_iterator<charT> >
class time_get : public locale::facet, public time_base {
public:

typedef charT
typedef InputIterator

char_type;
iter_type;

explicit time_get(size_t refs = 0);

dateorder date_order()
iter_type get_time(iter_type s, iter_type end, ios_base& f,

const { return do_date_order(); }

iter_type get_date(iter_type s, iter_type end, ios_base& f,

ios_base::iostate& err, tm* t)

const;

ios_base::iostate& err, tm* t)

const;

iter_type get_weekday(iter_type s, iter_type end, ios_base& f,

ios_base::iostate& err, tm* t) const;

iter_type get_monthname(iter_type s, iter_type end, ios_base& f,

ios_base::iostate& err, tm* t) const;

iter_type get_year(iter_type s, iter_type end, ios_base& f,

iter_type get(iter_type s, iter_type end, ios_base& f,

ios_base::iostate& err, tm* t) const;

iter_type get(iter_type s, iter_type end, ios_base& f,

ios_base::iostate& err, tm* t, char format, char modifier = 0) const;

§ 22.4.5.1

726

c(cid:13) ISO/IEC

N4296

ios_base::iostate& err, tm* t, const char_type* fmt,
const char_type* fmtend) const;

static locale::id id;

~time_get();
virtual dateorder do_date_order()
virtual iter_type do_get_time(iter_type s, iter_type end, ios_base&,
ios_base::iostate& err, tm* t) const;
virtual iter_type do_get_date(iter_type s, iter_type end, ios_base&,
ios_base::iostate& err, tm* t) const;

const;

virtual iter_type do_get_weekday(iter_type s, iter_type end, ios_base&,
ios_base::iostate& err, tm* t) const;

virtual iter_type do_get_monthname(iter_type s, iter_type end, ios_base&,
ios_base::iostate& err, tm* t) const;

virtual iter_type do_get_year(iter_type s, iter_type end, ios_base&,
ios_base::iostate& err, tm* t) const;

virtual iter_type do_get(iter_type s, iter_type end, ios_base& f,

ios_base::iostate& err, tm* t, char format, char modifier) const;

protected:

};

}

1 time_get is used to parse a character sequence, extracting components of a time or date into a struct
tm record. Each get member parses a format as produced by a corresponding format speciﬁer to time_-
put<>::put. If the sequence being parsed matches the correct format, the corresponding members of the
struct tm argument are set to the values used to produce the sequence; otherwise either an error is reported
or unspeciﬁed values are assigned.249
If the end iterator is reached during parsing by any of the get() member functions, the member sets ios_-
base::eofbit in err.
22.4.5.1.1 time_get members
dateorder date_order() const;

[locale.time.get.members]

2

1

2

3

4

Returns: do_date_order()

iter_type get_time(iter_type s, iter_type end, ios_base& str,

ios_base::iostate& err, tm* t) const;

Returns: do_get_time(s, end, str, err, t)

iter_type get_date(iter_type s, iter_type end, ios_base& str,

ios_base::iostate& err, tm* t) const;

Returns: do_get_date(s, end, str, err, t)

iter_type get_weekday(iter_type s, iter_type end, ios_base& str,

ios_base::iostate& err, tm* t) const;

iter_type get_monthname(iter_type s, iter_type end, ios_base& str,

ios_base::iostate& err, tm* t) const;

Returns: do_get_weekday(s, end, str, err, t) or do_get_monthname(s, end, str, err, t)

249) In other words, user conﬁrmation is required for reliable parsing of user-entered dates and times, but machine-generated
formats can be parsed reliably. This allows parsers to be aggressive about interpreting user variations on standard formats.

§ 22.4.5.1.1

727

5

6

7

8

(8.1)

(8.2)

(8.3)

(8.4)

(8.5)

(8.6)

9

10

1

c(cid:13) ISO/IEC

N4296

iter_type get_year(iter_type s, iter_type end, ios_base& str,

ios_base::iostate& err, tm* t) const;

Returns: do_get_year(s, end, str, err, t)

iter_type get(iter_type s, iter_type end, ios_base& f,

ios_base::iostate& err, tm* t, char format, char modifier = 0) const;
Returns: do_get(s, end, f, err, t, format, modifier)

iter_type get(iter_type s, iter_type end, ios_base& f,

ios_base::iostate& err, tm* t, const char_type* fmt, const char_type* fmtend) const;
Requires: [fmt,fmtend) shall be a valid range.
Eﬀects: The function starts by evaluating err = ios_base::goodbit. It then enters a loop, reading
zero or more characters from s at each iteration. Unless otherwise speciﬁed below, the loop terminates
when the ﬁrst of the following conditions holds:
—
—
—

The expression fmt == fmtend evaluates to true.
The expression err == ios_base::goodbit evaluates to false.
The expression s == end evaluates to true, in which case the function evaluates err = ios_-
base::eofbit | ios_base::failbit.
The next element of fmt is equal to ’%’, optionally followed by a modiﬁer character, followed
by a conversion speciﬁer character, format, together forming a conversion speciﬁcation valid for
the ISO/IEC 9945 function strptime. If the number of elements in the range [fmt,fmtend) is
not suﬃcient to unambiguously determine whether the conversion speciﬁcation is complete and
valid, the function evaluates err = ios_base::failbit. Otherwise, the function evaluates s =
do_get(s, end, f, err, t, format, modifier), where the value of modifier is ’\0’ when
the optional modiﬁer is absent from the conversion speciﬁcation. If err == ios_base::goodbit
holds after the evaluation of the expression, the function increments fmt to point just past the
end of the conversion speciﬁcation and continues looping.
The expression isspace(*fmt, f.getloc()) evaluates to true, in which case the function ﬁrst
increments fmt until fmt == fmtend || !isspace(*fmt, f.getloc()) evaluates to true, then
advances s until s == end || !isspace(*s, f.getloc()) is true, and ﬁnally resumes looping.
The next character read from s matches the element pointed to by fmt in a case-insensitive
comparison, in which case the function evaluates ++fmt, ++s and continues looping. Otherwise,
the function evaluates err = ios_base::failbit.

—

—

—

[ Note: The function uses the ctype<charT> facet installed in f’s locale to determine valid whitespace
characters.
It is unspeciﬁed by what means the function performs case-insensitive comparison or
whether multi-character sequences are considered while doing so. — end note ]
Returns: s

22.4.5.1.2 time_get virtual functions
dateorder do_date_order() const;

[locale.time.get.virtuals]

Returns: An enumeration value indicating the preferred order of components for those date formats
that are composed of day, month, and year.250 Returns no_order if the date format speciﬁed by ’x’
contains other variable components (e.g., Julian day, week number, week day).

iter_type do_get_time(iter_type s, iter_type end, ios_base& str,

ios_base::iostate& err, tm* t) const;

250) This function is intended as a convenience only, for common formats, and may return no_order in valid locales.

§ 22.4.5.1.2

728

2

3

4

5

6

7

8

9

10

11

12

c(cid:13) ISO/IEC

N4296

Eﬀects: Reads characters starting at s until it has extracted those struct tm members, and remaining
format characters, used by time_put<>::put to produce the format speciﬁed by "%H:%M:%S", or until
it encounters an error or end of sequence.
Returns: An iterator pointing immediately beyond the last character recognized as possibly part of a
valid time.

iter_type do_get_date(iter_type s, iter_type end, ios_base& str,

ios_base::iostate& err, tm* t) const;

Eﬀects: Reads characters starting at s until it has extracted those struct tm members and remaining
format characters used by time_put<>::put to produce one of the following formats, or until it
encounters an error. The format depends on the value returned by date_order() as shown in Table 92.

Table 92 — do_get_date eﬀects

date_order()
no_order
dmy
mdy
ymd
ydm

Format
"%m%d%y"
"%d%m%y"
"%m%d%y"
"%y%m%d"
"%y%d%m"

An implementation may also accept additional implementation-deﬁned formats.
Returns: An iterator pointing immediately beyond the last character recognized as possibly part of a
valid date.

iter_type do_get_weekday(iter_type s, iter_type end, ios_base& str,

ios_base::iostate& err, tm* t) const;

iter_type do_get_monthname(iter_type s, iter_type end, ios_base& str,

ios_base::iostate& err, tm* t) const;

Eﬀects: Reads characters starting at s until it has extracted the (perhaps abbreviated) name of a
weekday or month. If it ﬁnds an abbreviation that is followed by characters that could match a full
name, it continues reading until it matches the full name or fails. It sets the appropriate struct tm
member accordingly.
Returns: An iterator pointing immediately beyond the last character recognized as part of a valid
name.

iter_type do_get_year(iter_type s, iter_type end, ios_base& str,

ios_base::iostate& err, tm* t) const;

Eﬀects: Reads characters starting at s until it has extracted an unambiguous year identiﬁer. It is
implementation-deﬁned whether two-digit year numbers are accepted, and (if so) what century they
are assumed to lie in. Sets the t->tm_year member accordingly.
Returns: An iterator pointing immediately beyond the last character recognized as part of a valid year
identiﬁer.

iter_type do_get(iter_type s, iter_type end, ios_base& f,

ios_base::iostate& err, tm* t, char format, char modifier) const;
Requires: t shall point to an object.
Eﬀects: The function starts by evaluating err = ios_base::goodbit. It then reads characters start-
ing at s until it encounters an error, or until it has extracted and assigned those struct tm members,

§ 22.4.5.1.2

729

c(cid:13) ISO/IEC

N4296

and any remaining format characters, corresponding to a conversion directive appropriate for the
ISO/IEC 9945 function strptime, formed by concatenating ’%’, the modifier character, when non-
NUL, and the format character. When the concatenation fails to yield a complete valid directive
the function leaves the object pointed to by t unchanged and evaluates err |= ios_base::failbit.
When s == end evaluates to true after reading a character the function evaluates err |= ios_-
base::eofbit.
For complex conversion directives such as %c, %x, or %X, or directives that involve the optional modiﬁers
E or O, when the function is unable to unambiguously determine some or all struct tm members from
the input sequence [s,end), it evaluates err |= ios_base::eofbit. In such cases the values of those
struct tm members are unspeciﬁed and may be outside their valid range.
Remark: It is unspeciﬁed whether multiple calls to do_get() with the address of the same struct
tm object will update the current contents of the object or simply overwrite its members. Portable
programs must zero out the object before invoking the function.
Returns: An iterator pointing immediately beyond the last character recognized as possibly part of a
valid input sequence for the given format and modifier.

13

14

15

22.4.5.2 Class template time_get_byname

[locale.time.get.byname]

namespace std {

template <class charT, class InputIterator = istreambuf_iterator<charT> >
class time_get_byname : public time_get<charT, InputIterator> {
public:

typedef time_base::dateorder dateorder;
typedef InputIterator
iter_type;

explicit time_get_byname(const char*, size_t refs = 0);
explicit time_get_byname(const string&, size_t refs = 0);

protected:

~time_get_byname();

};

}

22.4.5.3 Class template time_put

[locale.time.put]

namespace std {

template <class charT, class OutputIterator = ostreambuf_iterator<charT> >
class time_put : public locale::facet {
public:

typedef charT
typedef OutputIterator

char_type;
iter_type;

explicit time_put(size_t refs = 0);

// the following is implemented in terms of other member functions.
iter_type put(iter_type s, ios_base& f, char_type fill, const tm* tmb,

const charT* pattern, const charT* pat_end) const;

iter_type put(iter_type s, ios_base& f, char_type fill,

const tm* tmb, char format, char modifier = 0) const;

static locale::id id;

protected:

~time_put();
virtual iter_type do_put(iter_type s, ios_base&, char_type, const tm* t,

§ 22.4.5.3

730

c(cid:13) ISO/IEC

};

}

char format, char modifier) const;

22.4.5.3.1 time_put members
iter_type put(iter_type s, ios_base& str, char_type fill, const tm* t,

const charT* pattern, const charT* pat_end) const;

iter_type put(iter_type s, ios_base& str, char_type fill, const tm* t,

char format, char modifier = 0) const;

N4296

[locale.time.put.members]

1

2

3

4

1

2

Eﬀects: The ﬁrst form steps through the sequence from pattern to pat_end, identifying characters
that are part of a format sequence. Each character that is not part of a format sequence is written
to s immediately, and each format sequence, as it is identiﬁed, results in a call to do_put; thus,
format elements and other characters are interleaved in the output in the order in which they appear
in the pattern. Format sequences are identiﬁed by converting each character c to a char value as
if by ct.narrow(c,0), where ct is a reference to ctype<charT> obtained from str.getloc(). The
ﬁrst character of each sequence is equal to ’%’, followed by an optional modiﬁer character mod251
and a format speciﬁer character spec as deﬁned for the function strftime. If no modiﬁer character
is present, mod is zero. For each valid format sequence identiﬁed, calls do_put(s, str, fill, t,
spec, mod).
The second form calls do_put(s, str, fill, t, format, modifier).
[ Note: The fill argument may be used in the implementation-deﬁned formats or by derivations. A
space character is a reasonable default for this argument. — end note ]
Returns: An iterator pointing immediately after the last character produced.

22.4.5.3.2 time_put virtual functions
iter_type do_put(iter_type s, ios_base&, char_type fill, const tm* t,

char format, char modifier) const;

[locale.time.put.virtuals]

Eﬀects: Formats the contents of the parameter t into characters placed on the output sequence s.
Formatting is controlled by the parameters format and modifier, interpreted identically as the format
speciﬁers in the string argument to the standard library function strftime()252, except that the
sequence of characters produced for those speciﬁers that are described as depending on the C locale
are instead implementation-deﬁned.253
Returns: An iterator pointing immediately after the last character produced. [ Note: The fill argu-
ment may be used in the implementation-deﬁned formats or by derivations. A space character is a
reasonable default for this argument. — end note ]

22.4.5.4 Class template time_put_byname

[locale.time.put.byname]

namespace std {

template <class charT, class OutputIterator = ostreambuf_iterator<charT> >
class time_put_byname : public time_put<charT, OutputIterator>
{
public:

typedef charT
char_type;
typedef OutputIterator iter_type;

explicit time_put_byname(const char*, size_t refs = 0);

251) Although the C programming language deﬁnes no modiﬁers, most vendors do.
252) Interpretation of the modifier argument is implementation-deﬁned, but should follow POSIX conventions.
253) Implementations are encouraged to refer to other standards such as POSIX for these deﬁnitions.

§ 22.4.5.4

731

c(cid:13) ISO/IEC

N4296

explicit time_put_byname(const string&, size_t refs = 0);

protected:

~time_put_byname();

};

}

22.4.6 The monetary category

[category.monetary]
1 These templates handle monetary formats. A template parameter indicates whether local or international

monetary formats are to be used.

2 All speciﬁcations of member functions for money_put and money_get in the subclauses of 22.4.6 only apply
to the specializations required in Tables 81 and 82 (22.3.1.1.1). Their members use their ios_base&, ios_-
base :: iostate&, and fill arguments as described in (22.4), and the moneypunct<> and ctype<> facets,
to determine formatting details.
22.4.6.1 Class template money_get

[locale.money.get]

namespace std {

template <class charT,

class InputIterator = istreambuf_iterator<charT> >

class money_get : public locale::facet {
public:

typedef charT
typedef InputIterator
typedef basic_string<charT> string_type;

char_type;
iter_type;

explicit money_get(size_t refs = 0);

iter_type get(iter_type s, iter_type end, bool intl,

ios_base& f, ios_base::iostate& err,
long double& units) const;

iter_type get(iter_type s, iter_type end, bool intl,

ios_base& f, ios_base::iostate& err,
string_type& digits) const;

static locale::id id;

~money_get();
virtual iter_type do_get(iter_type, iter_type, bool, ios_base&,

virtual iter_type do_get(iter_type, iter_type, bool, ios_base&,

ios_base::iostate& err, long double& units) const;

ios_base::iostate& err, string_type& digits) const;

protected:

};

}

22.4.6.1.1 money_get members
iter_type get(iter_type s, iter_type end, bool intl,

ios_base& f, ios_base::iostate& err,
long double& quant) const;

iter_type get(s, iter_type end, bool intl, ios_base&f,

ios_base::iostate& err, string_type& quant) const;

[locale.money.get.members]

1

Returns: do_get(s, end, intl, f, err, quant)

22.4.6.1.2 money_get virtual functions

[locale.money.get.virtuals]

§ 22.4.6.1.2

732

c(cid:13) ISO/IEC

N4296

iter_type do_get(iter_type s, iter_type end, bool intl,
ios_base& str, ios_base::iostate& err,
long double& units) const;

iter_type do_get(iter_type s, iter_type end, bool intl,
ios_base& str, ios_base::iostate& err,
string_type& digits) const;

1

2

3

4

Eﬀects: Reads characters from s to parse and construct a monetary value according to the for-
mat speciﬁed by a moneypunct<charT,Intl> facet reference mp and the character mapping spec-
iﬁed by a ctype<charT> facet reference ct obtained from the locale returned by str.getloc(),
and str.flags().
If a valid sequence is recognized, does not change err; otherwise, sets err to
(err|str.failbit), or (err|str.failbit|str.eofbit) if no more characters are available, and
does not change units or digits. Uses the pattern returned by mp.neg_format() to parse all values.
The result is returned as an integral value stored in units or as a sequence of digits possibly pre-
ceded by a minus sign (as produced by ct.widen(c) where c is ’-’ or in the range from ’0’ through
’9’, inclusive) stored in digits.
[ Example: The sequence $1,056.23 in a common United States
locale would yield, for units, 105623, or, for digits, "105623". — end example ] If mp.grouping()
indicates that no thousands separators are permitted, any such characters are not read, and parsing
is terminated at the point where they ﬁrst appear. Otherwise, thousands separators are optional; if
present, they are checked for correct placement only after all format components have been read.
Where money_base::space or money_base::none appears as the last element in the format pattern, no
white space is consumed. Otherwise, where money_base::space appears in any of the initial elements
of the format pattern, at least one white space character is required. Where money_base::none
appears in any of the initial elements of the format pattern, white space is allowed but not required.
If (str.flags() & str.showbase) is false, the currency symbol is optional and is consumed only if
other characters are needed to complete the format; otherwise, the currency symbol is required.
If the ﬁrst character (if any) in the string pos returned by mp.positive_sign() or the string neg
returned by mp.negative_sign() is recognized in the position indicated by sign in the format pattern,
it is consumed and any remaining characters in the string are required after all the other format
components.
[ Example: If showbase is oﬀ, then for a neg value of "()" and a currency symbol of
"L", in "(100 L)" the "L" is consumed; but if neg is "-", the "L" in "-100 L" is not consumed.
— end example ] If pos or neg is empty, the sign component is optional, and if no sign is detected, the
result is given the sign that corresponds to the source of the empty string. Otherwise, the character
in the indicated position must match the ﬁrst character of pos or neg, and the result is given the
corresponding sign. If the ﬁrst character of pos is equal to the ﬁrst character of neg, or if both strings
are empty, the result is given a positive sign.
Digits in the numeric monetary component are extracted and placed in digits, or into a character
buﬀer buf1 for conversion to produce a value for units, in the order in which they appear, preceded
by a minus sign if and only if the result is negative. The value units is produced as if by254

buf2[i] = src[find(atoms, atoms+sizeof(src), buf1[i]) - atoms];

for (int i = 0; i < n; ++i)

buf2[n] = 0;
sscanf(buf2, "%Lf", &units);

where n is the number of characters placed in buf1, buf2 is a character buﬀer, and the values src and
atoms are deﬁned as if by

static const char src[] = "0123456789-";
charT atoms[sizeof(src)];
ct.widen(src, src + sizeof(src) - 1, atoms);

254) The semantics here are diﬀerent from ct.narrow.

§ 22.4.6.1.2

733

c(cid:13) ISO/IEC

N4296

5

Returns: An iterator pointing immediately beyond the last character recognized as part of a valid
monetary quantity.

22.4.6.2 Class template money_put

[locale.money.put]

namespace std {

template <class charT,

class OutputIterator = ostreambuf_iterator<charT> >

class money_put : public locale::facet {
public:

typedef charT
typedef OutputIterator
typedef basic_string<charT> string_type;

char_type;
iter_type;

explicit money_put(size_t refs = 0);

iter_type put(iter_type s, bool intl, ios_base& f,

iter_type put(iter_type s, bool intl, ios_base& f,

char_type fill, long double units) const;

char_type fill, const string_type& digits) const;

static locale::id id;

protected:

~money_put();
virtual iter_type do_put(iter_type, bool, ios_base&, char_type fill,

long double units) const;

virtual iter_type do_put(iter_type, bool, ios_base&, char_type fill,

const string_type& digits) const;

};

}

1

1

22.4.6.2.1 money_put members
iter_type put(iter_type s, bool intl, ios_base& f, char_type fill,

long double quant) const;

iter_type put(iter_type s, bool intl, ios_base& f, char_type fill,

const string_type& quant) const;
Returns: do_put(s, intl, f, loc, quant)

22.4.6.2.2 money_put virtual functions
iter_type do_put(iter_type s, bool intl, ios_base& str,

iter_type do_put(iter_type s, bool intl, ios_base& str,

char_type fill, long double units) const;

char_type fill, const string_type& digits) const;

[locale.money.put.members]

[locale.money.put.virtuals]

Eﬀects: Writes characters to s according to the format speciﬁed by a moneypunct<charT,Intl> facet
reference mp and the character mapping speciﬁed by a ctype<charT> facet reference ct obtained from
the locale returned by str.getloc(), and str.flags(). The argument units is transformed into a
sequence of wide characters as if by

ct.widen(buf1, buf1 + sprintf(buf1, "%.0Lf", units), buf2)

for character buﬀers buf1 and buf2. If the ﬁrst character in digits or buf2 is equal to ct.widen(’-’),
then the pattern used for formatting is the result of mp.neg_format(); otherwise the pattern is the
result of mp.pos_format(). Digit characters are written, interspersed with any thousands separators

§ 22.4.6.2.2

734

c(cid:13) ISO/IEC

N4296

and decimal point speciﬁed by the format, in the order they appear (after the optional leading minus
sign) in digits or buf2. In digits, only the optional leading minus sign and the immediately subse-
quent digit characters (as classiﬁed according to ct) are used; any trailing characters (including digits
appearing after a non-digit character) are ignored. Calls str.width(0).
Remarks: The currency symbol is generated if and only if (str.flags() & str.showbase) is nonzero.
If the number of characters generated for the speciﬁed format is less than the value returned by
str.width() on entry to the function, then copies of fill are inserted as necessary to pad to the speci-
ﬁed width. For the value af equal to (str.flags() & str.adjustfield), if (af == str.internal)
is true, the ﬁll characters are placed where none or space appears in the formatting pattern; otherwise
if (af == str.left) is true, they are placed after the other characters; otherwise, they are placed
before the other characters. [ Note: It is possible, with some combinations of format patterns and ﬂag
values, to produce output that cannot be parsed using num_get<>::get. — end note ]
Returns: An iterator pointing immediately after the last character produced.

2

3

22.4.6.3 Class template moneypunct

[locale.moneypunct]

namespace std {

class money_base {
public:

enum part { none, space, symbol, sign, value };
struct pattern { char field[4]; };

};

template <class charT, bool International = false>
class moneypunct : public locale::facet, public money_base {
public:

typedef charT char_type;
typedef basic_string<charT> string_type;

explicit moneypunct(size_t refs = 0);

charT
charT
string
string_type
string_type
string_type
int
pattern
pattern

decimal_point() const;
thousands_sep() const;
const;
grouping()
curr_symbol()
const;
positive_sign() const;
negative_sign() const;
const;
frac_digits()
const;
pos_format()
neg_format()
const;

static locale::id id;
static const bool intl = International;

protected:

~moneypunct();
virtual charT
virtual charT
virtual string
virtual string_type
virtual string_type
virtual string_type
virtual int
virtual pattern

do_decimal_point() const;
do_thousands_sep() const;
const;
do_grouping()
do_curr_symbol()
const;
do_positive_sign() const;
do_negative_sign() const;
const;
do_frac_digits()
do_pos_format()
const;

§ 22.4.6.3

735

c(cid:13) ISO/IEC

N4296

virtual pattern

do_neg_format()

const;

};

}

1 The moneypunct<> facet deﬁnes monetary formatting parameters used by money_get<> and money_put<>.
A monetary format is a sequence of four components, speciﬁed by a pattern value p, such that the part value
static_cast<part>(p.field[i]) determines the ith component of the format255 In the field member of
a pattern object, each value symbol, sign, value, and either space or none appears exactly once. The
value none, if present, is not ﬁrst; the value space, if present, is neither ﬁrst nor last.

2 Where none or space appears, white space is permitted in the format, except where none appears at the end,
in which case no white space is permitted. The value space indicates that at least one space is required at
that position. Where symbol appears, the sequence of characters returned by curr_symbol() is permitted,
and can be required. Where sign appears, the ﬁrst (if any) of the sequence of characters returned by
positive_sign() or negative_sign() (respectively as the monetary value is non-negative or negative) is
required. Any remaining characters of the sign sequence are required after all other format components.
Where value appears, the absolute numeric monetary value is required.

3 The format of the numeric monetary value is a decimal number:

value ::= units [ decimal-point [ digits ]] |

decimal-point digits

if frac_digits() returns a positive value, or

value ::= units

otherwise. The symbol decimal-point indicates the character returned by decimal_point(). The other
symbols are deﬁned as follows:

units ::= digits [ thousands-sep units ]
digits ::= adigit [ digits ]

In the syntax speciﬁcation, the symbol adigit is any of the values ct.widen(c) for c in the range ’0’
through ’9’, inclusive, and ct is a reference of type const ctype<charT>& obtained as described in the
deﬁnitions of money_get<> and money_put<>. The symbol thousands-sep is the character returned by
thousands_sep(). The space character used is the value ct.widen(’ ’). White space characters are those
characters c for which ci.is(space,c) returns true. The number of digits required after the decimal point
(if any) is exactly the value returned by frac_digits().

4 The placement of thousands-separator characters (if any) is determined by the value returned by grouping(),

deﬁned identically as the member numpunct<>::do_grouping().
22.4.6.3.1 moneypunct members

[locale.moneypunct.members]

charT
charT
string
string_type
string_type
string_type
int
pattern
pattern

decimal_point() const;
thousands_sep() const;
const;
grouping()
curr_symbol()
const;
positive_sign() const;
negative_sign() const;
const;
frac_digits()
const;
pos_format()
neg_format()
const;

1 Each of these functions F returns the result of calling the corresponding virtual member function do_F().
[locale.moneypunct.virtuals]

22.4.6.3.2 moneypunct virtual functions
255) An array of char, rather than an array of part, is speciﬁed for pattern::field purely for eﬃciency.

§ 22.4.6.3.2

736

c(cid:13) ISO/IEC

N4296

charT do_decimal_point() const;

Returns: The radix separator to use in case do_frac_digits() is greater than zero.256

charT do_thousands_sep() const;

Returns: The digit group separator to use in case do_grouping() speciﬁes a digit grouping pattern.257

string do_grouping() const;

Returns: A pattern deﬁned identically as, but not necessarily equal to, the result of numpunct<charT>::
do_grouping().258

string_type do_curr_symbol() const;

Returns: A string to use as the currency identiﬁer symbol.259

string_type do_positive_sign() const;
string_type do_negative_sign() const;

Returns: do_positive_sign() returns the string to use to indicate a positive monetary value;260
do_negative_sign() returns the string to use to indicate a negative value.

int do_frac_digits() const;

Returns: The number of digits after the decimal radix separator, if any.261

pattern do_pos_format() const;
pattern do_neg_format() const;

Returns: The specializations required in Table 82 (22.3.1.1.1), namely moneypunct<char>, moneypunct<
wchar_t>, moneypunct<char,true>, and moneypunct<wchar_t,true>, return an object of type pattern
initialized to { symbol, sign, none, value }.262

22.4.6.4 Class template moneypunct_byname

[locale.moneypunct.byname]

1

2

3

4

5

6

7

namespace std {

template <class charT, bool Intl = false>
class moneypunct_byname : public moneypunct<charT, Intl> {
public:

typedef money_base::pattern pattern;
typedef basic_string<charT> string_type;

explicit moneypunct_byname(const char*, size_t refs = 0);
explicit moneypunct_byname(const string&, size_t refs = 0);

protected:

~moneypunct_byname();

};

}

22.4.7 The message retrieval category

[category.messages]

1 Class messages<charT> implements retrieval of strings from message catalogs.

256) In common U.S. locales this is ’.’.
257) In common U.S. locales this is ’,’.
258) To specify grouping by 3s, the value is "\003" not "3".
259) For international specializations (second template parameter true) this is typically four characters long, usually three
letters and a space.
260) This is usually the empty string.
261) In common U.S. locales, this is 2.
262) Note that the international symbol returned by do_curr_sym() usually contains a space, itself; for example, "USD ".

§ 22.4.7

737

c(cid:13) ISO/IEC

22.4.7.1 Class template messages

N4296

[locale.messages]

namespace std {

class messages_base {
public:

};

typedef unspecified signed integer type catalog;

template <class charT>
class messages : public locale::facet, public messages_base {
public:

typedef charT char_type;
typedef basic_string<charT> string_type;

explicit messages(size_t refs = 0);

catalog open(const basic_string<char>& fn, const locale&) const;
string_type get(catalog c, int set, int msgid,

const string_type& dfault) const;

void close(catalog c) const;

static locale::id id;

~messages();
virtual catalog do_open(const basic_string<char>&, const locale&) const;
virtual string_type do_get(catalog, int set, int msgid,

const string_type& dfault) const;

virtual void do_close(catalog) const;

protected:

};

}

1 Values of type messages_base::catalog usable as arguments to members get and close can be obtained

only by calling member open.
22.4.7.1.1 messages members
catalog open(const basic_string<char>& name, const locale& loc) const;

[locale.messages.members]

[locale.messages.virtuals]

Returns: do_open(name, loc).

string_type get(catalog cat, int set, int msgid,
const string_type& dfault) const;
Returns: do_get(cat, set, msgid, dfault).

void

close(catalog cat) const;
Eﬀects: Calls do_close(cat).

22.4.7.1.2 messages virtual functions
catalog do_open(const basic_string<char>& name,

const locale& loc) const;

1

2

3

1

2

Returns: A value that may be passed to get() to retrieve a message from the message catalog identiﬁed
by the string name according to an implementation-deﬁned mapping. The result can be used until it
is passed to close().
Returns a value less than 0 if no such catalog can be opened.

§ 22.4.7.1.2

738

c(cid:13) ISO/IEC

N4296

3

4

5

6

7

8

Remarks: The locale argument loc is used for character set code conversion when retrieving messages,
if needed.

string_type do_get(catalog cat, int set, int msgid,

const string_type& dfault) const;

Requires: cat shall be a catalog obtained from open() and not yet closed.
Returns: A message identiﬁed by arguments set, msgid, and dfault, according to an implementation-
deﬁned mapping. If no such message can be found, returns dfault.

void do_close(catalog cat) const;

Requires: cat shall be a catalog obtained from open() and not yet closed.
Eﬀects: Releases unspeciﬁed resources associated with cat.
Remarks: The limit on such resources, if any, is implementation-deﬁned.

22.4.7.2 Class template messages_byname

[locale.messages.byname]

namespace std {

template <class charT>
class messages_byname : public messages<charT> {
public:

typedef messages_base::catalog catalog;
typedef basic_string<charT>

string_type;

explicit messages_byname(const char*, size_t refs = 0);
explicit messages_byname(const string&, size_t refs = 0);

protected:

~messages_byname();

};

}

22.4.8 Program-deﬁned facets

[facets.examples]
1 A C++ program may deﬁne facets to be added to a locale and used identically as the built-in facets. To
create a new facet interface, C++ programs simply derive from locale::facet a class containing a static
member: static locale::id id.
[ Note: The locale member function templates verify its type and storage class. — end note ]
[ Example: Traditional global localization is still easy:

2

3

// set the global locale
// imbue it on all the std streams

#include <iostream>
#include <locale>
int main(int argc, char** argv) {

using namespace std;
locale::global(locale(""));

cin.imbue(locale());
cout.imbue(locale());
cerr.imbue(locale());
wcin.imbue(locale());
wcout.imbue(locale());
wcerr.imbue(locale());

return MyObject(argc, argv).doit();

}

§ 22.4.8

739

c(cid:13) ISO/IEC

N4296

— end example ]
[ Example: Greater ﬂexibility is possible:

4

#include <iostream>
#include <locale>
int main() {

using namespace std;
cin.imbue(locale(""));
cout.imbue(locale::classic());
double f;
while (cin >> f) cout << f << endl;
return (cin.fail() != 0);

// the user’s preferred locale

}

};

In a European locale, with input 3.456,78, output is 3456.78. — end example ]

5 This can be important even for simple programs, which may need to write a data ﬁle in a ﬁxed format,

regardless of a user’s preference.
[ Example: Here is an example of the use of locales in a library interface.

6

// ﬁle: Date.h
#include <iosfwd>
#include <string>
#include <locale>

class Date {
public:

Date(unsigned day, unsigned month, unsigned year);
std::string asString(const std::locale& = std::locale());

std::istream& operator>>(std::istream& s, Date& d);
std::ostream& operator<<(std::ostream& s, Date d);

7 This example illustrates two architectural uses of class locale.
8 The ﬁrst is as a default argument in Date::asString(), where the default is the global (presumably user-

preferred) locale.

9 The second is in the operators << and >>, where a locale “hitchhikes” on another object, in this case a

stream, to the point where it is needed.

// ﬁle: Date.C
#include "Date"
#include <sstream>
std::string Date::asString(const std::locale& l) {

// includes <ctime>

using namespace std;
ostringstream s; s.imbue(l);
s << *this; return s.str();

}

std::istream& operator>>(std::istream& s, Date& d) {

using namespace std;
istream::sentry cerberos(s);
if (cerberos) {

ios_base::iostate err = goodbit;
struct tm t;

§ 22.4.8

740

c(cid:13) ISO/IEC

N4296

use_facet< time_get<char> >(s.getloc()).get_date(s, 0, s, err, &t);
if (!err) d = Date(t.tm_day, t.tm_mon + 1, t.tm_year + 1900);
s.setstate(err);

}
return s;

}

— end example ]

10 A locale object may be extended with a new facet simply by constructing it with an instance of a class
derived from locale::facet. The only member a C++ program must deﬁne is the static member id, which
identiﬁes your class interface as a new facet.
[ Example: Classifying Japanese characters:

11

// ﬁle: <jctype>
#include <locale>
namespace My {

using namespace std;
class JCtype : public locale::facet {
public:

static locale::id id;
bool is_kanji (wchar_t c) const;
JCtype() { }

protected:

~JCtype() { }

};

}

// required for use as a new locale facet

// ﬁle: filt.C
#include <iostream>
#include <locale>
#include "jctype"
std::locale::id My::JCtype::id; // the static JCtype member declared above.

// above

int main() {

using namespace std;
typedef ctype<wchar_t> wctype;
locale loc(locale(""),
new My::JCtype);

// the user’s preferred locale ...
// and a new feature ...

wchar_t c = use_facet<wctype>(loc).widen(’!’);
if (!use_facet<My::JCtype>(loc).is_kanji(c))

cout << "no it isn’t!" << endl;

return 0;

}

12 The new facet is used exactly like the built-in facets. — end example ]
13

[ Example: Replacing an existing facet is even easier. The code does not deﬁne a member id because it is
reusing the numpunct<charT> facet interface:

// ﬁle: my_bool.C
#include <iostream>
#include <locale>
#include <string>
namespace My {

using namespace std;
typedef numpunct_byname<char> cnumpunct;

§ 22.4.8

741

c(cid:13) ISO/IEC

N4296

class BoolNames : public cnumpunct {
protected:

string do_truename()
const { return "Oui Oui!"; }
string do_falsename() const { return "Mais Non!"; }
~BoolNames() { }

BoolNames(const char* name) : cnumpunct(name) { }

public:

};

}

int main(int argc, char** argv) {

using namespace std;
// make the user’s preferred locale, except for...
locale loc(locale(""), new My::BoolNames(""));
cout.imbue(loc);
cout << boolalpha << "Any arguments today? " << (argc > 1) << endl;
return 0;

}

— end example ]
22.5 Standard code conversion facets

1 The header <codecvt> provides code conversion facets for various character encodings.
2 Header <codecvt> synopsis

[locale.stdcvt]

namespace std {

enum codecvt_mode {

consume_header = 4,
generate_header = 2,
little_endian = 1

};

};

};

template<class Elem, unsigned long Maxcode = 0x10ffff,

codecvt_mode Mode = (codecvt_mode)0>

class codecvt_utf8

: public codecvt<Elem, char, mbstate_t> {

public:

explicit codecvt_utf8(size_t refs = 0);
~codecvt_utf8();

template<class Elem, unsigned long Maxcode = 0x10ffff,

codecvt_mode Mode = (codecvt_mode)0>

class codecvt_utf16

: public codecvt<Elem, char, mbstate_t> {

public:

explicit codecvt_utf16(size_t refs = 0);
~codecvt_utf16();

template<class Elem, unsigned long Maxcode = 0x10ffff,

codecvt_mode Mode = (codecvt_mode)0>

class codecvt_utf8_utf16

: public codecvt<Elem, char, mbstate_t> {

public:

§ 22.5

742

c(cid:13) ISO/IEC

N4296

explicit codecvt_utf8_utf16(size_t refs = 0);
~codecvt_utf8_utf16();

};

}

3 For each of the three code conversion facets codecvt_utf8, codecvt_utf16, and codecvt_utf8_utf16:

(3.1)

(3.2)

(3.3)

(3.4)

(3.5)

—
—

—

—

—

Elem is the wide-character type, such as wchar_t, char16_t, or char32_t.
Maxcode is the largest wide-character code that the facet will read or write without reporting a con-
version error.
If (Mode & consume_header), the facet shall consume an initial header sequence, if present, when
reading a multibyte sequence to determine the endianness of the subsequent multibyte sequence to be
read.
If (Mode & generate_header), the facet shall generate an initial header sequence when writing a
multibyte sequence to advertise the endianness of the subsequent multibyte sequence to be written.
If (Mode & little_endian), the facet shall generate a multibyte sequence in little-endian order, as
opposed to the default big-endian order.

4 For the facet codecvt_utf8:

(4.1)

(4.2)

(4.3)

—

—
—

The facet shall convert between UTF-8 multibyte sequences and UCS2 or UCS4 (depending on the
size of Elem) within the program.
Endianness shall not aﬀect how multibyte sequences are read or written.
The multibyte sequences may be written as either a text or a binary ﬁle.

5 For the facet codecvt_utf16:

(5.1)

(5.2)

(5.3)

—

The facet shall convert between UTF-16 multibyte sequences and UCS2 or UCS4 (depending on the
size of Elem) within the program.
Multibyte sequences shall be read or written according to the Mode ﬂag, as set out above.
The multibyte sequences may be written only as a binary ﬁle. Attempting to write to a text ﬁle
produces undeﬁned behavior.
6 For the facet codecvt_utf8_utf16:

—
—

(6.1)

(6.2)

(6.3)

—

—
—

The facet shall convert between UTF-8 multibyte sequences and UTF-16 (one or two 16-bit codes)
within the program.
Endianness shall not aﬀect how multibyte sequences are read or written.
The multibyte sequences may be written as either a text or a binary ﬁle.

See also: ISO/IEC 10646-1:1993.
22.6 C library locales

[c.locales]

1 Table 93 describes header <clocale>.
2 The contents are the same as the Standard C library header <locale.h>.
3 Calls to the function setlocale may introduce a data race (17.6.5.9) with other calls to setlocale or with

calls to the functions listed in Table 94.
See also: ISO C Clause 7.4.

§ 22.6

743

c(cid:13) ISO/IEC

N4296

Table 93 — Header <clocale> synopsis

Type
Macros:

Struct:
Functions:

LC_ALL
LC_MONETARY
NULL
lconv
localeconv

Name(s)
LC_COLLATE
LC_NUMERIC

LC_CTYPE
LC_TIME

setlocale

Table 94 — Potential setlocale data races

fprintf
fscanf
isalnum
isalpha
isblank
iscntrl
isdigit
isgraph
islower

isprint
ispunct
isspace
isupper
iswalnum
iswalpha
iswblank
iswcntrl
iswctype

iswdigit
iswgraph
iswlower
iswprint
iswpunct
iswspace
iswupper
iswxdigit
isxdigit

localeconv
mblen
mbstowcs
mbtowc
setlocale
strcoll
strerror
strtod
strxfrm

tolower
toupper
towlower
towupper
wcscoll
wcstod
wcstombs
wcsxfrm
wctomb

§ 22.6

744

c(cid:13) ISO/IEC

23 Containers library
23.1 General

N4296

[containers]
[containers.general]

1 This Clause describes components that C++ programs may use to organize collections of information.
2 The following subclauses describe container requirements, and components for sequence containers and

associative containers, as summarized in Table 95.

Table 95 — Containers library summary

Subclause

23.2 Requirements
23.3

Sequence containers

23.4 Associative containers

23.5 Unordered associative containers

23.6 Container adaptors

Header(s)

<array>
<deque>
<forward_list>
<list>
<vector>
<map>
<set>
<unordered_map>
<unordered_set>
<queue>
<stack>

23.2 Container requirements
23.2.1 General container requirements

[container.requirements]
[container.requirements.general]
1 Containers are objects that store other objects. They control allocation and deallocation of these objects

through constructors, destructors, insert and erase operations.

2 All of the complexity requirements in this Clause are stated solely in terms of the number of operations on the
contained objects. [ Example: the copy constructor of type vector <vector<int> > has linear complexity,
even though the complexity of copying each contained vector<int> is itself linear. — end example ]

3 For the components aﬀected by this subclause that declare an allocator_type, objects stored in these
components shall be constructed using the allocator_traits<allocator_type>::construct function and
destroyed using the allocator_traits<allocator_type>::destroy function (20.7.8.2). These functions
are called only for the container’s element type, not for internal types used by the container. [ Note: This
means, for example, that a node-based container might need to construct nodes containing aligned buﬀers
and call construct to place the element into the buﬀer. — end note ]
In Tables 96, 97, and 98 X denotes a container class containing objects of type T, a and b denote values of
type X, u denotes an identiﬁer, r denotes a non-const value of type X, and rv denotes a non-const rvalue of
type X.

4

§ 23.2.1

745

c(cid:13) ISO/IEC

N4296

Table 96 — Container requirements

Expression

Return type

Operational
semantics

X::value_-
type

T

X::reference
X::const_-
reference
X::iterator

T&
const T&

iterator type
whose value
type is T

X::const_-
iterator

X::dif-
ference_type

constant
iterator type
whose value
type is T
signed integer
type

X::size_type

unsigned
integer type

X u;
X()
X(a)

X u(a)
X u = a;

X u(rv)
X u = rv

a = rv

X&

All existing elements
of a are either move
assigned to or
destroyed

Assertion/note

pre-/post-condition
Requires: T is
Erasable from X
(see 23.2.1, below)

any iterator category
that meets the
forward iterator
requirements.
convertible to
X::const_iterator.
any iterator category
that meets the
forward iterator
requirements.
is identical to the
diﬀerence type of
X::iterator and
X::const_iterator
size_type can
represent any
non-negative value of
difference_type
post: u.empty()
post: X().empty()
Requires:T is
CopyInsertable into
X (see below).
post: a == X(a).
Requires:T is
CopyInsertable into
X (see below).
post: u == a
post: u shall be
equal to the value
that rv had before
this construction
a shall be equal to
the value that rv
had before this
assignment

Complexity

compile time

compile time
compile time

compile time

compile time

compile time

compile time

constant
constant
linear

linear

(Note B)

linear

§ 23.2.1

746

c(cid:13) ISO/IEC

N4296

Table 96 — Container requirements (continued)

Expression

Return type

Operational
semantics

(&a)->~X()

void

a.begin()

a.end()

a.cbegin()

a.cend()

a == b

iterator;
const_-
iterator for
constant a
iterator;
const_-
iterator for
constant a
const_-
iterator
const_-
iterator
convertible to
bool

a != b

a.swap(b)

swap(a, b)
r = a
a.size()

convertible to
bool
void

void
X&
size_type

a.max_size()

size_type

a.empty()

convertible to
bool

const_cast<X
const&>(a).begin();
const_cast<X
const&>(a).end();
== is an equivalence
relation.
equal(a.begin(),
a.end(),
b.begin(),
b.end())
Equivalent to: !(a
== b)

a.swap(b)

distance(a.begin(),
a.end())
distance(begin(),
end()) for the
largest possible
container
a.begin() ==
a.end()

Assertion/note

pre-/post-condition
note: the destructor
is applied to every
element of a; any
memory obtained is
deallocated.

Requires: T is
EqualityComparable

exchanges the
contents of a and b

post: r == a.

Complexity

linear

constant

constant

constant

constant

Constant if
a.size() !=
b.size(),
linear
otherwise

linear

(Note A)

(Note A)
linear
constant

constant

constant

Notes: the algorithm equal() is deﬁned in Clause 25. Those entries marked “(Note A)” or “(Note B)” have
linear complexity for array and have constant complexity for all other standard containers.

5 The member function size() returns the number of elements in the container. The number of elements is

deﬁned by the rules of constructors, inserts, and erases.

6 begin() returns an iterator referring to the ﬁrst element in the container. end() returns an iterator which

is the past-the-end value for the container. If the container is empty, then begin() == end();
In the expressions

7

§ 23.2.1

747

c(cid:13) ISO/IEC

i == j
i != j
i < j
i <= j
i >= j
i > j
i - j

N4296

where i and j denote objects of a container’s iterator type, either or both may be replaced by an object
of the container’s const_iterator type referring to the same element with no change in semantics.

8 Unless otherwise speciﬁed, all containers deﬁned in this clause obtain memory using an allocator (see 17.6.3.5).
Copy constructors for these container types obtain an allocator by calling allocator_traits<allocator_-
type>::select_on_container_copy_construction on the allocator belonging to the container being copied.
Move constructors obtain an allocator by move construction from the allocator belonging to the container
being moved. Such move construction of the allocator shall not exit via an exception. All other con-
structors for these container types take a const allocator_type& argument.
[ Note: If an invocation of
a constructor uses the default value of an optional allocator argument, then the Allocator type must
support value initialization. — end note ] A copy of this allocator is used for any memory allocation
performed, by these constructors and by all member functions, during the lifetime of each container ob-
ject or until the allocator is replaced. The allocator may be replaced only via assignment or swap().
Allocator replacement is performed by copy assignment, move assignment, or swapping of the alloca-
tor only if allocator_traits<allocator_type>::propagate_on_container_copy_assignment::value,
allocator_traits<allocator_type>::propagate_on_container_move_assignment::value, or alloca-
tor_traits<allocator_type>::propagate_on_container_swap::value is true within the implementa-
tion of the corresponding container operation. In all container types deﬁned in this Clause, the member
get_allocator() returns a copy of the allocator used to construct the container or, if that allocator has
been replaced, a copy of the most recent replacement.

9 The expression a.swap(b), for containers a and b of a standard container type other than array, shall ex-
change the values of a and b without invoking any move, copy, or swap operations on the individual container
elements. Lvalues of any Compare, Pred, or Hash types belonging to a and b shall be swappable and shall be
exchanged by calling swap as described in 17.6.3.2. If allocator_traits<allocator_type>::propagate_-
on_container_swap::value is true, then lvalues of type allocator_type shall be swappable and the allo-
cators of a and b shall also be exchanged by calling swap as described in 17.6.3.2. Otherwise, the allocators
shall not be swapped, and the behavior is undeﬁned unless a.get_allocator() == b.get_allocator().
Every iterator referring to an element in one container before the swap shall refer to the same element in
the other container after the swap. It is unspeciﬁed whether an iterator with value a.end() before the swap
will have value b.end() after the swap.
If the iterator type of a container belongs to the bidirectional or random access iterator categories (24.2),
the container is called reversible and satisﬁes the additional requirements in Table 97.

10

Table 97 — Reversible container requirements

Expression

Return type

X::reverse_-
iterator
X::const_-
reverse_-
iterator

iterator type whose value type
is T
constant iterator type whose
value type is T

Assertion/note

pre-/post-condition

Complexity

reverse_iterator<iterator>

compile time

reverse_iterator<const_-
iterator>

compile time

§ 23.2.1

748

c(cid:13) ISO/IEC

N4296

Table 97 — Reversible container requirements (continued)

Expression

Return type

a.rbegin()

a.rend()

a.crbegin()

reverse_iterator;
const_reverse_iterator for
constant a
reverse_iterator;
const_reverse_iterator for
constant a
const_reverse_iterator

a.crend()

const_reverse_iterator

Assertion/note

pre-/post-condition
reverse_iterator(end())

Complexity

constant

reverse_iterator(begin())

constant

const_cast<X
const&>(a).rbegin()
const_cast<X
const&>(a).rend()

constant

constant

11 Unless otherwise speciﬁed (see 23.2.4.1, 23.2.5.1, 23.3.3.4, and 23.3.6.5) all container types deﬁned in this

Clause meet the following additional requirements:

(11.1)

(11.2)

(11.3)

(11.4)

(11.5)

(11.6)

—

—

—
—
—
—

if an exception is thrown by an insert() or emplace() function while inserting a single element, that
function has no eﬀects.
if an exception is thrown by a push_back(), push_front(), emplace_back(), or emplace_front()
function, that function has no eﬀects.
no erase(), clear(), pop_back() or pop_front() function throws an exception.
no copy constructor or assignment operator of a returned iterator throws an exception.
no swap() function throws an exception.
no swap() function invalidates any references, pointers, or iterators referring to the elements of the
containers being swapped.
[ Note: The end() iterator does not refer to any element, so it may be
invalidated. — end note ]

12 Unless otherwise speciﬁed (either explicitly or by deﬁning a function in terms of other functions), invoking a
container member function or passing a container as an argument to a library function shall not invalidate
iterators to, or change the values of, objects within that container.

13 A contiguous container is a container that supports random access iterators (24.2.7) and whose member

types iterator and const_iterator are contiguous iterators (24.2.1).

14 Table 98 lists operations that are provided for some types of containers but not others. Those containers
for which the listed operations are provided shall implement the semantics described in Table 98 unless
otherwise stated.

§ 23.2.1

749

c(cid:13) ISO/IEC

N4296

Table 98 — Optional container operations

Expression

Return type

a < b

convertible to
bool

a > b

a <= b

a >= b

convertible to
bool
convertible to
bool
convertible to
bool

Operational
semantics

lexicographical_-
compare(
a.begin(),
a.end(),
b.begin(),
b.end())
b < a

!(a > b)

!(a < b)

Assertion/note

pre-/post-condition
pre: < is deﬁned for
values of T. < is a
total ordering
relationship.

Complexity

linear

linear

linear

linear

Note: the algorithm lexicographical_compare() is deﬁned in Clause 25.

15 All of the containers deﬁned in this Clause and in (21.4) except array meet the additional requirements of

an allocator-aware container, as described in Table 99.
Given a container type X having an allocator_type identical to A and a value_type identical to T and
given an lvalue m of type A, a pointer p of type T*, an expression v of type (possibly const) T, and an
rvalue rv of type T, the following terms are deﬁned. If X is not allocator-aware, the terms below are deﬁned
as if A were std::allocator<T> — no allocator object needs to be created and user specializations of
std::allocator<T> are not instantiated:

(15.1)

—

T is DefaultInsertable into X means that the following expression is well-formed:

allocator_traits<A>::construct(m, p)

(15.2)

—

An element of X is default-inserted if it is initialized by evaluation of the expression

allocator_traits<A>::construct(m, p)

where p is the address of the uninitialized storage for the element allocated within X.
T is MoveInsertable into X means that the following expression is well-formed:

(15.3)

—

allocator_traits<A>::construct(m, p, rv)

and its evaluation causes the following postcondition to hold: The value of *p is equivalent to the value
of rv before the evaluation. [ Note: rv remains a valid object. Its state is unspeciﬁed — end note ]
T is CopyInsertable into X means that, in addition to T being MoveInsertable into X, the following
expression is well-formed:

(15.4)

—

allocator_traits<A>::construct(m, p, v)

and its evaluation causes the following postcondition to hold: The value of v is unchanged and is
equivalent to *p.
T is EmplaceConstructible into X from args , for zero or more arguments args, means that the
following expression is well-formed:

(15.5)

—

§ 23.2.1

750

c(cid:13) ISO/IEC

N4296

allocator_traits<A>::construct(m, p, args)

(15.6)

—

T is Erasable from X means that the following expression is well-formed:

allocator_traits<A>::destroy(m, p)

[ Note: A container calls allocator_traits<A>::construct(m, p, args) to construct an element at p
using args. The default construct in std::allocator will call ::new((void*)p) T(args), but specialized
allocators may choose a diﬀerent deﬁnition. — end note ]
In Table 99, X denotes an allocator-aware container class with a value_type of T using allocator of type A,
u denotes a variable, a and b denote non-const lvalues of type X, t denotes an lvalue or a const rvalue of
type X, rv denotes a non-const rvalue of type X, and m is a value of type A.

16

Table 99 — Allocator-aware container requirements

Expression

Return type

A

A

allocator_-
type

get_-
allocator()
X()
X u;

X(m)
X u(m);
X(t, m)
X u(t, m);

X(rv)
X u(rv)

X(rv, m)
X u(rv, m);

Assertion/note

pre-/post-condition

Requires:allocator_-
type::value_type is the same
as X::value_type.

Requires: A is
DefaultConstructible.
post: u.empty() returns true,
u.get_allocator() == A()
post: u.empty() returns true,
u.get_allocator() == m
Requires: T is CopyInsertable
into X.
post: u == t,
u.get_allocator() == m
Requires: move construction of
A shall not exit via an
exception.
post: u shall have the same
elements as rv had before this
construction; the value of
u.get_allocator() shall be
the same as the value of
rv.get_allocator() before
this construction.
Requires: T is MoveInsertable
into X.
post: u shall have the same
elements, or copies of the
elements, that rv had before
this construction,
u.get_allocator() == m

Complexity

compile time

constant

constant

constant

linear

constant

constant if m
== rv.get_-
allocator(),
otherwise
linear

§ 23.2.1

751

c(cid:13) ISO/IEC

Table 99 — Allocator-aware container requirements (continued)

Expression

Return type

a = t

a = rv

X&

X&

a.swap(b)

void

Assertion/note

pre-/post-condition

Requires: T is CopyInsertable
into X and CopyAssignable.
post: a == t
Requires: If allocator_-
traits<allocator_type>
::propagate_on_container_-
move_assignment::value is
false, T is MoveInsertable
into X and MoveAssignable.
All existing elements of a are
either move assigned to or
destroyed.
post: a shall be equal to the
value that rv had before this
assignment.
exchanges the contents of a and
b

N4296

Complexity

linear

linear

constant

23.2.2 Container data races

[container.requirements.dataraces]
1 For purposes of avoiding data races (17.6.5.9), implementations shall consider the following functions to be
const: begin, end, rbegin, rend, front, back, data, find, lower_bound, upper_bound, equal_range, at
and, except in associative or unordered associative containers, operator[].

3

2 Notwithstanding (17.6.5.9), implementations are required to avoid data races when the contents of the con-
tained object in diﬀerent elements in the same container, excepting vector<bool>, are modiﬁed concurrently.
[ Note: For a vector<int> x with a size greater than one, x[1] = 5 and *x.begin() = 10 can be executed
concurrently without a data race, but x[0] = 5 and *x.begin() = 10 executed concurrently may result in
a data race. As an exception to the general rule, for a vector<bool> y, y[0] = true may race with y[1]
= true. — end note ]
23.2.3 Sequence containers

[sequence.reqmts]
1 A sequence container organizes a ﬁnite set of objects, all of the same type, into a strictly linear arrangement.
The library provides four basic kinds of sequence containers: vector, forward_list, list, and deque. In
addition, array is provided as a sequence container which provides limited sequence operations because it
has a ﬁxed number of elements. The library also provides container adaptors that make it easy to construct
abstract data types, such as stacks or queues, out of the basic sequence container kinds (or out of other
kinds of sequence containers that the user might deﬁne).

2 The sequence containers oﬀer the programmer diﬀerent complexity trade-oﬀs and should be used accordingly.
vector or array is the type of sequence container that should be used by default. list or forward_list
should be used when there are frequent insertions and deletions from the middle of the sequence. deque is
the data structure of choice when most insertions and deletions take place at the beginning or at the end of
the sequence.
In Tables 100 and 101, X denotes a sequence container class, a denotes a value of X containing elements of type
T, A denotes X::allocator_type if the qualiﬁed-id X::allocator_type is valid and denotes a type (14.8.2)
and std::allocator<T> if it doesn’t, i and j denote iterators satisfying input iterator requirements and

3

§ 23.2.3

752

c(cid:13) ISO/IEC

N4296

refer to elements implicitly convertible to value_type, [i, j) denotes a valid range, il designates an
object of type initializer_list<value_type>, n denotes a value of X::size_type, p denotes a valid
const iterator to a, q denotes a valid dereferenceable const iterator to a, [q1, q2) denotes a valid range of
const iterators in a, t denotes an lvalue or a const rvalue of X::value_type, and rv denotes a non-const
rvalue of X::value_type. Args denotes a template parameter pack; args denotes a function parameter
pack with the pattern Args&&.

4 The complexities of the expressions are sequence dependent.

Table 100 — Sequence container requirements (in addition to con-
tainer)

Expression

Return type

X(n, t)
X a(n, t)

X(i, j)
X a(i, j)

X(il);
a = il;

X&

a.emplace(p, args);

iterator

a.insert(p,t)

iterator

a.insert(p,rv)

iterator

Assertion/note

pre-/post-condition

Requires: T shall be CopyInsertable into X.
post: distance(begin(), end()) == n
Constructs a sequence container with n copies
of t
Requires: T shall be EmplaceConstructible
into X from *i. For vector, if the iterator
does not meet the forward iterator
requirements (24.2.5), T shall also be
MoveInsertable into X. Each iterator in the
range [i,j) shall be dereferenced exactly
once.
post: distance(begin(), end()) ==
distance(i, j)
Constructs a sequence container equal to the
range [i, j)
Equivalent to X(il.begin(), il.end())
Requires: T is CopyInsertable into X and
CopyAssignable. Assigns the range
[il.begin(),il.end()) into a. All existing
elements of a are either assigned to or
destroyed.
Returns: *this.
Requires: T is EmplaceConstructible into X
from args. For vector and deque, T is also
MoveInsertable into X and MoveAssignable.
Eﬀects: Inserts an object of type T
constructed with
std::forward<Args>(args)... before p.
Requires: T shall be CopyInsertable into X.
For vector and deque, T shall also be
CopyAssignable.
Eﬀects: Inserts a copy of t before p.
Requires: T shall be MoveInsertable into X.
For vector and deque, T shall also be
MoveAssignable.
Eﬀects: Inserts a copy of rv before p.

§ 23.2.3

753

c(cid:13) ISO/IEC

N4296

Table 100 — Sequence container requirements (in addition to con-
tainer) (continued)

Expression

Return type

a.insert(p,n,t)

iterator

a.insert(p,i,j)

iterator

a.insert(p, il);
a.erase(q)

iterator
iterator

a.erase(q1,q2)

iterator

a.clear()

void

a.assign(i,j)

void

a.assign(il)
a.assign(n,t)

void
void

Assertion/note

pre-/post-condition

Requires: T shall be CopyInsertable into X
and CopyAssignable.
Inserts n copies of t before p.
Requires: T shall be EmplaceConstructible
into X from *i. For vector and deque, T
shall also be MoveInsertable into X,
MoveConstructible, MoveAssignable, and
swappable (17.6.3.2). Each iterator in the
range [i,j) shall be dereferenced exactly
once.
pre: i and j are not iterators into a.
Inserts copies of elements in [i, j) before p
a.insert(p, il.begin(), il.end()).
Requires: For vector and deque, T shall be
MoveAssignable.
Eﬀects: Erases the element pointed to by q
Requires: For vector and deque, T shall be
MoveAssignable.
Eﬀects: Erases the elements in the range [q1,
q2).
Destroys all elements in a. Invalidates all
references, pointers, and iterators referring to
the elements of a and may invalidate the
past-the-end iterator.
post: a.empty() returns true.
Complexity: Linear.
Requires: T shall be EmplaceConstructible
into X from *i and assignable from *i. For
vector, if the iterator does not meet the
forward iterator requirements (24.2.5), T shall
also be MoveInsertable into X.
Each iterator in the range [i,j) shall be
dereferenced exactly once.
pre: i, j are not iterators into a.
Replaces elements in a with a copy of [i, j).
a.assign(il.begin(), il.end()).
Requires: T shall be CopyInsertable into X
and CopyAssignable.
pre: t is not a reference into a.
Replaces elements in a with n copies of t.

5 iterator and const_iterator types for sequence containers shall be at least of the forward iterator category.
6 The iterator returned from a.insert(p, t) points to the copy of t inserted into a.
7 The iterator returned from a.insert(p, rv) points to the copy of rv inserted into a.

§ 23.2.3

754

c(cid:13) ISO/IEC

N4296

8 The iterator returned from a.insert(p, n, t) points to the copy of the ﬁrst element inserted into a, or p

if n == 0.

9 The iterator returned from a.insert(p, i, j) points to the copy of the ﬁrst element inserted into a, or p

if i == j.

10 The iterator returned from a.insert(p, il) points to the copy of the ﬁrst element inserted into a, or p if

il is empty.

11 The iterator returned from a.emplace(p, args) points to the new element constructed from args into a.
12 The iterator returned from a.erase(q) points to the element immediately following q prior to the element

being erased. If no such element exists, a.end() is returned.

13 The iterator returned by a.erase(q1,q2) points to the element pointed to by q2 prior to any elements

being erased. If no such element exists, a.end() is returned.

14 For every sequence container deﬁned in this Clause and in Clause 21:

(14.1)

—

If the constructor

template <class InputIterator>
X(InputIterator first, InputIterator last,

const allocator_type& alloc = allocator_type())

is called with a type InputIterator that does not qualify as an input iterator, then the constructor
shall not participate in overload resolution.
If the member functions of the forms:

(14.2)

—

template <class InputIterator>
rt fx1(const_iterator p, InputIterator first, InputIterator last);

// such as insert()

template <class InputIterator>
rt fx2(InputIterator first, InputIterator last);

// such as append(), assign()

template <class InputIterator>
rt fx3(const_iterator i1, const_iterator i2, InputIterator first, InputIterator last);

// such as replace()

are called with a type InputIterator that does not qualify as an input iterator, then these functions
shall not participate in overload resolution.

15 The extent to which an implementation determines that a type cannot be an input iterator is unspeciﬁed,

except that as a minimum integral types shall not qualify as input iterators.

16 Table 101 lists operations that are provided for some types of sequence containers but not others. An
implementation shall provide these operations for all container types shown in the “container” column, and
shall implement them so as to take amortized constant time.

Expression
a.front()

Table 101 — Optional sequence container operations

Return type

Operational semantics

reference; const_reference
for constant a

*a.begin()

§ 23.2.3

Container

basic_-
string,
array, deque,
forward_-
list, list,
vector

755

c(cid:13) ISO/IEC

N4296

Table 101 — Optional sequence container operations (continued)

Expression
a.back()

Return type

Operational semantics

reference; const_reference
for constant a

{ auto tmp = a.end();
--tmp;
return *tmp; }

a.emplace_-
front(args)

void

a.emplace_-
back(args)

void

a.push_-
front(t)

a.push_-
front(rv)

a.push_-
back(t)

a.push_-
back(rv)

a.pop_-
front()

void

void

void

void

void

a.pop_back()

void

Prepends an
object of type T constructed with
std::forward<Args>(args)....

Requires: T shall be
EmplaceConstructible into X
from args.
Appends an
object of type T constructed with
std::forward<Args>(args)....

Requires: T shall be
EmplaceConstructible into X
from args. For vector, T shall
also be MoveInsertable into X.
Prepends a copy of t.
Requires: T shall be
CopyInsertable into X.

Prepends a copy of rv.
Requires: T shall be
MoveInsertable into X.

Appends a copy of t.
Requires: T shall be
CopyInsertable into X.

Appends a copy of rv.
Requires: T shall be
MoveInsertable into X.

Destroys the ﬁrst element.
Requires: a.empty() shall be
false.

Destroys the last element.
Requires: a.empty() shall be
false.

a[n]

reference; const_reference
for constant a

*(a.begin() + n)

Container

basic_-
string,
array, deque,
list, vector
deque,
forward_-
list,
list

deque, list,
vector

deque,
forward_-
list,
list
deque,
forward_-
list,
list
basic_-
string,
deque, list,
vector
basic_-
string,
deque, list,
vector
deque,
forward_-
list,
list
basic_-
string,
deque, list,
vector
basic_-
string,
array, deque,
vector

§ 23.2.3

756

c(cid:13) ISO/IEC

Table 101 — Optional sequence container operations (continued)

Expression
a.at(n)

Return type

Operational semantics

reference; const_reference
for constant a

*(a.begin() + n)

N4296

Container

basic_-
string,
array, deque,
vector

17 The member function at() provides bounds-checked access to container elements. at() throws out_of_-

range if n >= a.size().
23.2.4 Associative containers

[associative.reqmts]
1 Associative containers provide fast retrieval of data based on keys. The library provides four basic kinds of

associative containers: set, multiset, map and multimap.

2 Each associative container is parameterized on Key and an ordering relation Compare that induces a strict
weak ordering (25.4) on elements of Key. In addition, map and multimap associate an arbitrary mapped type
T with the Key. The object of type Compare is called the comparison object of a container.

3 The phrase “equivalence of keys” means the equivalence relation imposed by the comparison and not the
operator== on keys. That is, two keys k1 and k2 are considered to be equivalent if for the comparison
object comp, comp(k1, k2) == false && comp(k2, k1) == false. For any two keys k1 and k2 in the
same container, calling comp(k1, k2) shall always return the same value.

4 An associative container supports unique keys if it may contain at most one element for each key. Otherwise,
it supports equivalent keys. The set and map classes support unique keys; the multiset and multimap classes
support equivalent keys. For multiset and multimap, insert, emplace, and erase preserve the relative
ordering of equivalent elements.

5 For set and multiset the value type is the same as the key type. For map and multimap it is equal to

pair<const Key, T>.

6 iterator of an associative container is of the bidirectional iterator category. For associative containers where
the value type is the same as the key type, both iterator and const_iterator are constant iterators. It is
unspeciﬁed whether or not iterator and const_iterator are the same type. [ Note: iterator and const_-
iterator have identical semantics in this case, and iterator is convertible to const_iterator. Users can
avoid violating the One Deﬁnition Rule by always using const_iterator in their function parameter lists.
— end note ]

8

7 The associative containers meet all the requirements of Allocator-aware containers (23.2.1), except that
for map and multimap, the requirements placed on value_type in Table 96 apply instead to key_type
and mapped_type.
[ Note: For example, in some cases key_type and mapped_type are required to be
CopyAssignable even though the associated value_type, pair<const key_type, mapped_type>, is not
CopyAssignable. — end note ]
In Table 102, X denotes an associative container class, a denotes a value of X, a_uniq denotes a value of X
when X supports unique keys, a_eq denotes a value of X when X supports multiple keys, a_tran denotes a
value of X when the qualiﬁed-id X::key_compare::is_transparent is valid and denotes a type (14.8.2), i
and j satisfy input iterator requirements and refer to elements implicitly convertible to value_type, [i,j)
denotes a valid range, p denotes a valid const iterator to a, q denotes a valid dereferenceable const iterator
to a, [q1, q2) denotes a valid range of const iterators in a, il designates an object of type initializer_-
list<value_type>, t denotes a value of X::value_type, k denotes a value of X::key_type and c denotes
a value of type X::key_compare; kl is a value such that a is partitioned (25.4) with respect to c(r, kl),
with r the key value of e and e in a; ku is a value such that a is partitioned with respect to !c(ku, r); ke is

§ 23.2.4

757

c(cid:13) ISO/IEC

N4296

a value such that a is partitioned with respect to c(r, ke) and !c(ke, r), with c(r, ke) implying !c(ke,
r). A denotes the storage allocator used by X, if any, or std::allocator<X::value_type> otherwise, and
m denotes an allocator of a type convertible to A.

Table 102 — Associative container requirements (in addition to
container)

Expression

Return type

Assertion/note

pre-/post-condition

Complexity

X::key_type
mapped_type
(map and
multimap
only)
X::value_-
type (set
and
multiset
only)
X::value_-
type (map
and
multimap
only)
X::key_-
compare
X::value_-
compare

X(c)
X a(c);

X()
X a;

Key
T

Key

compile time
compile time

Requires: value_type is
Erasable from X

compile time

pair<const
Key, T>

Requires: value_type is
Erasable from X

compile time

Compare

defaults to less<key_type>

compile time

a binary
predicate type

is the same as key_compare
for set and multiset; is an
ordering relation on pairs
induced by the ﬁrst component
(i.e., Key) for map and
multimap.
Requires: key_compare is
CopyConstructible.
Eﬀects: Constructs an empty
container. Uses a copy of c as
a comparison object.
Requires: key_compare is
DefaultConstructible.
Eﬀects: Constructs an empty
container. Uses Compare() as
a comparison object

compile time

constant

constant

§ 23.2.4

758

c(cid:13) ISO/IEC

N4296

Table 102 — Associative container requirements (in addition to
container) (continued)

Expression

Return type

X(i,j,c)
X a(i,j,c);

X(i,j)
X a(i,j);

X(il);

X(il,c);

a = il

X&

a.key_-
comp()

X::key_-
compare

a.value_-
comp()

X::value_-
compare

Assertion/note

pre-/post-condition
Requires: key_compare is
CopyConstructible.
value_type is
EmplaceConstructible into X
from *i.
Eﬀects: Constructs an empty
container and inserts elements
from the range [i, j) into it;
uses c as a comparison object.
Requires: key_compare is
DefaultConstructible.
value_type is
EmplaceConstructible into X
from *i.
Eﬀects: Same as above, but
uses Compare() as a
comparison object
Same as X(il.begin(),
il.end()).
Same as X(il.begin(),
il.end(), c).
Requires: value_type is
CopyInsertable into X and
CopyAssignable.
Eﬀects: Assigns the range
[il.begin(),il.end()) into
a. All existing elements of a
are either assigned to or
destroyed.
returns the comparison object
out of which a was
constructed.
returns an object of
value_compare constructed
out of the comparison object

Complexity

N log N in general (N has
the value distance(i, j));
linear if [i, j) is sorted
with value_comp()

same as above

Same as X(il.begin(),
il.end()).
Same as X(il.begin(),
il.end(), c).
N logN in general (where N
has the value il.size() +
a.size()); linear if
[il.begin(),il.end()) is
sorted with value_comp().

constant

constant

§ 23.2.4

759

c(cid:13) ISO/IEC

N4296

Table 102 — Associative container requirements (in addition to
container) (continued)

Assertion/note

pre-/post-condition

Complexity

logarithmic

Expression

Return type

a_uniq.
emplace(args)

pair<iterator,
bool>

a_eq.
emplace(args)

iterator

a.emplace_-
hint(p,
args)

iterator

Requires: value_type shall be
EmplaceConstructible into X
from args.
Eﬀects: Inserts a value_type
object t constructed with
std::forward<Args>(args)...
if and only if there is no
element in the container with
key equivalent to the key of t.
The bool component of the
returned pair is true if and
only if the insertion takes
place, and the iterator
component of the pair points
to the element with key
equivalent to the key of t.
Requires: value_type shall be
EmplaceConstructible into X
from args.
Eﬀects: Inserts a value_type
object t constructed with
std::forward<Args>(args)...
and returns the iterator
pointing to the newly inserted
element. If a range containing
elements equivalent to t exists
in a_eq, t is inserted at the
end of that range.
equivalent to a.emplace(
std::forward<Args>(args)...).
Return value is an iterator
pointing to the element with
the key equivalent to the newly
inserted element. The element
is inserted as close as possible
to the position just prior to p.

logarithmic

logarithmic in general, but
amortized constant if the
element is inserted right
before p

§ 23.2.4

760

c(cid:13) ISO/IEC

N4296

Table 102 — Associative container requirements (in addition to
container) (continued)

Expression

Return type

a_uniq.
insert(t)

pair<iterator,
bool>

a_-
eq.insert(t)

iterator

a.insert(
p, t)

iterator

Complexity

logarithmic

logarithmic

logarithmic in general, but
amortized constant if t is
inserted right before p.

Assertion/note

pre-/post-condition
Requires: If t is a non-const
rvalue expression, value_type
shall be MoveInsertable into
X; otherwise, value_type shall
be CopyInsertable into X.
Eﬀects: Inserts t if and only if
there is no element in the
container with key equivalent
to the key of t. The bool
component of the returned
pair is true if and only if the
insertion takes place, and the
iterator component of the
pair points to the element with
key equivalent to the key of t.
Requires: If t is a non-const
rvalue expression, value_type
shall be MoveInsertable into
X; otherwise, value_type shall
be CopyInsertable into X.
Eﬀects: Inserts t and returns
the iterator pointing to the
newly inserted element. If a
range containing elements
equivalent to t exists in a_eq,
t is inserted at the end of that
range.
Requires: If t is a non-const
rvalue expression, value_type
shall be MoveInsertable into
X; otherwise, value_type shall
be CopyInsertable into X.
Eﬀects: Inserts t if and only if
there is no element with key
equivalent to the key of t in
containers with unique keys;
always inserts t in containers
with equivalent keys. Always
returns the iterator pointing to
the element with key
equivalent to the key of t. t is
inserted as close as possible to
the position just prior to p.

§ 23.2.4

761

c(cid:13) ISO/IEC

N4296

Table 102 — Associative container requirements (in addition to
container) (continued)

Expression

Return type

a.insert(
i, j)

void

a.insert(il) void

a.erase(k)

size_type

a.erase(q)

iterator

a.erase(
q1, q2)

iterator

a.clear()

void

a.find(k)

a_tran.
find(ke)

iterator;
const_-
iterator for
constant a.
iterator;
const_-
iterator for
constant
a_tran.

Assertion/note

pre-/post-condition

Requires: value_type shall be
EmplaceConstructible into X
from *i.
pre: i, j are not iterators into
a. inserts each element from
the range [i,j) if and only if
there is no element with key
equivalent to the key of that
element in containers with
unique keys; always inserts
that element in containers
with equivalent keys.
Equivalent to
a.insert(il.begin(),
il.end()).
erases all elements in the
container with key equivalent
to k. returns the number of
erased elements.
erases the element pointed to
by q. Returns an iterator
pointing to the element
immediately following q prior
to the element being erased. If
no such element exists, returns
a.end().
erases all the elements in the
range [q1,q2). Returns an
iterator pointing to the
element pointed to by q2 prior
to any elements being erased.
If no such element exists,
a.end() is returned.
a.erase(a.begin(),a.end())

post: a.empty() returns true
returns an iterator pointing to
an element with the key
equivalent to k, or a.end() if
such an element is not found
returns an iterator pointing to
an element with key r such
that !c(r, ke) && !c(ke,
r), or a_tran.end() if such
an element is not found

Complexity

N log(a.size() + N) (N has
the value distance(i, j)

log(a.size()) + a.count(k)

amortized constant

log(a.size()) + N where N
has the value distance(q1,
q2).

linear in a.size().

logarithmic

logarithmic

§ 23.2.4

762

c(cid:13) ISO/IEC

N4296

Table 102 — Associative container requirements (in addition to
container) (continued)

Assertion/note

pre-/post-condition

returns the number of elements
with key equivalent to k
returns the number of
elements with key r such that
!c(r, ke) && !c(ke, r)
returns an iterator pointing to
the ﬁrst element with key not
less than k, or a.end() if such
an element is not found.
returns an iterator pointing to
the ﬁrst element with key r
such that !c(r, kl), or
a_tran.end() if such an
element is not found.
returns an iterator pointing to
the ﬁrst element with key
greater than k, or a.end() if
such an element is not found.
returns an iterator pointing to
the ﬁrst element with key r
such that c(ku, r), or
a_tran.end() if such an
element is not found.
equivalent to make_-
pair(a.lower_bound(k),
a.upper_bound(k)).

Complexity

log(a.size()) + a.count(k)

log(a_tran.size()) +
a_tran.count(ke)

logarithmic

logarithmic

logarithmic

logarithmic

logarithmic

equivalent to make_pair(
a_tran.lower_bound(ke),
a_tran.upper_bound(ke)).

logarithmic

Expression

Return type

a.count(k)

size_type

a_tran.
count(ke)

a.lower_-
bound(k)

a_tran.
lower_-
bound(kl)

a.upper_-
bound(k)

a_tran.
upper_-
bound(ku)

a.equal_-
range(k)

a_tran.
equal_-
range(ke)

size_type

iterator;
const_-
iterator for
constant a.
iterator;
const_-
iterator for
constant
a_tran.
iterator;
const_-
iterator for
constant a.
iterator;
const_-
iterator for
constant
a_tran.
pair<iterator,
iterator>;
pair<const_-
iterator,
const_-
iterator> for
constant a.
pair<iterator,
iterator>;
pair<const_-
iterator,
const_-
iterator> for
constant
a_tran.

9 The insert and emplace members shall not aﬀect the validity of iterators and references to the container,

and the erase members shall invalidate only iterators and references to the erased elements.

10 The fundamental property of iterators of associative containers is that they iterate through the containers
in the non-descending order of keys where non-descending is deﬁned by the comparison that was used to
construct them. For any two dereferenceable iterators i and j such that distance from i to j is positive,

§ 23.2.4

763

c(cid:13) ISO/IEC

value_comp(*j, *i) == false

N4296

11 For associative containers with unique keys the stronger condition holds,

value_comp(*i, *j) != false.

12 When an associative container is constructed by passing a comparison object the container shall not store
a pointer or reference to the passed object, even if that object is passed by reference. When an associative
container is copied, either through a copy constructor or an assignment operator, the target container shall
then use the comparison object from the container being copied, as if that comparison object had been
passed to the target container in its constructor.

13 The member function templates find, count, lower_bound, upper_bound, and equal_range shall not
participate in overload resolution unless the qualiﬁed-id Compare::is_transparent is valid and denotes a
type (14.8.2).
23.2.4.1 Exception safety guarantees

[associative.reqmts.except]
1 For associative containers, no clear() function throws an exception. erase(k) does not throw an exception

unless that exception is thrown by the container’s Compare object (if any).

2 For associative containers, if an exception is thrown by any operation from within an insert or emplace

function inserting a single element, the insertion has no eﬀect.

3 For associative containers, no swap function throws an exception unless that exception is thrown by the

swap of the container’s Compare object (if any).
23.2.5 Unordered associative containers

[unord.req]
1 Unordered associative containers provide an ability for fast retrieval of data based on keys. The worst-
case complexity for most operations is linear, but the average case is much faster. The library provides four
unordered associative containers: unordered_set, unordered_map, unordered_multiset, and unordered_-
multimap.

2 Unordered associative containers conform to the requirements for Containers (23.2), except that the expres-

sions a == b and a != b have diﬀerent semantics than for the other container types.

3 Each unordered associative container is parameterized by Key, by a function object type Hash that meets the
Hash requirements (17.6.3.4) and acts as a hash function for argument values of type Key, and by a binary
predicate Pred that induces an equivalence relation on values of type Key. Additionally, unordered_map and
unordered_multimap associate an arbitrary mapped type T with the Key.

4 The container’s object of type Hash — denoted by hash — is called the hash function of the container. The
container’s object of type Pred — denoted by pred — is called the key equality predicate of the container.
5 Two values k1 and k2 of type Key are considered equivalent if the container’s key equality predicate returns
true when passed those values. If k1 and k2 are equivalent, the container’s hash function shall return the
same value for both.
[ Note: Thus, when an unordered associative container is instantiated with a non-
default Pred parameter it usually needs a non-default Hash parameter as well. — end note ] For any two
keys k1 and k2 in the same container, calling pred(k1, k2) shall always return the same value. For any
key k in a container, calling hash(k) shall always return the same value.

6 An unordered associative container supports unique keys if it may contain at most one element for each
key. Otherwise, it supports equivalent keys. unordered_set and unordered_map support unique keys.
unordered_multiset and unordered_multimap support equivalent keys. In containers that support equiv-
alent keys, elements with equivalent keys are adjacent to each other in the iteration order of the container.
Thus, although the absolute order of elements in an unordered container is not speciﬁed, its elements are
grouped into equivalent-key groups such that all elements of each group have equivalent keys. Mutating

§ 23.2.5

764

c(cid:13) ISO/IEC

N4296

operations on unordered containers shall preserve the relative order of elements within each equivalent-key
group unless otherwise speciﬁed.

7 For unordered_set and unordered_multiset the value type is the same as the key type. For unordered_-

map and unordered_multimap it is std::pair<const Key, T>.

8 For unordered containers where the value type is the same as the key type, both iterator and const_-
iterator are constant iterators. It is unspeciﬁed whether or not iterator and const_iterator are the
same type.
[ Note: iterator and const_iterator have identical semantics in this case, and iterator is
convertible to const_iterator. Users can avoid violating the One Deﬁnition Rule by always using const_-
iterator in their function parameter lists. — end note ]

9 The elements of an unordered associative container are organized into buckets. Keys with the same hash
code appear in the same bucket. The number of buckets is automatically increased as elements are added
to an unordered associative container, so that the average number of elements per bucket is kept below
a bound. Rehashing invalidates iterators, changes ordering between elements, and changes which buckets
elements appear in, but does not invalidate pointers or references to elements. For unordered_multiset
and unordered_multimap, rehashing preserves the relative ordering of equivalent elements.

11

10 The unordered associative containers meet all the requirements of Allocator-aware containers (23.2.1), except
that for unordered_map and unordered_multimap, the requirements placed on value_type in Table 96 apply
instead to key_type and mapped_type.
[ Note: For example, key_type and mapped_type are sometimes
required to be CopyAssignable even though the associated value_type, pair<const key_type, mapped_-
type>, is not CopyAssignable. — end note ]
In table 103: X is an unordered associative container class, a is an object of type X, b is a possibly const
object of type X, a_uniq is an object of type X when X supports unique keys, a_eq is an object of type X
when X supports equivalent keys, i and j are input iterators that refer to value_type, [i, j) is a valid
range, p and q2 are valid const iterators to a, q and q1 are valid dereferenceable const iterators to a, [q1,
q2) is a valid range in a, il designates an object of type initializer_list<value_type>, t is a value of
type X::value_type, k is a value of type key_type, hf is a possibly const value of type hasher, eq is a
possibly const value of type key_equal, n is a value of type size_type, and z is a value of type float.

Table 103 — Unordered associative container requirements (in ad-
dition to container)

Return type

Assertion/note pre-/post-condition

Key
T

Key

Requires: value_type is
Erasable from X

pair<const Key, T>

Requires: value_type is
Erasable from X

Hash

Hash shall be a unary function
object type such that the
expression hf(k) has type
std::size_t.

Expression

X::key_type
X::mapped_type
(unordered_map and
unordered_multimap
only)
X::value_type
(unordered_set and
unordered_multiset
only)
X::value_type
(unordered_map and
unordered_multimap
only)
X::hasher

§ 23.2.5

Complexity
compile time
compile time

compile time

compile time

compile time

765

c(cid:13) ISO/IEC

N4296

Table 103 — Unordered associative container requirements (in ad-
dition to container) (continued)

Expression

Return type

X::key_equal

Pred

X::local_iterator

X::const_local_-
iterator

X(n, hf, eq)
X a(n, hf, eq)

An iterator type whose
category, value type,
diﬀerence type, and
pointer and reference
types are the same as
X::iterator’s.
An iterator type whose
category, value type,
diﬀerence type, and
pointer and reference
types are the same as
X::const_iterator’s.
X

X(n, hf)
X a(n, hf)

X(n)
X a(n)

X

X

Assertion/note pre-/post-condition
Pred shall be a binary predicate
that takes two arguments of
type Key. Pred is an
equivalence relation.
A local_iterator object may
be used to iterate through a
single bucket, but may not be
used to iterate across buckets.

Complexity
compile time

compile time

compile time

O(n)

O(n)

O(n)

A const_local_iterator
object may be used to iterate
through a single bucket, but
may not be used to iterate
across buckets.

Requires: hasher and
key_equal are
CopyConstructible.
Eﬀects: Constructs an empty
container with at least n
buckets, using hf as the hash
function and eq as the key
equality predicate.
Requires: hasher is
CopyConstructible and
key_equal is
DefaultConstructible.
Eﬀects: Constructs an empty
container with at least n
buckets, using hf as the hash
function and key_equal() as
the key equality predicate.
Requires: hasher and
key_equal are
DefaultConstructible.
Eﬀects: Constructs an empty
container with at least n
buckets, using hasher() as the
hash function and key_equal()
as the key equality predicate.

§ 23.2.5

766

c(cid:13) ISO/IEC

Table 103 — Unordered associative container requirements (in ad-
dition to container) (continued)

Expression

Return type

X()
X a

X(i, j, n, hf, eq)
X a(i, j, n, hf,
eq)

X(i, j, n, hf)
X a(i, j, n, hf)

X

X

X

Assertion/note pre-/post-condition
Requires: hasher and
key_equal are
DefaultConstructible.
Eﬀects: Constructs an empty
container with an unspeciﬁed
number of buckets, using
hasher() as the hash function
and key_equal() as the key
equality predicate.
Requires: hasher and
key_equal are
CopyConstructible.
value_type is
EmplaceConstructible into X
from *i.
Eﬀects: Constructs an empty
container with at least n
buckets, using hf as the hash
function and eq as the key
equality predicate, and inserts
elements from [i, j) into it.
Requires: hasher is
CopyConstructible and
key_equal is
DefaultConstructible.
value_type is
EmplaceConstructible into X
from *i.
Eﬀects: Constructs an empty
container with at least n
buckets, using hf as the hash
function and key_equal() as
the key equality predicate, and
inserts elements from [i, j)
into it.

N4296

Complexity
constant

Average case
O(N) (N is
distance(i,
j)), worst case
O(N 2)

Average case
O(N) (N is
distance(i,
j)), worst case
O(N 2)

§ 23.2.5

767

c(cid:13) ISO/IEC

Table 103 — Unordered associative container requirements (in ad-
dition to container) (continued)

Expression

Return type

X

X

X

X

X

X

X

X(i, j, n)
X a(i, j, n)

X(i, j)
X a(i, j)

X(il)

X(il, n)

X(il, n, hf)

X(il, n, hf, eq)

X(b)
X a(b)

§ 23.2.5

Assertion/note pre-/post-condition
Requires: hasher and
key_equal are
DefaultConstructible.
value_type is
EmplaceConstructible into X
from *i.
Eﬀects: Constructs an empty
container with at least n
buckets, using hasher() as the
hash function and key_equal()
as the key equality predicate,
and inserts elements from [i,
j) into it.
Requires: hasher and
key_equal are
DefaultConstructible.
value_type is
EmplaceConstructible into X
from *i.
Eﬀects: Constructs an empty
container with an unspeciﬁed
number of buckets, using
hasher() as the hash function
and key_equal() as the key
equality predicate, and inserts
elements from [i, j) into it.
Same as X(il.begin(),
il.end()).

Same as X(il.begin(),
il.end(), n).

Same as X(il.begin(),
il.end(), n, hf).

Same as X(il.begin(),
il.end(), n, hf, eq).

Copy constructor. In addition
to the requirements of Table 96,
copies the hash function,
predicate, and maximum load
factor.

N4296

Complexity
Average case
O(N) (N is
distance(i,
j)), worst case
O(N 2)

Average case
O(N) (N is
distance(i,
j)), worst case
O(N 2)

Same as
X(il.begin(),
il.end()).
Same as
X(il.begin(),
il.end(), n).
Same as
X(il.begin(),
il.end(), n,
hf).
Same as
X(il.begin(),
il.end(), n,
hf, eq).
Average case
linear in
b.size(),
worst case
quadratic.

768

c(cid:13) ISO/IEC

Table 103 — Unordered associative container requirements (in ad-
dition to container) (continued)

Expression

Return type

a = b

a = il

X&

X&

b.hash_function()
b.key_eq()

hasher
key_equal

Assertion/note pre-/post-condition
Copy assignment operator. In
addition to the requirements of
Table 96, copies the hash
function, predicate, and
maximum load factor.
Requires: value_type is
CopyInsertable into X and
CopyAssignable.
Eﬀects: Assigns the range
[il.begin(),il.end()) into
a. All existing elements of a are
either assigned to or destroyed.
Returns b’s hash function.
Returns b’s key equality
predicate.

a_uniq.
emplace(args)

a_eq.emplace(args)

pair<iterator, bool> Requires: value_type shall be
EmplaceConstructible into X
from args.
Eﬀects: Inserts a value_type
object t constructed with
std::forward<Args>(args)...
if and only if there is no
element in the container with
key equivalent to the key of t.
The bool component of the
returned pair is true if and only
if the insertion takes place, and
the iterator component of the
pair points to the element with
key equivalent to the key of t.
Requires: value_type shall be
EmplaceConstructible into X
from args.
Eﬀects: Inserts a value_type
object t constructed with
std::forward<Args>(args)...
and returns the iterator
pointing to the newly inserted
element.

iterator

N4296

Complexity
Average case
linear in
b.size(),
worst case
quadratic.
Same as a =
X(il).

constant
constant

Average case
O(1), worst
case O(a_uniq.
size()).

Average case
O(1), worst
case O(a_eq.
size()).

§ 23.2.5

769

c(cid:13) ISO/IEC

Table 103 — Unordered associative container requirements (in ad-
dition to container) (continued)

Expression

a.emplace_hint(p,
args)

Return type

iterator

a_uniq.insert(t)

pair<iterator,
bool>

a_eq.insert(t)

iterator

Assertion/note pre-/post-condition
Requires: value_type shall be
EmplaceConstructible into X
from args.
Eﬀects: Equivalent to
a.emplace(
std::forward<Args>(args)...).
Return value is an iterator
pointing to the element with
the key equivalent to the newly
inserted element. The
const_iterator p is a hint
pointing to where the search
should start. Implementations
are permitted to ignore the
hint.
Requires: If t is a non-const
rvalue expression, value_type
shall be MoveInsertable into
X; otherwise, value_type shall
be CopyInsertable into X.
Eﬀects: Inserts t if and only if
there is no element in the
container with key equivalent to
the key of t. The bool
component of the returned pair
indicates whether the insertion
takes place, and the iterator
component points to the
element with key equivalent to
the key of t.
Requires: If t is a non-const
rvalue expression, value_type
shall be MoveInsertable into
X; otherwise, value_type shall
be CopyInsertable into X.
Eﬀects: Inserts t, and returns
an iterator pointing to the
newly inserted element.

N4296

Complexity
Average case
O(1), worst
case
O(a.size()).

Average case
O(1), worst
case O(a_uniq.
size()).

Average case
O(1), worst
case O(a_eq.
size()).

§ 23.2.5

770

c(cid:13) ISO/IEC

Table 103 — Unordered associative container requirements (in ad-
dition to container) (continued)

Expression
a.insert(q, t)

Return type

iterator

a.insert(i, j)

void

a.insert(il)

void

a.erase(k)

size_type

a.erase(q)

iterator

a.erase(q1, q2)

iterator

a.clear()

void

b.find(k)

iterator;
const_iterator for
const b.

§ 23.2.5

Assertion/note pre-/post-condition
Requires: If t is a non-const
rvalue expression, value_type
shall be MoveInsertable into
X; otherwise, value_type shall
be CopyInsertable into X.
Eﬀects: Equivalent to
a.insert(t). Return value is an
iterator pointing to the element
with the key equivalent to that
of t. The iterator q is a hint
pointing to where the search
should start. Implementations
are permitted to ignore the
hint.
Requires: value_type shall be
EmplaceConstructible into X
from *i.
Pre: i and j are not iterators in
a. Equivalent to a.insert(t)
for each element in [i,j).

Same as
a.insert(il.begin(),
il.end()).

Erases all elements with key
equivalent to k. Returns the
number of elements erased.

Erases the element pointed to
by q. Return value is the
iterator immediately following q
prior to the erasure.
Erases all elements in the range
[q1, q2). Return value is the
iterator immediately following
the erased elements prior to the
erasure.
Erases all elements in the
container. Post: a.empty()
returns true
Returns an iterator pointing to
an element with key equivalent
to k, or b.end() if no such
element exists.

N4296

Complexity
Average case
O(1), worst
case
O(a.size()).

Average case
O(N), where N
is distance(i,
j). Worst case
O(N ∗
(a.size())
+ N).
Same as
a.insert(
il.begin(),
il.end()).
Average case
O(a.count(k)).
Worst case
O(a.size()).
Average case
O(1), worst
case
O(a.size()).
Average case
linear in
distance(q1,
q2), worst case
O(a.size()).
Linear.

Average case
O(1), worst
case
O(b.size()).

771

c(cid:13) ISO/IEC

Table 103 — Unordered associative container requirements (in ad-
dition to container) (continued)

Expression

Return type

b.count(k)

size_type

Assertion/note pre-/post-condition
Returns the number of elements
with key equivalent to k.

b.equal_range(k)

b.bucket_count()

b.max_bucket_-
count()

pair<iterator,
iterator>;
pair<const_-
iterator,
const_iterator> for
const b.
size_type

size_type

b.bucket(k)

size_type

b.bucket_size(n)

size_type

b.begin(n)

b.end(n)

b.cbegin(n)

b.cend(n)

§ 23.2.5

local_iterator;
const_local_-
iterator for const
b.

local_iterator;
const_local_-
iterator for const
b.

const_local_-
iterator

const_local_-
iterator

Returns a range containing all
elements with keys equivalent
to k. Returns
make_pair(b.end(),
b.end()) if no such elements
exist.
Returns the number of buckets
that b contains.
Returns an upper bound on the
number of buckets that b might
ever contain.
Pre: b.bucket_count() > 0.
Returns the index of the bucket
in which elements with keys
equivalent to k would be found,
if any such element existed.
Post: the return value shall be
in the range [0,
b.bucket_count()).
Pre: n shall be in the range [0,
b.bucket_count()). Returns
the number of elements in the
n th bucket.
Pre: n shall be in the range [0,
b.bucket_count()).
b.begin(n) returns an iterator
referring to the ﬁrst element in
the bucket. If the bucket is
empty, then b.begin(n) ==
b.end(n).
Pre: n shall be in the range [0,
b.bucket_count()). b.end(n)
returns an iterator which is the
past-the-end value for the
bucket.
Pre: n shall be in the range [0,
b.bucket_count()). Note:
[b.cbegin(n), b.cend(n)) is
a valid range containing all of
the elements in the n th bucket.
Pre: n shall be in the range [0,
b.bucket_count()).

N4296

Complexity
Average case
O(b.count(k)),
worst case
O(b.size()).
Average case
O(b.count(k)).
Worst case
O(b.size()).

Constant

Constant

Constant

O(b.bucket_-
size(n))

Constant

Constant

Constant

Constant

772

c(cid:13) ISO/IEC

Table 103 — Unordered associative container requirements (in ad-
dition to container) (continued)

Expression
b.load_factor()

Return type

float

b.max_load_factor()

float

a.max_load_-
factor(z)

a.rehash(n)

void

void

a.reserve(n)

void

Assertion/note pre-/post-condition
Returns the average number of
elements per bucket.
Returns a positive number that
the container attempts to keep
the load factor less than or
equal to. The container
automatically increases the
number of buckets as necessary
to keep the load factor below
this number.
Pre: z shall be positive. May
change the container’s
maximum load factor, using z
as a hint.
Post: a.bucket_count() >
a.size() /
a.max_load_factor() and
a.bucket_count() >= n.

Same as a.rehash(ceil(n /
a.max_load_factor())).

N4296

Complexity
Constant

Constant

Constant

Average case
linear in
a.size(),
worst case
quadratic.
Average case
linear in
a.size(),
worst case
quadratic.

12 Two unordered containers a and b compare equal if a.size() == b.size() and, for every equivalent-
key group [Ea1,Ea2) obtained from a.equal_range(Ea1), there exists an equivalent-key group [Eb1,Eb2)
obtained from b.equal_range(Ea1), such that is_permutation(Ea1, Ea2, Eb1, Eb2) returns true. For
unordered_set and unordered_map, the complexity of operator== (i.e., the number of calls to the ==
operator of the value_type, to the predicate returned by key_equal(), and to the hasher returned by
hash_function()) is proportional to N in the average case and to N 2 in the worst case, where N is a.size().

For unordered_multiset and unordered_multimap, the complexity of operator== is proportional toP E2

in the average case and to N 2 in the worst case, where N is a.size(), and Ei is the size of the ith equivalent-
key group in a. However, if the respective elements of each corresponding pair of equivalent-key groups Eai
and Ebi are arranged in the same order (as is commonly the case, e.g., if a and b are unmodiﬁed copies of
the same container), then the average-case complexity for unordered_multiset and unordered_multimap
becomes proportional to N (but worst-case complexity remains O(N 2), e.g., for a pathologically bad hash
function). The behavior of a program that uses operator== or operator!= on unordered containers is
undeﬁned unless the Hash and Pred function objects respectively have the same behavior for both containers
and the equality comparison operator for Key is a reﬁnement263 of the partition into equivalent-key groups
produced by Pred.

i

13 The iterator types iterator and const_iterator of an unordered associative container are of at least the
forward iterator category. For unordered associative containers where the key type and value type are the
same, both iterator and const_iterator are const iterators.
263) Equality comparison is a reﬁnement of partitioning if no two objects that compare equal fall into diﬀerent partitions.

§ 23.2.5

773

c(cid:13) ISO/IEC

N4296

14 The insert and emplace members shall not aﬀect the validity of references to container elements, but may
invalidate all iterators to the container. The erase members shall invalidate only iterators and references
to the erased elements, and preserve the relative order of the elements that are not erased.

15 The insert and emplace members shall not aﬀect the validity of iterators if (N+n) < z * B, where N is the
number of elements in the container prior to the insert operation, n is the number of elements inserted, B is
the container’s bucket count, and z is the container’s maximum load factor.
23.2.5.1 Exception safety guarantees

[unord.req.except]
1 For unordered associative containers, no clear() function throws an exception. erase(k) does not throw

an exception unless that exception is thrown by the container’s Hash or Pred object (if any).

2 For unordered associative containers, if an exception is thrown by any operation other than the container’s
hash function from within an insert or emplace function inserting a single element, the insertion has no
eﬀect.

3 For unordered associative containers, no swap function throws an exception unless that exception is thrown

by the swap of the container’s Hash or Pred object (if any).

4 For unordered associative containers, if an exception is thrown from within a rehash() function other than

by the container’s hash function or comparison function, the rehash() function has no eﬀect.
23.3 Sequence containers
23.3.1

[sequences]
[sequences.general]
1 The headers <array>, <deque>, <forward_list>, <list>, and <vector> deﬁne template classes that meet

In general

the requirements for sequence containers.

2 The headers <queue> and <stack> deﬁne container adaptors (23.6) that also meet the requirements for

sequence containers.
Header <array> synopsis

#include <initializer_list>

namespace std {

template <class T, size_t N> struct array;
template <class T, size_t N>

bool operator==(const array<T,N>& x, const array<T,N>& y);

bool operator!=(const array<T,N>& x, const array<T,N>& y);

bool operator<(const array<T,N>& x, const array<T,N>& y);

bool operator>(const array<T,N>& x, const array<T,N>& y);

template <class T, size_t N>

template <class T, size_t N>

template <class T, size_t N>

template <class T, size_t N>

template <class T, size_t N>

template <class T, size_t N>

bool operator<=(const array<T,N>& x, const array<T,N>& y);

bool operator>=(const array<T,N>& x, const array<T,N>& y);

void swap(array<T,N>& x, array<T,N>& y) noexcept(noexcept(x.swap(y)));

template <class T> class tuple_size;
template <size_t I, class T> class tuple_element;
template <class T, size_t N>

struct tuple_size<array<T, N> >;

template <size_t I, class T, size_t N>

struct tuple_element<I, array<T, N> >;

§ 23.3.1

774

c(cid:13) ISO/IEC

N4296

template <size_t I, class T, size_t N>

constexpr T& get(array<T, N>&) noexcept;

template <size_t I, class T, size_t N>

constexpr T&& get(array<T, N>&&) noexcept;

template <size_t I, class T, size_t N>

constexpr const T& get(const array<T, N>&) noexcept;

}

Header <deque> synopsis

#include <initializer_list>

namespace std {

template <class T, class Allocator = allocator<T> > class deque;
template <class T, class Allocator>

bool operator==(const deque<T,Allocator>& x, const deque<T,Allocator>& y);

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

bool operator<(const deque<T,Allocator>& x, const deque<T,Allocator>& y);

bool operator!=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);

bool operator>(const deque<T,Allocator>& x, const deque<T,Allocator>& y);

bool operator>=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);

bool operator<=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);

template <class T, class Allocator>

void swap(deque<T,Allocator>& x, deque<T,Allocator>& y)

noexcept(noexcept(x.swap(y)));

Header <forward_list> synopsis

#include <initializer_list>

namespace std {

}

}

template <class T, class Allocator = allocator<T> > class forward_list;
template <class T, class Allocator>

bool operator==(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y);

bool operator< (const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y);

bool operator!=(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y);

bool operator> (const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y);

bool operator>=(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y);

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

bool operator<=(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y);

void swap(forward_list<T,Allocator>& x, forward_list<T,Allocator>& y)

noexcept(noexcept(x.swap(y)));

Header <list> synopsis

#include <initializer_list>

§ 23.3.1

775

c(cid:13) ISO/IEC

N4296

namespace std {

template <class T, class Allocator = allocator<T> > class list;
template <class T, class Allocator>

bool operator==(const list<T,Allocator>& x, const list<T,Allocator>& y);

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

bool operator< (const list<T,Allocator>& x, const list<T,Allocator>& y);

bool operator!=(const list<T,Allocator>& x, const list<T,Allocator>& y);

bool operator> (const list<T,Allocator>& x, const list<T,Allocator>& y);

bool operator>=(const list<T,Allocator>& x, const list<T,Allocator>& y);

bool operator<=(const list<T,Allocator>& x, const list<T,Allocator>& y);

template <class T, class Allocator>

void swap(list<T,Allocator>& x, list<T,Allocator>& y)

noexcept(noexcept(x.swap(y)));

}

Header <vector> synopsis

#include <initializer_list>

namespace std {

template <class T, class Allocator = allocator<T> > class vector;
template <class T, class Allocator>

bool operator==(const vector<T,Allocator>& x,const vector<T,Allocator>& y);

bool operator< (const vector<T,Allocator>& x,const vector<T,Allocator>& y);

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

bool operator!=(const vector<T,Allocator>& x,const vector<T,Allocator>& y);

bool operator> (const vector<T,Allocator>& x,const vector<T,Allocator>& y);

bool operator>=(const vector<T,Allocator>& x,const vector<T,Allocator>& y);

bool operator<=(const vector<T,Allocator>& x,const vector<T,Allocator>& y);

template <class T, class Allocator>

void swap(vector<T,Allocator>& x, vector<T,Allocator>& y)

noexcept(noexcept(x.swap(y)));

template <class Allocator> class vector<bool,Allocator>;

// hash support
template <class T> struct hash;
template <class Allocator> struct hash<vector<bool, Allocator> >;

}

23.3.2 Class template array
23.3.2.1 Class template array overview

[array]
[array.overview]
1 The header <array> deﬁnes a class template for storing ﬁxed-size sequences of objects. An array is a
contiguous container (23.2.1). An instance of array<T, N> stores N elements of type T, so that size() ==
N is an invariant.

§ 23.3.2.1

776

c(cid:13) ISO/IEC

N4296

2 An array is an aggregate (8.5.1) that can be initialized with the syntax

array<T, N> a = { initializer-list };

where initializer-list is a comma-separated list of up to N elements whose types are convertible to T.

3 An array satisﬁes all of the requirements of a container and of a reversible container (23.2), except that a
default constructed array object is not empty and that swap does not have constant complexity. An array
satisﬁes some of the requirements of a sequence container (23.2.3). Descriptions are provided here only for
operations on array that are not described in one of these tables and for operations where there is additional
semantic information.

namespace std {

template <class T, size_t N>
struct array {

// types:
typedef T&
typedef const T&
typedef implementation-defined
typedef implementation-defined
typedef size_t
typedef ptrdiff_t
typedef T
typedef T*
typedef const T*
typedef std::reverse_iterator<iterator>
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

reference;
const_reference;
iterator;
const_iterator;
size_type;
difference_type;
value_type;
pointer;
const_pointer;
reverse_iterator;

T

elems[N];

// exposition only

// no explicit construct/copy/destroy for aggregate type

void fill(const T& u);
void swap(array&) noexcept(noexcept(swap(declval<T&>(), declval<T&>())));

// iterators:
iterator
const_iterator
iterator
const_iterator

begin() noexcept;
begin() const noexcept;
end() noexcept;
end() const noexcept;

reverse_iterator
const_reverse_iterator rbegin() const noexcept;
reverse_iterator
const_reverse_iterator rend() const noexcept;

rbegin() noexcept;

rend() noexcept;

const_iterator
const_iterator
const_reverse_iterator crbegin() const noexcept;
const_reverse_iterator crend() const noexcept;

cbegin() const noexcept;
cend() const noexcept;

// capacity:
constexpr size_type size() const noexcept;
constexpr size_type max_size() const noexcept;
constexpr bool

empty() const noexcept;

// element access:

§ 23.3.2.1

777

c(cid:13) ISO/IEC

N4296

operator[](size_type n);

reference
constexpr const_reference operator[](size_type n) const;
reference
constexpr const_reference at(size_type n) const;
reference
constexpr const_reference front() const;
reference
constexpr const_reference back() const;

at(size_type n);

front();

back();

T *
const T * data() const noexcept;

data() noexcept;

};

}

4

[ Note: The member variable elems is shown for exposition only, to emphasize that array is a class aggregate.
The name elems is not part of array’s interface. — end note ]
23.3.2.2 array constructors, copy, and assignment

[array.cons]
1 The conditions for an aggregate (8.5.1) shall be met. Class array relies on the implicitly-declared special
member functions (12.1, 12.4, and 12.8) to conform to the container requirements table in 23.2. In addition
to the requirements speciﬁed in the container requirements table, the implicit move constructor and move
assignment operator for array require that T be MoveConstructible or MoveAssignable, respectively.
23.3.2.3 array specialized algorithms
[array.special]
template <class T, size_t N> void swap(array<T,N>& x, array<T,N>& y) noexcept(noexcept(x.swap(y)));

1

2

1

1

1

1

2

3

Eﬀects:

x.swap(y);

Complexity: Linear in N.

23.3.2.4 array::size
template <class T, size_t N> constexpr size_type array<T,N>::size() const noexcept;

[array.size]

Returns: N

23.3.2.5 array::data
T* data() noexcept;
const T* data() const noexcept;

Returns: elems.

23.3.2.6 array::fill
void fill(const T& u);

Eﬀects: fill_n(begin(), N, u)

23.3.2.7 array::swap
void swap(array& y) noexcept(noexcept(swap(declval<T&>(), declval<T&>())));

[array.data]

[array.ﬁll]

[array.swap]

Eﬀects: swap_ranges(begin(), end(), y.begin())
Throws: Nothing unless one of the element-wise swap calls throws an exception.
Note: Unlike the swap function for other containers, array::swap takes linear time, may exit via an
exception, and does not cause iterators to become associated with the other container.

§ 23.3.2.7

778

c(cid:13) ISO/IEC

23.3.2.8 Zero sized arrays

N4296

[array.zero]

In the case that N == 0, begin() == end() == unique value. The return value of data() is unspeciﬁed.

1 array shall provide support for the special case N == 0.
2
3 The eﬀect of calling front() or back() for a zero-sized array is undeﬁned.
4 Member function swap() shall have a noexcept-speciﬁcation which is equivalent to noexcept(true).

[array.tuple]

23.3.2.9 Tuple interface to class template array
template <class T, size_t N>
struct tuple_size<array<T, N>>

: integral_constant<size_t, N> { };

tuple_element<I, array<T, N> >::type

Requires: I < N. The program is ill-formed if I is out of bounds.
Value: The type T.

template <size_t I, class T, size_t N>
constexpr T& get(array<T, N>& a) noexcept;

Requires: I < N. The program is ill-formed if I is out of bounds.
Returns: A reference to the Ith element of a, where indexing is zero-based.

template <size_t I, class T, size_t N>
constexpr T&& get(array<T, N>&& a) noexcept;

Eﬀects: Equivalent to return std::move(get<I>(a));

template <size_t I, class T, size_t N>
constexpr const T& get(const array<T, N>& a) noexcept;

Requires: I < N. The program is ill-formed if I is out of bounds.
Returns: A const reference to the Ith element of a, where indexing is zero-based.

1

2

3

4

5

6

7

23.3.3 Class template deque
23.3.3.1 Class template deque overview

[deque]
[deque.overview]
1 A deque is a sequence container that, like a vector (23.3.6), supports random access iterators. In addition,
it supports constant time insert and erase operations at the beginning or the end; insert and erase in the
middle take linear time. That is, a deque is especially optimized for pushing and popping elements at the
beginning and end. As with vectors, storage management is handled automatically.

2 A deque satisﬁes all of the requirements of a container, of a reversible container (given in tables in 23.2), of
a sequence container, including the optional sequence container requirements (23.2.3), and of an allocator-
aware container (Table 99). Descriptions are provided here only for operations on deque that are not
described in one of these tables or for operations where there is additional semantic information.

namespace std {

template <class T, class Allocator = allocator<T> >
class deque {
public:

// types:
typedef value_type&
typedef const value_type&
typedef implementation-defined

reference;
const_reference;
iterator;

// See 23.2

§ 23.3.3.1

779

c(cid:13) ISO/IEC

N4296

typedef implementation-defined
typedef implementation-defined
typedef implementation-defined
typedef T
typedef Allocator
typedef typename allocator_traits<Allocator>::pointer
typedef typename allocator_traits<Allocator>::const_pointer
typedef std::reverse_iterator<iterator>
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

const_iterator; // See 23.2
// See 23.2
size_type;
difference_type;// See 23.2
value_type;
allocator_type;

reverse_iterator;

pointer;
const_pointer;

// 23.3.3.2, construct/copy/destroy:
deque() : deque(Allocator()) { }
explicit deque(const Allocator&);
explicit deque(size_type n, const Allocator& = Allocator());
deque(size_type n, const T& value, const Allocator& = Allocator());
template <class InputIterator>

deque(InputIterator first, InputIterator last, const Allocator& = Allocator());

deque(const deque& x);
deque(deque&&);
deque(const deque&, const Allocator&);
deque(deque&&, const Allocator&);
deque(initializer_list<T>, const Allocator& = Allocator());

~deque();
deque& operator=(const deque& x);
deque& operator=(deque&& x)

noexcept(allocator_traits<Allocator>::is_always_equal::value);

deque& operator=(initializer_list<T>);
template <class InputIterator>

void assign(InputIterator first, InputIterator last);

void assign(size_type n, const T& t);
void assign(initializer_list<T>);
allocator_type get_allocator() const noexcept;

// iterators:
iterator
const_iterator
iterator
const_iterator
reverse_iterator
const_reverse_iterator rbegin() const noexcept;
reverse_iterator
const_reverse_iterator rend() const noexcept;

begin() noexcept;
begin() const noexcept;
end() noexcept;
end() const noexcept;
rbegin() noexcept;

rend() noexcept;

const_iterator
const_iterator
const_reverse_iterator crbegin() const noexcept;
const_reverse_iterator crend() const noexcept;

cbegin() const noexcept;
cend() const noexcept;

// 23.3.3.3, capacity:
size_type size() const noexcept;
size_type max_size() const noexcept;
void
void
void

resize(size_type sz);
resize(size_type sz, const T& c);
shrink_to_fit();

§ 23.3.3.1

780

c(cid:13) ISO/IEC

N4296

bool

empty() const noexcept;

operator[](size_type n);

// element access:
reference
const_reference operator[](size_type n) const;
reference
const_reference at(size_type n) const;
reference
const_reference front() const;
reference
const_reference back() const;

at(size_type n);

front();

back();

// 23.3.3.4, modiﬁers:
template <class... Args> void emplace_front(Args&&... args);
template <class... Args> void emplace_back(Args&&... args);
template <class... Args> iterator emplace(const_iterator position, Args&&... args);

void push_front(const T& x);
void push_front(T&& x);
void push_back(const T& x);
void push_back(T&& x);

iterator insert(const_iterator position, const T& x);
iterator insert(const_iterator position, T&& x);
iterator insert(const_iterator position, size_type n, const T& x);
template <class InputIterator>

iterator insert (const_iterator position, InputIterator first, InputIterator last);

iterator insert(const_iterator position, initializer_list<T>);

void pop_front();
void pop_back();

iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
void

swap(deque&)

noexcept(allocator_traits<Allocator>::is_always_equal::value);

void

clear() noexcept;

};

bool operator==(const deque<T,Allocator>& x, const deque<T,Allocator>& y);

bool operator< (const deque<T,Allocator>& x, const deque<T,Allocator>& y);

bool operator!=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);

bool operator> (const deque<T,Allocator>& x, const deque<T,Allocator>& y);

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

bool operator>=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);

bool operator<=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);

// specialized algorithms:
template <class T, class Allocator>

void swap(deque<T,Allocator>& x, deque<T,Allocator>& y)

§ 23.3.3.1

781

c(cid:13) ISO/IEC

noexcept(noexcept(x.swap(y)));

}

23.3.3.2 deque constructors, copy, and assignment
explicit deque(const Allocator&);

Eﬀects: Constructs an empty deque, using the speciﬁed allocator.
Complexity: Constant.

explicit deque(size_type n, const Allocator& = Allocator());

N4296

[deque.cons]

Eﬀects: Constructs a deque with n default-inserted elements using the speciﬁed allocator.
Requires: T shall be DefaultInsertable into *this.
Complexity: Linear in n.

deque(size_type n, const T& value,

const Allocator& = Allocator());
Eﬀects: Constructs a deque with n copies of value, using the speciﬁed allocator.
Requires: T shall be CopyInsertable into *this.
Complexity: Linear in n.

1

2

3

4

5

6

7

8

template <class InputIterator>

deque(InputIterator first, InputIterator last,

const Allocator& = Allocator());

9

10

Eﬀects: Constructs a deque equal to the range [first,last), using the speciﬁed allocator.
Complexity: Linear in distance(first, last).

23.3.3.3 deque capacity
void resize(size_type sz);

If sz <= size(), equivalent to calling pop_back() size() - sz times.

Eﬀects:
appends sz - size() default-inserted elements to the sequence.
Requires: T shall be MoveInsertable and DefaultInsertable into *this.

[deque.capacity]

If size() < sz,

void resize(size_type sz, const T& c);

If sz <= size(), equivalent to calling pop_back() size() - sz times.

Eﬀects:
appends sz - size() copies of c to the sequence.
Requires: T shall be CopyInsertable into *this.

If size() < sz,

void shrink_to_fit();

Requires: T shall be MoveInsertable into *this.
Complexity: Linear in the size of the sequence.
Remarks: shrink_to_fit is a non-binding request to reduce memory use but does not change the
size of the sequence. [ Note: The request is non-binding to allow latitude for implementation-speciﬁc
optimizations. — end note ]

1

2

3

4

5

6

7

§ 23.3.3.3

782

c(cid:13) ISO/IEC

23.3.3.4 deque modiﬁers
iterator insert(const_iterator position, const T& x);
iterator insert(const_iterator position, T&& x);
iterator insert(const_iterator position, size_type n, const T& x);
template <class InputIterator>

iterator insert(const_iterator position,

iterator insert(const_iterator position, initializer_list<T>);

InputIterator first, InputIterator last);

N4296

[deque.modiﬁers]

template <class... Args> void emplace_front(Args&&... args);
template <class... Args> void emplace_back(Args&&... args);
template <class... Args> iterator emplace(const_iterator position, Args&&... args);
void push_front(const T& x);
void push_front(T&& x);
void push_back(const T& x);
void push_back(T&& x);

Eﬀects: An insertion in the middle of the deque invalidates all the iterators and references to elements
of the deque. An insertion at either end of the deque invalidates all the iterators to the deque, but has
no eﬀect on the validity of references to elements of the deque.
Remarks: If an exception is thrown other than by the copy constructor, move constructor, assignment
operator, or move assignment operator of T there are no eﬀects.
If an exception is thrown while
inserting a single element at either end, there are no eﬀects. Otherwise, if an exception is thrown by
the move constructor of a non-CopyInsertable T, the eﬀects are unspeciﬁed.
Complexity: The complexity is linear in the number of elements inserted plus the lesser of the distances
to the beginning and end of the deque. Inserting a single element either at the beginning or end of a
deque always takes constant time and causes a single call to a constructor of T.

iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);

Eﬀects: An erase operation that erases the last element of a deque invalidates only the past-the-end
iterator and all iterators and references to the erased elements. An erase operation that erases the ﬁrst
element of a deque but not the last element invalidates only the erased elements. An erase operation
that erases neither the ﬁrst element nor the last element of a deque invalidates the past-the-end iterator
and all iterators and references to all the elements of the deque.
Complexity: The number of calls to the destructor is the same as the number of elements erased, but
the number of calls to the assignment operator is no more than the lesser of the number of elements
before the erased elements and the number of elements after the erased elements.
Throws: Nothing unless an exception is thrown by the copy constructor, move constructor, assignment
operator, or move assignment operator of T.

23.3.3.5 deque specialized algorithms
template <class T, class Allocator>

void swap(deque<T,Allocator>& x, deque<T,Allocator>& y)

noexcept(noexcept(x.swap(y)));
Eﬀects:

x.swap(y);

§ 23.3.3.5

[deque.special]

783

1

2

3

4

5

6

1

c(cid:13) ISO/IEC

N4296

23.3.4 Class template forward_list
23.3.4.1 Class template forward_list overview

[forwardlist]
[forwardlist.overview]
1 A forward_list is a container that supports forward iterators and allows constant time insert and erase
operations anywhere within the sequence, with storage management handled automatically. Fast random
access to list elements is not supported. [ Note: It is intended that forward_list have zero space or time
overhead relative to a hand-written C-style singly linked list. Features that would conﬂict with that goal
have been omitted. — end note ]

2 A forward_list satisﬁes all of the requirements of a container (Table 96), except that the size() member
function is not provided and operator== has linear complexity. A forward_list also satisﬁes all of the
requirements for an allocator-aware container (Table 99). In addition, a forward_list provides the assign
member functions (Table 100) and several of the optional container requirements (Table 101). Descriptions
are provided here only for operations on forward_list that are not described in that table or for operations
where there is additional semantic information.
[ Note: Modifying any list requires access to the element preceding the ﬁrst element of interest, but in a
forward_list there is no constant-time way to access a preceding element. For this reason, ranges that are
modiﬁed, such as those supplied to erase and splice, must be open at the beginning. — end note ]

3

namespace std {

template <class T, class Allocator = allocator<T> >
class forward_list {
public:

// types:
typedef value_type&
typedef const value_type&
// See 23.2
typedef implementation-defined iterator;
typedef implementation-defined const_iterator; // See 23.2
// See 23.2
typedef implementation-defined size_type;
typedef implementation-defined difference_type;// See 23.2
typedef T value_type;
typedef Allocator allocator_type;
typedef typename allocator_traits<Allocator>::pointer
typedef typename allocator_traits<Allocator>::const_pointer

reference;
const_reference;

pointer;
const_pointer;

// 23.3.4.2, construct/copy/destroy:
forward_list() : forward_list(Allocator()) { }
explicit forward_list(const Allocator&);
explicit forward_list(size_type n, const Allocator& = Allocator());
forward_list(size_type n, const T& value,

const Allocator& = Allocator());

template <class InputIterator>

forward_list(InputIterator first, InputIterator last,

const Allocator& = Allocator());

forward_list(const forward_list& x);
forward_list(forward_list&& x);
forward_list(const forward_list& x, const Allocator&);
forward_list(forward_list&& x, const Allocator&);
forward_list(initializer_list<T>, const Allocator& = Allocator());
~forward_list();
forward_list& operator=(const forward_list& x);
forward_list& operator=(forward_list&& x)

noexcept(allocator_traits<Allocator>::is_always_equal::value);

forward_list& operator=(initializer_list<T>);
template <class InputIterator>

§ 23.3.4.1

784

c(cid:13) ISO/IEC

N4296

void assign(InputIterator first, InputIterator last);

void assign(size_type n, const T& t);
void assign(initializer_list<T>);
allocator_type get_allocator() const noexcept;

// 23.3.4.3, iterators:
iterator before_begin() noexcept;
const_iterator before_begin() const noexcept;
iterator begin() noexcept;
const_iterator begin() const noexcept;
iterator end() noexcept;
const_iterator end() const noexcept;

const_iterator cbegin() const noexcept;
const_iterator cbefore_begin() const noexcept;
const_iterator cend() const noexcept;

// capacity:
bool empty() const noexcept;
size_type max_size() const noexcept;

// 23.3.4.4, element access:
reference front();
const_reference front() const;

// 23.3.4.5, modiﬁers:
template <class... Args> void emplace_front(Args&&... args);
void push_front(const T& x);
void push_front(T&& x);
void pop_front();

template <class... Args> iterator emplace_after(const_iterator position, Args&&... args);
iterator insert_after(const_iterator position, const T& x);
iterator insert_after(const_iterator position, T&& x);

iterator insert_after(const_iterator position, size_type n, const T& x);
template <class InputIterator>

iterator insert_after(const_iterator position, InputIterator first, InputIterator last);

iterator insert_after(const_iterator position, initializer_list<T> il);

iterator erase_after(const_iterator position);
iterator erase_after(const_iterator position, const_iterator last);
void swap(forward_list&)

noexcept(allocator_traits<Allocator>::is_always_equal::value);

void resize(size_type sz);
void resize(size_type sz, const value_type& c);
void clear() noexcept;

// 23.3.4.6, forward_list operations:
void splice_after(const_iterator position, forward_list& x);
void splice_after(const_iterator position, forward_list&& x);
void splice_after(const_iterator position, forward_list& x,

void splice_after(const_iterator position, forward_list&& x,

const_iterator i);

§ 23.3.4.1

785

c(cid:13) ISO/IEC

N4296

const_iterator i);

void splice_after(const_iterator position, forward_list& x,

const_iterator first, const_iterator last);
void splice_after(const_iterator position, forward_list&& x,
const_iterator first, const_iterator last);

void remove(const T& value);
template <class Predicate> void remove_if(Predicate pred);

void unique();
template <class BinaryPredicate> void unique(BinaryPredicate binary_pred);

void merge(forward_list& x);
void merge(forward_list&& x);
template <class Compare> void merge(forward_list& x, Compare comp);
template <class Compare> void merge(forward_list&& x, Compare comp);

void sort();
template <class Compare> void sort(Compare comp);

void reverse() noexcept;

};

bool operator==(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y);

bool operator< (const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y);

bool operator!=(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y);

// Comparison operators
template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

bool operator> (const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y);

bool operator>=(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y);

bool operator<=(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y);

// 23.3.4.7, specialized algorithms:
template <class T, class Allocator>

void swap(forward_list<T,Allocator>& x, forward_list<T,Allocator>& y)

noexcept(noexcept(x.swap(y)));

}

23.3.4.2 forward_list constructors, copy, assignment
explicit forward_list(const Allocator&);

Eﬀects: Constructs an empty forward_list object using the speciﬁed allocator.
Complexity: Constant.

[forwardlist.cons]

explicit forward_list(size_type n, const Allocator& = Allocator());

Eﬀects: Constructs a forward_list object with n default-inserted elements using the speciﬁed allo-
cator.
Requires: T shall be DefaultInsertable into *this.

1

2

3

4

§ 23.3.4.2

786

c(cid:13) ISO/IEC

Complexity: Linear in n.

N4296

forward_list(size_type n, const T& value, const Allocator& = Allocator());

Eﬀects: Constructs a forward_list object with n copies of value using the speciﬁed allocator.
Requires: T shall be CopyInsertable into *this.
Complexity: Linear in n.

template <class InputIterator>

forward_list(InputIterator first, InputIterator last, const Allocator& = Allocator());

Eﬀects: Constructs a forward_list object equal to the range [first,last).
Complexity: Linear in distance(first, last).

23.3.4.3 forward_list iterators
iterator before_begin() noexcept;
const_iterator before_begin() const noexcept;
const_iterator cbefore_begin() const noexcept;

[forwardlist.iter]

Returns: A non-dereferenceable iterator that, when incremented, is equal to the iterator returned by
begin().
Eﬀects: cbefore_begin() is equivalent to const_cast<forward_list const&>(*this).before_-
begin().
Remarks: before_begin() == end() shall equal false.

23.3.4.4 forward_list element access
reference front();
const_reference front() const;

Returns: *begin()

[forwardlist.access]

5

6

7

8

9

10

1

2

3

1

23.3.4.5 forward_list modiﬁers

[forwardlist.modiﬁers]
1 None of the overloads of insert_after shall aﬀect the validity of iterators and references, and erase_-
after shall invalidate only iterators and references to the erased elements. If an exception is thrown during
insert_after there shall be no eﬀect. Inserting n elements into a forward_list is linear in n, and the
number of calls to the copy or move constructor of T is exactly equal to n. Erasing n elements from a
forward_list is linear in n and the number of calls to the destructor of type T is exactly equal to n.

2

3

4

template <class... Args> void emplace_front(Args&&... args);

Eﬀects: Inserts an object of type value_type constructed with value_type(std::forward<Args>(
args)...) at the beginning of the list.

void push_front(const T& x);
void push_front(T&& x);

Eﬀects: Inserts a copy of x at the beginning of the list.

void pop_front();

Eﬀects: erase_after(before_begin())

iterator insert_after(const_iterator position, const T& x);
iterator insert_after(const_iterator position, T&& x);

§ 23.3.4.5

787

c(cid:13) ISO/IEC

N4296

Requires: position is before_begin() or is a dereferenceable iterator in the range [begin(),end()).
Eﬀects: Inserts a copy of x after position.
Returns: An iterator pointing to the copy of x.

iterator insert_after(const_iterator position, size_type n, const T& x);

Requires: position is before_begin() or is a dereferenceable iterator in the range [begin(),end()).
Eﬀects: Inserts n copies of x after position.
Returns: An iterator pointing to the last inserted copy of x or position if n == 0.

template <class InputIterator>

iterator insert_after(const_iterator position, InputIterator first, InputIterator last);

Requires: position is before_begin() or is a dereferenceable iterator in the range [begin(),end()).
first and last are not iterators in *this.
Eﬀects: Inserts copies of elements in [first,last) after position.
Returns: An iterator pointing to the last inserted element or position if first == last.

iterator insert_after(const_iterator position, initializer_list<T> il);

Eﬀects: insert_after(p, il.begin(), il.end()).
Returns: An iterator pointing to the last inserted element or position if il is empty.

template <class... Args>

iterator emplace_after(const_iterator position, Args&&... args);

Requires: position is before_begin() or is a dereferenceable iterator in the range [begin(),end()).
Eﬀects: Inserts an object of type value_type constructed with value_type(std::forward<Args>(
args)...) after position.
Returns: An iterator pointing to the new object.

iterator erase_after(const_iterator position);

Requires: The iterator following position is dereferenceable.
Eﬀects: Erases the element pointed to by the iterator following position.
Returns: An iterator pointing to the element following the one that was erased, or end() if no such
element exists.
Throws: Nothing.

iterator erase_after(const_iterator position, const_iterator last);

Requires: All iterators in the range (position,last) are dereferenceable.
Eﬀects: Erases the elements in the range (position,last).
Returns: last.
Throws: Nothing.

void resize(size_type sz);

Eﬀects: If sz < distance(begin(), end()), erases the last distance(begin(), end()) - sz ele-
ments from the list. Otherwise, inserts sz - distance(begin(), end()) default-inserted elements
at the end of the list.
Requires: T shall be DefaultInsertable into *this.

§ 23.3.4.5

788

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

c(cid:13) ISO/IEC

N4296

void resize(size_type sz, const value_type& c);

Eﬀects: If sz < distance(begin(), end()), erases the last distance(begin(), end()) - sz el-
ements from the list. Otherwise, inserts sz - distance(begin(), end()) elements at the end of
the list such that each new element, e, is initialized by a method equivalent to calling allocator_-
traits<allocator_type>::construct(get_allocator(), std::addressof(e), c).
Requires: T shall be CopyInsertable into *this.

void clear() noexcept;

Eﬀects: Erases all elements in the range [begin(),end()).
Remarks: Does not invalidate past-the-end iterators.

23.3.4.6 forward_list operations
void splice_after(const_iterator position, forward_list& x);
void splice_after(const_iterator position, forward_list&& x);

[forwardlist.ops]

Requires: position is before_begin() or is a dereferenceable iterator in the range [begin(),end()).
get_allocator() == x.get_allocator(). &x != this.
Eﬀects: Inserts the contents of x after position, and x becomes empty. Pointers and references to the
moved elements of x now refer to those same elements but as members of *this. Iterators referring
to the moved elements will continue to refer to their elements, but they now behave as iterators into
*this, not into x.
Throws: Nothing.
Complexity: O(distance(x.begin(), x.end()))

void splice_after(const_iterator position, forward_list& x, const_iterator i);
void splice_after(const_iterator position, forward_list&& x, const_iterator i);

Requires: position is before_begin() or is a dereferenceable iterator in the range [begin(),end()).
The iterator following i is a dereferenceable iterator in x. get_allocator() == x.get_allocator().
Eﬀects: Inserts the element following i into *this, following position, and removes it from x. The
result is unchanged if position == i or position == ++i. Pointers and references to *++i continue
to refer to the same element but as a member of *this. Iterators to *++i continue to refer to the
same element, but now behave as iterators into *this, not into x.
Throws: Nothing.
Complexity: O(1)

void splice_after(const_iterator position, forward_list& x,

const_iterator first, const_iterator last);
void splice_after(const_iterator position, forward_list&& x,
const_iterator first, const_iterator last);

Requires: position is before_begin() or is a dereferenceable iterator in the range [begin(),end()).
(first,last) is a valid range in x, and all iterators in the range (first,last) are dereferenceable.
position is not an iterator in the range (first,last). get_allocator() == x.get_allocator().
Eﬀects: Inserts elements in the range (first,last) after position and removes the elements from x.
Pointers and references to the moved elements of x now refer to those same elements but as members
of *this. Iterators referring to the moved elements will continue to refer to their elements, but they
now behave as iterators into *this, not into x.
Complexity: O(distance(f irst, last))

§ 23.3.4.6

789

29

30

31

32

1

2

3

4

5

6

7

8

9

10

11

c(cid:13) ISO/IEC

N4296

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

void remove(const T& value);
template <class Predicate> void remove_if(Predicate pred);

Eﬀects: Erases all the elements in the list referred by a list iterator i for which the following conditions
hold: *i == value (for remove()), pred(*i) is true (for remove_if()). Invalidates only the iterators
and references to the erased elements.
Throws: Nothing unless an exception is thrown by the equality comparison or the predicate.
Remarks: Stable (17.6.5.7).
Complexity: Exactly distance(begin(), end()) applications of the corresponding predicate.

void unique();
template <class BinaryPredicate> void unique(BinaryPredicate pred);

Eﬀects: Erases all but the ﬁrst element from every consecutive group of equal elements referred to
by the iterator i in the range [first + 1,last) for which *i == *(i-1) (for the version with no
arguments) or pred(*i, *(i - 1)) (for the version with a predicate argument) holds. Invalidates
only the iterators and references to the erased elements.
Throws: Nothing unless an exception is thrown by the equality comparison or the predicate.
Complexity: If the range [first,last) is not empty, exactly (last - first) - 1 applications of
the corresponding predicate, otherwise no applications of the predicate.

void merge(forward_list& x);
void merge(forward_list&& x);
template <class Compare> void merge(forward_list& x, Compare comp);
template <class Compare> void merge(forward_list&& x, Compare comp);

Requires: comp deﬁnes a strict weak ordering (25.4), and *this and x are both sorted according to
this ordering. get_allocator() == x.get_allocator().
Eﬀects: Merges the two sorted ranges [begin(), end()) and [x.begin(), x.end()). x is empty
after the merge. If an exception is thrown other than by a comparison there are no eﬀects. Pointers
and references to the moved elements of x now refer to those same elements but as members of *this.
Iterators referring to the moved elements will continue to refer to their elements, but they now behave
as iterators into *this, not into x.
Remarks: Stable (17.6.5.7). The behavior is undeﬁned if this->get_allocator() != x.get_allocator().
Complexity: At most distance(begin(), end()) + distance(x.begin(), x.end()) - 1 compar-
isons.

void sort();
template <class Compare> void sort(Compare comp);

Requires: operator< (for the version with no arguments) or comp (for the version with a comparison
argument) deﬁnes a strict weak ordering (25.4).
Eﬀects: Sorts the list according to the operator< or the comp function object.
If an exception is
thrown the order of the elements in *this is unspeciﬁed. Does not aﬀect the validity of iterators and
references.
Remarks: Stable (17.6.5.7).
Complexity: Approximately N log N comparisons, where N is distance(begin(), end()).

void reverse() noexcept;

Eﬀects: Reverses the order of the elements in the list. Does not aﬀect the validity of iterators and
references.
Complexity: Linear time.

§ 23.3.4.6

790

c(cid:13) ISO/IEC

23.3.4.7 forward_list specialized algorithms
template <class T, class Allocator>

void swap(forward_list<T,Allocator>& x, forward_list<T,Allocator>& y)

noexcept(noexcept(x.swap(y)));
Eﬀects: x.swap(y)

1

N4296

[forwardlist.spec]

23.3.5 Class template list
23.3.5.1 Class template list overview

[list]
[list.overview]
1 A list is a sequence container that supports bidirectional iterators and allows constant time insert and
erase operations anywhere within the sequence, with storage management handled automatically. Unlike
vectors (23.3.6) and deques (23.3.3), fast random access to list elements is not supported, but many algo-
rithms only need sequential access anyway.

2 A list satisﬁes all of the requirements of a container, of a reversible container (given in two tables in 23.2),
of a sequence container, including most of the optional sequence container requirements (23.2.3), and of an
allocator-aware container (Table 99). The exceptions are the operator[] and at member functions, which
are not provided.264 Descriptions are provided here only for operations on list that are not described in
one of these tables or for operations where there is additional semantic information.

namespace std {

template <class T, class Allocator = allocator<T> >
class list {
public:

// types:
typedef value_type&
typedef const value_type&
typedef implementation-defined
typedef implementation-defined
typedef implementation-defined
typedef implementation-defined
typedef T
typedef Allocator
typedef typename allocator_traits<Allocator>::pointer
typedef typename allocator_traits<Allocator>::const_pointer
typedef std::reverse_iterator<iterator>
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

// see 23.2
iterator;
const_iterator; // see 23.2
// see 23.2
size_type;
difference_type;// see 23.2
value_type;
allocator_type;

reverse_iterator;

pointer;
const_pointer;

reference;
const_reference;

// 23.3.5.2, construct/copy/destroy:
list() : list(Allocator()) { }
explicit list(const Allocator&);
explicit list(size_type n, const Allocator& = Allocator());
list(size_type n, const T& value, const Allocator& = Allocator());
template <class InputIterator>

list(InputIterator first, InputIterator last, const Allocator& = Allocator());

list(const list& x);
list(list&& x);
list(const list&, const Allocator&);
list(list&&, const Allocator&);
list(initializer_list<T>, const Allocator& = Allocator());
~list();
list& operator=(const list& x);
list& operator=(list&& x)

264) These member functions are only provided by containers whose iterators are random access iterators.

§ 23.3.5.1

791

c(cid:13) ISO/IEC

N4296

noexcept(allocator_traits<Allocator>::is_always_equal::value);

list& operator=(initializer_list<T>);
template <class InputIterator>

void assign(InputIterator first, InputIterator last);

void assign(size_type n, const T& t);
void assign(initializer_list<T>);
allocator_type get_allocator() const noexcept;

// iterators:
iterator
const_iterator
iterator
const_iterator
reverse_iterator
const_reverse_iterator rbegin() const noexcept;
reverse_iterator
const_reverse_iterator rend() const noexcept;

begin() noexcept;
begin() const noexcept;
end() noexcept;
end() const noexcept;
rbegin() noexcept;

rend() noexcept;

const_iterator
const_iterator
const_reverse_iterator crbegin() const noexcept;
const_reverse_iterator crend() const noexcept;

cbegin() const noexcept;
cend() const noexcept;

// 23.3.5.3, capacity:
bool
empty() const noexcept;
size_type size() const noexcept;
size_type max_size() const noexcept;
void
void

resize(size_type sz);
resize(size_type sz, const T& c);

// element access:
reference
const_reference front() const;
reference
const_reference back() const;

front();

back();

// 23.3.5.4, modiﬁers:
template <class... Args> void emplace_front(Args&&... args);
void pop_front();
template <class... Args> void emplace_back(Args&&... args);
void push_front(const T& x);
void push_front(T&& x);
void push_back(const T& x);
void push_back(T&& x);
void pop_back();

template <class... Args> iterator emplace(const_iterator position, Args&&... args);
iterator insert(const_iterator position, const T& x);
iterator insert(const_iterator position, T&& x);
iterator insert(const_iterator position, size_type n, const T& x);
template <class InputIterator>

iterator insert(const_iterator position, InputIterator first,

iterator insert(const_iterator position, initializer_list<T> il);

InputIterator last);

§ 23.3.5.1

792

c(cid:13) ISO/IEC

N4296

iterator erase(const_iterator position);
iterator erase(const_iterator position, const_iterator last);
void

swap(list&)

noexcept(allocator_traits<Allocator>::is_always_equal::value);

void

clear() noexcept;

// 23.3.5.5, list operations:
void splice(const_iterator position, list& x);
void splice(const_iterator position, list&& x);
void splice(const_iterator position, list& x, const_iterator i);
void splice(const_iterator position, list&& x, const_iterator i);
void splice(const_iterator position, list& x,

const_iterator first, const_iterator last);

void splice(const_iterator position, list&& x,

const_iterator first, const_iterator last);

void remove(const T& value);
template <class Predicate> void remove_if(Predicate pred);

void unique();
template <class BinaryPredicate>

void unique(BinaryPredicate binary_pred);

void merge(list& x);
void merge(list&& x);
template <class Compare> void merge(list& x, Compare comp);
template <class Compare> void merge(list&& x, Compare comp);

void sort();
template <class Compare> void sort(Compare comp);

void reverse() noexcept;

};

bool operator==(const list<T,Allocator>& x, const list<T,Allocator>& y);

bool operator< (const list<T,Allocator>& x, const list<T,Allocator>& y);

bool operator!=(const list<T,Allocator>& x, const list<T,Allocator>& y);

bool operator> (const list<T,Allocator>& x, const list<T,Allocator>& y);

bool operator>=(const list<T,Allocator>& x, const list<T,Allocator>& y);

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

bool operator<=(const list<T,Allocator>& x, const list<T,Allocator>& y);

// specialized algorithms:
template <class T, class Allocator>

void swap(list<T,Allocator>& x, list<T,Allocator>& y)

noexcept(noexcept(x.swap(y)));

}

23.3.5.2 list constructors, copy, and assignment

§ 23.3.5.2

[list.cons]

793

1

2

3

4

5

6

7

8

9

10

1

2

3

4

c(cid:13) ISO/IEC

N4296

explicit list(const Allocator&);

Eﬀects: Constructs an empty list, using the speciﬁed allocator.
Complexity: Constant.

explicit list(size_type n, const Allocator& = Allocator());

Eﬀects: Constructs a list with n default-inserted elements using the speciﬁed allocator.
Requires: T shall be DefaultInsertable into *this.
Complexity: Linear in n.

list(size_type n, const T& value,

const Allocator& = Allocator());
Eﬀects: Constructs a list with n copies of value, using the speciﬁed allocator.
Requires: T shall be CopyInsertable into *this.
Complexity: Linear in n.

template <class InputIterator>
list(InputIterator first, InputIterator last,

const Allocator& = Allocator());
Eﬀects: Constructs a list equal to the range [first,last).
Complexity: Linear in distance(first, last).

23.3.5.3 list capacity
void resize(size_type sz);

[list.capacity]

Eﬀects: If size() < sz, appends sz - size() default-inserted elements to the sequence. If sz <=
size(), equivalent to

list<T>::iterator it = begin();
advance(it, sz);
erase(it, end());

Requires: T shall be DefaultInsertable into *this.

void resize(size_type sz, const T& c);

Eﬀects:

if (sz > size())

insert(end(), sz-size(), c);

else if (sz < size()) {
iterator i = begin();
advance(i, sz);
erase(i, end());

}
else
;

// do nothing

Requires: T shall be CopyInsertable into *this.

§ 23.3.5.3

794

c(cid:13) ISO/IEC

23.3.5.4 list modiﬁers
iterator insert(const_iterator position, const T& x);
iterator insert(const_iterator position, T&& x);
iterator insert(const_iterator position, size_type n, const T& x);
template <class InputIterator>

iterator insert(const_iterator position, InputIterator first,

iterator insert(const_iterator position, initializer_list<T>);

InputIterator last);

N4296

[list.modiﬁers]

template <class... Args> void emplace_front(Args&&... args);
template <class... Args> void emplace_back(Args&&... args);
template <class... Args> iterator emplace(const_iterator position, Args&&... args);
void push_front(const T& x);
void push_front(T&& x);
void push_back(const T& x);
void push_back(T&& x);

Remarks: Does not aﬀect the validity of iterators and references. If an exception is thrown there are
no eﬀects.
Complexity: Insertion of a single element into a list takes constant time and exactly one call to a
constructor of T. Insertion of multiple elements into a list is linear in the number of elements inserted,
and the number of calls to the copy constructor or move constructor of T is exactly equal to the number
of elements inserted.

iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);

void pop_front();
void pop_back();
void clear() noexcept;

Eﬀects: Invalidates only the iterators and references to the erased elements.
Throws: Nothing.
Complexity: Erasing a single element is a constant time operation with a single call to the destructor
of T. Erasing a range in a list is linear time in the size of the range and the number of calls to the
destructor of type T is exactly equal to the size of the range.

1

2

3

4

5

23.3.5.5 list operations

[list.ops]
1 Since lists allow fast insertion and erasing from the middle of a list, certain operations are provided speciﬁcally

for them.265

2 list provides three splice operations that destructively move elements from one list to another. The behavior

of splice operations is undeﬁned if get_allocator() != x.get_allocator().

void splice(const_iterator position, list& x);
void splice(const_iterator position, list&& x);

3

4

Requires: &x != this.
Eﬀects: Inserts the contents of x before position and x becomes empty. Pointers and references to
the moved elements of x now refer to those same elements but as members of *this. Iterators referring
to the moved elements will continue to refer to their elements, but they now behave as iterators into
*this, not into x.

265) As speciﬁed in 17.6.3.5, the requirements in this Clause apply only to lists whose allocators compare equal.

§ 23.3.5.5

795

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

c(cid:13) ISO/IEC

Throws: Nothing.
Complexity: Constant time.

N4296

void splice(const_iterator position, list& x, const_iterator i);
void splice(const_iterator position, list&& x, const_iterator i);

Eﬀects: Inserts an element pointed to by i from list x before position and removes the element from
x. The result is unchanged if position == i or position == ++i. Pointers and references to *i
continue to refer to this same element but as a member of *this. Iterators to *i (including i itself)
continue to refer to the same element, but now behave as iterators into *this, not into x.
Requires: i is a valid dereferenceable iterator of x.
Throws: Nothing.
Complexity: Constant time.

void splice(const_iterator position, list& x, const_iterator first,

void splice(const_iterator position, list&& x, const_iterator first,

const_iterator last);

const_iterator last);

Eﬀects: Inserts elements in the range [first,last) before position and removes the elements from
x.
Requires: [first, last) is a valid range in x. The result is undeﬁned if position is an iterator in
the range [first,last). Pointers and references to the moved elements of x now refer to those same
elements but as members of *this. Iterators referring to the moved elements will continue to refer to
their elements, but they now behave as iterators into *this, not into x.
Throws: Nothing.
Complexity: Constant time if &x == this; otherwise, linear time.

template <class Predicate> void remove_if(Predicate pred);

void remove(const T& value);

Eﬀects: Erases all the elements in the list referred by a list iterator i for which the following conditions
hold: *i == value, pred(*i) != false. Invalidates only the iterators and references to the erased
elements.
Throws: Nothing unless an exception is thrown by *i == value or pred(*i) != false.
Remarks: Stable (17.6.5.7).
Complexity: Exactly size() applications of the corresponding predicate.

template <class BinaryPredicate> void unique(BinaryPredicate binary_pred);

void unique();

Eﬀects: Erases all but the ﬁrst element from every consecutive group of equal elements referred to
by the iterator i in the range [first + 1,last) for which *i == *(i-1) (for the version of unique
with no arguments) or pred(*i, *(i - 1)) (for the version of unique with a predicate argument)
holds. Invalidates only the iterators and references to the erased elements.
Throws: Nothing unless an exception is thrown by *i == *(i-1) or pred(*i, *(i - 1))
Complexity: If the range [first, last) is not empty, exactly (last - first) - 1 applications of
the corresponding predicate, otherwise no applications of the predicate.

§ 23.3.5.5

796

c(cid:13) ISO/IEC

N4296

void
void
template <class Compare> void merge(list& x, Compare comp);
template <class Compare> void merge(list&& x, Compare comp);

merge(list& x);
merge(list&& x);

Requires: comp shall deﬁne a strict weak ordering (25.4), and both the list and the argument list shall
be sorted according to this ordering.
Eﬀects: If (&x == this) does nothing; otherwise, merges the two sorted ranges [begin(), end())
and [x.begin(), x.end()). The result is a range in which the elements will be sorted in non-
decreasing order according to the ordering deﬁned by comp; that is, for every iterator i, in the range
other than the ﬁrst, the condition comp(*i, *(i - 1)) will be false. Pointers and references to the
moved elements of x now refer to those same elements but as members of *this. Iterators referring
to the moved elements will continue to refer to their elements, but they now behave as iterators into
*this, not into x.
Remarks: Stable (17.6.5.7). If (&x != this) the range [x.begin(), x.end()) is empty after the
merge. No elements are copied by this operation. The behavior is undeﬁned if this->get_allocator()
!= x.get_allocator().
Complexity: At most size() + x.size() - 1 applications of comp if (&x != this); otherwise, no
applications of comp are performed. If an exception is thrown other than by a comparison there are
no eﬀects.

void reverse() noexcept;

Eﬀects: Reverses the order of the elements in the list. Does not aﬀect the validity of iterators and
references.
Complexity: Linear time.

template <class Compare> void sort(Compare comp);

void sort();

Requires: operator< (for the ﬁrst version) or comp (for the second version) shall deﬁne a strict weak
ordering (25.4).
Eﬀects: Sorts the list according to the operator< or a Compare function object. Does not aﬀect the
validity of iterators and references.
Remarks: Stable (17.6.5.7).
Complexity: Approximately N log(N) comparisons, where N == size().

23.3.5.6 list specialized algorithms
template <class T, class Allocator>

void swap(list<T,Allocator>& x, list<T,Allocator>& y)

noexcept(noexcept(x.swap(y)));
Eﬀects:

[list.special]

22

23

24

25

26

27

28

29

30

31

1

x.swap(y);

23.3.6 Class template vector
23.3.6.1 Class template vector overview

[vector]
[vector.overview]
1 A vector is a sequence container that supports (amortized) constant time insert and erase operations at the
end; insert and erase in the middle take linear time. Storage management is handled automatically, though
hints can be given to improve eﬃciency.

§ 23.3.6.1

797

c(cid:13) ISO/IEC

N4296

2 A vector satisﬁes all of the requirements of a container and of a reversible container (given in two tables
in 23.2), of a sequence container, including most of the optional sequence container requirements (23.2.3),
of an allocator-aware container (Table 99), and, for an element type other than bool, of a contiguous
container (23.2.1). The exceptions are the push_front, pop_front, and emplace_front member functions,
which are not provided. Descriptions are provided here only for operations on vector that are not described
in one of these tables or for operations where there is additional semantic information.

namespace std {

template <class T, class Allocator = allocator<T> >
class vector {
public:

// types:
typedef value_type&
typedef const value_type&
typedef implementation-defined
typedef implementation-defined
typedef implementation-defined
typedef implementation-defined
typedef T
typedef Allocator
typedef typename allocator_traits<Allocator>::pointer
typedef typename allocator_traits<Allocator>::const_pointer
typedef std::reverse_iterator<iterator>
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

reference;
const_reference;
// see 23.2
iterator;
const_iterator; // see 23.2
// see 23.2
size_type;
difference_type;// see 23.2
value_type;
allocator_type;

reverse_iterator;

pointer;
const_pointer;

// 23.3.6.2, construct/copy/destroy:
vector() noexcept : vector(Allocator()) { }
explicit vector(const Allocator&) noexcept;
explicit vector(size_type n, const Allocator& = Allocator());
vector(size_type n, const T& value, const Allocator& = Allocator());
template <class InputIterator>

vector(InputIterator first, InputIterator last,

const Allocator& = Allocator());

vector(const vector& x);
vector(vector&&) noexcept;
vector(const vector&, const Allocator&);
vector(vector&&, const Allocator&);
vector(initializer_list<T>, const Allocator& = Allocator());
~vector();
vector& operator=(const vector& x);
vector& operator=(vector&& x)

noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||

allocator_traits<Allocator>::is_always_equal::value);

vector& operator=(initializer_list<T>);
template <class InputIterator>

void assign(InputIterator first, InputIterator last);

void assign(size_type n, const T& u);
void assign(initializer_list<T>);
allocator_type get_allocator() const noexcept;

// iterators:
iterator
const_iterator
iterator
const_iterator

begin() noexcept;
begin() const noexcept;
end() noexcept;
end() const noexcept;

§ 23.3.6.1

798

c(cid:13) ISO/IEC

N4296

reverse_iterator
const_reverse_iterator rbegin() const noexcept;
reverse_iterator
const_reverse_iterator rend() const noexcept;

rbegin() noexcept;

rend() noexcept;

const_iterator
const_iterator
const_reverse_iterator crbegin() const noexcept;
const_reverse_iterator crend() const noexcept;

cbegin() const noexcept;
cend() const noexcept;

// 23.3.6.3, capacity:
size_type size() const noexcept;
size_type max_size() const noexcept;
void
void
size_type capacity() const noexcept;
bool
void
void

empty() const noexcept;
reserve(size_type n);
shrink_to_fit();

resize(size_type sz);
resize(size_type sz, const T& c);

operator[](size_type n);

// element access:
reference
const_reference operator[](size_type n) const;
const_reference at(size_type n) const;
reference
reference
const_reference front() const;
reference
const_reference back() const;

at(size_type n);
front();

back();

// 23.3.6.4, data access
T*
const T*

data() noexcept;
data() const noexcept;

// 23.3.6.5, modiﬁers:
template <class... Args> void emplace_back(Args&&... args);
void push_back(const T& x);
void push_back(T&& x);
void pop_back();

template <class... Args> iterator emplace(const_iterator position, Args&&... args);
iterator insert(const_iterator position, const T& x);
insert(const_iterator position, T&& x);
iterator
iterator
insert(const_iterator position, size_type n, const T& x);
template <class InputIterator>

iterator insert(const_iterator position,

InputIterator first, InputIterator last);

799

insert(const_iterator position, initializer_list<T> il);

iterator
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
void

swap(vector&)

noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||

allocator_traits<Allocator>::is_always_equal::value);

clear() noexcept;

void

};

§ 23.3.6.1

c(cid:13) ISO/IEC

N4296

bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);

bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);

bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

template <class T, class Allocator>

bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);

bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);

bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);

// 23.3.6.6, specialized algorithms:
template <class T, class Allocator>

void swap(vector<T,Allocator>& x, vector<T,Allocator>& y)

noexcept(noexcept(x.swap(y)));

}

1

2

3

4

5

6

7

8

9

10

23.3.6.2 vector constructors, copy, and assignment
explicit vector(const Allocator&);

Eﬀects: Constructs an empty vector, using the speciﬁed allocator.
Complexity: Constant.

explicit vector(size_type n, const Allocator& = Allocator());

[vector.cons]

Eﬀects: Constructs a vector with n default-inserted elements using the speciﬁed allocator.
Requires: T shall be DefaultInsertable into *this.
Complexity: Linear in n.

vector(size_type n, const T& value,

const Allocator& = Allocator());

Eﬀects: Constructs a vector with n copies of value, using the speciﬁed allocator.
Requires: T shall be CopyInsertable into *this.
Complexity: Linear in n.

template <class InputIterator>

vector(InputIterator first, InputIterator last,

const Allocator& = Allocator());

Eﬀects: Constructs a vector equal to the range [first,last), using the speciﬁed allocator.
Complexity: Makes only N calls to the copy constructor of T (where N is the distance between first
and last) and no reallocations if iterators ﬁrst and last are of forward, bidirectional, or random access
categories. It makes order N calls to the copy constructor of T and order log(N) reallocations if they
are just input iterators.

§ 23.3.6.2

800

c(cid:13) ISO/IEC

23.3.6.3 vector capacity
size_type capacity() const noexcept;

N4296

[vector.capacity]

Returns: The total number of elements that the vector can hold without requiring reallocation.

void reserve(size_type n);

Requires: T shall be MoveInsertable into *this.
Eﬀects: A directive that informs a vector of a planned change in size, so that it can manage the storage
allocation accordingly. After reserve(), capacity() is greater or equal to the argument of reserve if
reallocation happens; and equal to the previous value of capacity() otherwise. Reallocation happens
at this point if and only if the current capacity is less than the argument of reserve(). If an exception
is thrown other than by the move constructor of a non-CopyInsertable type, there are no eﬀects.
Complexity: It does not change the size of the sequence and takes at most linear time in the size of
the sequence.
Throws: length_error if n > max_size().266
Remarks: Reallocation invalidates all the references, pointers, and iterators referring to the elements in
the sequence. No reallocation shall take place during insertions that happen after a call to reserve()
until the time when an insertion would make the size of the vector greater than the value of capacity().

void shrink_to_fit();

Requires: T shall be MoveInsertable into *this.
Complexity: Linear in the size of the sequence.
Remarks: shrink_to_fit is a non-binding request to reduce capacity() to size().
[ Note: The
request is non-binding to allow latitude for implementation-speciﬁc optimizations. — end note ] If
an exception is thrown other than by the move constructor of a non-CopyInsertable T there are no
eﬀects.

void swap(vector& x)

noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||

allocator_traits<Allocator>::is_always_equal::value);

Eﬀects: Exchanges the contents and capacity() of *this with that of x.
Complexity: Constant time.

void resize(size_type sz);

If sz <= size(), equivalent to calling pop_back() size() - sz times.

Eﬀects:
appends sz - size() default-inserted elements to the sequence.
Requires: T shall be MoveInsertable and DefaultInsertable into *this.
Remarks: If an exception is thrown other than by the move constructor of a non-CopyInsertable T
there are no eﬀects.

If size() < sz,

void resize(size_type sz, const T& c);

If sz <= size(), equivalent to calling pop_back() size() - sz times.

Eﬀects:
appends sz - size() copies of c to the sequence.
Requires: T shall be CopyInsertable into *this.
Remarks: If an exception is thrown there are no eﬀects.

If size() < sz,

266) reserve() uses Allocator::allocate() which may throw an appropriate exception.

§ 23.3.6.3

801

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

1

2

1

2

3

4

5

1

c(cid:13) ISO/IEC

23.3.6.4 vector data
T*
const T*

data() noexcept;
data() const noexcept;

N4296

[vector.data]

Returns: A pointer such that [data(),data() + size()) is a valid range. For a non-empty vector,
data() == &front().
Complexity: Constant time.

23.3.6.5 vector modiﬁers
iterator insert(const_iterator position, const T& x);
iterator insert(const_iterator position, T&& x);
iterator insert(const_iterator position, size_type n, const T& x);
template <class InputIterator>

iterator insert(const_iterator position, InputIterator first, InputIterator last);

iterator insert(const_iterator position, initializer_list<T>);

[vector.modiﬁers]

template <class... Args> void emplace_back(Args&&... args);
template <class... Args> iterator emplace(const_iterator position, Args&&... args);
void push_back(const T& x);
void push_back(T&& x);

Remarks: Causes reallocation if the new size is greater than the old capacity. If no reallocation happens,
all the iterators and references before the insertion point remain valid. If an exception is thrown other
than by the copy constructor, move constructor, assignment operator, or move assignment operator of
T or by any InputIterator operation there are no eﬀects. If an exception is thrown while inserting a
single element at the end and T is CopyInsertable or is_nothrow_move_constructible<T>::value
is true, there are no eﬀects. Otherwise, if an exception is thrown by the move constructor of a
non-CopyInsertable T, the eﬀects are unspeciﬁed.
Complexity: The complexity is linear in the number of elements inserted plus the distance to the end
of the vector.

iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);

Eﬀects: Invalidates iterators and references at or after the point of the erase.
Complexity: The destructor of T is called the number of times equal to the number of the elements
erased, but the move assignment operator of T is called the number of times equal to the number of
elements in the vector after the erased elements.
Throws: Nothing unless an exception is thrown by the copy constructor, move constructor, assignment
operator, or move assignment operator of T.

23.3.6.6 vector specialized algorithms
template <class T, class Allocator>

void swap(vector<T,Allocator>& x, vector<T,Allocator>& y)

noexcept(noexcept(x.swap(y)));
Eﬀects:

x.swap(y);

§ 23.3.6.6

[vector.special]

802

c(cid:13) ISO/IEC

23.3.7 Class vector<bool>

1 To optimize space allocation, a specialization of vector for bool elements is provided:

N4296

[vector.bool]

namespace std {

template <class Allocator> class vector<bool, Allocator> {
public:

// types:
typedef bool
typedef implementation-defined
typedef implementation-defined
typedef implementation-defined
typedef implementation-defined
typedef bool
typedef Allocator
typedef implementation-defined
typedef implementation-defined
typedef std::reverse_iterator<iterator>
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

const_reference;
// see 23.2
iterator;
const_iterator; // see 23.2
// see 23.2
size_type;
difference_type;// see 23.2
value_type;
allocator_type;
pointer;
const_pointer;
reverse_iterator;

// bit reference:
class reference {

friend class vector;
reference() noexcept;

public:

~reference();
operator bool() const noexcept;
reference& operator=(const bool x) noexcept;
reference& operator=(const reference& x) noexcept;
void flip() noexcept;

// ﬂips the bit

};

// construct/copy/destroy:
vector() : vector(Allocator()) { }
explicit vector(const Allocator&);
explicit vector(size_type n, const Allocator& = Allocator());
vector(size_type n, const bool& value,
const Allocator& = Allocator());

template <class InputIterator>

vector(InputIterator first, InputIterator last,

const Allocator& = Allocator());
vector(const vector<bool,Allocator>& x);
vector(vector<bool,Allocator>&& x);
vector(const vector&, const Allocator&);
vector(vector&&, const Allocator&);
vector(initializer_list<bool>, const Allocator& = Allocator()));
~vector();
vector<bool,Allocator>& operator=(const vector<bool,Allocator>& x);
vector<bool,Allocator>& operator=(vector<bool,Allocator>&& x);
vector& operator=(initializer_list<bool>);
template <class InputIterator>

void assign(InputIterator first, InputIterator last);

void assign(size_type n, const bool& t);
void assign(initializer_list<bool>);
allocator_type get_allocator() const noexcept;

§ 23.3.7

803

c(cid:13) ISO/IEC

N4296

// iterators:
iterator
const_iterator
iterator
const_iterator
reverse_iterator
const_reverse_iterator rbegin() const noexcept;
reverse_iterator
const_reverse_iterator rend() const noexcept;

begin() noexcept;
begin() const noexcept;
end() noexcept;
end() const noexcept;
rbegin() noexcept;

rend() noexcept;

const_iterator
const_iterator
const_reverse_iterator crbegin() const noexcept;
const_reverse_iterator crend() const noexcept;

cbegin() const noexcept;
cend() const noexcept;

// capacity:
size_type size() const noexcept;
size_type max_size() const noexcept;
void
size_type capacity() const noexcept;
bool
void
void

empty() const noexcept;
reserve(size_type n);
shrink_to_fit();

resize(size_type sz, bool c = false);

operator[](size_type n);

// element access:
reference
const_reference operator[](size_type n) const;
const_reference at(size_type n) const;
reference
reference
const_reference front() const;
reference
const_reference back() const;

at(size_type n);
front();

back();

// modiﬁers:
template <class... Args> void emplace_back(Args&&... args);
void push_back(const bool& x);
void pop_back();
template <class... Args> iterator emplace(const_iterator position, Args&&... args);
iterator insert(const_iterator position, const bool& x);
iterator insert (const_iterator position, size_type n, const bool& x);
template <class InputIterator>

iterator insert(const_iterator position,

iterator insert(const_iterator position, initializer_list<bool> il);

InputIterator first, InputIterator last);

iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
void swap(vector<bool,Allocator>&);
static void swap(reference x, reference y) noexcept;
void flip() noexcept;
void clear() noexcept;

// ﬂips all bits

};

}

§ 23.3.7

804

c(cid:13) ISO/IEC

N4296

2 Unless described below, all operations have the same requirements and semantics as the primary vector
template, except that operations dealing with the bool value type map to bit values in the container storage
and allocator_traits::construct (20.7.8.2) is not used to construct these values.

3 There is no requirement that the data be stored as a contiguous allocation of bool values. A space-optimized

representation of bits is recommended instead.

4 reference is a class that simulates the behavior of references of a single bit in vector<bool>. The conversion
operator returns true when the bit is set, and false otherwise. The assignment operator sets the bit when
the argument is (convertible to) true and clears it otherwise. flip reverses the state of the bit.

void flip() noexcept;

Eﬀects: Replaces each element in the container with its complement.

static void swap(reference x, reference y) noexcept;
Eﬀects: exchanges the contents of x and y as if by

bool b = x;
x = y;
y = b;

template <class Allocator> struct hash<vector<bool, Allocator> >;

The template specialization shall meet the requirements of class template hash (20.9.13).

5

6

7

23.4 Associative containers
23.4.1

[associative]
[associative.general]
1 The header <map> deﬁnes the class templates map and multimap; the header <set> deﬁnes the class templates

In general

set and multiset.
23.4.2 Header <map> synopsis

#include <initializer_list>

namespace std {

[associative.map.syn]

template <class Key, class T, class Compare = less<Key>,

class Allocator = allocator<pair<const Key, T> > >

class map;

template <class Key, class T, class Compare, class Allocator>

bool operator==(const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);

template <class Key, class T, class Compare, class Allocator>

bool operator< (const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);

template <class Key, class T, class Compare, class Allocator>

bool operator!=(const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);

template <class Key, class T, class Compare, class Allocator>

bool operator> (const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);

template <class Key, class T, class Compare, class Allocator>

bool operator>=(const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);

template <class Key, class T, class Compare, class Allocator>

§ 23.4.2

805

c(cid:13) ISO/IEC

N4296

bool operator<=(const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);

template <class Key, class T, class Compare, class Allocator>

void swap(map<Key,T,Compare,Allocator>& x,
map<Key,T,Compare,Allocator>& y)

noexcept(noexcept(x.swap(y)));

template <class Key, class T, class Compare = less<Key>,

class Allocator = allocator<pair<const Key, T> > >

class multimap;

template <class Key, class T, class Compare, class Allocator>
bool operator==(const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);
template <class Key, class T, class Compare, class Allocator>
bool operator< (const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);
template <class Key, class T, class Compare, class Allocator>
bool operator!=(const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);
template <class Key, class T, class Compare, class Allocator>
bool operator> (const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);
template <class Key, class T, class Compare, class Allocator>
bool operator>=(const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);
template <class Key, class T, class Compare, class Allocator>
bool operator<=(const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);
template <class Key, class T, class Compare, class Allocator>

void swap(multimap<Key,T,Compare,Allocator>& x,
multimap<Key,T,Compare,Allocator>& y)

noexcept(noexcept(x.swap(y)));

}

23.4.3 Header <set> synopsis

#include <initializer_list>

namespace std {

[associative.set.syn]

template <class Key, class Compare = less<Key>,

class Allocator = allocator<Key> >

class set;

template <class Key, class Compare, class Allocator>

bool operator==(const set<Key,Compare,Allocator>& x,
const set<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

bool operator< (const set<Key,Compare,Allocator>& x,
const set<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

bool operator!=(const set<Key,Compare,Allocator>& x,
const set<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

bool operator> (const set<Key,Compare,Allocator>& x,
const set<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

§ 23.4.3

806

c(cid:13) ISO/IEC

N4296

bool operator>=(const set<Key,Compare,Allocator>& x,
const set<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

bool operator<=(const set<Key,Compare,Allocator>& x,
const set<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

void swap(set<Key,Compare,Allocator>& x,
set<Key,Compare,Allocator>& y)

noexcept(noexcept(x.swap(y)));

template <class Key, class Compare = less<Key>,

class Allocator = allocator<Key> >

class multiset;

template <class Key, class Compare, class Allocator>

bool operator==(const multiset<Key,Compare,Allocator>& x,
const multiset<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

bool operator< (const multiset<Key,Compare,Allocator>& x,
const multiset<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

bool operator!=(const multiset<Key,Compare,Allocator>& x,
const multiset<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

bool operator> (const multiset<Key,Compare,Allocator>& x,
const multiset<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

bool operator>=(const multiset<Key,Compare,Allocator>& x,
const multiset<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

bool operator<=(const multiset<Key,Compare,Allocator>& x,
const multiset<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

void swap(multiset<Key,Compare,Allocator>& x,
multiset<Key,Compare,Allocator>& y)

noexcept(noexcept(x.swap(y)));

}

23.4.4 Class template map
23.4.4.1 Class template map overview

[map]
[map.overview]
1 A map is an associative container that supports unique keys (contains at most one of each key value) and
provides for fast retrieval of values of another type T based on the keys. The map class supports bidirectional
iterators.

2 A map satisﬁes all of the requirements of a container, of a reversible container (23.2), of an associative
container (23.2.4), and of an allocator-aware container (Table 99). A map also provides most operations
described in (23.2.4) for unique keys. This means that a map supports the a_uniq operations in (23.2.4)
but not the a_eq operations. For a map<Key,T> the key_type is Key and the value_type is pair<const
Key,T>. Descriptions are provided here only for operations on map that are not described in one of those
tables or for operations where there is additional semantic information.

template <class Key, class T, class Compare = less<Key>,

class Allocator = allocator<pair<const Key, T> > >

namespace std {

class map {
public:

§ 23.4.4.1

807

c(cid:13) ISO/IEC

N4296

// types:
typedef Key
typedef T
typedef pair<const Key, T>
typedef Compare
typedef Allocator
typedef value_type&
typedef const value_type&
typedef implementation-defined
typedef implementation-defined
typedef implementation-defined
typedef implementation-defined
typedef typename allocator_traits<Allocator>::pointer
typedef typename allocator_traits<Allocator>::const_pointer
typedef std::reverse_iterator<iterator>
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

key_type;
mapped_type;
value_type;
key_compare;
allocator_type;
reference;
const_reference;
// see 23.2
iterator;
const_iterator; // see 23.2
// see 23.2
size_type;
difference_type;// see 23.2
pointer;
const_pointer;

reverse_iterator;

class value_compare {
friend class map;
protected:

Compare comp;
value_compare(Compare c) : comp(c) {}

public:

typedef bool result_type;
typedef value_type first_argument_type;
typedef value_type second_argument_type;
bool operator()(const value_type& x, const value_type& y) const {

return comp(x.first, y.first);

const Compare& comp = Compare(), const Allocator& = Allocator());

}

};

// 23.4.4.2, construct/copy/destroy:
map() : map(Compare()) { }
explicit map(const Compare& comp,

const Allocator& = Allocator());

template <class InputIterator>

map(InputIterator first, InputIterator last,

map(const map& x);
map(map&& x);
explicit map(const Allocator&);
map(const map&, const Allocator&);
map(map&&, const Allocator&);
map(initializer_list<value_type>,

const Compare& = Compare(),
const Allocator& = Allocator());

template <class InputIterator>
map(InputIterator first, InputIterator last, const Allocator& a)

: map(first, last, Compare(), a) { }

map(initializer_list<value_type> il, const Allocator& a)

: map(il, Compare(), a) { }

~map();
map& operator=(const map& x);
map& operator=(map&& x)

noexcept(allocator_traits<Allocator>::is_always_equal::value &&

§ 23.4.4.1

808

c(cid:13) ISO/IEC

N4296

is_nothrow_move_assignable<Compare>::value);

map& operator=(initializer_list<value_type>);
allocator_type get_allocator() const noexcept;

// iterators:
iterator
const_iterator
iterator
const_iterator

begin() noexcept;
begin() const noexcept;
end() noexcept;
end() const noexcept;

reverse_iterator
const_reverse_iterator rbegin() const noexcept;
reverse_iterator
const_reverse_iterator rend() const noexcept;

rbegin() noexcept;

rend() noexcept;

const_iterator
const_iterator
const_reverse_iterator crbegin() const noexcept;
const_reverse_iterator crend() const noexcept;

cbegin() const noexcept;
cend() const noexcept;

// capacity:
bool
empty() const noexcept;
size_type size() const noexcept;
size_type max_size() const noexcept;

// 23.4.4.3, element access:
T& operator[](const key_type& x);
T& operator[](key_type&& x);
T&
const T& at(const key_type& x) const;

at(const key_type& x);

// 23.4.4.4, modiﬁers:
template <class... Args> pair<iterator, bool> emplace(Args&&... args);
template <class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
pair<iterator, bool> insert(const value_type& x);
pair<iterator, bool> insert(value_type&& x);
template <class P> pair<iterator, bool> insert(P&& x);
iterator insert(const_iterator position, const value_type& x);
iterator insert(const_iterator position, value_type&& x);
template <class P>

iterator insert(const_iterator position, P&&);

template <class InputIterator>

void insert(InputIterator first, InputIterator last);

void insert(initializer_list<value_type>);

template <class... Args>

pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);

pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);

iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);

template <class... Args>

template <class... Args>

template <class... Args>

template <class M>

iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);

pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);

§ 23.4.4.1

809

c(cid:13) ISO/IEC

N4296

template <class M>

template <class M>

template <class M>

pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);

iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);

iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);

erase(const_iterator position);

iterator
size_type erase(const key_type& x);
iterator
void swap(map&)

erase(const_iterator first, const_iterator last);

noexcept(allocator_traits<Allocator>::is_always_equal::value &&

noexcept(swap(declval<Compare&>(),declval<Compare&>())));

void clear() noexcept;

// observers:
key_compare
value_compare value_comp() const;

key_comp() const;

// map operations:
iterator
const_iterator find(const key_type& x) const;
template <class K> iterator
template <class K> const_iterator find(const K& x) const;

find(const key_type& x);

find(const K& x);

size_type
template <class K> size_type count(const K& x) const;

count(const key_type& x) const;

lower_bound(const key_type& x);

iterator
const_iterator lower_bound(const key_type& x) const;
template <class K> iterator
template <class K> const_iterator lower_bound(const K& x) const;

lower_bound(const K& x);

upper_bound(const key_type& x);

iterator
const_iterator upper_bound(const key_type& x) const;
template <class K> iterator
template <class K> const_iterator upper_bound(const K& x) const;

upper_bound(const K& x);

pair<iterator,iterator>

equal_range(const key_type& x);

pair<const_iterator,const_iterator>

equal_range(const key_type& x) const;

template <class K>

pair<iterator, iterator>

template <class K>

pair<const_iterator, const_iterator> equal_range(const K& x) const;

};

equal_range(const K& x);

template <class Key, class T, class Compare, class Allocator>

bool operator==(const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);

template <class Key, class T, class Compare, class Allocator>

bool operator< (const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);

template <class Key, class T, class Compare, class Allocator>

§ 23.4.4.1

810

c(cid:13) ISO/IEC

N4296

bool operator!=(const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);

template <class Key, class T, class Compare, class Allocator>

bool operator> (const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);

template <class Key, class T, class Compare, class Allocator>

bool operator>=(const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);

template <class Key, class T, class Compare, class Allocator>

bool operator<=(const map<Key,T,Compare,Allocator>& x,
const map<Key,T,Compare,Allocator>& y);

// specialized algorithms:
template <class Key, class T, class Compare, class Allocator>

void swap(map<Key,T,Compare,Allocator>& x,
map<Key,T,Compare,Allocator>& y)

noexcept(noexcept(x.swap(y)));

}

23.4.4.2 map constructors, copy, and assignment
explicit map(const Compare& comp,

const Allocator& = Allocator());

Eﬀects: Constructs an empty map using the speciﬁed comparison object and allocator.
Complexity: Constant.

[map.cons]

template <class InputIterator>

map(InputIterator first, InputIterator last,

const Compare& comp = Compare(), const Allocator& = Allocator());
Requires: If the iterator’s indirection operator returns an lvalue or a const rvalue pair<key_type,
mapped_type>, then both key_type and mapped_type shall be CopyInsertable into *this.
Eﬀects: Constructs an empty map using the speciﬁed comparison object and allocator, and inserts
elements from the range [first,last).
Complexity: Linear in N if the range [first,last) is already sorted using comp and otherwise N log N,
where N is last - first.
23.4.4.3 map element access
T& operator[](const key_type& x);

[map.access]

Eﬀects: If there is no key equivalent to x in the map, inserts value_type(x, T()) into the map.
Requires: key_type shall be CopyInsertable and mapped_type shall be DefaultInsertable into
*this.
Returns: A reference to the mapped_type corresponding to x in *this.
Complexity: Logarithmic.

T& operator[](key_type&& x);

Eﬀects: If there is no key equivalent to x in the map, inserts value_type(std::move(x), T()) into
the map.
Requires: mapped_type shall be DefaultInsertable into *this.
Returns: A reference to the mapped_type corresponding to x in *this.

§ 23.4.4.3

811

1

2

3

4

5

1

2

3

4

5

6

7

c(cid:13) ISO/IEC

Complexity: Logarithmic.

T&
const T& at(const key_type& x) const;

at(const key_type& x);

N4296

Returns: A reference to the mapped_type corresponding to x in *this.
Throws: An exception object of type out_of_range if no such element is present.
Complexity: Logarithmic.

23.4.4.4 map modiﬁers
template <class P> pair<iterator, bool> insert(P&& x);
template <class P> iterator insert(const_iterator position, P&& x);
template <class InputIterator>

void insert(InputIterator first, InputIterator last);

[map.modiﬁers]

Eﬀects: The ﬁrst form is equivalent to return emplace(std::forward<P>(x)). The second form is
equivalent to return emplace_hint(position, std::forward<P>(x)).
Remarks: These signatures shall not participate in overload resolution unless std::is_constructible<value_-
type, P&&>::value is true.

template <class... Args> pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
template <class... Args> pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
template <class... Args> iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
template <class... Args> iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);

Eﬀects: If the key k already exists in the map, there is no eﬀect. Otherwise, inserts an element into the
map. In the ﬁrst and third forms, the element is constructed from the arguments as value_type(k,
std::forward<Args>(args)...). In the second and fourth forms, the element is constructed from
the arguments as value_type(std::move(k), std::forward<Args>(args)...).
In the ﬁrst two
overloads, the bool component of the returned pair is true if and only if the insertion took place. The
returned iterator points to the element of the map whose key is equivalent to k.
Complexity: The same as emplace and emplace_hint, respectively.

template <class M> pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
template <class M> pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
template <class M> iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
template <class M> iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);

Eﬀects: If the key k does not exist in the map, inserts an element into the map. In the ﬁrst and third
forms, the element is constructed from the arguments as value_type(k, std::forward<Args>(args)...).
In the second and fourth forms, the element is constructed from the arguments as value_type(std::move(k),
std::forward<Args>(args)...). If the key already exists, std::forward<M>(obj) is assigned to the
mapped_type corresponding to the key. In the ﬁrst two overloads, the bool component of the returned
value is true if and only if the insertion took place. The returned iterator points to the element that
was inserted or updated.
Complexity: The same as emplace and emplace_hint, respectively.

8

9

10

11

1

2

3

4

5

6

23.4.4.5 map specialized algorithms
template <class Key, class T, class Compare, class Allocator>

void swap(map<Key,T,Compare,Allocator>& x,
map<Key,T,Compare,Allocator>& y)

noexcept(noexcept(x.swap(y)));

§ 23.4.4.5

[map.special]

812

c(cid:13) ISO/IEC

1

Eﬀects:

x.swap(y);

N4296

23.4.5 Class template multimap
23.4.5.1 Class template multimap overview

[multimap]
[multimap.overview]
1 A multimap is an associative container that supports equivalent keys (possibly containing multiple copies
of the same key value) and provides for fast retrieval of values of another type T based on the keys. The
multimap class supports bidirectional iterators.

2 A multimap satisﬁes all of the requirements of a container and of a reversible container (23.2), of an asso-
ciative container (23.2.4), and of an allocator-aware container (Table 99). A multimap also provides most
operations described in (23.2.4) for equal keys. This means that a multimap supports the a_eq operations
in (23.2.4) but not the a_uniq operations. For a multimap<Key,T> the key_type is Key and the value_-
type is pair<const Key,T>. Descriptions are provided here only for operations on multimap that are not
described in one of those tables or for operations where there is additional semantic information.

template <class Key, class T, class Compare = less<Key>,

class Allocator = allocator<pair<const Key, T> > >

namespace std {

class multimap {
public:

// types:
typedef Key
typedef T
typedef pair<const Key,T>
typedef Compare
typedef Allocator
typedef value_type&
typedef const value_type&
typedef implementation-defined
typedef implementation-defined
typedef implementation-defined
typedef implementation-defined
typedef typename allocator_traits<Allocator>::pointer
typedef typename allocator_traits<Allocator>::const_pointer
typedef std::reverse_iterator<iterator>
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

key_type;
mapped_type;
value_type;
key_compare;
allocator_type;
reference;
const_reference;
// see 23.2
iterator;
const_iterator; // see 23.2
// see 23.2
size_type;
difference_type;// see 23.2
pointer;
const_pointer;

reverse_iterator;

class value_compare {
friend class multimap;
protected:

Compare comp;
value_compare(Compare c) : comp(c) { }

public:

typedef bool result_type;
typedef value_type first_argument_type;
typedef value_type second_argument_type;
bool operator()(const value_type& x, const value_type& y) const {

return comp(x.first, y.first);

}

};

// construct/copy/destroy:
multimap() : multimap(Compare()) { }

§ 23.4.5.1

813

c(cid:13) ISO/IEC

N4296

explicit multimap(const Compare& comp,

const Allocator& = Allocator());

template <class InputIterator>

multimap(InputIterator first, InputIterator last,

const Compare& comp = Compare(),
const Allocator& = Allocator());

multimap(const multimap& x);
multimap(multimap&& x);
explicit multimap(const Allocator&);
multimap(const multimap&, const Allocator&);
multimap(multimap&&, const Allocator&);
multimap(initializer_list<value_type>,

const Compare& = Compare(),
const Allocator& = Allocator());

template <class InputIterator>
multimap(InputIterator first, InputIterator last, const Allocator& a)

: multimap(first, last, Compare(), a) { }

multimap(initializer_list<value_type> il, const Allocator& a)

: multimap(il, Compare(), a) { }

~multimap();
multimap& operator=(const multimap& x);
multimap& operator=(multimap&& x)

noexcept(allocator_traits<Allocator>::is_always_equal::value &&

is_nothrow_move_assignable<Compare>::value);

multimap& operator=(initializer_list<value_type>);
allocator_type get_allocator() const noexcept;

// iterators:
iterator
const_iterator
iterator
const_iterator

begin() noexcept;
begin() const noexcept;
end() noexcept;
end() const noexcept;

reverse_iterator
const_reverse_iterator rbegin() const noexcept;
reverse_iterator
const_reverse_iterator rend() const noexcept;

rbegin() noexcept;

rend() noexcept;

const_iterator
const_iterator
const_reverse_iterator crbegin() const noexcept;
const_reverse_iterator crend() const noexcept;

cbegin() const noexcept;
cend() const noexcept;

// capacity:
bool
size_type
size_type

empty() const noexcept;
size() const noexcept;
max_size() const noexcept;

// modiﬁers:
template <class... Args> iterator emplace(Args&&... args);
template <class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
iterator insert(const value_type& x);
iterator insert(value_type&& x);
template <class P> iterator insert(P&& x);
iterator insert(const_iterator position, const value_type& x);

§ 23.4.5.1

814

c(cid:13) ISO/IEC

N4296

iterator insert(const_iterator position, value_type&& x);
template <class P> iterator insert(const_iterator position, P&& x);
template <class InputIterator>

void insert(InputIterator first, InputIterator last);

void insert(initializer_list<value_type>);

erase(const_iterator position);

iterator
size_type erase(const key_type& x);
iterator
void swap(multimap&)

erase(const_iterator first, const_iterator last);

noexcept(allocator_traits<Allocator>::is_always_equal::value &&

noexcept(swap(declval<Compare&>(),declval<Compare&>())));

void clear() noexcept;

// observers:
key_compare
value_compare

key_comp() const;
value_comp() const;

// map operations:
iterator
const_iterator find(const key_type& x) const;
template <class K> iterator
template <class K> const_iterator find(const K& x) const;

find(const key_type& x);

find(const K& x);

size_type
template <class K> size_type count(const K& x) const;

count(const key_type& x) const;

lower_bound(const key_type& x);

iterator
const_iterator lower_bound(const key_type& x) const;
template <class K> iterator
template <class K> const_iterator lower_bound(const K& x) const;

lower_bound(const K& x);

upper_bound(const key_type& x);

iterator
const_iterator upper_bound(const key_type& x) const;
template <class K> iterator
template <class K> const_iterator upper_bound(const K& x) const;

upper_bound(const K& x);

pair<iterator,iterator>

equal_range(const key_type& x);

pair<const_iterator,const_iterator>

equal_range(const key_type& x) const;

template <class K>

pair<iterator, iterator>

template <class K>

equal_range(const K& x);

pair<const_iterator, const_iterator> equal_range(const K& x) const;

};

template <class Key, class T, class Compare, class Allocator>
bool operator==(const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);
template <class Key, class T, class Compare, class Allocator>
bool operator< (const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);
template <class Key, class T, class Compare, class Allocator>
bool operator!=(const multimap<Key,T,Compare,Allocator>& x,

§ 23.4.5.1

815

c(cid:13) ISO/IEC

N4296

const multimap<Key,T,Compare,Allocator>& y);
template <class Key, class T, class Compare, class Allocator>
bool operator> (const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);
template <class Key, class T, class Compare, class Allocator>
bool operator>=(const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);
template <class Key, class T, class Compare, class Allocator>
bool operator<=(const multimap<Key,T,Compare,Allocator>& x,
const multimap<Key,T,Compare,Allocator>& y);

// specialized algorithms:
template <class Key, class T, class Compare, class Allocator>

void swap(multimap<Key,T,Compare,Allocator>& x,
multimap<Key,T,Compare,Allocator>& y)

noexcept(noexcept(x.swap(y)));

}

23.4.5.2 multimap constructors
explicit multimap(const Compare& comp,

const Allocator& = Allocator());

[multimap.cons]

Eﬀects: Constructs an empty multimap using the speciﬁed comparison object and allocator.
Complexity: Constant.

template <class InputIterator>

multimap(InputIterator first, InputIterator last,

const Compare& comp = Compare(),
const Allocator& = Allocator());

Requires: If the iterator’s indirection operator returns an lvalue or a const rvalue pair<key_type,
mapped_type>, then both key_type and mapped_type shall be CopyInsertable into *this.
Eﬀects: Constructs an empty multimap using the speciﬁed comparison object and allocator, and inserts
elements from the range [first,last).
Complexity: Linear in N if the range [first,last) is already sorted using comp and otherwise N log N,
where N is last - first.
23.4.5.3 multimap modiﬁers
template <class P> iterator insert(P&& x);
template <class P> iterator insert(const_iterator position, P&& x);

[multimap.modiﬁers]

Eﬀects: The ﬁrst form is equivalent to return emplace(std::forward<P>(x)). The second form is
equivalent to return emplace_hint(position, std::forward<P>(x)).
Remarks: These signatures shall not participate in overload resolution unless std::is_constructible<value_-
type, P&&>::value is true.

23.4.5.4 multimap specialized algorithms
template <class Key, class T, class Compare, class Allocator>

void swap(multimap<Key,T,Compare,Allocator>& x,
multimap<Key,T,Compare,Allocator>& y)

noexcept(noexcept(x.swap(y)));
Eﬀects:

[multimap.special]

§ 23.4.5.4

816

1

2

3

4

5

1

2

1

c(cid:13) ISO/IEC

x.swap(y);

N4296

23.4.6 Class template set
23.4.6.1 Class template set overview

[set]
[set.overview]
1 A set is an associative container that supports unique keys (contains at most one of each key value) and

provides for fast retrieval of the keys themselves. The set class supports bidirectional iterators.

2 A set satisﬁes all of the requirements of a container, of a reversible container (23.2), of an associative
container (23.2.4), and of an allocator-aware container (Table 99). A set also provides most operations
described in (23.2.4) for unique keys. This means that a set supports the a_uniq operations in (23.2.4) but
not the a_eq operations. For a set<Key> both the key_type and value_type are Key. Descriptions are
provided here only for operations on set that are not described in one of these tables and for operations
where there is additional semantic information.

namespace std {

template <class Key, class Compare = less<Key>,

class Allocator = allocator<Key> >

class set {
public:

// types:
typedef Key
typedef Key
typedef Compare
typedef Compare
typedef Allocator
typedef value_type&
typedef const value_type&
typedef implementation-defined
typedef implementation-defined
typedef implementation-defined
typedef implementation-defined
typedef typename allocator_traits<Allocator>::pointer
typedef typename allocator_traits<Allocator>::const_pointer
typedef std::reverse_iterator<iterator>
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

key_type;
value_type;
key_compare;
value_compare;
allocator_type;
reference;
const_reference;
// See 23.2
iterator;
const_iterator; // See 23.2
// See 23.2
size_type;
difference_type;// See 23.2
pointer;
const_pointer;

reverse_iterator;

const Compare& comp = Compare(), const Allocator& = Allocator());

// 23.4.6.2, construct/copy/destroy:
set() : set(Compare()) { }
explicit set(const Compare& comp,

const Allocator& = Allocator());

template <class InputIterator>

set(InputIterator first, InputIterator last,

set(const set& x);
set(set&& x);
explicit set(const Allocator&);
set(const set&, const Allocator&);
set(set&&, const Allocator&);
set(initializer_list<value_type>,

const Compare& = Compare(),
const Allocator& = Allocator());

template <class InputIterator>
set(InputIterator first, InputIterator last, const Allocator& a)

: set(first, last, Compare(), a) { }

set(initializer_list<value_type> il, const Allocator& a)

§ 23.4.6.1

817

c(cid:13) ISO/IEC

N4296

: set(il, Compare(), a) { }

~set();
set& operator=(const set& x);
set& operator=(set&& x)

noexcept(allocator_traits<Allocator>::is_always_equal::value &&

is_nothrow_move_assignable<Compare>::value);

set& operator=(initializer_list<value_type>);
allocator_type get_allocator() const noexcept;

// iterators:
iterator
const_iterator
iterator
const_iterator

begin() noexcept;
begin() const noexcept;
end() noexcept;
end() const noexcept;

reverse_iterator
const_reverse_iterator rbegin() const noexcept;
reverse_iterator
const_reverse_iterator rend() const noexcept;

rbegin() noexcept;

rend() noexcept;

const_iterator
const_iterator
const_reverse_iterator crbegin() const noexcept;
const_reverse_iterator crend() const noexcept;

cbegin() const noexcept;
cend() const noexcept;

// capacity:
bool
size_type
size_type

empty() const noexcept;
size() const noexcept;
max_size() const noexcept;

// modiﬁers:
template <class... Args> pair<iterator, bool> emplace(Args&&... args);
template <class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
pair<iterator,bool> insert(const value_type& x);
pair<iterator,bool> insert(value_type&& x);
iterator insert(const_iterator position, const value_type& x);
iterator insert(const_iterator position, value_type&& x);
template <class InputIterator>

void insert(InputIterator first, InputIterator last);

void insert(initializer_list<value_type>);

erase(const_iterator position);

iterator
size_type erase(const key_type& x);
iterator
void swap(set&)

erase(const_iterator first, const_iterator last);

noexcept(allocator_traits<Allocator>::is_always_equal::value &&

noexcept(swap(declval<Compare&>(),declval<Compare&>())));

void clear() noexcept;

// observers:
key_compare
value_compare value_comp() const;

key_comp() const;

// set operations:
iterator

find(const key_type& x);

§ 23.4.6.1

818

c(cid:13) ISO/IEC

N4296

const_iterator
template <class K> iterator
template <class K> const_iterator find(const K& x) const;

find(const key_type& x) const;

find(const K& x);

size_type count(const key_type& x) const;
template <class K> size_type count(const K& x) const;

iterator
const_iterator
template <class K> iterator
template <class K> const_iterator lower_bound(const K& x) const;

lower_bound(const key_type& x);
lower_bound(const key_type& x) const;

lower_bound(const K& x);

iterator
const_iterator
template <class K> iterator
template <class K> const_iterator upper_bound(const K& x) const;

upper_bound(const key_type& x);
upper_bound(const key_type& x) const;

upper_bound(const K& x);

pair<iterator,iterator>
pair<const_iterator,const_iterator> equal_range(const key_type& x) const;
template <class K>

equal_range(const key_type& x);

equal_range(const K& x);

pair<const_iterator, const_iterator> equal_range(const K& x) const;

pair<iterator, iterator>

template <class K>

};

template <class Key, class Compare, class Allocator>

bool operator==(const set<Key,Compare,Allocator>& x,
const set<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

bool operator< (const set<Key,Compare,Allocator>& x,
const set<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

bool operator!=(const set<Key,Compare,Allocator>& x,
const set<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

bool operator> (const set<Key,Compare,Allocator>& x,
const set<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

bool operator>=(const set<Key,Compare,Allocator>& x,
const set<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

bool operator<=(const set<Key,Compare,Allocator>& x,
const set<Key,Compare,Allocator>& y);

// specialized algorithms:
template <class Key, class Compare, class Allocator>

void swap(set<Key,Compare,Allocator>& x,
set<Key,Compare,Allocator>& y)

noexcept(noexcept(x.swap(y)));

}

23.4.6.2 set constructors, copy, and assignment
explicit set(const Compare& comp,

const Allocator& = Allocator());

§ 23.4.6.2

[set.cons]

819

c(cid:13) ISO/IEC

N4296

Eﬀects: Constructs an empty set using the speciﬁed comparison objects and allocator.
Complexity: Constant.

template <class InputIterator>

set(InputIterator first, InputIterator last,

const Compare& comp = Compare(), const Allocator& = Allocator());
Eﬀects: Constructs an empty set using the speciﬁed comparison object and allocator, and inserts
elements from the range [first,last).
Requires: If the iterator’s indirection operator returns an lvalue or a non-const rvalue, then Key shall
be CopyInsertable into *this.
Complexity: Linear in N if the range [first,last) is already sorted using comp and otherwise N log N,
where N is last - first.

23.4.6.3 set specialized algorithms
template <class Key, class Compare, class Allocator>

void swap(set<Key,Compare,Allocator>& x,
set<Key,Compare,Allocator>& y)

noexcept(noexcept(x.swap(y)));
Eﬀects:

[set.special]

1

2

3

4

5

1

x.swap(y);

23.4.7 Class template multiset
23.4.7.1 Class template multiset overview

[multiset]
[multiset.overview]
1 A multiset is an associative container that supports equivalent keys (possibly contains multiple copies of
the same key value) and provides for fast retrieval of the keys themselves. The multiset class supports
bidirectional iterators.

2 A multiset satisﬁes all of the requirements of a container, of a reversible container (23.2), of an associative
container (23.2.4), and of an allocator-aware container (Table 99). multiset also provides most opera-
tions described in (23.2.4) for duplicate keys. This means that a multiset supports the a_eq operations
in (23.2.4) but not the a_uniq operations. For a multiset<Key> both the key_type and value_type are
Key. Descriptions are provided here only for operations on multiset that are not described in one of these
tables and for operations where there is additional semantic information.

namespace std {

template <class Key, class Compare = less<Key>,

class Allocator = allocator<Key> >

class multiset {
public:

// types:
typedef Key
typedef Key
typedef Compare
typedef Compare
typedef Allocator
typedef value_type&
typedef const value_type&
typedef implementation-defined
typedef implementation-defined
typedef implementation-defined
typedef implementation-defined

key_type;
value_type;
key_compare;
value_compare;
allocator_type;
reference;
const_reference;

// see 23.2
iterator;
const_iterator; // see 23.2
// see 23.2
size_type;
difference_type;// see 23.2

§ 23.4.7.1

820

c(cid:13) ISO/IEC

N4296

typedef typename allocator_traits<Allocator>::pointer
typedef typename allocator_traits<Allocator>::const_pointer
typedef std::reverse_iterator<iterator>
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

reverse_iterator;

pointer;
const_pointer;

// construct/copy/destroy:
multiset() : multiset(Compare()) { }
explicit multiset(const Compare& comp,

const Allocator& = Allocator());

template <class InputIterator>

multiset(InputIterator first, InputIterator last,

const Compare& comp = Compare(),
const Allocator& = Allocator());

multiset(const multiset& x);
multiset(multiset&& x);
explicit multiset(const Allocator&);
multiset(const multiset&, const Allocator&);
multiset(multiset&&, const Allocator&);
multiset(initializer_list<value_type>,

const Compare& = Compare(),
const Allocator& = Allocator());

template <class InputIterator>
multiset(InputIterator first, InputIterator last, const Allocator& a)

: multiset(first, last, Compare(), a) { }

multiset(initializer_list<value_type> il, const Allocator& a)

: multiset(il, Compare(), a) { }

~multiset();
multiset& operator=(const multiset& x);
multiset& operator=(multiset&& x)

noexcept(allocator_traits<Allocator>::is_always_equal::value &&

is_nothrow_move_assignable<Compare>::value);

multiset& operator=(initializer_list<value_type>);
allocator_type get_allocator() const noexcept;

// iterators:
iterator
const_iterator
iterator
const_iterator

begin() noexcept;
begin() const noexcept;
end() noexcept;
end() const noexcept;

reverse_iterator
const_reverse_iterator rbegin() const noexcept;
reverse_iterator
const_reverse_iterator rend() const noexcept;

rbegin() noexcept;

rend() noexcept;

const_iterator
const_iterator
const_reverse_iterator crbegin() const noexcept;
const_reverse_iterator crend() const noexcept;

cbegin() const noexcept;
cend() const noexcept;

// capacity:
bool
size_type
size_type

empty() const noexcept;
size() const noexcept;
max_size() const noexcept;

§ 23.4.7.1

821

c(cid:13) ISO/IEC

N4296

// modiﬁers:
template <class... Args> iterator emplace(Args&&... args);
template <class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
iterator insert(const value_type& x);
iterator insert(value_type&& x);
iterator insert(const_iterator position, const value_type& x);
iterator insert(const_iterator position, value_type&& x);
template <class InputIterator>

void insert(InputIterator first, InputIterator last);

void insert(initializer_list<value_type>);

erase(const_iterator position);

iterator
size_type erase(const key_type& x);
iterator
void swap(multiset&)

erase(const_iterator first, const_iterator last);

noexcept(allocator_traits<Allocator>::is_always_equal::value &&

noexcept(swap(declval<Compare&>(),declval<Compare&>())));

void clear() noexcept;

// observers:
key_compare
value_compare value_comp() const;

key_comp() const;

// set operations:
iterator
const_iterator
template <class K> iterator
template <class K> const_iterator find(const K& x) const;

find(const key_type& x);
find(const key_type& x) const;

find(const K& x);

size_type count(const key_type& x) const;
template <class K> size_type count(const K& x) const;

iterator
const_iterator
template <class K> iterator
template <class K> const_iterator lower_bound(const K& x) const;

lower_bound(const key_type& x);
lower_bound(const key_type& x) const;

lower_bound(const K& x);

iterator
const_iterator
template <class K> iterator
template <class K> const_iterator upper_bound(const K& x) const;

upper_bound(const key_type& x);
upper_bound(const key_type& x) const;

upper_bound(const K& x);

pair<iterator,iterator>
pair<const_iterator,const_iterator> equal_range(const key_type& x) const;
template <class K>

equal_range(const key_type& x);

equal_range(const K& x);

pair<iterator, iterator>

template <class K>

pair<const_iterator, const_iterator> equal_range(const K& x) const;

};

template <class Key, class Compare, class Allocator>

bool operator==(const multiset<Key,Compare,Allocator>& x,
const multiset<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

bool operator< (const multiset<Key,Compare,Allocator>& x,

§ 23.4.7.1

822

c(cid:13) ISO/IEC

N4296

const multiset<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

bool operator!=(const multiset<Key,Compare,Allocator>& x,
const multiset<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

bool operator> (const multiset<Key,Compare,Allocator>& x,
const multiset<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

bool operator>=(const multiset<Key,Compare,Allocator>& x,
const multiset<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>

bool operator<=(const multiset<Key,Compare,Allocator>& x,
const multiset<Key,Compare,Allocator>& y);

// specialized algorithms:
template <class Key, class Compare, class Allocator>

void swap(multiset<Key,Compare,Allocator>& x,
multiset<Key,Compare,Allocator>& y)

noexcept(noexcept(x.swap(y)));

}

23.4.7.2 multiset constructors
explicit multiset(const Compare& comp,

const Allocator& = Allocator());

[multiset.cons]

Eﬀects: Constructs an empty set using the speciﬁed comparison object and allocator.
Complexity: Constant.

template <class InputIterator>

multiset(InputIterator first, InputIterator last,

const Compare& comp = Compare(), const Allocator& = Allocator());

Requires: If the iterator’s indirection operator returns an lvalue or a const rvalue, then Key shall be
CopyInsertable into *this.
Eﬀects: Constructs an empty multiset using the speciﬁed comparison object and allocator, and inserts
elements from the range [first,last).
Complexity: Linear in N if the range [first,last) is already sorted using comp and otherwise N log N,
where N is last - first.

23.4.7.3 multiset specialized algorithms
template <class Key, class Compare, class Allocator>

void swap(multiset<Key,Compare,Allocator>& x,
multiset<Key,Compare,Allocator>& y)

noexcept(noexcept(x.swap(y)));
Eﬀects:

[multiset.special]

1

2

3

4

5

1

x.swap(y);

23.5 Unordered associative containers
23.5.1 In general

[unord]
[unord.general]
1 The header <unordered_map> deﬁnes the class templates unordered_map and unordered_multimap; the

header <unordered_set> deﬁnes the class templates unordered_set and unordered_multiset.

§ 23.5.1

823

c(cid:13) ISO/IEC

N4296

23.5.2 Header <unordered_map> synopsis

[unord.map.syn]

#include <initializer_list>

namespace std {

// 23.5.4, class template unordered_map:
template <class Key,

class T,
class Hash = hash<Key>,
class Pred = std::equal_to<Key>,
class Alloc = std::allocator<std::pair<const Key, T> > >

class unordered_map;

// 23.5.5, class template unordered_multimap:
template <class Key,

class T,
class Hash = hash<Key>,
class Pred = std::equal_to<Key>,
class Alloc = std::allocator<std::pair<const Key, T> > >

class unordered_multimap;

template <class Key, class T, class Hash, class Pred, class Alloc>

void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,
unordered_map<Key, T, Hash, Pred, Alloc>& y)

noexcept(noexcept(x.swap(y)));

template <class Key, class T, class Hash, class Pred, class Alloc>

void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
unordered_multimap<Key, T, Hash, Pred, Alloc>& y)

noexcept(noexcept(x.swap(y)));

template <class Key, class T, class Hash, class Pred, class Alloc>

bool operator==(const unordered_map<Key, T, Hash, Pred, Alloc>& a,
const unordered_map<Key, T, Hash, Pred, Alloc>& b);

template <class Key, class T, class Hash, class Pred, class Alloc>

bool operator!=(const unordered_map<Key, T, Hash, Pred, Alloc>& a,
const unordered_map<Key, T, Hash, Pred, Alloc>& b);

template <class Key, class T, class Hash, class Pred, class Alloc>

bool operator==(const unordered_multimap<Key, T, Hash, Pred, Alloc>& a,
const unordered_multimap<Key, T, Hash, Pred, Alloc>& b);

template <class Key, class T, class Hash, class Pred, class Alloc>

bool operator!=(const unordered_multimap<Key, T, Hash, Pred, Alloc>& a,
const unordered_multimap<Key, T, Hash, Pred, Alloc>& b);

} // namespace std

23.5.3 Header <unordered_set> synopsis

[unord.set.syn]

#include <initializer_list>

namespace std {

// 23.5.6, class template unordered_set:
template <class Key,

class Hash = hash<Key>,
class Pred = std::equal_to<Key>,

§ 23.5.3

824

c(cid:13) ISO/IEC

N4296

class Alloc = std::allocator<Key> >

class unordered_set;

// 23.5.7, class template unordered_multiset:
template <class Key,

class Hash = hash<Key>,
class Pred = std::equal_to<Key>,
class Alloc = std::allocator<Key> >

class unordered_multiset;

template <class Key, class Hash, class Pred, class Alloc>

void swap(unordered_set<Key, Hash, Pred, Alloc>& x,
unordered_set<Key, Hash, Pred, Alloc>& y)

noexcept(noexcept(x.swap(y)));

template <class Key, class Hash, class Pred, class Alloc>
void swap(unordered_multiset<Key, Hash, Pred, Alloc>& x,
unordered_multiset<Key, Hash, Pred, Alloc>& y)

noexcept(noexcept(x.swap(y)));

template <class Key, class Hash, class Pred, class Alloc>

bool operator==(const unordered_set<Key, Hash, Pred, Alloc>& a,
const unordered_set<Key, Hash, Pred, Alloc>& b);

template <class Key, class Hash, class Pred, class Alloc>

bool operator!=(const unordered_set<Key, Hash, Pred, Alloc>& a,
const unordered_set<Key, Hash, Pred, Alloc>& b);

template <class Key, class Hash, class Pred, class Alloc>

bool operator==(const unordered_multiset<Key, Hash, Pred, Alloc>& a,
const unordered_multiset<Key, Hash, Pred, Alloc>& b);

template <class Key, class Hash, class Pred, class Alloc>

bool operator!=(const unordered_multiset<Key, Hash, Pred, Alloc>& a,
const unordered_multiset<Key, Hash, Pred, Alloc>& b);

} // namespace std

23.5.4 Class template unordered_map
23.5.4.1 Class template unordered_map overview

[unord.map]
[unord.map.overview]
1 An unordered_map is an unordered associative container that supports unique keys (an unordered_map
contains at most one of each key value) and that associates values of another type mapped_type with the
keys. The unordered_map class supports forward iterators.

2 An unordered_map satisﬁes all of the requirements of a container, of an unordered associative container, and
of an allocator-aware container (Table 99). It provides the operations described in the preceding requirements
table for unique keys; that is, an unordered_map supports the a_uniq operations in that table, not the a_eq
operations. For an unordered_map<Key, T> the key type is Key, the mapped type is T, and the value type
is std::pair<const Key, T>.

3 This section only describes operations on unordered_map that are not described in one of the requirement

tables, or for which there is additional semantic information.

namespace std {

template <class Key,

class T,
class Hash
class Pred
class Allocator = std::allocator<std::pair<const Key, T> > >

= hash<Key>,
= std::equal_to<Key>,

§ 23.5.4.1

825

c(cid:13) ISO/IEC

N4296

class unordered_map
{
public:

// types
typedef Key
typedef std::pair<const Key, T>
typedef T
typedef Hash
typedef Pred
typedef Allocator
typedef typename allocator_traits<Allocator>::pointer
typedef typename allocator_traits<Allocator>::const_pointer const_pointer;
typedef value_type&
typedef const value_type&
typedef implementation-defined
typedef implementation-defined

key_type;
value_type;
mapped_type;
hasher;
key_equal;
allocator_type;
pointer;

reference;
const_reference;
size_type;
difference_type;

typedef implementation-defined
typedef implementation-defined
typedef implementation-defined
typedef implementation-defined

iterator;
const_iterator;
local_iterator;
const_local_iterator;

// construct/destroy/copy
unordered_map();
explicit unordered_map(size_type n,

const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

template <class InputIterator>

unordered_map(InputIterator f, InputIterator l,

size_type n = see below ,
const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

unordered_map(const unordered_map&);
unordered_map(unordered_map&&);
explicit unordered_map(const Allocator&);
unordered_map(const unordered_map&, const Allocator&);
unordered_map(unordered_map&&, const Allocator&);
unordered_map(initializer_list<value_type> il,

size_type n = see below ,
const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

unordered_map(size_type n, const allocator_type& a)
: unordered_map(n, hasher(), key_equal(), a) { }

unordered_map(size_type n, const hasher& hf, const allocator_type& a)

: unordered_map(n, hf, key_equal(), a) { }

template <class InputIterator>

unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
: unordered_map(f, l, n, hasher(), key_equal(), a) { }

template <class InputIterator>

unordered_map(InputIterator f, InputIterator l, size_type n, const hasher& hf,
const allocator_type& a)
: unordered_map(f, l, n, hf, key_equal(), a) { }

§ 23.5.4.1

826

c(cid:13) ISO/IEC

N4296

unordered_map(initializer_list<value_type> il, size_type n, const allocator_type& a)

: unordered_map(il, n, hasher(), key_equal(), a) { }

unordered_map(initializer_list<value_type> il, size_type n, const hasher& hf,
const allocator_type& a)

: unordered_map(il, n, hf, key_equal(), a) { }

~unordered_map();
unordered_map& operator=(const unordered_map&);
unordered_map& operator=(unordered_map&&)

noexcept(allocator_traits<Allocator>::is_always_equal::value &&

is_nothrow_move_assignable<Hash>::value &&
is_nothrow_move_assignable<Pred>::value);

unordered_map& operator=(initializer_list<value_type>);
allocator_type get_allocator() const noexcept;

// size and capacity
bool empty() const noexcept;
size_type size() const noexcept;
size_type max_size() const noexcept;

begin() noexcept;

// iterators
iterator
const_iterator begin() const noexcept;
iterator
const_iterator end() const noexcept;
const_iterator cbegin() const noexcept;
const_iterator cend() const noexcept;

end() noexcept;

// modiﬁers
template <class... Args> pair<iterator, bool> emplace(Args&&... args);
template <class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
pair<iterator, bool> insert(const value_type& obj);
pair<iterator, bool> insert(value_type&& obj);
template <class P> pair<iterator, bool> insert(P&& obj);
iterator
iterator
template <class P> iterator insert(const_iterator hint, P&& obj);
template <class InputIterator> void insert(InputIterator first, InputIterator last);
void insert(initializer_list<value_type>);

insert(const_iterator hint, const value_type& obj);
insert(const_iterator hint, value_type&& obj);

pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);

pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);

iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);

iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);

template <class... Args>

template <class... Args>

template <class... Args>

template <class... Args>

template <class M>

template <class M>

template <class M>

template <class M>

pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);

pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);

iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);

iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);

§ 23.5.4.1

827

c(cid:13) ISO/IEC

N4296

iterator erase(const_iterator position);
size_type erase(const key_type& k);
iterator erase(const_iterator first, const_iterator last);
void clear() noexcept;

void swap(unordered_map&)

noexcept(allocator_traits<Allocator>::is_always_equal::value &&

noexcept(swap(declval<Hash&>(),declval<Hash&>())) &&
noexcept(swap(declval<Pred&>(),declval<Pred&>())));

// observers
hasher hash_function() const;
key_equal key_eq() const;

find(const key_type& k);

// lookup
iterator
const_iterator find(const key_type& k) const;
size_type count(const key_type& k) const;
std::pair<iterator, iterator>
std::pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

equal_range(const key_type& k);

mapped_type& operator[](const key_type& k);
mapped_type& operator[](key_type&& k);
mapped_type& at(const key_type& k);
const mapped_type& at(const key_type& k) const;

// bucket interface
size_type bucket_count() const noexcept;
size_type max_bucket_count() const noexcept;
size_type bucket_size(size_type n) const;
size_type bucket(const key_type& k) const;
local_iterator begin(size_type n);
const_local_iterator begin(size_type n) const;
local_iterator end(size_type n);
const_local_iterator end(size_type n) const;
const_local_iterator cbegin(size_type n) const;
const_local_iterator cend(size_type n) const;

// hash policy
float load_factor() const noexcept;
float max_load_factor() const noexcept;
void max_load_factor(float z);
void rehash(size_type n);
void reserve(size_type n);

};

template <class Key, class T, class Hash, class Pred, class Alloc>

void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,
unordered_map<Key, T, Hash, Pred, Alloc>& y)

noexcept(noexcept(x.swap(y)));

template <class Key, class T, class Hash, class Pred, class Alloc>

bool operator==(const unordered_map<Key, T, Hash, Pred, Alloc>& a,
const unordered_map<Key, T, Hash, Pred, Alloc>& b);

§ 23.5.4.1

828

c(cid:13) ISO/IEC

N4296

template <class Key, class T, class Hash, class Pred, class Alloc>

bool operator!=(const unordered_map<Key, T, Hash, Pred, Alloc>& a,
const unordered_map<Key, T, Hash, Pred, Alloc>& b);

}

23.5.4.2 unordered_map constructors
unordered_map() : unordered_map(size_type(see below )) { }
explicit unordered_map(size_type n,

const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

[unord.map.cnstr]

Eﬀects: Constructs an empty unordered_map using the speciﬁed hash function, key equality function,
and allocator, and using at least n buckets. For the default constructor, the number of buckets is
implementation-deﬁned. max_load_factor() returns 1.0.
Complexity: Constant.

template <class InputIterator>

unordered_map(InputIterator f, InputIterator l,

unordered_map(initializer_list<value_type> il,

size_type n = see below ,
const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

size_type n = see below ,
const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

Eﬀects: Constructs an empty unordered_map using the speciﬁed hash function, key equality func-
tion, and allocator, and using at least n buckets.
If n is not provided, the number of buckets is
implementation-deﬁned. Then inserts elements from the range [f,l) for the ﬁrst form, or from the
range [il.begin(),il.end()) for the second form. max_load_factor() returns 1.0.
Complexity: Average case linear, worst case quadratic.

23.5.4.3 unordered_map element access
mapped_type& operator[](const key_type& k);
mapped_type& operator[](key_type&& k);

[unord.map.elem]

Requires: mapped_type shall be DefaultInsertable into *this. For the ﬁrst operator, key_type shall
be CopyInsertable into *this. For the second operator, key_type shall be MoveConstructible.
Eﬀects: If the unordered_map does not already contain an element whose key is equivalent to k , the
ﬁrst operator inserts the value value_type(k, mapped_type()) and the second operator inserts the
value value_type(std::move(k), mapped_type()).
Returns: A reference to x.second, where x is the (unique) element whose key is equivalent to k .
Complexity: Average case O(1), worst case O(size()).

mapped_type& at(const key_type& k);
const mapped_type& at(const key_type& k) const;

Returns: A reference to x.second, where x is the (unique) element whose key is equivalent to k.
Throws: An exception object of type out_of_range if no such element is present.

§ 23.5.4.3

829

1

2

3

4

1

2

3

4

5

6

c(cid:13) ISO/IEC

23.5.4.4 unordered_map modiﬁers
template <class P>

pair<iterator, bool> insert(P&& obj);

N4296

[unord.map.modiﬁers]

Eﬀects: Equivalent to return emplace(std::forward<P>(obj)).
Remarks: This signature shall not participate in overload resolution unless std::is_constructible<value_-
type, P&&>::value is true.

template <class P>

iterator insert(const_iterator hint, P&& obj);

Eﬀects: Equivalent to return emplace_hint(hint, std::forward<P>(obj)).
Remarks: This signature shall not participate in overload resolution unless std::is_constructible<value_-
type, P&&>::value is true.

template <class... Args> pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
template <class... Args> pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
template <class... Args> iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
template <class... Args> iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);

Eﬀects: If the key k already exists in the map, there is no eﬀect. Otherwise, inserts an element into the
map. In the ﬁrst and third forms, the element is constructed from the arguments as value_type(k,
std::forward<Args>(args)...). In the second and fourth forms, the element is constructed from
the arguments as value_type(std::move(k), std::forward<Args>(args)...).
In the ﬁrst two
overloads, the bool component of the returned pair is true if and only if the insertion took place. The
returned iterator points to the element of the map whose key is equivalent to k.
Complexity: The same as emplace and emplace_hint, respectively.

template <class M> pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
template <class M> pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
template <class M> iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
template <class M> iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);

Eﬀects: If the key k does not exist in the map, inserts an element into the map. In the ﬁrst and third
forms, the element is constructed from the arguments as value_type(k, std::forward<Args>(args)...).
In the second and fourth forms, the element is constructed from the arguments as value_type(std::move(k),
std::forward<Args>(args)...). If the key already exists, std::forward<M>(obj) is assigned to the
mapped_type corresponding to the key. In the ﬁrst two overloads, the bool component of the returned
value is true if and only if the insertion took place. The returned iterator points to the element that
was inserted or updated.
Complexity: The same as emplace and emplace_hint, respectively.

23.5.4.5 unordered_map swap
template <class Key, class T, class Hash, class Pred, class Alloc>

void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,
unordered_map<Key, T, Hash, Pred, Alloc>& y)

noexcept(noexcept(x.swap(y)));
Eﬀects: x.swap(y).

[unord.map.swap]

1

2

3

4

5

6

7

8

1

§ 23.5.4.5

830

c(cid:13) ISO/IEC

N4296

23.5.5 Class template unordered_multimap
23.5.5.1 Class template unordered_multimap overview

[unord.multimap]
[unord.multimap.overview]
1 An unordered_multimap is an unordered associative container that supports equivalent keys (an instance of
unordered_multimap may contain multiple copies of each key value) and that associates values of another
type mapped_type with the keys. The unordered_multimap class supports forward iterators.

2 An unordered_multimap satisﬁes all of the requirements of a container, of an unordered associative con-
tainer, and of an allocator-aware container (Table 99). It provides the operations described in the preceding
requirements table for equivalent keys; that is, an unordered_multimap supports the a_eq operations in
that table, not the a_uniq operations. For an unordered_multimap<Key, T> the key type is Key, the
mapped type is T, and the value type is std::pair<const Key, T>.

3 This section only describes operations on unordered_multimap that are not described in one of the require-

ment tables, or for which there is additional semantic information.

namespace std {

template <class Key,

class unordered_multimap
{
public:

class T,
class Hash
class Pred
class Allocator = std::allocator<std::pair<const Key, T> > >

= hash<Key>,
= std::equal_to<Key>,

// types
typedef Key
typedef std::pair<const Key, T>
typedef T
typedef Hash
typedef Pred
typedef Allocator
typedef typename allocator_traits<Allocator>::pointer
typedef typename allocator_traits<Allocator>::const_pointer const_pointer;
typedef value_type&
typedef const value_type&
typedef implementation-defined
typedef implementation-defined

key_type;
value_type;
mapped_type;
hasher;
key_equal;
allocator_type;
pointer;

reference;
const_reference;
size_type;
difference_type;

typedef implementation-defined
typedef implementation-defined
typedef implementation-defined
typedef implementation-defined

iterator;
const_iterator;
local_iterator;
const_local_iterator;

// construct/destroy/copy
unordered_multimap();
explicit unordered_multimap(size_type n,

const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

template <class InputIterator>

unordered_multimap(InputIterator f, InputIterator l,

size_type n = see below ,
const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

§ 23.5.5.1

831

c(cid:13) ISO/IEC

N4296

unordered_multimap(const unordered_multimap&);
unordered_multimap(unordered_multimap&&);
explicit unordered_multimap(const Allocator&);
unordered_multimap(const unordered_multimap&, const Allocator&);
unordered_multimap(unordered_multimap&&, const Allocator&);
unordered_multimap(initializer_list<value_type> il,

size_type n = see below ,
const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

unordered_multimap(size_type n, const allocator_type& a)
: unordered_multimap(n, hasher(), key_equal(), a) { }

unordered_multimap(size_type n, const hasher& hf, const allocator_type& a)

: unordered_multimap(n, hf, key_equal(), a) { }

template <class InputIterator>

unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
: unordered_multimap(f, l, n, hasher(), key_equal(), a) { }

template <class InputIterator>

unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher& hf,
const allocator_type& a)
: unordered_multimap(f, l, n, hf, key_equal(), a) { }

unordered_multimap(initializer_list<value_type> il, size_type n, const allocator_type& a)

: unordered_multimap(il, n, hasher(), key_equal(), a) { }

unordered_multimap(initializer_list<value_type> il, size_type n, const hasher& hf,
const allocator_type& a)

: unordered_multimap(il, n, hf, key_equal(), a) { }

~unordered_multimap();
unordered_multimap& operator=(const unordered_multimap&);
unordered_multimap& operator=(unordered_multimap&&)

noexcept(allocator_traits<Allocator>::is_always_equal::value &&

is_nothrow_move_assignable<Hash>::value &&
is_nothrow_move_assignable<Pred>::value);

unordered_multimap& operator=(initializer_list<value_type>);
allocator_type get_allocator() const noexcept;

// size and capacity
bool empty() const noexcept;
size_type size() const noexcept;
size_type max_size() const noexcept;

begin() noexcept;

// iterators
iterator
const_iterator begin() const noexcept;
iterator
const_iterator end() const noexcept;
const_iterator cbegin() const noexcept;
const_iterator cend() const noexcept;

end() noexcept;

// modiﬁers
template <class... Args> iterator emplace(Args&&... args);
template <class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
iterator insert(const value_type& obj);
iterator insert(value_type&& obj);
template <class P> iterator insert(P&& obj);
iterator insert(const_iterator hint, const value_type& obj);

§ 23.5.5.1

832

c(cid:13) ISO/IEC

N4296

iterator insert(const_iterator hint, value_type&& obj);
template <class P> iterator insert(const_iterator hint, P&& obj);
template <class InputIterator> void insert(InputIterator first, InputIterator last);
void insert(initializer_list<value_type>);

iterator erase(const_iterator position);
size_type erase(const key_type& k);
iterator erase(const_iterator first, const_iterator last);
void clear() noexcept;

void swap(unordered_multimap&)

noexcept(allocator_traits<Allocator>::is_always_equal::value &&

noexcept(swap(declval<Hash&>(),declval<Hash&>())) &&
noexcept(swap(declval<Pred&>(),declval<Pred&>())));

// observers
hasher hash_function() const;
key_equal key_eq() const;

find(const key_type& k);

// lookup
iterator
const_iterator find(const key_type& k) const;
size_type count(const key_type& k) const;
std::pair<iterator, iterator>
std::pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

equal_range(const key_type& k);

// bucket interface
size_type bucket_count() const noexcept;
size_type max_bucket_count() const noexcept;
size_type bucket_size(size_type n) const;
size_type bucket(const key_type& k) const;
local_iterator begin(size_type n);
const_local_iterator begin(size_type n) const;
local_iterator end(size_type n);
const_local_iterator end(size_type n) const;
const_local_iterator cbegin(size_type n) const;
const_local_iterator cend(size_type n) const;

// hash policy
float load_factor() const noexcept;
float max_load_factor() const noexcept;
void max_load_factor(float z);
void rehash(size_type n);
void reserve(size_type n);

};

template <class Key, class T, class Hash, class Pred, class Alloc>

void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
unordered_multimap<Key, T, Hash, Pred, Alloc>& y)

noexcept(noexcept(x.swap(y)));

template <class Key, class T, class Hash, class Pred, class Alloc>

bool operator==(const unordered_multimap<Key, T, Hash, Pred, Alloc>& a,
const unordered_multimap<Key, T, Hash, Pred, Alloc>& b);

template <class Key, class T, class Hash, class Pred, class Alloc>

§ 23.5.5.1

833

c(cid:13) ISO/IEC

N4296

bool operator!=(const unordered_multimap<Key, T, Hash, Pred, Alloc>& a,
const unordered_multimap<Key, T, Hash, Pred, Alloc>& b);

}

23.5.5.2 unordered_multimap constructors
unordered_multimap() : unordered_multimap(size_type(see below )) { }
explicit unordered_multimap(size_type n,

const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

[unord.multimap.cnstr]

Eﬀects: Constructs an empty unordered_multimap using the speciﬁed hash function, key equality
function, and allocator, and using at least n buckets. For the default constructor, the number of
buckets is implementation-deﬁned. max_load_factor() returns 1.0.
Complexity: Constant.

template <class InputIterator>

unordered_multimap(InputIterator f, InputIterator l,

unordered_multimap(InputIterator f, InputIterator l,

size_type n = see below ,
const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

size_type n = see below ,
const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

Eﬀects: Constructs an empty unordered_multimap using the speciﬁed hash function, key equality
function, and allocator, and using at least n buckets. If n is not provided, the number of buckets is
implementation-deﬁned. Then inserts elements from the range [f,l) for the ﬁrst form, or from the
range [il.begin(),il.end()) for the second form. max_load_factor() returns 1.0.
Complexity: Average case linear, worst case quadratic.

23.5.5.3 unordered_multimap modiﬁers
template <class P>

iterator insert(P&& obj);

[unord.multimap.modiﬁers]

Eﬀects: Equivalent to return emplace(std::forward<P>(obj)).
Remarks: This signature shall not participate in overload resolution unless std::is_constructible<value_-
type, P&&>::value is true.

template <class P>

iterator insert(const_iterator hint, P&& obj);

Eﬀects: Equivalent to return emplace_hint(hint, std::forward<P>(obj)).
Remarks: This signature shall not participate in overload resolution unless std::is_constructible<value_-
type, P&&>::value is true.

23.5.5.4 unordered_multimap swap
template <class Key, class T, class Hash, class Pred, class Alloc>

void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
unordered_multimap<Key, T, Hash, Pred, Alloc>& y)

noexcept(noexcept(x.swap(y)));

[unord.multimap.swap]

§ 23.5.5.4

834

1

2

3

4

1

2

3

4

c(cid:13) ISO/IEC

1

Eﬀects: x.swap(y).

N4296

23.5.6 Class template unordered_set
23.5.6.1 Class template unordered_set overview

[unord.set]
[unord.set.overview]
1 An unordered_set is an unordered associative container that supports unique keys (an unordered_set
contains at most one of each key value) and in which the elements’ keys are the elements themselves. The
unordered_set class supports forward iterators.

2 An unordered_set satisﬁes all of the requirements of a container, of an unordered associative container, and
of an allocator-aware container (Table 99). It provides the operations described in the preceding requirements
table for unique keys; that is, an unordered_set supports the a_uniq operations in that table, not the a_eq
operations. For an unordered_set<Key> the key type and the value type are both Key. The iterator and
const_iterator types are both const iterator types. It is unspeciﬁed whether they are the same type.

3 This section only describes operations on unordered_set that are not described in one of the requirement

tables, or for which there is additional semantic information.

namespace std {

template <class Key,
class Hash
class Pred
class Allocator = std::allocator<Key> >

= hash<Key>,
= std::equal_to<Key>,

class unordered_set
{
public:

// types
typedef Key
typedef Key
typedef Hash
typedef Pred
typedef Allocator
typedef typename allocator_traits<Allocator>::pointer
typedef typename allocator_traits<Allocator>::const_pointer const_pointer;
typedef value_type&
typedef const value_type&
typedef implementation-defined
typedef implementation-defined

key_type;
value_type;
hasher;
key_equal;
allocator_type;
pointer;

reference;
const_reference;
size_type;
difference_type;

typedef implementation-defined
typedef implementation-defined
typedef implementation-defined
typedef implementation-defined

iterator;
const_iterator;
local_iterator;
const_local_iterator;

// construct/destroy/copy
unordered_set();
explicit unordered_set(size_type n,

const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

template <class InputIterator>

unordered_set(InputIterator f, InputIterator l,

size_type n = see below ,
const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

§ 23.5.6.1

835

c(cid:13) ISO/IEC

N4296

unordered_set(const unordered_set&);
unordered_set(unordered_set&&);
explicit unordered_set(const Allocator&);
unordered_set(const unordered_set&, const Allocator&);
unordered_set(unordered_set&&, const Allocator&);
unordered_set(initializer_list<value_type> il,

size_type n = see below ,
const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

unordered_set(size_type n, const allocator_type& a)
: unordered_set(n, hasher(), key_equal(), a) { }

unordered_set(size_type n, const hasher& hf, const allocator_type& a)

: unordered_set(n, hf, key_equal(), a) { }

template <class InputIterator>

unordered_set(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
: unordered_set(f, l, n, hasher(), key_equal(), a) { }

template <class InputIterator>

unordered_set(InputIterator f, InputIterator l, size_type n, const hasher& hf,
const allocator_type& a)
: unordered_set(f, l, n, hf, key_equal(), a) { }

unordered_set(initializer_list<value_type> il, size_type n, const allocator_type& a)

: unordered_set(il, n, hasher(), key_equal(), a) { }

unordered_set(initializer_list<value_type> il, size_type n, const hasher& hf,
const allocator_type& a)

: unordered_set(il, n, hf, key_equal(), a) { }

~unordered_set();
unordered_set& operator=(const unordered_set&);
unordered_set& operator=(unordered_set&&)

noexcept(allocator_traits<Allocator>::is_always_equal::value &&

is_nothrow_move_assignable<Hash>::value &&
is_nothrow_move_assignable<Pred>::value);

unordered_set& operator=(initializer_list<value_type>);
allocator_type get_allocator() const noexcept;

// size and capacity
bool empty() const noexcept;
size_type size() const noexcept;
size_type max_size() const noexcept;

begin() noexcept;

// iterators
iterator
const_iterator begin() const noexcept;
iterator
const_iterator end() const noexcept;
const_iterator cbegin() const noexcept;
const_iterator cend() const noexcept;

end() noexcept;

// modiﬁers
template <class... Args> pair<iterator, bool> emplace(Args&&... args);
template <class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
pair<iterator, bool> insert(const value_type& obj);
pair<iterator, bool> insert(value_type&& obj);
iterator insert(const_iterator hint, const value_type& obj);
iterator insert(const_iterator hint, value_type&& obj);

§ 23.5.6.1

836

c(cid:13) ISO/IEC

N4296

template <class InputIterator> void insert(InputIterator first, InputIterator last);
void insert(initializer_list<value_type>);

iterator erase(const_iterator position);
size_type erase(const key_type& k);
iterator erase(const_iterator first, const_iterator last);
void clear() noexcept;

void swap(unordered_set&)

noexcept(allocator_traits<Allocator>::is_always_equal::value &&

noexcept(swap(declval<Hash&>(),declval<Hash&>())) &&
noexcept(swap(declval<Pred&>(),declval<Pred&>())));

// observers
hasher hash_function() const;
key_equal key_eq() const;

find(const key_type& k);

// lookup
iterator
const_iterator find(const key_type& k) const;
size_type count(const key_type& k) const;
std::pair<iterator, iterator>
std::pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

equal_range(const key_type& k);

// bucket interface
size_type bucket_count() const noexcept;
size_type max_bucket_count() const noexcept;
size_type bucket_size(size_type n) const;
size_type bucket(const key_type& k) const;
local_iterator begin(size_type n);
const_local_iterator begin(size_type n) const;
local_iterator end(size_type n);
const_local_iterator end(size_type n) const;
const_local_iterator cbegin(size_type n) const;
const_local_iterator cend(size_type n) const;

// hash policy
float load_factor() const noexcept;
float max_load_factor() const noexcept;
void max_load_factor(float z);
void rehash(size_type n);
void reserve(size_type n);

};

template <class Key, class Hash, class Pred, class Alloc>

void swap(unordered_set<Key, Hash, Pred, Alloc>& x,
unordered_set<Key, Hash, Pred, Alloc>& y)

noexcept(noexcept(x.swap(y)));

template <class Key, class Hash, class Pred, class Alloc>

bool operator==(const unordered_set<Key, Hash, Pred, Alloc>& a,
const unordered_set<Key, Hash, Pred, Alloc>& b);

template <class Key, class Hash, class Pred, class Alloc>

bool operator!=(const unordered_set<Key, Hash, Pred, Alloc>& a,
const unordered_set<Key, Hash, Pred, Alloc>& b);

§ 23.5.6.1

837

c(cid:13) ISO/IEC

}

23.5.6.2 unordered_set constructors
unordered_set() : unordered_set(size_type(see below )) { }
explicit unordered_set(size_type n,

const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

N4296

[unord.set.cnstr]

Eﬀects: Constructs an empty unordered_set using the speciﬁed hash function, key equality function,
and allocator, and using at least n buckets. For the default constructor, the number of buckets is
implementation-deﬁned. max_load_factor() returns 1.0.
Complexity: Constant.

template <class InputIterator>

unordered_set(InputIterator f, InputIterator l,

unordered_set(initializer_list<value_type> il,

size_type n = see below ,
const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

size_type n = see below ,
const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

1

2

3

4

1

Eﬀects: Constructs an empty unordered_set using the speciﬁed hash function, key equality func-
tion, and allocator, and using at least n buckets.
If n is not provided, the number of buckets is
implementation-deﬁned. Then inserts elements from the range [f,l) for the ﬁrst form, or from the
range [il.begin(),il.end()) for the second form. max_load_factor() returns 1.0.
Complexity: Average case linear, worst case quadratic.

23.5.6.3 unordered_set swap
template <class Key, class Hash, class Pred, class Alloc>

void swap(unordered_set<Key, Hash, Pred, Alloc>& x,
unordered_set<Key, Hash, Pred, Alloc>& y)

noexcept(noexcept(x.swap(y)));
Eﬀects: x.swap(y).

[unord.set.swap]

23.5.7 Class template unordered_multiset
23.5.7.1 Class template unordered_multiset overview

[unord.multiset]
[unord.multiset.overview]
1 An unordered_multiset is an unordered associative container that supports equivalent keys (an instance
of unordered_multiset may contain multiple copies of the same key value) and in which each element’s
key is the element itself. The unordered_multiset class supports forward iterators.

2 An unordered_multiset satisﬁes all of the requirements of a container, of an unordered associative con-
tainer, and of an allocator-aware container (Table 99). It provides the operations described in the preceding
requirements table for equivalent keys; that is, an unordered_multiset supports the a_eq operations in
that table, not the a_uniq operations. For an unordered_multiset<Key> the key type and the value type
are both Key. The iterator and const_iterator types are both const iterator types. It is unspeciﬁed
whether they are the same type.

§ 23.5.7.1

838

c(cid:13) ISO/IEC

N4296

3 This section only describes operations on unordered_multiset that are not described in one of the require-

ment tables, or for which there is additional semantic information.

namespace std {

template <class Key,
class Hash
class Pred
class Allocator = std::allocator<Key> >

= hash<Key>,
= std::equal_to<Key>,

class unordered_multiset
{
public:

// types
typedef Key
typedef Key
typedef Hash
typedef Pred
typedef Allocator
typedef typename allocator_traits<Allocator>::pointer
typedef typename allocator_traits<Allocator>::const_pointer const_pointer;
typedef value_type&
typedef const value_type&
typedef implementation-defined
typedef implementation-defined

key_type;
value_type;
hasher;
key_equal;
allocator_type;
pointer;

reference;
const_reference;
size_type;
difference_type;

typedef implementation-defined
typedef implementation-defined
typedef implementation-defined
typedef implementation-defined

iterator;
const_iterator;
local_iterator;
const_local_iterator;

// construct/destroy/copy
unordered_multiset();
explicit unordered_multiset(size_type n,

const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

template <class InputIterator>

unordered_multiset(InputIterator f, InputIterator l,

size_type n = see below ,
const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

unordered_multiset(const unordered_multiset&);
unordered_multiset(unordered_multiset&&);
explicit unordered_multiset(const Allocator&);
unordered_multiset(const unordered_multiset&, const Allocator&);
unordered_multiset(unordered_multiset&&, const Allocator&);
unordered_multiset(initializer_list<value_type> il,

size_type n = see below ,
const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

unordered_multiset(size_type n, const allocator_type& a)
: unordered_multiset(n, hasher(), key_equal(), a) { }

unordered_multiset(size_type n, const hasher& hf, const allocator_type& a)

: unordered_multiset(n, hf, key_equal(), a) { }

template <class InputIterator>

§ 23.5.7.1

839

c(cid:13) ISO/IEC

N4296

unordered_multiset(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
: unordered_multiset(f, l, n, hasher(), key_equal(), a) { }

template <class InputIterator>

unordered_multiset(InputIterator f, InputIterator l, size_type n, const hasher& hf,
const allocator_type& a)
: unordered_multiset(f, l, n, hf, key_equal(), a) { }

unordered_multiset(initializer_list<value_type> il, size_type n, const allocator_type& a)

: unordered_multiset(il, n, hasher(), key_equal(), a) { }

unordered_multiset(initializer_list<value_type> il, size_type n, const hasher& hf,
const allocator_type& a)

: unordered_multiset(il, n, hf, key_equal(), a) { }

~unordered_multiset();
unordered_multiset& operator=(const unordered_multiset&);
unordered_multiset& operator=(unordered_multiset&&)

noexcept(allocator_traits<Allocator>::is_always_equal::value &&

is_nothrow_move_assignable<Hash>::value &&
is_nothrow_move_assignable<Pred>::value);

unordered_multiset& operator=(initializer_list<value_type>);
allocator_type get_allocator() const noexcept;

// size and capacity
bool empty() const noexcept;
size_type size() const noexcept;
size_type max_size() const noexcept;

begin() noexcept;

// iterators
iterator
const_iterator begin() const noexcept;
iterator
const_iterator end() const noexcept;
const_iterator cbegin() const noexcept;
const_iterator cend() const noexcept;

end() noexcept;

// modiﬁers
template <class... Args> iterator emplace(Args&&... args);
template <class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
iterator insert(const value_type& obj);
iterator insert(value_type&& obj);
iterator insert(const_iterator hint, const value_type& obj);
iterator insert(const_iterator hint, value_type&& obj);
template <class InputIterator> void insert(InputIterator first, InputIterator last);
void insert(initializer_list<value_type>);

iterator erase(const_iterator position);
size_type erase(const key_type& k);
iterator erase(const_iterator first, const_iterator last);
void clear() noexcept;

void swap(unordered_multiset&)

noexcept(allocator_traits<Allocator>::is_always_equal::value &&

noexcept(swap(declval<Hash&>(),declval<Hash&>())) &&
noexcept(swap(declval<Pred&>(),declval<Pred&>())));

// observers
hasher hash_function() const;

§ 23.5.7.1

840

c(cid:13) ISO/IEC

key_equal key_eq() const;

N4296

find(const key_type& k);

// lookup
iterator
const_iterator find(const key_type& k) const;
size_type count(const key_type& k) const;
std::pair<iterator, iterator>
std::pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

equal_range(const key_type& k);

// bucket interface
size_type bucket_count() const noexcept;
size_type max_bucket_count() const noexcept;
size_type bucket_size(size_type n) const;
size_type bucket(const key_type& k) const;
local_iterator begin(size_type n);
const_local_iterator begin(size_type n) const;
local_iterator end(size_type n);
const_local_iterator end(size_type n) const;
const_local_iterator cbegin(size_type n) const;
const_local_iterator cend(size_type n) const;

// hash policy
float load_factor() const noexcept;
float max_load_factor() const noexcept;
void max_load_factor(float z);
void rehash(size_type n);
void reserve(size_type n);

};

template <class Key, class Hash, class Pred, class Alloc>
void swap(unordered_multiset<Key, Hash, Pred, Alloc>& x,
unordered_multiset<Key, Hash, Pred, Alloc>& y)

noexcept(noexcept(x.swap(y)));

template <class Key, class Hash, class Pred, class Alloc>

bool operator==(const unordered_multiset<Key, Hash, Pred, Alloc>& a,
const unordered_multiset<Key, Hash, Pred, Alloc>& b);

template <class Key, class Hash, class Pred, class Alloc>

bool operator!=(const unordered_multiset<Key, Hash, Pred, Alloc>& a,
const unordered_multiset<Key, Hash, Pred, Alloc>& b);

}

23.5.7.2 unordered_multiset constructors
unordered_multiset() : unordered_multiset(size_type(see below )) { }
explicit unordered_multiset(size_type n,

const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

[unord.multiset.cnstr]

1

2

Eﬀects: Constructs an empty unordered_multiset using the speciﬁed hash function, key equality
function, and allocator, and using at least n buckets. For the default constructor, the number of
buckets is implementation-deﬁned. max_load_factor() returns 1.0.
Complexity: Constant.

§ 23.5.7.2

841

c(cid:13) ISO/IEC

N4296

template <class InputIterator>

unordered_multiset(InputIterator f, InputIterator l,

unordered_multiset(initializer_list<value_type> il,

size_type n = see below ,
const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

size_type n = see below ,
const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());

3

4

1

Eﬀects: Constructs an empty unordered_multiset using the speciﬁed hash function, key equality
function, and allocator, and using at least n buckets. If n is not provided, the number of buckets is
implementation-deﬁned. Then inserts elements from the range [f,l) for the ﬁrst form, or from the
range [il.begin(),il.end()) for the second form. max_load_factor() returns 1.0.
Complexity: Average case linear, worst case quadratic.

23.5.7.3 unordered_multiset swap
template <class Key, class Hash, class Pred, class Alloc>
void swap(unordered_multiset<Key, Hash, Pred, Alloc>& x,
unordered_multiset<Key, Hash, Pred, Alloc>& y)

noexcept(noexcept(x.swap(y)));
Eﬀects: x.swap(y);

[unord.multiset.swap]

23.6 Container adaptors
23.6.1

In general

[container.adaptors]
[container.adaptors.general]

1 The headers <queue> and <stack> deﬁne the container adaptors queue, priority_queue, and stack.
2 The container adaptors each take a Container template parameter, and each constructor takes a Container
reference argument. This container is copied into the Container member of each adaptor. If the container
takes an allocator, then a compatible allocator may be passed in to the adaptor’s constructor. Otherwise,
normal copy or move construction is used for the container argument.

3 For container adaptors, no swap function throws an exception unless that exception is thrown by the swap

of the adaptor’s Container or Compare object (if any).
23.6.2 Header <queue> synopsis

[queue.syn]

#include <initializer_list>

namespace std {

template <class T, class Container = deque<T> > class queue;
template <class T, class Container = vector<T>,

class Compare = less<typename Container::value_type> >

class priority_queue;

template <class T, class Container>

bool operator==(const queue<T, Container>& x,const queue<T, Container>& y);

template <class T, class Container>

template <class T, class Container>

bool operator< (const queue<T, Container>& x,const queue<T, Container>& y);

bool operator!=(const queue<T, Container>& x,const queue<T, Container>& y);

§ 23.6.2

842

c(cid:13) ISO/IEC

N4296

template <class T, class Container>

template <class T, class Container>

template <class T, class Container>

bool operator> (const queue<T, Container>& x,const queue<T, Container>& y);

bool operator>=(const queue<T, Container>& x,const queue<T, Container>& y);

bool operator<=(const queue<T, Container>& x,const queue<T, Container>& y);

template <class T, class Container>

void swap(queue<T, Container>& x, queue<T, Container>& y) noexcept(noexcept(x.swap(y)));

template <class T, class Container, class Compare>

void swap(priority_queue<T, Container, Compare>& x,

priority_queue<T, Container, Compare>& y) noexcept(noexcept(x.swap(y)));

}

23.6.3 Class template queue
23.6.3.1 queue deﬁnition

[queue]
[queue.defn]
1 Any sequence container supporting operations front(), back(), push_back() and pop_front() can be

used to instantiate queue. In particular, list (23.3.5) and deque (23.3.3) can be used.

namespace std {

template <class T, class Container = deque<T> >
class queue {
public:

typedef typename Container::value_type
typedef typename Container::reference
typedef typename Container::const_reference
typedef typename Container::size_type
typedef
protected:

Container

Container c;

value_type;
reference;
const_reference;
size_type;
container_type;

public:

explicit queue(const Container&);
explicit queue(Container&& = Container());
template <class Alloc> explicit queue(const Alloc&);
template <class Alloc> queue(const Container&, const Alloc&);
template <class Alloc> queue(Container&&, const Alloc&);
template <class Alloc> queue(const queue&, const Alloc&);
template <class Alloc> queue(queue&&, const Alloc&);

empty() const
bool
size()
const
size_type
front()
reference
front() const
const_reference
back()
reference
back() const
const_reference
void push(const value_type& x)
void push(value_type&& x)
template <class... Args> void emplace(Args&&... args)

{ return c.empty(); }
{ return c.size(); }
{ return c.front(); }
{ return c.front(); }
{ return c.back(); }
{ return c.back(); }
{ c.push_back(x); }
{ c.push_back(std::move(x)); }

{ c.emplace_back(std::forward<Args>(args)...); }

void pop()
void swap(queue& q) noexcept(noexcept(swap(c, q.c)))

{ c.pop_front(); }

{ using std::swap; swap(c, q.c); }

};

§ 23.6.3.1

843

c(cid:13) ISO/IEC

N4296

template <class T, class Container>

template <class T, class Container>

template <class T, class Container>

template <class T, class Container>

bool operator==(const queue<T, Container>& x, const queue<T, Container>& y);

bool operator< (const queue<T, Container>& x, const queue<T, Container>& y);

bool operator!=(const queue<T, Container>& x, const queue<T, Container>& y);

bool operator> (const queue<T, Container>& x, const queue<T, Container>& y);

template <class T, class Container>

template <class T, class Container>

bool operator>=(const queue<T, Container>& x, const queue<T, Container>& y);

bool operator<=(const queue<T, Container>& x, const queue<T, Container>& y);

template <class T, class Container>

void swap(queue<T, Container>& x, queue<T, Container>& y) noexcept(noexcept(x.swap(y)));

template <class T, class Container, class Alloc>

struct uses_allocator<queue<T, Container>, Alloc>

: uses_allocator<Container, Alloc>::type { };

}

23.6.3.2 queue constructors
explicit queue(const Container& cont);

Eﬀects: Initializes c with cont.

[queue.cons]

explicit queue(Container&& cont = Container());
Eﬀects: Initializes c with std::move(cont).
23.6.3.3 queue constructors with allocators
[queue.cons.alloc]
If uses_allocator<container_type, Alloc>::value is false the constructors in this subclause shall not
participate in overload resolution.

template <class Alloc>

explicit queue(const Alloc& a);

Eﬀects: Initializes c with a.

template <class Alloc>

queue(const container_type& cont, const Alloc& a);

Eﬀects: Initializes c with cont as the ﬁrst argument and a as the second argument.

template <class Alloc>

queue(container_type&& cont, const Alloc& a);

Eﬀects: Initializes c with std::move(cont) as the ﬁrst argument and a as the second argument.

template <class Alloc>

queue(const queue& q, const Alloc& a);

Eﬀects: Initializes c with q.c as the ﬁrst argument and a as the second argument.

template <class Alloc>

queue(queue&& q, const Alloc& a);

Eﬀects: Initializes c with std::move(q.c) as the ﬁrst argument and a as the second argument.

§ 23.6.3.3

844

1

2

1

2

3

4

5

6

c(cid:13) ISO/IEC

23.6.3.4 queue operators
template <class T, class Container>

bool operator==(const queue<T, Container>& x,
const queue<T, Container>& y);

Returns: x.c == y.c.

template <class T, class Container>

bool operator!=(const queue<T, Container>& x,
const queue<T, Container>& y);

Returns: x.c != y.c.

template <class T, class Container>

bool operator< (const queue<T, Container>& x,
const queue<T, Container>& y);

Returns: x.c < y.c.

template <class T, class Container>

bool operator<=(const queue<T, Container>& x,
const queue<T, Container>& y);

Returns: x.c <= y.c.

template <class T, class Container>

bool operator> (const queue<T, Container>& x,
const queue<T, Container>& y);

Returns: x.c > y.c.

template <class T, class Container>

bool operator>=(const queue<T, Container>& x,
const queue<T, Container>& y);

Returns: x.c >= y.c.

23.6.3.5 queue specialized algorithms
template <class T, class Container>

Eﬀects: x.swap(y).

1

2

3

4

5

6

1

N4296

[queue.ops]

[queue.special]

void swap(queue<T, Container>& x, queue<T, Container>& y) noexcept(noexcept(x.swap(y)));

23.6.4 Class template priority_queue

[priority.queue]
1 Any sequence container with random access iterator and supporting operations front(), push_back() and
pop_back() can be used to instantiate priority_queue. In particular, vector (23.3.6) and deque (23.3.3)
can be used. Instantiating priority_queue also involves supplying a function or function object for mak-
ing priority comparisons; the library assumes that the function or function object deﬁnes a strict weak
ordering (25.4).

namespace std {

template <class T, class Container = vector<T>,

class Compare = less<typename Container::value_type> >

class priority_queue {
public:

typedef typename Container::value_type
typedef typename Container::reference

value_type;
reference;

§ 23.6.4

845

c(cid:13) ISO/IEC

N4296

typedef typename Container::const_reference
typedef typename Container::size_type
typedef
protected:

Container

Container c;
Compare comp;

const_reference;
size_type;
container_type;

public:

priority_queue(const Compare& x, const Container&);
explicit priority_queue(const Compare& x = Compare(), Container&& = Container());
template <class InputIterator>

priority_queue(InputIterator first, InputIterator last,

const Compare& x, const Container&);

template <class InputIterator>

priority_queue(InputIterator first, InputIterator last,

const Compare& x = Compare(), Container&& = Container());

template <class Alloc> explicit priority_queue(const Alloc&);
template <class Alloc> priority_queue(const Compare&, const Alloc&);
template <class Alloc> priority_queue(const Compare&,

const Container&, const Alloc&);

template <class Alloc> priority_queue(const Compare&,

Container&&, const Alloc&);

template <class Alloc> priority_queue(const priority_queue&, const Alloc&);
template <class Alloc> priority_queue(priority_queue&&, const Alloc&);

{ return c.empty(); }
empty() const
const
{ return c.size(); }
top() const { return c.front(); }

bool
size_type size()
const_reference
void push(const value_type& x);
void push(value_type&& x);
template <class... Args> void emplace(Args&&... args);
void pop();
void swap(priority_queue& q) noexcept(

noexcept(swap(c, q.c)) && noexcept(swap(comp, q.comp)))

{ using std::swap; swap(c, q.c); swap(comp, q.comp); }

};
// no equality is provided
template <class T, class Container, class Compare>

void swap(priority_queue<T, Container, Compare>& x,

priority_queue<T, Container, Compare>& y) noexcept(noexcept(x.swap(y)));

template <class T, class Container, class Compare, class Alloc>

struct uses_allocator<priority_queue<T, Container, Compare>, Alloc>

: uses_allocator<Container, Alloc>::type { };

}

23.6.4.1 priority_queue constructors
priority_queue(const Compare& x,

const Container& y);

explicit priority_queue(const Compare& x = Compare(),

Container&& y = Container());

[priqueue.cons]

1

2

Requires: x shall deﬁne a strict weak ordering (25.4).
Eﬀects: Initializes comp with x and c with y (copy constructing or move constructing as appropriate);

§ 23.6.4.1

846

c(cid:13) ISO/IEC

N4296

calls make_heap(c.begin(), c.end(), comp).

template <class InputIterator>

priority_queue(InputIterator first, InputIterator last,

const Compare& x,
const Container& y);

template <class InputIterator>

priority_queue(InputIterator first, InputIterator last,

const Compare& x = Compare(),
Container&& y = Container());

3

4

1

2

3

4

5

6

7

Requires: x shall deﬁne a strict weak ordering (25.4).
Eﬀects: Initializes comp with x and c with y (copy constructing or move constructing as appropriate);
calls c.insert(c.end(), first, last); and ﬁnally calls make_heap(c.begin(), c.end(), comp).
23.6.4.2 priority_queue constructors with allocators
[priqueue.cons.alloc]
If uses_allocator<container_type, Alloc>::value is false the constructors in this subclause shall not
participate in overload resolution.

template <class Alloc>

explicit priority_queue(const Alloc& a);

Eﬀects: Initializes c with a and value-initializes comp.

template <class Alloc>

priority_queue(const Compare& compare, const Alloc& a);

Eﬀects: Initializes c with a and initializes comp with compare.

template <class Alloc>

priority_queue(const Compare& compare, const Container& cont, const Alloc& a);

Eﬀects: Initializes c with cont as the ﬁrst argument and a as the second argument, and initializes comp
with compare.

template <class Alloc>

priority_queue(const Compare& compare, Container&& cont, const Alloc& a);

Eﬀects: Initializes c with std::move(cont) as the ﬁrst argument and a as the second argument, and
initializes comp with compare.

template <class Alloc>

priority_queue(const priority_queue& q, const Alloc& a);

Eﬀects: Initializes c with q.c as the ﬁrst argument and a as the second argument, and initializes comp
with q.comp.

template <class Alloc>

priority_queue(priority_queue&& q, const Alloc& a);

Eﬀects: Initializes c with std::move(q.c) as the ﬁrst argument and a as the second argument, and
initializes comp with std::move(q.comp).

§ 23.6.4.2

847

c(cid:13) ISO/IEC

23.6.4.3 priority_queue members
void push(const value_type& x);

Eﬀects:

c.push_back(x);
push_heap(c.begin(), c.end(), comp);

void push(value_type&& x);

Eﬀects:

c.push_back(std::move(x));
push_heap(c.begin(), c.end(), comp);

template <class... Args> void emplace(Args&&... args)

Eﬀects:

c.emplace_back(std::forward<Args>(args)...);
push_heap(c.begin(), c.end(), comp);

void pop();
Eﬀects:

pop_heap(c.begin(), c.end(), comp);
c.pop_back();

23.6.4.4 priority_queue specialized algorithms
template <class T, class Container, Compare>

void swap(priority_queue<T, Container, Compare>& x,

1

2

3

4

1

N4296

[priqueue.members]

[priqueue.special]

priority_queue<T, Container, Compare>& y) noexcept(noexcept(x.swap(y)));

Eﬀects: x.swap(y).

23.6.5 Class template stack

[stack]
1 Any sequence container supporting operations back(), push_back() and pop_back() can be used to in-

stantiate stack. In particular, vector (23.3.6), list (23.3.5) and deque (23.3.3) can be used.
23.6.5.1 Header <stack> synopsis

[stack.syn]

#include <initializer_list>

namespace std {

template <class T, class Container = deque<T> > class stack;
template <class T, class Container>

bool operator==(const stack<T, Container>& x,const stack<T, Container>& y);

template <class T, class Container>

bool operator< (const stack<T, Container>& x,const stack<T, Container>& y);

template <class T, class Container>

template <class T, class Container>

template <class T, class Container>

bool operator!=(const stack<T, Container>& x,const stack<T, Container>& y);

bool operator> (const stack<T, Container>& x,const stack<T, Container>& y);

bool operator>=(const stack<T, Container>& x,const stack<T, Container>& y);

§ 23.6.5.1

848

c(cid:13) ISO/IEC

N4296

template <class T, class Container>

template <class T, class Container>

bool operator<=(const stack<T, Container>& x,const stack<T, Container>& y);

void swap(stack<T, Container>& x, stack<T, Container>& y) noexcept(noexcept(x.swap(y)));

}

23.6.5.2 stack deﬁnition

[stack.defn]

namespace std {

template <class T, class Container = deque<T> >
class stack {
public:

typedef typename Container::value_type
typedef typename Container::reference
typedef typename Container::const_reference
typedef typename Container::size_type
typedef
protected:

Container

Container c;

value_type;
reference;
const_reference;
size_type;
container_type;

public:

explicit stack(const Container&);
explicit stack(Container&& = Container());
template <class Alloc> explicit stack(const Alloc&);
template <class Alloc> stack(const Container&, const Alloc&);
template <class Alloc> stack(Container&&, const Alloc&);
template <class Alloc> stack(const stack&, const Alloc&);
template <class Alloc> stack(stack&&, const Alloc&);

empty() const
bool
const
size_type size()
top()
reference
const_reference
top() const
void push(const value_type& x)
void push(value_type&& x)
template <class... Args> void emplace(Args&&... args)

{ return c.empty(); }
{ return c.size(); }
{ return c.back(); }
{ return c.back(); }
{ c.push_back(x); }
{ c.push_back(std::move(x)); }

{ c.emplace_back(std::forward<Args>(args)...); }

{ c.pop_back(); }
void pop()
void swap(stack& s) noexcept(noexcept(swap(c, s.c)))

{ using std::swap; swap(c, s.c); }

};

bool operator==(const stack<T, Container>& x, const stack<T, Container>& y);

bool operator< (const stack<T, Container>& x, const stack<T, Container>& y);

bool operator!=(const stack<T, Container>& x, const stack<T, Container>& y);

bool operator> (const stack<T, Container>& x, const stack<T, Container>& y);

template <class T, class Container>

template <class T, class Container>

template <class T, class Container>

template <class T, class Container>

template <class T, class Container>

template <class T, class Container>

template <class T, class Container>

bool operator>=(const stack<T, Container>& x, const stack<T, Container>& y);

bool operator<=(const stack<T, Container>& x, const stack<T, Container>& y);

void swap(stack<T, Container>& x, stack<T, Container>& y) noexcept(noexcept(x.swap(y)));

§ 23.6.5.2

849

c(cid:13) ISO/IEC

template <class T, class Container, class Alloc>

struct uses_allocator<stack<T, Container>, Alloc>

: uses_allocator<Container, Alloc>::type { };

}

23.6.5.3 stack constructors
explicit stack(const Container& cont);

Eﬀects: Initializes c with cont.

N4296

[stack.cons]

explicit stack(Container&& cont = Container());
Eﬀects: Initializes c with std::move(cont).
23.6.5.4 stack constructors with allocators
[stack.cons.alloc]
If uses_allocator<container_type, Alloc>::value is false the constructors in this subclause shall not
participate in overload resolution.

template <class Alloc>

explicit stack(const Alloc& a);

Eﬀects: Initializes c with a.

template <class Alloc>

stack(const container_type& cont, const Alloc& a);

Eﬀects: Initializes c with cont as the ﬁrst argument and a as the second argument.

template <class Alloc>

stack(container_type&& cont, const Alloc& a);

Eﬀects: Initializes c with std::move(cont) as the ﬁrst argument and a as the second argument.

template <class Alloc>

stack(const stack& s, const Alloc& a);

Eﬀects: Initializes c with s.c as the ﬁrst argument and a as the second argument.

template <class Alloc>

stack(stack&& s, const Alloc& a);

Eﬀects: Initializes c with std::move(s.c) as the ﬁrst argument and a as the second argument.

23.6.5.5 stack operators
template <class T, class Container>

bool operator==(const stack<T, Container>& x,
const stack<T, Container>& y);

Returns: x.c == y.c.

template <class T, class Container>

bool operator!=(const stack<T, Container>& x,
const stack<T, Container>& y);

Returns: x.c != y.c.

[stack.ops]

§ 23.6.5.5

850

1

2

1

2

3

4

5

6

1

2

3

4

5

6

1

c(cid:13) ISO/IEC

N4296

template <class T, class Container>

bool operator< (const stack<T, Container>& x,
const stack<T, Container>& y);

Returns: x.c < y.c.

template <class T, class Container>

bool operator<=(const stack<T, Container>& x,
const stack<T, Container>& y);

Returns: x.c <= y.c.

template <class T, class Container>

bool operator> (const stack<T, Container>& x,
const stack<T, Container>& y);

Returns: x.c > y.c.

template <class T, class Container>

bool operator>=(const stack<T, Container>& x,
const stack<T, Container>& y);

Returns: x.c >= y.c.

23.6.5.6 stack specialized algorithms
template <class T, class Container>

void swap(stack<T, Container>& x, stack<T, Container>& y) noexcept(noexcept(x.swap(y)));

[stack.special]

Eﬀects: x.swap(y).

§ 23.6.5.6

851

c(cid:13) ISO/IEC

N4296

24 Iterators library
24.1 General

[iterators]
[iterators.general]
1 This Clause describes components that C++ programs may use to perform iterations over containers (Clause

23), streams (27.7), and stream buﬀers (27.6).

2 The following subclauses describe iterator requirements, and components for iterator primitives, predeﬁned

iterators, and stream iterators, as summarized in Table 104.

Table 104 — Iterators library summary
Header(s)

<iterator>

Subclause
24.2 Requirements
24.4
Iterator primitives
24.5 Predeﬁned iterators
24.6

Stream iterators

1

In general

[iterator.requirements]
24.2 Iterator requirements
24.2.1
[iterator.requirements.general]
Iterators are a generalization of pointers that allow a C++ program to work with diﬀerent data structures
(containers) in a uniform manner. To be able to construct template algorithms that work correctly and
eﬃciently on diﬀerent types of data structures, the library formalizes not just the interfaces but also the
semantics and complexity assumptions of iterators. All input iterators i support the expression *i, resulting
in a value of some object type T, called the value type of the iterator. All output iterators support the
expression *i = o where o is a value of some type that is in the set of types that are writable to the
particular iterator type of i. All iterators i for which the expression (*i).m is well-deﬁned, support the
expression i->m with the same semantics as (*i).m. For every iterator type X for which equality is deﬁned,
there is a corresponding signed integer type called the diﬀerence type of the iterator.

2 Since iterators are an abstraction of pointers, their semantics is a generalization of most of the semantics
of pointers in C++. This ensures that every function template that takes iterators works as well with
regular pointers. This International Standard deﬁnes ﬁve categories of iterators, according to the operations
deﬁned on them: input iterators, output iterators, forward iterators, bidirectional iterators and random access
iterators, as shown in Table 105.

Table 105 — Relations among iterator categories

Random Access → Bidirectional → Forward → Input

→ Output

3 Forward iterators satisfy all the requirements of input iterators and can be used whenever an input iterator is
speciﬁed; Bidirectional iterators also satisfy all the requirements of forward iterators and can be used when-
ever a forward iterator is speciﬁed; Random access iterators also satisfy all the requirements of bidirectional
iterators and can be used whenever a bidirectional iterator is speciﬁed.
Iterators that further satisfy the requirements of output iterators are called mutable iterators. Nonmutable
iterators are referred to as constant iterators.

4

§ 24.2.1

852

c(cid:13) ISO/IEC

N4296

5

Iterators that further satisfy the requirement that, for integral values n and dereferenceable iterator values
a and (a + n), *(a + n) is equivalent to *(addressof(*a) + n), are called contiguous iterators.
[ Note:
For example, the type “pointer to int” is a contiguous iterator, but reverse_iterator<int *> is not.
For a valid iterator range [a,b) with dereferenceable a, the corresponding range denoted by pointers is
[addressof(*a),addressof(*a) + (b - a)); b might not be dereferenceable. — end note ]

6 Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element
of the array, so for any iterator type there is an iterator value that points past the last element of a
corresponding sequence. These values are called past-the-end values. Values of an iterator i for which the
expression *i is deﬁned are called dereferenceable. The library never assumes that past-the-end values are
dereferenceable. Iterators can also have singular values that are not associated with any sequence. [ Example:
After the declaration of an uninitialized pointer x (as with int* x;), x must always be assumed to have a
singular value of a pointer. — end example ] Results of most expressions are undeﬁned for singular values;
the only exceptions are destroying an iterator that holds a singular value, the assignment of a non-singular
value to an iterator that holds a singular value, and, for iterators that satisfy the DefaultConstructible
requirements, using a value-initialized iterator as the source of a copy or move operation.
[ Note: This
guarantee is not oﬀered for default initialization, although the distinction only matters for types with trivial
default constructors such as pointers or aggregates holding pointers. — end note ] In these cases the singular
value is overwritten the same way as any other value. Dereferenceable values are always non-singular.

7 An iterator j is called reachable from an iterator i if and only if there is a ﬁnite sequence of applications of
the expression ++i that makes i == j. If j is reachable from i, they refer to elements of the same sequence.
8 Most of the library’s algorithmic templates that operate on data structures have interfaces that use ranges.
A range is a pair of iterators that designate the beginning and end of the computation. A range [i,i) is an
empty range; in general, a range [i,j) refers to the elements in the data structure starting with the element
pointed to by i and up to but not including the element pointed to by j. Range [i,j) is valid if and only if
j is reachable from i. The result of the application of functions in the library to invalid ranges is undeﬁned.
9 All the categories of iterators require only those functions that are realizable for a given category in constant

time (amortized). Therefore, requirement tables for the iterators do not have a complexity column.

10 Destruction of an iterator may invalidate pointers and references previously obtained from that iterator.
11 An invalid iterator is an iterator that may be singular.267
12

In the following sections, a and b denote values of type X or const X, difference_type and reference refer
to the types iterator_traits<X>::difference_type and iterator_traits<X>::reference, respectively,
n denotes a value of difference_type, u, tmp, and m denote identiﬁers, r denotes a value of X&, t denotes
a value of value type T, o denotes a value of some type that is writable to the output iterator. [ Note: For
an iterator type X there must be an instantiation of iterator_traits<X> (24.4.1). — end note ]
24.2.2

[iterator.iterators]
1 The Iterator requirements form the basis of the iterator concept taxonomy; every iterator satisﬁes the
Iterator requirements. This set of requirements speciﬁes operations for dereferencing and incrementing an
iterator. Most algorithms will require additional operations to read (24.2.3) or write (24.2.4) values, or to
provide a richer set of iterator movements (24.2.5, 24.2.6, 24.2.7).)

Iterator

2 A type X satisﬁes the Iterator requirements if:

(2.1)

(2.2)

—

—

X satisﬁes the CopyConstructible, CopyAssignable, and Destructible requirements (17.6.3.1) and
lvalues of type X are swappable (17.6.3.2), and
the expressions in Table 106 are valid and have the indicated semantics.

267) This deﬁnition applies to pointers, since pointers are iterators. The eﬀect of dereferencing an iterator that has been
invalidated is undeﬁned.

§ 24.2.2

853

c(cid:13) ISO/IEC

N4296

Table 106 — Iterator requirements

Expression

Return type

*r
++r

reference
X&

Operational
semantics

Assertion/note

pre-/post-condition
pre: r is dereferenceable.

24.2.3

2

Input iterators

[input.iterators]
1 A class or pointer type X satisﬁes the requirements of an input iterator for the value type T if X satisﬁes the
Iterator (24.2.2) and EqualityComparable (Table 17) requirements and the expressions in Table 107 are
valid and have the indicated semantics.
In Table 107, the term the domain of == is used in the ordinary mathematical sense to denote the set of
values over which == is (required to be) deﬁned. This set can change over time. Each algorithm places
additional requirements on the domain of == for the iterator values it uses. These requirements can be
inferred from the uses that algorithm makes of == and !=. [ Example: the call find(a,b,x) is deﬁned only
if the value of a has the property p deﬁned as follows: b has property p and a value i has property p if
(*i==x) or if (*i!=x and ++i has property p). — end example ]

Table 107 — Input iterator requirements (in addition to Iterator)

Expression

Return type

a != b

*a

contextually
convertible to
bool
convertible to T

Operational
semantics

!(a == b)

a->m
++r

X&

(*a).m

(void)r++
*r++

convertible to T

{ T tmp = *r;
++r;
return tmp; }

Assertion/note

pre-/post-condition

pre: (a,b) is in the domain
of ==.

pre: a is dereferenceable.
The expression
(void)*a, *a is equivalent
to *a.
If a == b and (a,b) is in
the domain of == then *a is
equivalent to *b.
pre: a is dereferenceable.
pre: r is dereferenceable.
post: r is dereferenceable or
r is past-the-end.
post: any copies of the
previous value of r are no
longer required either to be
dereferenceable or to be in
the domain of ==.
equivalent to (void)++r

3

[ Note: For input iterators, a == b does not imply ++a == ++b. (Equality does not guarantee the substi-
tution property or referential transparency.) Algorithms on input iterators should never attempt to pass
through the same iterator twice. They should be single pass algorithms. Value type T is not required to be

§ 24.2.3

854

c(cid:13) ISO/IEC

N4296

a CopyAssignable type (Table 23). These algorithms can be used with istreams as the source of the input
data through the istream_iterator class template. — end note ]
24.2.4 Output iterators

[output.iterators]
1 A class or pointer type X satisﬁes the requirements of an output iterator if X satisﬁes the Iterator require-

ments (24.2.2) and the expressions in Table 108 are valid and have the indicated semantics.

Table 108 — Output iterator requirements (in addition to Iterator)

Expression

Return type

*r = o

result is not
used

Operational
semantics

++r

r++

X&

convertible to
const X&

{ X tmp = r;
++r;
return tmp; }

*r++ = o

result is not
used

Assertion/note

pre-/post-condition

Remark: After this operation
r is not required to be
dereferenceable.
post: r is incrementable.
&r == &++r.
Remark: After this operation
r is not required to be
dereferenceable.
post: r is incrementable.
Remark: After this operation
r is not required to be
dereferenceable.
post: r is incrementable.
Remark: After this operation
r is not required to be
dereferenceable.
post: r is incrementable.

2

[ Note: The only valid use of an operator* is on the left side of the assignment statement. Assignment
through the same value of the iterator happens only once. Algorithms on output iterators should never
attempt to pass through the same iterator twice. They should be single pass algorithms. Equality and
inequality might not be deﬁned. Algorithms that take output iterators can be used with ostreams as the
destination for placing data through the ostream_iterator class as well as with insert iterators and insert
pointers. — end note ]
24.2.5 Forward iterators

[forward.iterators]

1 A class or pointer type X satisﬁes the requirements of a forward iterator if

(1.1)

(1.2)

(1.3)

(1.4)

(1.5)

—
—
—

—
—

X satisﬁes the requirements of an input iterator (24.2.3),
X satisﬁes the DefaultConstructible requirements (17.6.3.1),
if X is a mutable iterator, reference is a reference to T; if X is a const iterator, reference is a reference
to const T,
the expressions in Table 109 are valid and have the indicated semantics, and
objects of type X oﬀer the multi-pass guarantee, described below.

2 The domain of == for forward iterators is that of iterators over the same underlying sequence. However,
value-initialized iterators may be compared and shall compare equal to other value-initialized iterators of

§ 24.2.5

855

c(cid:13) ISO/IEC

N4296

the same type.
sequence — end note ]

[ Note: value initialized iterators behave as if they refer past the end of the same empty

3 Two dereferenceable iterators a and b of type X oﬀer the multi-pass guarantee if:

—
—

a == b implies ++a == ++b and
X is a pointer type or the expression (void)++X(a), *a is equivalent to the expression *a.

[ Note: The requirement that a == b implies ++a == ++b (which is not true for input and output iterators)
and the removal of the restrictions on the number of the assignments through a mutable iterator (which
applies to output iterators) allows the use of multi-pass one-directional algorithms with forward iterators.
— end note ]

Table 109 — Forward iterator requirements (in addition to input
iterator)

Expression

Return type

Operational
semantics

Assertion/note

pre-/post-condition

r++

*r++

convertible to
const X&

reference

{ X tmp = r;
++r;
return tmp; }

(3.1)

(3.2)

4

5

6

If a and b are equal, then either a and b are both dereferenceable or else neither is dereferenceable.
If a and b are both dereferenceable, then a == b if and only if *a and *b are bound to the same object.
24.2.6 Bidirectional iterators

[bidirectional.iterators]
1 A class or pointer type X satisﬁes the requirements of a bidirectional iterator if, in addition to satisfying the

requirements for forward iterators, the following expressions are valid as shown in Table 110.

Table 110 — Bidirectional iterator requirements (in addition to
forward iterator)

Expression

Return type

--r

X&

Operational
semantics

r--

*r--

convertible to
const X&

reference

{ X tmp = r;
--r;
return tmp; }

Assertion/note

pre-/post-condition

pre: there exists s such that
r == ++s.
post: r is dereferenceable.
--(++r) == r.
--r == --s implies r == s.
&r == &--r.

2

[ Note: Bidirectional iterators allow algorithms to move iterators backward as well as forward. — end note ]

§ 24.2.6

856

c(cid:13) ISO/IEC

N4296

24.2.7 Random access iterators

[random.access.iterators]
1 A class or pointer type X satisﬁes the requirements of a random access iterator if, in addition to satisfying

the requirements for bidirectional iterators, the following expressions are valid as shown in Table 111.

Table 111 — Random access iterator requirements (in addition to
bidirectional iterator)

Expression

Return type

r += n

X&

a + n
n + a
r -= n
a - n

b - a

a[n]

a < b

a > b

a >= b

a <= b

X

X&
X

difference_-
type

convertible to
reference
contextually
convertible to
bool
contextually
convertible to
bool
contextually
convertible to
bool
contextually
convertible to
bool.

Operational
semantics

Assertion/note

pre-/post-condition

{ difference_type m = n;
if (m >= 0)
while (m--)
++r;
else
while (m++)
--r;
return r; }
{ X tmp = a;
return tmp += n; }
return r += -n;
{ X tmp = a;
return tmp -= n; }
return n

*(a + n)

b - a > 0

b < a

!(a < b)

!(a > b)

a + n == n + a.

pre: there exists a value n of
type difference_type such
that a + n == b.
b == a + (b - a).

< is a total ordering relation

> is a total ordering relation
opposite to <.

24.3 Header <iterator> synopsis

namespace std {

// 24.4, primitives:
template<class Iterator> struct iterator_traits;
template<class T> struct iterator_traits<T*>;

template<class Category, class T, class Distance = ptrdiff_t,

class Pointer = T*, class Reference = T&> struct iterator;

[iterator.synopsis]

§ 24.3

857

c(cid:13) ISO/IEC

N4296

struct input_iterator_tag { };
struct output_iterator_tag { };
struct forward_iterator_tag: public input_iterator_tag { };
struct bidirectional_iterator_tag: public forward_iterator_tag { };
struct random_access_iterator_tag: public bidirectional_iterator_tag { };

// 24.4.4, iterator operations:
template <class InputIterator, class Distance>
void advance(InputIterator& i, Distance n);

template <class InputIterator>

typename iterator_traits<InputIterator>::difference_type
distance(InputIterator first, InputIterator last);

template <class ForwardIterator>

ForwardIterator next(ForwardIterator x,

typename std::iterator_traits<ForwardIterator>::difference_type n = 1);

template <class BidirectionalIterator>

BidirectionalIterator prev(BidirectionalIterator x,

typename std::iterator_traits<BidirectionalIterator>::difference_type n = 1);

// 24.5, predeﬁned iterators:
template <class Iterator> class reverse_iterator;

template <class Iterator1, class Iterator2>

bool operator==(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
template <class Iterator1, class Iterator2>

bool operator<(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
template <class Iterator1, class Iterator2>

bool operator!=(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
template <class Iterator1, class Iterator2>

bool operator>(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
template <class Iterator1, class Iterator2>

bool operator>=(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
template <class Iterator1, class Iterator2>

bool operator<=(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>

auto operator-(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y) ->decltype(y.base() - x.base());

template <class Iterator>

reverse_iterator<Iterator>

operator+(

typename reverse_iterator<Iterator>::difference_type n,

§ 24.3

858

c(cid:13) ISO/IEC

N4296

const reverse_iterator<Iterator>& x);

template <class Iterator>

reverse_iterator<Iterator> make_reverse_iterator(Iterator i);

template <class Container> class back_insert_iterator;
template <class Container>

back_insert_iterator<Container> back_inserter(Container& x);

template <class Container> class front_insert_iterator;
template <class Container>

front_insert_iterator<Container> front_inserter(Container& x);

template <class Container> class insert_iterator;
template <class Container>

insert_iterator<Container> inserter(Container& x, typename Container::iterator i);

const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

template <class Iterator> class move_iterator;
template <class Iterator1, class Iterator2>

bool operator==(

template <class Iterator1, class Iterator2>

bool operator!=(

template <class Iterator1, class Iterator2>

bool operator<(

template <class Iterator1, class Iterator2>

bool operator<=(

template <class Iterator1, class Iterator2>

bool operator>(

template <class Iterator1, class Iterator2>

bool operator>=(

const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>

auto operator-(
const move_iterator<Iterator1>& x,
const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());

template <class Iterator>

move_iterator<Iterator> operator+(

typename move_iterator<Iterator>::difference_type n, const move_iterator<Iterator>& x);

template <class Iterator>

move_iterator<Iterator> make_move_iterator(Iterator i);

// 24.6, stream iterators:
template <class T, class charT = char, class traits = char_traits<charT>,

class Distance = ptrdiff_t>

class istream_iterator;
template <class T, class charT, class traits, class Distance>

bool operator==(const istream_iterator<T,charT,traits,Distance>& x,

const istream_iterator<T,charT,traits,Distance>& y);
template <class T, class charT, class traits, class Distance>

§ 24.3

859

c(cid:13) ISO/IEC

N4296

bool operator!=(const istream_iterator<T,charT,traits,Distance>& x,

const istream_iterator<T,charT,traits,Distance>& y);

template <class T, class charT = char, class traits = char_traits<charT> >

class ostream_iterator;

template<class charT, class traits = char_traits<charT> >

class istreambuf_iterator;

template <class charT, class traits>

bool operator==(const istreambuf_iterator<charT,traits>& a,

const istreambuf_iterator<charT,traits>& b);

template <class charT, class traits>

bool operator!=(const istreambuf_iterator<charT,traits>& a,

const istreambuf_iterator<charT,traits>& b);

template <class charT, class traits = char_traits<charT> >

class ostreambuf_iterator;

// 24.7, range access:
template <class C> auto begin(C& c) -> decltype(c.begin());
template <class C> auto begin(const C& c) -> decltype(c.begin());
template <class C> auto end(C& c) -> decltype(c.end());
template <class C> auto end(const C& c) -> decltype(c.end());
template <class T, size_t N> constexpr T* begin(T (&array)[N]) noexcept;
template <class T, size_t N> constexpr T* end(T (&array)[N]) noexcept;
template <class C> constexpr auto cbegin(const C& c) noexcept(noexcept(std::begin(c)))

template <class C> constexpr auto cend(const C& c) noexcept(noexcept(std::end(c)))

-> decltype(std::begin(c));

-> decltype(std::end(c));

template <class C> auto rbegin(C& c) -> decltype(c.rbegin());
template <class C> auto rbegin(const C& c) -> decltype(c.rbegin());
template <class C> auto rend(C& c) -> decltype(c.rend());
template <class C> auto rend(const C& c) -> decltype(c.rend());
template <class T, size_t N> reverse_iterator<T*> rbegin(T (&array)[N]);
template <class T, size_t N> reverse_iterator<T*> rend(T (&array)[N]);
template <class E> reverse_iterator<const E*> rbegin(initializer_list<E> il);
template <class E> reverse_iterator<const E*> rend(initializer_list<E> il);
template <class C> auto crbegin(const C& c) -> decltype(std::rbegin(c));
template <class C> auto crend(const C& c) -> decltype(std::rend(c));

// 24.8, container access:
template <class C> constexpr auto size(const C& c) -> decltype(c.size());
template <class T, size_t N> constexpr size_t size(const T (&array)[N]) noexcept;
template <class C> constexpr auto empty(const C& c) -> decltype(c.empty());
template <class T, size_t N> constexpr bool empty(const T (&array)[N]) noexcept;
template <class E> constexpr bool empty(initializer_list<E> il) noexcept;
template <class C> constexpr auto data(C& c) -> decltype(c.data());
template <class C> constexpr auto data(const C& c) -> decltype(c.data());
template <class T, size_t N> constexpr T* data(T (&array)[N]) noexcept;
template <class E> constexpr const E* data(initializer_list<E> il) noexcept;

}

24.4 Iterator primitives

[iterator.primitives]

1 To simplify the task of deﬁning iterators, the library provides several classes and functions:

§ 24.4

860

c(cid:13) ISO/IEC

N4296

24.4.1

Iterator traits

[iterator.traits]
1 To implement algorithms only in terms of iterators, it is often necessary to determine the value and diﬀerence
types that correspond to a particular iterator type. Accordingly, it is required that if Iterator is the type
of an iterator, the types

iterator_traits<Iterator>::difference_type
iterator_traits<Iterator>::value_type
iterator_traits<Iterator>::iterator_category

be deﬁned as the iterator’s diﬀerence type, value type and iterator category, respectively. In addition, the
types

iterator_traits<Iterator>::reference
iterator_traits<Iterator>::pointer

shall be deﬁned as the iterator’s reference and pointer types, that is, for an iterator object a, the same type
as the type of *a and a->, respectively. In the case of an output iterator, the types

iterator_traits<Iterator>::difference_type
iterator_traits<Iterator>::value_type
iterator_traits<Iterator>::reference
iterator_traits<Iterator>::pointer

2

may be deﬁned as void.
If Iterator has valid (14.8.2) member types difference_type, value_type, pointer, reference, and
iterator_category, iterator_traits<Iterator> shall have the following as publicly accessible members
and shall have no other members:

typedef typename Iterator::difference_type difference_type;
typedef typename Iterator::value_type value_type;
typedef typename Iterator::pointer pointer;
typedef typename Iterator::reference reference;
typedef typename Iterator::iterator_category iterator_category;

Otherwise, iterator_traits<Iterator> shall have no members.
It is specialized for pointers as

3

template<class T> struct iterator_traits<T*> {

typedef ptrdiff_t difference_type;
typedef T value_type;
typedef T* pointer;
typedef T& reference;
typedef random_access_iterator_tag iterator_category;

namespace std {

};

}

and for pointers to const as

namespace std {

template<class T> struct iterator_traits<const T*> {

typedef ptrdiff_t difference_type;
typedef T value_type;
typedef const T* pointer;
typedef const T& reference;
typedef random_access_iterator_tag iterator_category;

§ 24.4.1

861

c(cid:13) ISO/IEC

};

}

4

[ Example: To implement a generic reverse function, a C++ program can do the following:

N4296

template <class BidirectionalIterator>
void reverse(BidirectionalIterator first, BidirectionalIterator last) {
typename iterator_traits<BidirectionalIterator>::difference_type n =

distance(first, last);

--n;
while(n > 0) {

typename iterator_traits<BidirectionalIterator>::value_type
tmp = *first;
*first++ = *--last;
*last = tmp;
n -= 2;

}

}

};

}

— end example ]
24.4.2 Basic iterator

[iterator.basic]
1 The iterator template may be used as a base class to ease the deﬁnition of required types for new iterators.

namespace std {

template<class Category, class T, class Distance = ptrdiff_t,

class Pointer = T*, class Reference = T&>

struct iterator {

typedef T
typedef Distance
typedef Pointer
typedef Reference reference;
typedef Category

value_type;
difference_type;
pointer;

iterator_category;

1

[std.iterator.tags]
24.4.3 Standard iterator tags
It is often desirable for a function template specialization to ﬁnd out what is the most speciﬁc cate-
gory of its iterator argument, so that the function can select the most eﬃcient algorithm at compile
time. To facilitate this, the library introduces category tag classes which are used as compile time tags
for algorithm selection. They are: input_iterator_tag, output_iterator_tag, forward_iterator_tag,
bidirectional_iterator_tag and random_access_iterator_tag. For every iterator of type Iterator,
iterator_traits<Iterator>::iterator_category shall be deﬁned to be the most speciﬁc category tag
that describes the iterator’s behavior.

namespace std {

struct input_iterator_tag { };
struct output_iterator_tag { };
struct forward_iterator_tag: public input_iterator_tag { };
struct bidirectional_iterator_tag: public forward_iterator_tag { };
struct random_access_iterator_tag: public bidirectional_iterator_tag { };

}

2

[ Example: For a program-deﬁned iterator BinaryTreeIterator, it could be included into the bidirectional
iterator category by specializing the iterator_traits template:

§ 24.4.3

862

c(cid:13) ISO/IEC

N4296

template<class T> struct iterator_traits<BinaryTreeIterator<T> > {

typedef std::ptrdiff_t difference_type;
typedef T value_type;
typedef T* pointer;
typedef T& reference;
typedef bidirectional_iterator_tag iterator_category;

Typically, however, it would be easier to derive BinaryTreeIterator<T> from iterator<bidirectional_-
iterator_tag,T,ptrdiff_t,T*,T&>. — end example ]
[ Example: If evolve() is well deﬁned for bidirectional iterators, but can be implemented more eﬃciently
for random access iterators, then the implementation is as follows:

3

template <class BidirectionalIterator>
inline void
evolve(BidirectionalIterator first, BidirectionalIterator last) {

evolve(first, last,

typename iterator_traits<BidirectionalIterator>::iterator_category());

};

}

}

}

};

template <class BidirectionalIterator>
void evolve(BidirectionalIterator first, BidirectionalIterator last,

bidirectional_iterator_tag) {
// more generic, but less eﬃcient algorithm

template <class RandomAccessIterator>
void evolve(RandomAccessIterator first, RandomAccessIterator last,

random_access_iterator_tag) {
// more eﬃcient, but less generic algorithm

4

— end example ]
[ Example: If a C++ program wants to deﬁne a bidirectional iterator for some data structure containing
double and such that it works on a large memory model of the implementation, it can do so with:

class MyIterator :

public iterator<bidirectional_iterator_tag, double, long, T*, T&> {
// code implementing ++, etc.

5 Then there is no need to specialize the iterator_traits template. — end example ]

24.4.4

Iterator operations

[iterator.operations]
1 Since only random access iterators provide + and - operators, the library provides two function templates
advance and distance. These function templates use + and - for random access iterators (and are, therefore,
constant time for them); for input, forward and bidirectional iterators they use ++ to provide linear time
implementations.

template <class InputIterator, class Distance>
void advance(InputIterator& i, Distance n);

2

3

Requires: n shall be negative only for bidirectional and random access iterators.
Eﬀects: Increments (or decrements for negative n) iterator reference i by n.

§ 24.4.4

863

c(cid:13) ISO/IEC

N4296

template<class InputIterator>

typename iterator_traits<InputIterator>::difference_type

distance(InputIterator first, InputIterator last);

Eﬀects: If InputIterator meets the requirements of random access iterator, returns (last - first);
otherwise, returns the number of increments needed to get from first to last.
Requires: If InputIterator meets the requirements of random access iterator, last shall be reachable
from first or first shall be reachable from last; otherwise, last shall be reachable from first.

template <class ForwardIterator>

ForwardIterator next(ForwardIterator x,

typename std::iterator_traits<ForwardIterator>::difference_type n = 1);
Eﬀects: Equivalent to advance(x, n); return x;

template <class BidirectionalIterator>

BidirectionalIterator prev(BidirectionalIterator x,

typename std::iterator_traits<BidirectionalIterator>::difference_type n = 1);
Eﬀects: Equivalent to advance(x, -n); return x;

4

5

6

7

24.5 Iterator adaptors
24.5.1 Reverse iterators

[predef.iterators]
[reverse.iterators]
1 Class template reverse_iterator is an iterator adaptor that iterates from the end of the sequence deﬁned
by its underlying iterator to the beginning of that sequence. The fundamental relation between a reverse
iterator and its corresponding iterator i is established by the identity: &*(reverse_iterator(i)) == &*(i
- 1).
24.5.1.1 Class template reverse_iterator

[reverse.iterator]

namespace std {

template <class Iterator>
class reverse_iterator : public

iterator<typename iterator_traits<Iterator>::iterator_category,
typename iterator_traits<Iterator>::value_type,
typename iterator_traits<Iterator>::difference_type,
typename iterator_traits<Iterator>::pointer,
typename iterator_traits<Iterator>::reference> {

public:

typedef Iterator
typedef typename iterator_traits<Iterator>::difference_type difference_type;
typedef typename iterator_traits<Iterator>::reference
typedef typename iterator_traits<Iterator>::pointer

reference;
pointer;

iterator_type;

reverse_iterator();
explicit reverse_iterator(Iterator x);
template <class U> reverse_iterator(const reverse_iterator<U>& u);
template <class U> reverse_iterator& operator=(const reverse_iterator<U>& u);

Iterator base() const;
reference operator*() const;
pointer
operator->() const;

// explicit

reverse_iterator& operator++();
reverse_iterator
reverse_iterator& operator--();

operator++(int);

§ 24.5.1.1

864

c(cid:13) ISO/IEC

N4296

reverse_iterator

operator--(int);

operator+ (difference_type n) const;

reverse_iterator
reverse_iterator& operator+=(difference_type n);
reverse_iterator
reverse_iterator& operator-=(difference_type n);
unspecified

operator[](difference_type n) const;

operator- (difference_type n) const;

protected:

Iterator current;

};

template <class Iterator1, class Iterator2>

bool operator==(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
template <class Iterator1, class Iterator2>

bool operator<(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
template <class Iterator1, class Iterator2>

bool operator!=(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
template <class Iterator1, class Iterator2>

bool operator>(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
template <class Iterator1, class Iterator2>

bool operator>=(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
template <class Iterator1, class Iterator2>

bool operator<=(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
template <class Iterator1, class Iterator2>

auto operator-(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y) -> decltype(y.base() - x.base());

template <class Iterator>

reverse_iterator<Iterator> operator+(

typename reverse_iterator<Iterator>::difference_type n,
const reverse_iterator<Iterator>& x);

template <class Iterator>

reverse_iterator<Iterator> make_reverse_iterator(Iterator i);

}

24.5.1.2 reverse_iterator requirements

[reverse.iter.requirements]

1 The template parameter Iterator shall meet all the requirements of a Bidirectional Iterator (24.2.6).
2 Additionally, Iterator shall meet the requirements of a Random Access Iterator (24.2.7) if any of the mem-
bers operator+ (24.5.1.3.8), operator- (24.5.1.3.10), operator+= (24.5.1.3.9), operator-= (24.5.1.3.11),
operator [] (24.5.1.3.12), or the global operators operator< (24.5.1.3.14), operator> (24.5.1.3.16),
operator <= (24.5.1.3.18), operator>= (24.5.1.3.17), operator- (24.5.1.3.19) or operator+ (24.5.1.3.20) are

§ 24.5.1.2

865

c(cid:13) ISO/IEC

referenced in a way that requires instantiation (14.7.1).
24.5.1.3 reverse_iterator operations
24.5.1.3.1 reverse_iterator constructor
reverse_iterator();

N4296

[reverse.iter.ops]
[reverse.iter.cons]

Eﬀects: Value initializes current. Iterator operations applied to the resulting iterator have deﬁned
behavior if and only if the corresponding operations are deﬁned on a value-initialized iterator of type
Iterator.

explicit reverse_iterator(Iterator x);
Eﬀects: Initializes current with x.

template <class U> reverse_iterator(const reverse_iterator<U> &u);

Eﬀects: Initializes current with u.current.

24.5.1.3.2 reverse_iterator::operator=
template <class U>
reverse_iterator&

operator=(const reverse_iterator<U>& u);

Eﬀects: Assigns u.base() to current.
Returns: *this.

// explicit

24.5.1.3.3 Conversion
Iterator base() const;
Returns: current.
24.5.1.3.4 operator*
reference operator*() const;

Eﬀects:

Iterator tmp = current;
return *--tmp;

24.5.1.3.5 operator->
pointer operator->() const;

Returns: std::addressof(operator*()).

24.5.1.3.6 operator++
reverse_iterator& operator++();

Eﬀects: --current;
Returns: *this.

reverse_iterator operator++(int);

Eﬀects:

reverse_iterator tmp = *this;
--current;
return tmp;

§ 24.5.1.3.6

[reverse.iter.op=]

[reverse.iter.conv]

[reverse.iter.op.star]

[reverse.iter.opref]

[reverse.iter.op++]

866

1

2

3

1

2

1

1

1

1

2

3

c(cid:13) ISO/IEC

24.5.1.3.7 operator--
reverse_iterator& operator--();

Eﬀects: ++current
Returns: *this.

reverse_iterator operator--(int);

Eﬀects:

reverse_iterator tmp = *this;
++current;
return tmp;

N4296

[reverse.iter.op--]

24.5.1.3.8 operator+
reverse_iterator
operator+(typename reverse_iterator<Iterator>::difference_type n) const;

Returns: reverse_iterator(current-n).

24.5.1.3.9 operator+=
reverse_iterator&
operator+=(typename reverse_iterator<Iterator>::difference_type n);

[reverse.iter.op+]

[reverse.iter.op+=]

Eﬀects: current -= n;
Returns: *this.

24.5.1.3.10 operator-
reverse_iterator
operator-(typename reverse_iterator<Iterator>::difference_type n) const;

Returns: reverse_iterator(current+n).

24.5.1.3.11 operator-=
reverse_iterator&
operator-=(typename reverse_iterator<Iterator>::difference_type n);

[reverse.iter.op-]

[reverse.iter.op-=]

Eﬀects: current += n;
Returns: *this.

24.5.1.3.12 operator[]
operator[](
unspecified

typename reverse_iterator<Iterator>::difference_type n) const;
Returns: current[-n-1].

24.5.1.3.13 operator==
template <class Iterator1, class Iterator2>

bool operator==(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
Returns: x.current == y.current.

[reverse.iter.opindex]

[reverse.iter.op==]

1

2

3

1

1

2

1

1

2

1

1

§ 24.5.1.3.13

867

c(cid:13) ISO/IEC

24.5.1.3.14 operator<
template <class Iterator1, class Iterator2>

bool operator<(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
Returns: x.current > y.current.

24.5.1.3.15 operator!=
template <class Iterator1, class Iterator2>

bool operator!=(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
Returns: x.current != y.current.

24.5.1.3.16 operator>
template <class Iterator1, class Iterator2>

bool operator>(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
Returns: x.current < y.current.

24.5.1.3.17 operator>=
template <class Iterator1, class Iterator2>

bool operator>=(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
Returns: x.current <= y.current.

24.5.1.3.18 operator<=
template <class Iterator1, class Iterator2>

bool operator<=(

const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
Returns: x.current >= y.current.

24.5.1.3.19 operator-
template <class Iterator1, class Iterator2>

auto operator-(
const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y) -> decltype(y.base() - x.base());
Returns: y.current - x.current.

24.5.1.3.20 operator+
template <class Iterator>

reverse_iterator<Iterator> operator+(

typename reverse_iterator<Iterator>::difference_type n,
const reverse_iterator<Iterator>& x);
Returns: reverse_iterator<Iterator> (x.current - n).

1

1

1

1

1

1

1

N4296

[reverse.iter.op<]

[reverse.iter.op!=]

[reverse.iter.op>]

[reverse.iter.op>=]

[reverse.iter.op<=]

[reverse.iter.opdiﬀ]

[reverse.iter.opsum]

§ 24.5.1.3.20

868

c(cid:13) ISO/IEC

24.5.1.3.21 Non-member function make_reverse_iterator()
template <class Iterator>

reverse_iterator<Iterator> make_reverse_iterator(Iterator i);

1

Returns: reverse_iterator<Iterator>(i).

N4296

[reverse.iter.make]

24.5.2

[insert.iterators]
1 To make it possible to deal with insertion in the same way as writing into an array, a special kind of iterator

Insert iterators

adaptors, called insert iterators, are provided in the library. With regular iterator classes,

while (first != last) *result++ = *first++;

causes a range [first,last) to be copied into a range starting with result. The same code with result
being an insert iterator will insert corresponding elements into the container. This device allows all of the
copying algorithms in the library to work in the insert mode instead of the regular overwrite mode.

2 An insert iterator is constructed from a container and possibly one of its iterators pointing to where insertion
takes place if it is neither at the beginning nor at the end of the container. Insert iterators satisfy the require-
ments of output iterators. operator* returns the insert iterator itself. The assignment operator=(const
T& x) is deﬁned on insert iterators to allow writing into them, it inserts x right before where the insert
iterator is pointing. In other words, an insert iterator is like a cursor pointing into the container where the
insertion takes place. back_insert_iterator inserts elements at the end of a container, front_insert_-
iterator inserts elements at the beginning of a container, and insert_iterator inserts elements where
the iterator points to in a container. back_inserter, front_inserter, and inserter are three functions
making the insert iterators out of a container.
24.5.2.1 Class template back_insert_iterator

[back.insert.iterator]

namespace std {

template <class Container>
class back_insert_iterator :

public iterator<output_iterator_tag,void,void,void,void> {

protected:

Container* container;

public:

typedef Container container_type;
explicit back_insert_iterator(Container& x);
back_insert_iterator& operator=(const typename Container::value_type& value);
back_insert_iterator& operator=(typename Container::value_type&& value);

back_insert_iterator& operator*();
back_insert_iterator& operator++();
back_insert_iterator

operator++(int);

};

template <class Container>

back_insert_iterator<Container> back_inserter(Container& x);

}

24.5.2.2 back_insert_iterator operations
24.5.2.2.1 back_insert_iterator constructor
explicit back_insert_iterator(Container& x);

1

Eﬀects: Initializes container with std::addressof(x).

[back.insert.iter.ops]
[back.insert.iter.cons]

§ 24.5.2.2.1

869

c(cid:13) ISO/IEC

N4296

24.5.2.2.2 back_insert_iterator::operator=
back_insert_iterator& operator=(const typename Container::value_type& value);

[back.insert.iter.op=]

Eﬀects: container->push_back(value);
Returns: *this.

back_insert_iterator& operator=(typename Container::value_type&& value);

Eﬀects: container->push_back(std::move(value));
Returns: *this.

24.5.2.2.3 back_insert_iterator::operator*
back_insert_iterator& operator*();

Returns: *this.

24.5.2.2.4 back_insert_iterator::operator++
back_insert_iterator& operator++();
back_insert_iterator
Returns: *this.

operator++(int);

24.5.2.2.5
template <class Container>

back_inserter

back_insert_iterator<Container> back_inserter(Container& x);

[back.insert.iter.op*]

[back.insert.iter.op++]

[back.inserter]

Returns: back_insert_iterator<Container>(x).

24.5.2.3 Class template front_insert_iterator

[front.insert.iterator]

1

2

3

4

1

1

1

namespace std {

template <class Container>
class front_insert_iterator :

public iterator<output_iterator_tag,void,void,void,void> {

protected:

Container* container;

public:

typedef Container container_type;
explicit front_insert_iterator(Container& x);
front_insert_iterator& operator=(const typename Container::value_type& value);
front_insert_iterator& operator=(typename Container::value_type&& value);

front_insert_iterator& operator*();
front_insert_iterator& operator++();
front_insert_iterator

operator++(int);

};

template <class Container>

front_insert_iterator<Container> front_inserter(Container& x);

}

24.5.2.4 front_insert_iterator operations
24.5.2.4.1 front_insert_iterator constructor

§ 24.5.2.4.1

[front.insert.iter.ops]
[front.insert.iter.cons]

870

c(cid:13) ISO/IEC

N4296

explicit front_insert_iterator(Container& x);

Eﬀects: Initializes container with std::addressof(x).

24.5.2.4.2 front_insert_iterator::operator=
front_insert_iterator& operator=(const typename Container::value_type& value);

[front.insert.iter.op=]

Eﬀects: container->push_front(value);
Returns: *this.

front_insert_iterator& operator=(typename Container::value_type&& value);

Eﬀects: container->push_front(std::move(value));
Returns: *this.

24.5.2.4.3 front_insert_iterator::operator*
front_insert_iterator& operator*();

Returns: *this.

24.5.2.4.4 front_insert_iterator::operator++
front_insert_iterator& operator++();
front_insert_iterator
Returns: *this.

operator++(int);

[front.insert.iter.op*]

[front.insert.iter.op++]

24.5.2.4.5 front_inserter
template <class Container>

front_insert_iterator<Container> front_inserter(Container& x);

Returns: front_insert_iterator<Container>(x).

24.5.2.5 Class template insert_iterator

[front.inserter]

[insert.iterator]

1

1

2

3

4

1

1

1

namespace std {

template <class Container>
class insert_iterator :

public iterator<output_iterator_tag,void,void,void,void> {

protected:

Container* container;
typename Container::iterator iter;

public:

typedef Container container_type;
insert_iterator(Container& x, typename Container::iterator i);
insert_iterator& operator=(const typename Container::value_type& value);
insert_iterator& operator=(typename Container::value_type&& value);

insert_iterator& operator*();
insert_iterator& operator++();
insert_iterator& operator++(int);

};

template <class Container>

insert_iterator<Container> inserter(Container& x, typename Container::iterator i);

}

§ 24.5.2.5

871

c(cid:13) ISO/IEC

24.5.2.6 insert_iterator operations
24.5.2.6.1 insert_iterator constructor
insert_iterator(Container& x, typename Container::iterator i);

Eﬀects: Initializes container with std::addressof(x) and iter with i.

24.5.2.6.2 insert_iterator::operator=
insert_iterator& operator=(const typename Container::value_type& value);

Eﬀects:

iter = container->insert(iter, value);
++iter;

Returns: *this.

insert_iterator& operator=(typename Container::value_type&& value);

Eﬀects:

iter = container->insert(iter, std::move(value));
++iter;

Returns: *this.

24.5.2.6.3 insert_iterator::operator*
insert_iterator& operator*();

Returns: *this.

24.5.2.6.4 insert_iterator::operator++
insert_iterator& operator++();
insert_iterator& operator++(int);

Returns: *this.
24.5.2.6.5 inserter
template <class Container>

1

1

2

3

4

1

1

1

N4296

[insert.iter.ops]
[insert.iter.cons]

[insert.iter.op=]

[insert.iter.op*]

[insert.iter.op++]

[inserter]

insert_iterator<Container> inserter(Container& x, typename Container::iterator i);

Returns: insert_iterator<Container>(x, i).

24.5.3 Move iterators

[move.iterators]
1 Class template move_iterator is an iterator adaptor with the same behavior as the underlying iterator
except that its indirection operator implicitly converts the value returned by the underlying iterator’s indi-
rection operator to an rvalue. Some generic algorithms can be called with move iterators to replace copying
with moving.
[ Example:

2

list<string> s;
// populate the list s
vector<string> v1(s.begin(), s.end());
vector<string> v2(make_move_iterator(s.begin()),

// copies strings into v1

make_move_iterator(s.end())); // moves strings into v2

— end example ]

§ 24.5.3

872

c(cid:13) ISO/IEC

24.5.3.1 Class template move_iterator

N4296

[move.iterator]

namespace std {

template <class Iterator>
class move_iterator {
public:

typedef Iterator
typedef typename iterator_traits<Iterator>::difference_type
typedef Iterator
typedef typename iterator_traits<Iterator>::value_type
typedef typename iterator_traits<Iterator>::iterator_category iterator_category;
typedef see below

iterator_type;
difference_type;
pointer;
value_type;

reference;

move_iterator();
explicit move_iterator(Iterator i);
template <class U> move_iterator(const move_iterator<U>& u);
template <class U> move_iterator& operator=(const move_iterator<U>& u);

iterator_type base() const;
reference operator*() const;
pointer operator->() const;

move_iterator& operator++();
move_iterator operator++(int);
move_iterator& operator--();
move_iterator operator--(int);

move_iterator operator+(difference_type n) const;
move_iterator& operator+=(difference_type n);
move_iterator operator-(difference_type n) const;
move_iterator& operator-=(difference_type n);
unspecified

operator[](difference_type n) const;

private:

};

Iterator current;

// exposition only

const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>

bool operator==(

template <class Iterator1, class Iterator2>

bool operator!=(

template <class Iterator1, class Iterator2>

bool operator<(

template <class Iterator1, class Iterator2>

bool operator<=(

template <class Iterator1, class Iterator2>

bool operator>(

template <class Iterator1, class Iterator2>

bool operator>=(

const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

§ 24.5.3.1

873

c(cid:13) ISO/IEC

N4296

template <class Iterator1, class Iterator2>

auto operator-(

const move_iterator<Iterator1>& x,
const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());

template <class Iterator>

move_iterator<Iterator> operator+(

typename move_iterator<Iterator>::difference_type n, const move_iterator<Iterator>& x);

template <class Iterator>

move_iterator<Iterator> make_move_iterator(Iterator i);

}

1 Let R be iterator_traits<Iterator>::reference. If is_reference<R >::value is true, the template
specialization move_iterator<Iterator> shall deﬁne the nested type named reference as a synonym for
remove_reference<R >::type&&, otherwise as a synonym for R.
24.5.3.2 move_iterator requirements

[move.iter.requirements]
1 The template parameter Iterator shall meet the requirements for an Input Iterator (24.2.3). Additionally,
if any of the bidirectional or random access traversal functions are instantiated, the template parameter shall
meet the requirements for a Bidirectional Iterator (24.2.6) or a Random Access Iterator (24.2.7), respectively.
24.5.3.3 move_iterator operations
[move.iter.ops]
[move.iter.op.const]
24.5.3.3.1 move_iterator constructors
move_iterator();

1

2

3

4

1

2

1

1

Eﬀects: Constructs a move_iterator, value initializing current. Iterator operations applied to the
resulting iterator have deﬁned behavior if and only if the corresponding operations are deﬁned on a
value-initialized iterator of type Iterator.

explicit move_iterator(Iterator i);

Eﬀects: Constructs a move_iterator, initializing current with i.

template <class U> move_iterator(const move_iterator<U>& u);

Eﬀects: Constructs a move_iterator, initializing current with u.base().
Requires: U shall be convertible to Iterator.

24.5.3.3.2 move_iterator::operator=
template <class U> move_iterator& operator=(const move_iterator<U>& u);

Eﬀects: Assigns u.base() to current.
Requires: U shall be convertible to Iterator.

24.5.3.3.3 move_iterator conversion
Iterator base() const;
Returns: current.

24.5.3.3.4 move_iterator::operator*
reference operator*() const;

Returns: static_cast<reference>(*current).

[move.iter.op=]

[move.iter.op.conv]

[move.iter.op.star]

§ 24.5.3.3.4

874

c(cid:13) ISO/IEC

24.5.3.3.5 move_iterator::operator->
pointer operator->() const;

Returns: current.

24.5.3.3.6 move_iterator::operator++
move_iterator& operator++();

Eﬀects: ++current.
Returns: *this.

move_iterator operator++(int);

Eﬀects:

move_iterator tmp = *this;
++current;
return tmp;

24.5.3.3.7 move_iterator::operator--
move_iterator& operator--();

Eﬀects: --current.
Returns: *this.

move_iterator operator--(int);

Eﬀects:

move_iterator tmp = *this;
--current;
return tmp;

24.5.3.3.8 move_iterator::operator+
move_iterator operator+(difference_type n) const;

Returns: move_iterator(current + n).

24.5.3.3.9 move_iterator::operator+=
move_iterator& operator+=(difference_type n);

Eﬀects: current += n.
Returns: *this.

24.5.3.3.10 move_iterator::operator-
move_iterator operator-(difference_type n) const;

Returns: move_iterator(current - n).

24.5.3.3.11 move_iterator::operator-=
move_iterator& operator-=(difference_type n);

Eﬀects: current -= n.
Returns: *this.

§ 24.5.3.3.11

1

1

2

3

1

2

3

1

1

2

1

1

2

N4296

[move.iter.op.ref]

[move.iter.op.incr]

[move.iter.op.decr]

[move.iter.op.+]

[move.iter.op.+=]

[move.iter.op.-]

[move.iter.op.-=]

875

1

1

2

3

4

5

6

1

2

3

c(cid:13) ISO/IEC

24.5.3.3.12 move_iterator::operator[]
unspecified

operator[](difference_type n) const;

Returns: std::move(current[n]).

N4296

[move.iter.op.index]

24.5.3.3.13 move_iterator comparisons
template <class Iterator1, class Iterator2>
bool operator==(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

[move.iter.op.comp]

Returns: x.base() == y.base().

template <class Iterator1, class Iterator2>
bool operator!=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

Returns: !(x == y).

template <class Iterator1, class Iterator2>
bool operator<(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

Returns: x.base() < y.base().

template <class Iterator1, class Iterator2>
bool operator<=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

Returns: !(y < x).

template <class Iterator1, class Iterator2>
bool operator>(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

Returns: y < x.

template <class Iterator1, class Iterator2>
bool operator>=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

Returns: !(x < y).

24.5.3.3.14 move_iterator non-member functions
template <class Iterator1, class Iterator2>

auto operator-(
const move_iterator<Iterator1>& x,
const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());
Returns: x.base() - y.base().

[move.iter.nonmember]

template <class Iterator>

move_iterator<Iterator> operator+(

typename move_iterator<Iterator>::difference_type n, const move_iterator<Iterator>& x);
Returns: x + n.

template <class Iterator>
move_iterator<Iterator> make_move_iterator(Iterator i);

Returns: move_iterator<Iterator>(i).

§ 24.5.3.3.14

876

c(cid:13) ISO/IEC

N4296

24.6 Stream iterators

[stream.iterators]
1 To make it possible for algorithmic templates to work directly with input/output streams, appropriate

iterator-like class templates are provided.
[ Example:

partial_sum(istream_iterator<double, char>(cin),

istream_iterator<double, char>(),
ostream_iterator<double, char>(cout, "\n"));

reads a ﬁle containing ﬂoating point numbers from cin, and prints the partial sums onto cout. — end
example ]
24.6.1 Class template istream_iterator

[istream.iterator]
1 The class template istream_iterator is an input iterator (24.2.3) that reads (using operator>>) successive
elements from the input stream for which it was constructed. After it is constructed, and every time ++ is
used, the iterator reads and stores a value of T. If the iterator fails to read and store a value of T (fail() on
the stream returns true), the iterator becomes equal to the end-of-stream iterator value. The constructor
with no arguments istream_iterator() always constructs an end-of-stream input iterator object, which is
the only legitimate iterator to be used for the end condition. The result of operator* on an end-of-stream
iterator is not deﬁned. For any other iterator value a const T& is returned. The result of operator-> on
an end-of-stream iterator is not deﬁned. For any other iterator value a const T* is returned. The behavior
of a program that applies operator++() to an end-of-stream iterator is undeﬁned. It is impossible to store
things into istream iterators.

2 Two end-of-stream iterators are always equal. An end-of-stream iterator is not equal to a non-end-of-stream

iterator. Two non-end-of-stream iterators are equal when they are constructed from the same stream.

template <class T, class charT = char, class traits = char_traits<charT>,

namespace std {

class Distance = ptrdiff_t>

class istream_iterator:

public iterator<input_iterator_tag, T, Distance, const T*, const T&> {

public:

typedef charT char_type;
typedef traits traits_type;
typedef basic_istream<charT,traits> istream_type;
see below istream_iterator();
istream_iterator(istream_type& s);
istream_iterator(const istream_iterator& x) = default;
~istream_iterator() = default;

const T& operator*() const;
const T* operator->() const;
istream_iterator& operator++();
istream_iterator

operator++(int);

private:

};

basic_istream<charT,traits>* in_stream; // exposition only
// exposition only
T value;

template <class T, class charT, class traits, class Distance>

bool operator==(const istream_iterator<T,charT,traits,Distance>& x,

const istream_iterator<T,charT,traits,Distance>& y);
template <class T, class charT, class traits, class Distance>

§ 24.6.1

877

c(cid:13) ISO/IEC

N4296

bool operator!=(const istream_iterator<T,charT,traits,Distance>& x,

const istream_iterator<T,charT,traits,Distance>& y);

}

24.6.1.1 istream_iterator constructors and destructor
see below istream_iterator();

[istream.iterator.cons]

Eﬀects: Constructs the end-of-stream iterator. If T is a literal type, then this constructor shall be a
constexpr constructor.
Postcondition: in_stream == 0.

istream_iterator(istream_type& s);

Eﬀects: Initializes in_stream with &s. value may be initialized during construction or the ﬁrst time it
is referenced.
Postcondition: in_stream == &s.

istream_iterator(const istream_iterator& x) = default;

Eﬀects: Constructs a copy of x. If T is a literal type, then this constructor shall be a trivial copy
constructor.
Postcondition: in_stream == x.in_stream.

~istream_iterator() = default;

Eﬀects: The iterator is destroyed. If T is a literal type, then this destructor shall be a trivial destructor.
[istream.iterator.ops]

24.6.1.2 istream_iterator operations
const T& operator*() const;

Returns: value.

const T* operator->() const;

Returns: &(operator*()).

istream_iterator& operator++();
Requires: in_stream != 0.
Eﬀects: *in_stream >>value.
Returns: *this.

istream_iterator operator++(int);

Requires: in_stream != 0.
Eﬀects:

istream_iterator tmp = *this;
*in_stream >> value;
return (tmp);

1

2

3

4

5

6

7

1

2

3

4

5

6

7

template <class T, class charT, class traits, class Distance>

bool operator==(const istream_iterator<T,charT,traits,Distance> &x,
const istream_iterator<T,charT,traits,Distance> &y);

§ 24.6.1.2

878

c(cid:13) ISO/IEC

N4296

8

9

Returns: x.in_stream == y.in_stream.

template <class T, class charT, class traits, class Distance>

bool operator!=(const istream_iterator<T,charT,traits,Distance> &x,
const istream_iterator<T,charT,traits,Distance> &y);

Returns: !(x == y)

24.6.2 Class template ostream_iterator

[ostream.iterator]
1 ostream_iterator writes (using operator<<) successive elements onto the output stream from which it
was constructed. If it was constructed with charT* as a constructor argument, this string, called a delimiter
string, is written to the stream after every T is written. It is not possible to get a value out of the output
iterator. Its only use is as an output iterator in situations like

while (first != last)

*result++ = *first++;

2 ostream_iterator is deﬁned as:

namespace std {

public:

template <class T, class charT = char, class traits = char_traits<charT> >
class ostream_iterator:

public iterator<output_iterator_tag, void, void, void, void> {

typedef charT char_type;
typedef traits traits_type;
typedef basic_ostream<charT,traits> ostream_type;
ostream_iterator(ostream_type& s);
ostream_iterator(ostream_type& s, const charT* delimiter);
ostream_iterator(const ostream_iterator& x);
~ostream_iterator();
ostream_iterator& operator=(const T& value);

ostream_iterator& operator*();
ostream_iterator& operator++();
ostream_iterator& operator++(int);

private:

basic_ostream<charT,traits>* out_stream; // exposition only
// exposition only
const charT* delim;

};

}

24.6.2.1 ostream_iterator constructors and destructor
ostream_iterator(ostream_type& s);

Eﬀects: Initializes out_stream with &s and delim with null.

ostream_iterator(ostream_type& s, const charT* delimiter);

Eﬀects: Initializes out_stream with &s and delim with delimiter.

[ostream.iterator.cons.des]

ostream_iterator(const ostream_iterator& x);

Eﬀects: Constructs a copy of x.

~ostream_iterator();

Eﬀects: The iterator is destroyed.

§ 24.6.2.1

879

1

2

3

4

c(cid:13) ISO/IEC

24.6.2.2 ostream_iterator operations
ostream_iterator& operator=(const T& value);

Eﬀects:

N4296

[ostream.iterator.ops]

*out_stream << value;
if (delim != 0)

*out_stream << delim ;

return *this;

ostream_iterator& operator*();

Returns: *this.

ostream_iterator& operator++();
ostream_iterator& operator++(int);

Returns: *this.

1

2

3

24.6.3 Class template istreambuf_iterator

[istreambuf.iterator]
1 The class template istreambuf_iterator deﬁnes an input iterator (24.2.3) that reads successive characters
from the streambuf for which it was constructed. operator* provides access to the current input character, if
any. [ Note: operator-> may return a proxy. — end note ] Each time operator++ is evaluated, the iterator
advances to the next input character. If the end of stream is reached (streambuf_type::sgetc() returns
traits::eof()), the iterator becomes equal to the end-of-stream iterator value. The default constructor
istreambuf_iterator() and the constructor istreambuf_iterator(0) both construct an end-of-stream
iterator object suitable for use as an end-of-range. All specializations of istreambuf_iterator shall have a
trivial copy constructor, a constexpr default constructor, and a trivial destructor.

2 The result of operator*() on an end-of-stream iterator is undeﬁned. For any other iterator value a char_-

type value is returned. It is impossible to assign a character via an input iterator.

namespace std {

template<class charT, class traits = char_traits<charT> >
class istreambuf_iterator

: public iterator<input_iterator_tag, charT,

typename traits::off_type, unspecified , charT> {

public:

typedef charT
typedef traits
typedef typename traits::int_type
typedef basic_streambuf<charT,traits> streambuf_type;
typedef basic_istream<charT,traits>

char_type;
traits_type;
int_type;

istream_type;

class proxy;

// exposition only

constexpr istreambuf_iterator() noexcept;
istreambuf_iterator(const istreambuf_iterator&) noexcept = default;
~istreambuf_iterator() = default;
istreambuf_iterator(istream_type& s) noexcept;
istreambuf_iterator(streambuf_type* s) noexcept;
istreambuf_iterator(const proxy& p) noexcept;
charT operator*() const;
pointer operator->() const;
istreambuf_iterator& operator++();
proxy operator++(int);

§ 24.6.3

880

c(cid:13) ISO/IEC

N4296

bool equal(const istreambuf_iterator& b) const;

streambuf_type* sbuf_;

// exposition only

private:

};

template <class charT, class traits>

bool operator==(const istreambuf_iterator<charT,traits>& a,

const istreambuf_iterator<charT,traits>& b);

template <class charT, class traits>

bool operator!=(const istreambuf_iterator<charT,traits>& a,

const istreambuf_iterator<charT,traits>& b);

}

24.6.3.1 Class template istreambuf_iterator::proxy

[istreambuf.iterator::proxy]

namespace std {

template <class charT, class traits = char_traits<charT> >
class istreambuf_iterator<charT, traits>::proxy { // exposition only

charT keep_;
basic_streambuf<charT,traits>* sbuf_;
proxy(charT c, basic_streambuf<charT,traits>* sbuf)

: keep_(c), sbuf_(sbuf) { }

charT operator*() { return keep_; }

public:

};

}

1 Class istreambuf_iterator<charT,traits>::proxy is for exposition only. An implementation is permit-
ted to provide equivalent functionality without providing a class with this name. Class istreambuf_-
iterator<charT, traits>::proxy provides a temporary placeholder as the return value of the post-
increment operator (operator++). It keeps the character pointed to by the previous value of the iterator for
some possible future access to get the character.
24.6.3.2 istreambuf_iterator constructors
constexpr istreambuf_iterator() noexcept;

[istreambuf.iterator.cons]

1

2

3

1

Eﬀects: Constructs the end-of-stream iterator.

istreambuf_iterator(basic_istream<charT,traits>& s) noexcept;
istreambuf_iterator(basic_streambuf<charT,traits>* s) noexcept;

Eﬀects: Constructs an istreambuf_iterator<> that uses the basic_streambuf<> object *(s.rdbuf()),
or *s, respectively. Constructs an end-of-stream iterator if s.rdbuf() is null.

istreambuf_iterator(const proxy& p) noexcept;

Eﬀects: Constructs a istreambuf_iterator<> that uses the basic_streambuf<> object pointed to
by the proxy object’s constructor argument p.

24.6.3.3 istreambuf_iterator::operator*
charT operator*() const

[istreambuf.iterator::op*]

Returns: The character obtained via the streambuf member sbuf_->sgetc().

§ 24.6.3.3

881

c(cid:13) ISO/IEC

24.6.3.4 istreambuf_iterator::operator++
istreambuf_iterator& operator++();

Eﬀects: sbuf_->sbumpc().
Returns: *this.

proxy operator++(int);

Returns: proxy(sbuf_->sbumpc(), sbuf_).

24.6.3.5 istreambuf_iterator::equal
bool equal(const istreambuf_iterator& b) const;

N4296

[istreambuf.iterator::op++]

[istreambuf.iterator::equal]

Returns: true if and only if both iterators are at end-of-stream, or neither is at end-of-stream, regard-
less of what streambuf object they use.

24.6.3.6 operator==
template <class charT, class traits>

bool operator==(const istreambuf_iterator<charT,traits>& a,
const istreambuf_iterator<charT,traits>& b);

Returns: a.equal(b).

24.6.3.7 operator!=
template <class charT, class traits>

bool operator!=(const istreambuf_iterator<charT,traits>& a,
const istreambuf_iterator<charT,traits>& b);

Returns: !a.equal(b).

[istreambuf.iterator::op==]

[istreambuf.iterator::op!=]

24.6.4 Class template ostreambuf_iterator

[ostreambuf.iterator]

1

2

3

1

1

1

namespace std {

public:

template <class charT, class traits = char_traits<charT> >
class ostreambuf_iterator :

public iterator<output_iterator_tag, void, void, void, void> {

typedef charT
typedef traits
typedef basic_streambuf<charT,traits> streambuf_type;
typedef basic_ostream<charT,traits>

char_type;
traits_type;

ostream_type;

public:

ostreambuf_iterator(ostream_type& s) noexcept;
ostreambuf_iterator(streambuf_type* s) noexcept;
ostreambuf_iterator& operator=(charT c);

ostreambuf_iterator& operator*();
ostreambuf_iterator& operator++();
ostreambuf_iterator& operator++(int);
bool failed() const noexcept;

private:

streambuf_type* sbuf_;

};

}

// exposition only

§ 24.6.4

882

c(cid:13) ISO/IEC

N4296

1 The class template ostreambuf_iterator writes successive characters onto the output stream from which

it was constructed. It is not possible to get a character value out of the output iterator.
24.6.4.1 ostreambuf_iterator constructors
ostreambuf_iterator(ostream_type& s) noexcept;

[ostreambuf.iter.cons]

1

2

3

4

1

2

3

4

5

1

2

3

4

5

Requires: s.rdbuf() shall not be a null pointer.
Eﬀects: Initializes sbuf_ with s.rdbuf().

ostreambuf_iterator(streambuf_type* s) noexcept;

Requires: s shall not be a null pointer.
Eﬀects: Initializes sbuf_ with s.

24.6.4.2 ostreambuf_iterator operations
ostreambuf_iterator& operator=(charT c);

[ostreambuf.iter.ops]

Eﬀects: If failed() yields false, calls sbuf_->sputc(c); otherwise has no eﬀect.
Returns: *this.

ostreambuf_iterator& operator*();

Returns: *this.

ostreambuf_iterator& operator++();
ostreambuf_iterator& operator++(int);

Returns: *this.

bool failed() const noexcept;

Returns: true if in any prior use of member operator=, the call to sbuf_->sputc() returned
traits::eof(); or false otherwise.

24.7 Range access
[iterator.range]
In addition to being available via inclusion of the <iterator> header, the function templates in 24.7 are
available when any of the following headers are included: <array>, <deque>, <forward_list>, <list>,
<map>, <regex>, <set>, <string>, <unordered_map>, <unordered_set>, and <vector>.

template <class C> auto begin(C& c) -> decltype(c.begin());
template <class C> auto begin(const C& c) -> decltype(c.begin());

Returns: c.begin().

template <class C> auto end(C& c) -> decltype(c.end());
template <class C> auto end(const C& c) -> decltype(c.end());

Returns: c.end().

template <class T, size_t N> constexpr T* begin(T (&array)[N]) noexcept;

Returns: array.

template <class T, size_t N> constexpr T* end(T (&array)[N]) noexcept;

Returns: array + N.

§ 24.7

883

c(cid:13) ISO/IEC

N4296

6

7

8

9

10

11

12

13

14

15

1

2

3

4

template <class C> constexpr auto cbegin(const C& c) noexcept(noexcept(std::begin(c)))

-> decltype(std::begin(c));
Returns: std::begin(c).

template <class C> constexpr auto cend(const C& c) noexcept(noexcept(std::end(c)))

-> decltype(std::end(c));
Returns: std::end(c).

template <class C> auto rbegin(C& c) -> decltype(c.rbegin());
template <class C> auto rbegin(const C& c) -> decltype(c.rbegin());

Returns: c.rbegin().

template <class C> auto rend(C& c) -> decltype(c.rend());
template <class C> auto rend(const C& c) -> decltype(c.rend());

Returns: c.rend().

template <class T, size_t N> reverse_iterator<T*> rbegin(T (&array)[N]);

Returns: reverse_iterator<T*>(array + N).

template <class T, size_t N> reverse_iterator<T*> rend(T (&array)[N]);

Returns: reverse_iterator<T*>(array).

template <class E> reverse_iterator<const E*> rbegin(initializer_list<E> il);

Returns: reverse_iterator<const E*>(il.end()).

template <class E> reverse_iterator<const E*> rend(initializer_list<E> il);

Returns: reverse_iterator<const E*>(il.begin()).

template <class C> auto crbegin(const C& c) -> decltype(std::rbegin(c));

Returns: std::rbegin(c).

template <class C> auto crend(const C& c) -> decltype(std::rend(c));

Returns: std::rend(c).
24.8 Container access
[iterator.container]
In addition to being available via inclusion of the <iterator> header, the function templates in 24.8 are
available when any of the following headers are included: <array>, <deque>, <forward_list>, <list>,
<map>, <regex>, <set>, <string>, <unordered_map>, <unordered_set>, and <vector>.

template <class C> constexpr auto size(const C& c) -> decltype(c.size());

Returns: c.size().

template <class T, size_t N> constexpr size_t size(const T (&array)[N]) noexcept;

Returns: N.

template <class C> constexpr auto empty(const C& c) -> decltype(c.empty());

Returns: c.empty().

§ 24.8

884

c(cid:13) ISO/IEC

N4296

template <class T, size_t N> constexpr bool empty(const T (&array)[N]) noexcept;

Returns: false.

template <class E> constexpr bool empty(initializer_list<E> il) noexcept;

Returns: il.size() == 0.

template <class C> constexpr auto data(C& c) -> decltype(c.data());
template <class C> constexpr auto data(const C& c) -> decltype(c.data());

Returns: c.data().

template <class T, size_t N> constexpr T* data(T (&array)[N]) noexcept;

Returns: array.

template <class E> constexpr const E* data(initializer_list<E> il) noexcept;

Returns: il.begin().

5

6

7

8

9

§ 24.8

885

c(cid:13) ISO/IEC

N4296

25 Algorithms library
25.1 General

[algorithms]
[algorithms.general]
1 This Clause describes components that C++ programs may use to perform algorithmic operations on con-

tainers (Clause 23) and other sequences.

2 The following subclauses describe components for non-modifying sequence operation, modifying sequence
operations, sorting and related operations, and algorithms from the ISO C library, as summarized in Ta-
ble 112.

Table 112 — Algorithms library summary

Subclause

25.2 Non-modifying sequence operations
25.3 Mutating sequence operations
25.4
Sorting and related operations
25.5 C library algorithms

Header(s)

<algorithm>

<cstdlib>

Header <algorithm> synopsis
#include <initializer_list>

namespace std {

// 25.2, non-modifying sequence operations:
template <class InputIterator, class Predicate>

bool all_of(InputIterator first, InputIterator last, Predicate pred);

template <class InputIterator, class Predicate>

bool any_of(InputIterator first, InputIterator last, Predicate pred);

template <class InputIterator, class Predicate>

bool none_of(InputIterator first, InputIterator last, Predicate pred);

template<class InputIterator, class Function>

Function for_each(InputIterator first, InputIterator last, Function f);

template<class InputIterator, class T>

InputIterator find(InputIterator first, InputIterator last,

template<class InputIterator, class Predicate>

InputIterator find_if(InputIterator first, InputIterator last,

const T& value);

Predicate pred);

template<class InputIterator, class Predicate>

InputIterator find_if_not(InputIterator first, InputIterator last,

Predicate pred);

template<class ForwardIterator1, class ForwardIterator2>

ForwardIterator1

find_end(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);

template<class ForwardIterator1, class ForwardIterator2,

class BinaryPredicate>
ForwardIterator1

find_end(ForwardIterator1 first1, ForwardIterator1 last1,

§ 25.1

886

c(cid:13) ISO/IEC

N4296

ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);

template<class InputIterator, class ForwardIterator>

InputIterator

find_first_of(InputIterator first1, InputIterator last1,

ForwardIterator first2, ForwardIterator last2);

template<class InputIterator, class ForwardIterator,

class BinaryPredicate>
InputIterator

find_first_of(InputIterator first1, InputIterator last1,

ForwardIterator first2, ForwardIterator last2,
BinaryPredicate pred);

template<class ForwardIterator>

ForwardIterator adjacent_find(ForwardIterator first,
ForwardIterator last);
template<class ForwardIterator, class BinaryPredicate>
ForwardIterator adjacent_find(ForwardIterator first,
ForwardIterator last,
BinaryPredicate pred);

template<class InputIterator, class T>

typename iterator_traits<InputIterator>::difference_type

count(InputIterator first, InputIterator last, const T& value);

template<class InputIterator, class Predicate>

typename iterator_traits<InputIterator>::difference_type

count_if(InputIterator first, InputIterator last, Predicate pred);

template<class InputIterator1, class InputIterator2>

pair<InputIterator1, InputIterator2>

mismatch(InputIterator1 first1, InputIterator1 last1,

InputIterator2 first2);

template
<class InputIterator1, class InputIterator2, class BinaryPredicate>
pair<InputIterator1, InputIterator2>

mismatch(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, BinaryPredicate pred);

template<class InputIterator1, class InputIterator2>

pair<InputIterator1, InputIterator2>

mismatch(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2);

template
<class InputIterator1, class InputIterator2, class BinaryPredicate>
pair<InputIterator1, InputIterator2>

mismatch(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
BinaryPredicate pred);

template<class InputIterator1, class InputIterator2>

bool equal(InputIterator1 first1, InputIterator1 last1,

InputIterator2 first2);

template

§ 25.1

887

c(cid:13) ISO/IEC

N4296

<class InputIterator1, class InputIterator2, class BinaryPredicate>
bool equal(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, BinaryPredicate pred);

template<class InputIterator1, class InputIterator2>

bool equal(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2);

template
<class InputIterator1, class InputIterator2, class BinaryPredicate>
bool equal(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
BinaryPredicate pred);

template<class ForwardIterator1, class ForwardIterator2>

bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,

template<class ForwardIterator1, class ForwardIterator2,

ForwardIterator2 first2);

class BinaryPredicate>

bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, BinaryPredicate pred);

template<class ForwardIterator1, class ForwardIterator2>

bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);

template<class ForwardIterator1, class ForwardIterator2,

class BinaryPredicate>

bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);

template<class ForwardIterator1, class ForwardIterator2>

ForwardIterator1 search(

ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);

template<class ForwardIterator1, class ForwardIterator2,

class BinaryPredicate>
ForwardIterator1 search(

ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);

template<class ForwardIterator, class Size, class T>

ForwardIterator search_n(ForwardIterator first, ForwardIterator last,

Size count, const T& value);

template
<class ForwardIterator, class Size, class T, class BinaryPredicate>
ForwardIterator search_n(ForwardIterator first, ForwardIterator last,

Size count, const T& value,
BinaryPredicate pred);

// 25.3, modifying sequence operations:
// 25.3.1, copy:
template<class InputIterator, class OutputIterator>

OutputIterator copy(InputIterator first, InputIterator last,

§ 25.1

888

c(cid:13) ISO/IEC

N4296

OutputIterator result);

template<class InputIterator, class Size, class OutputIterator>

OutputIterator copy_n(InputIterator first, Size n,

OutputIterator result);

template<class InputIterator, class OutputIterator, class Predicate>

OutputIterator copy_if(InputIterator first, InputIterator last,

OutputIterator result, Predicate pred);

template<class BidirectionalIterator1, class BidirectionalIterator2>

BidirectionalIterator2 copy_backward(

BidirectionalIterator1 first, BidirectionalIterator1 last,
BidirectionalIterator2 result);

// 25.3.2, move:
template<class InputIterator, class OutputIterator>

OutputIterator move(InputIterator first, InputIterator last,

OutputIterator result);

template<class BidirectionalIterator1, class BidirectionalIterator2>

BidirectionalIterator2 move_backward(

BidirectionalIterator1 first, BidirectionalIterator1 last,
BidirectionalIterator2 result);

// 25.3.3, swap:
template<class ForwardIterator1, class ForwardIterator2>
ForwardIterator2 swap_ranges(ForwardIterator1 first1,
ForwardIterator1 last1, ForwardIterator2 first2);

template<class ForwardIterator1, class ForwardIterator2>
void iter_swap(ForwardIterator1 a, ForwardIterator2 b);

template<class InputIterator, class OutputIterator, class UnaryOperation>

OutputIterator transform(InputIterator first, InputIterator last,

OutputIterator result, UnaryOperation op);

template<class InputIterator1, class InputIterator2, class OutputIterator,

class BinaryOperation>
OutputIterator transform(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, OutputIterator result,
BinaryOperation binary_op);

template<class ForwardIterator, class T>

void replace(ForwardIterator first, ForwardIterator last,

const T& old_value, const T& new_value);

template<class ForwardIterator, class Predicate, class T>

void replace_if(ForwardIterator first, ForwardIterator last,

Predicate pred, const T& new_value);

template<class InputIterator, class OutputIterator, class T>

OutputIterator replace_copy(InputIterator first, InputIterator last,

OutputIterator result,
const T& old_value, const T& new_value);

template<class InputIterator, class OutputIterator, class Predicate, class T>

OutputIterator replace_copy_if(InputIterator first, InputIterator last,

OutputIterator result,
Predicate pred, const T& new_value);

template<class ForwardIterator, class T>

void fill(ForwardIterator first, ForwardIterator last, const T& value);

template<class OutputIterator, class Size, class T>

§ 25.1

889

c(cid:13) ISO/IEC

N4296

OutputIterator fill_n(OutputIterator first, Size n, const T& value);

template<class ForwardIterator, class Generator>

void generate(ForwardIterator first, ForwardIterator last,

Generator gen);

template<class OutputIterator, class Size, class Generator>

OutputIterator generate_n(OutputIterator first, Size n, Generator gen);

template<class ForwardIterator, class T>

ForwardIterator remove(ForwardIterator first, ForwardIterator last,

const T& value);

Predicate pred);

template<class ForwardIterator, class Predicate>

ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,

template<class InputIterator, class OutputIterator, class T>

OutputIterator remove_copy(InputIterator first, InputIterator last,
OutputIterator result, const T& value);
template<class InputIterator, class OutputIterator, class Predicate>

OutputIterator remove_copy_if(InputIterator first, InputIterator last,
OutputIterator result, Predicate pred);

template<class ForwardIterator>

ForwardIterator unique(ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class BinaryPredicate>

ForwardIterator unique(ForwardIterator first, ForwardIterator last,

BinaryPredicate pred);

template<class InputIterator, class OutputIterator>

OutputIterator unique_copy(InputIterator first, InputIterator last,

OutputIterator result);

template<class InputIterator, class OutputIterator, class BinaryPredicate>

OutputIterator unique_copy(InputIterator first, InputIterator last,

OutputIterator result, BinaryPredicate pred);

template<class BidirectionalIterator>

void reverse(BidirectionalIterator first, BidirectionalIterator last);

template<class BidirectionalIterator, class OutputIterator>
OutputIterator reverse_copy(BidirectionalIterator first,
BidirectionalIterator last,
OutputIterator result);

template<class ForwardIterator>

ForwardIterator rotate(ForwardIterator first, ForwardIterator middle,

ForwardIterator last);

template<class ForwardIterator, class OutputIterator>

OutputIterator rotate_copy(

ForwardIterator first, ForwardIterator middle,
ForwardIterator last, OutputIterator result);

// 25.3.12, shuﬄe:
template<class RandomAccessIterator, class UniformRandomNumberGenerator>

void shuffle(RandomAccessIterator first,

RandomAccessIterator last,
UniformRandomNumberGenerator&& g);

// 25.3.13, partitions:

§ 25.1

890

c(cid:13) ISO/IEC

N4296

template <class InputIterator, class Predicate>

bool is_partitioned(InputIterator first, InputIterator last, Predicate pred);

template<class ForwardIterator, class Predicate>

ForwardIterator partition(ForwardIterator first,
ForwardIterator last,
Predicate pred);

template<class BidirectionalIterator, class Predicate>

BidirectionalIterator stable_partition(BidirectionalIterator first,
BidirectionalIterator last,
Predicate pred);

template <class InputIterator, class OutputIterator1,

class OutputIterator2, class Predicate>

pair<OutputIterator1, OutputIterator2>
partition_copy(InputIterator first, InputIterator last,

OutputIterator1 out_true, OutputIterator2 out_false,
Predicate pred);

template<class ForwardIterator, class Predicate>

ForwardIterator partition_point(ForwardIterator first,
ForwardIterator last,
Predicate pred);

// 25.4, sorting and related operations:
// 25.4.1, sorting:
template<class RandomAccessIterator>

void sort(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>

void sort(RandomAccessIterator first, RandomAccessIterator last,

Compare comp);

template<class RandomAccessIterator>

void stable_sort(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>

void stable_sort(RandomAccessIterator first, RandomAccessIterator last,

Compare comp);

template<class RandomAccessIterator>

void partial_sort(RandomAccessIterator first,
RandomAccessIterator middle,
RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>

void partial_sort(RandomAccessIterator first,
RandomAccessIterator middle,
RandomAccessIterator last, Compare comp);

template<class InputIterator, class RandomAccessIterator>

RandomAccessIterator partial_sort_copy(

InputIterator first, InputIterator last,
RandomAccessIterator result_first,
RandomAccessIterator result_last);

RandomAccessIterator partial_sort_copy(

InputIterator first, InputIterator last,
RandomAccessIterator result_first,
RandomAccessIterator result_last,
Compare comp);

template<class InputIterator, class RandomAccessIterator, class Compare>

§ 25.1

891

c(cid:13) ISO/IEC

N4296

template<class ForwardIterator>

bool is_sorted(ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>

bool is_sorted(ForwardIterator first, ForwardIterator last,

Compare comp);
template<class ForwardIterator>

ForwardIterator is_sorted_until(ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>

ForwardIterator is_sorted_until(ForwardIterator first, ForwardIterator last,

Compare comp);

template<class RandomAccessIterator>

void nth_element(RandomAccessIterator first, RandomAccessIterator nth,

RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>

void nth_element(RandomAccessIterator first, RandomAccessIterator nth,

RandomAccessIterator last, Compare comp);

// 25.4.3, binary search:
template<class ForwardIterator, class T>

ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,

const T& value);

template<class ForwardIterator, class T, class Compare>

ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,

const T& value, Compare comp);

template<class ForwardIterator, class T>

ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,

const T& value);

template<class ForwardIterator, class T, class Compare>

ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,

const T& value, Compare comp);

template<class ForwardIterator, class T>
pair<ForwardIterator, ForwardIterator>

equal_range(ForwardIterator first, ForwardIterator last,

const T& value);

template<class ForwardIterator, class T, class Compare>

pair<ForwardIterator, ForwardIterator>

equal_range(ForwardIterator first, ForwardIterator last,

const T& value, Compare comp);

template<class ForwardIterator, class T>

bool binary_search(ForwardIterator first, ForwardIterator last,

const T& value);

template<class ForwardIterator, class T, class Compare>

bool binary_search(ForwardIterator first, ForwardIterator last,

const T& value, Compare comp);

// 25.4.4, merge:
template<class InputIterator1, class InputIterator2, class OutputIterator>

OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);

template<class InputIterator1, class InputIterator2, class OutputIterator,

§ 25.1

892

c(cid:13) ISO/IEC

N4296

class Compare>
OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);

template<class BidirectionalIterator>

void inplace_merge(BidirectionalIterator first,
BidirectionalIterator middle,
BidirectionalIterator last);

template<class BidirectionalIterator, class Compare>

void inplace_merge(BidirectionalIterator first,
BidirectionalIterator middle,
BidirectionalIterator last, Compare comp);

// 25.4.5, set operations:
template<class InputIterator1, class InputIterator2>

bool includes(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2);

template<class InputIterator1, class InputIterator2, class Compare>

bool includes(

InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2, Compare comp);

template<class InputIterator1, class InputIterator2, class OutputIterator>

OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);

template<class InputIterator1, class InputIterator2, class OutputIterator,

class Compare>
OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);

template<class InputIterator1, class InputIterator2, class OutputIterator>

template<class InputIterator1, class InputIterator2, class OutputIterator,

OutputIterator set_intersection(

InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);

class Compare>
OutputIterator set_intersection(

InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);

OutputIterator set_difference(

InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);

class Compare>
OutputIterator set_difference(

InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,

template<class InputIterator1, class InputIterator2, class OutputIterator>

template<class InputIterator1, class InputIterator2, class OutputIterator,

§ 25.1

893

c(cid:13) ISO/IEC

N4296

OutputIterator result, Compare comp);

template<class InputIterator1, class InputIterator2, class OutputIterator>

template<class InputIterator1, class InputIterator2, class OutputIterator,

OutputIterator set_symmetric_difference(

InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);

class Compare>

OutputIterator set_symmetric_difference(

InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);

// 25.4.6, heap operations:
template<class RandomAccessIterator>

void push_heap(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>

void push_heap(RandomAccessIterator first, RandomAccessIterator last,

Compare comp);

template<class RandomAccessIterator>

void pop_heap(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>

void pop_heap(RandomAccessIterator first, RandomAccessIterator last,

Compare comp);

template<class RandomAccessIterator>

void make_heap(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>

void make_heap(RandomAccessIterator first, RandomAccessIterator last,

Compare comp);

template<class RandomAccessIterator>

void sort_heap(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>

void sort_heap(RandomAccessIterator first, RandomAccessIterator last,

Compare comp);

template<class RandomAccessIterator>

bool is_heap(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>

bool is_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template<class RandomAccessIterator>

RandomAccessIterator is_heap_until(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>

RandomAccessIterator is_heap_until(RandomAccessIterator first, RandomAccessIterator last,

Compare comp);

// 25.4.7, minimum and maximum:
template<class T> constexpr const T& min(const T& a, const T& b);
template<class T, class Compare>

constexpr const T& min(const T& a, const T& b, Compare comp);

template<class T>

constexpr T min(initializer_list<T> t);

§ 25.1

894

c(cid:13) ISO/IEC

N4296

template<class T, class Compare>

constexpr T min(initializer_list<T> t, Compare comp);

template<class T> constexpr const T& max(const T& a, const T& b);
template<class T, class Compare>

constexpr const T& max(const T& a, const T& b, Compare comp);

template<class T>

constexpr T max(initializer_list<T> t);

template<class T, class Compare>

constexpr T max(initializer_list<T> t, Compare comp);

template<class T> constexpr pair<const T&, const T&> minmax(const T& a, const T& b);
template<class T, class Compare>

constexpr pair<const T&, const T&> minmax(const T& a, const T& b, Compare comp);

template<class T>

constexpr pair<T, T> minmax(initializer_list<T> t);

template<class T, class Compare>

constexpr pair<T, T> minmax(initializer_list<T> t, Compare comp);

template<class ForwardIterator>

ForwardIterator min_element(ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>

ForwardIterator min_element(ForwardIterator first, ForwardIterator last,

Compare comp);

template<class ForwardIterator>

ForwardIterator max_element(ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>

ForwardIterator max_element(ForwardIterator first, ForwardIterator last,

template<class ForwardIterator>

pair<ForwardIterator, ForwardIterator>

Compare comp);

minmax_element(ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>

pair<ForwardIterator, ForwardIterator>

minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);

template<class InputIterator1, class InputIterator2>

bool lexicographical_compare(

InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2);

template<class InputIterator1, class InputIterator2, class Compare>

bool lexicographical_compare(

InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
Compare comp);

// 25.4.9, permutations:
template<class BidirectionalIterator>

bool next_permutation(BidirectionalIterator first,
BidirectionalIterator last);
template<class BidirectionalIterator, class Compare>
bool next_permutation(BidirectionalIterator first,

template<class BidirectionalIterator>

bool prev_permutation(BidirectionalIterator first,

BidirectionalIterator last, Compare comp);

§ 25.1

895

c(cid:13) ISO/IEC

N4296

BidirectionalIterator last);
template<class BidirectionalIterator, class Compare>
bool prev_permutation(BidirectionalIterator first,

BidirectionalIterator last, Compare comp);

}

3 All of the algorithms are separated from the particular implementations of data structures and are param-
eterized by iterator types. Because of this, they can work with program-deﬁned data structures, as long as
these data structures have iterator types satisfying the assumptions on the algorithms.

4 For purposes of determining the existence of data races, algorithms shall not modify objects referenced

through an iterator argument unless the speciﬁcation requires such modiﬁcation.

5 Throughout this Clause, the names of template parameters are used to express type requirements.

(5.1)

(5.2)

(5.3)

(5.4)

(5.5)

—

—

—

—

—

If an algorithm’s template parameter is named InputIterator, InputIterator1, or InputIterator2,
the template argument shall satisfy the requirements of an input iterator (24.2.3).
If an algorithm’s template parameter is named OutputIterator, OutputIterator1, or OutputIterator2,
the template argument shall satisfy the requirements of an output iterator (24.2.4).
If an algorithm’s template parameter is named ForwardIterator, ForwardIterator1, or ForwardIterator2,
the template argument shall satisfy the requirements of a forward iterator (24.2.5).
If an algorithm’s template parameter is named BidirectionalIterator, BidirectionalIterator1,
or BidirectionalIterator2, the template argument shall satisfy the requirements of a bidirectional
iterator (24.2.6).
If an algorithm’s template parameter is named RandomAccessIterator, RandomAccessIterator1, or
RandomAccessIterator2, the template argument shall satisfy the requirements of a random-access
iterator (24.2.7).

6

If an algorithm’s Eﬀects section says that a value pointed to by any iterator passed as an argument is
modiﬁed, then that algorithm has an additional type requirement: The type of that argument shall satisfy
the requirements of a mutable iterator (24.2). [ Note: This requirement does not aﬀect arguments that are
named OutputIterator, OutputIterator1, or OutputIterator2, because output iterators must always be
mutable. — end note ]

7 Both in-place and copying versions are provided for certain algorithms.268 When such a version is provided
for algorithm it is called algorithm_copy. Algorithms that take predicates end with the suﬃx _if (which
follows the suﬃx _copy).

8 The Predicate parameter is used whenever an algorithm expects a function object (20.9) that, when applied
to the result of dereferencing the corresponding iterator, returns a value testable as true. In other words,
if an algorithm takes Predicate pred as its argument and first as its iterator argument, it should work
correctly in the construct pred(*first) contextually converted to bool (Clause 4). The function object
pred shall not apply any non-constant function through the dereferenced iterator.

9 The BinaryPredicate parameter is used whenever an algorithm expects a function object that when ap-
plied to the result of dereferencing two corresponding iterators or to dereferencing an iterator and type
T when T is part of the signature returns a value testable as true. In other words, if an algorithm takes
BinaryPredicate binary_pred as its argument and first1 and first2 as its iterator arguments, it should
268) The decision whether to include a copying version was usually based on complexity considerations. When the cost of doing
the operation dominates the cost of copy, the copying version is not included. For example, sort_copy is not included because
the cost of sorting is much more signiﬁcant, and users might as well do copy followed by sort.

§ 25.1

896

c(cid:13) ISO/IEC

N4296

work correctly in the construct binary_pred(*first1, *first2) contextually converted to bool (Clause 4).
BinaryPredicate always takes the ﬁrst iterator’s value_type as its ﬁrst argument, that is, in those cases
when T value is part of the signature, it should work correctly in the construct binary_pred(*first1,
value) contextually converted to bool (Clause 4). binary_pred shall not apply any non-constant function
through the dereferenced iterators.
[ Note: Unless otherwise speciﬁed, algorithms that take function objects as arguments are permitted to copy
those function objects freely. Programmers for whom object identity is important should consider using a
wrapper class that points to a noncopied implementation object such as reference_wrapper<T> (20.9.4),
or some equivalent solution. — end note ]

10

11 When the description of an algorithm gives an expression such as *first == value for a condition, the

expression shall evaluate to either true or false in boolean contexts.
In the description of the algorithms operators + and - are used for some of the iterator categories for which
they do not have to be deﬁned. In these cases the semantics of a+n is the same as that of

12

1

2

1

2

1

2

X tmp = a;
advance(tmp, n);
return tmp;

and that of b-a is the same as of

return distance(a, b);

25.2 Non-modifying sequence operations
25.2.1 All of
template <class InputIterator, class Predicate>

bool all_of(InputIterator first, InputIterator last, Predicate pred);

[alg.nonmodifying]
[alg.all_of]

Returns: true if [first,last) is empty or if pred(*i) is true for every iterator i in the range
[first,last), and false otherwise.
Complexity: At most last - first applications of the predicate.

25.2.2 Any of
template <class InputIterator, class Predicate>

bool any_of(InputIterator first, InputIterator last, Predicate pred);

[alg.any_of]

Returns: false if [first,last) is empty or if there is no iterator i in the range [first,last) such
that pred(*i) is true, and true otherwise.
Complexity: At most last - first applications of the predicate.

25.2.3 None of
template <class InputIterator, class Predicate>

bool none_of(InputIterator first, InputIterator last, Predicate pred);

[alg.none_of]

Returns: true if [first,last) is empty or if pred(*i) is false for every iterator i in the range
[first,last), and false otherwise.
Complexity: At most last - first applications of the predicate.

25.2.4 For each
template<class InputIterator, class Function>

Function for_each(InputIterator first, InputIterator last, Function f);

§ 25.2.4

[alg.foreach]

897

1

2

3

4

5

1

2

1

2

3

c(cid:13) ISO/IEC

N4296

Requires: Function shall meet the requirements of MoveConstructible (Table 20). [ Note: Function
need not meet the requirements of CopyConstructible (Table 21). — end note ]
Eﬀects: Applies f to the result of dereferencing every iterator in the range [first,last), starting
from first and proceeding to last - 1. [ Note: If the type of first satisﬁes the requirements of a
mutable iterator, f may apply nonconstant functions through the dereferenced iterator. — end note ]
Returns: std::move(f).
Complexity: Applies f exactly last - first times.
Remarks: If f returns a result, the result is ignored.

25.2.5 Find
template<class InputIterator, class T>

InputIterator find(InputIterator first, InputIterator last,

const T& value);

[alg.ﬁnd]

template<class InputIterator, class Predicate>

InputIterator find_if(InputIterator first, InputIterator last,

Predicate pred);

template<class InputIterator, class Predicate>

InputIterator find_if_not(InputIterator first, InputIterator last,

Predicate pred);

Returns: The ﬁrst iterator i in the range [first,last) for which the following corresponding condi-
tions hold: *i == value, pred(*i) != false, pred(*i) == false. Returns last if no such iterator
is found.
Complexity: At most last - first applications of the corresponding predicate.

25.2.6 Find end
template<class ForwardIterator1, class ForwardIterator2>

ForwardIterator1

find_end(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);

[alg.ﬁnd.end]

template<class ForwardIterator1, class ForwardIterator2,

class BinaryPredicate>

ForwardIterator1

find_end(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);

Eﬀects: Finds a subsequence of equal values in a sequence.
Returns: The last iterator i in the range [first1,last1 - (last2 - first2)) such that for every
non-negative integer n < (last2 - first2), the following corresponding conditions hold: *(i + n)
== *(first2 + n), pred(*(i + n), *(first2 + n)) != false. Returns last1 if [first2,last2
) is empty or if no such iterator is found.
Complexity: At most (last2 - first2) * (last1 - first1 - (last2 - first2) + 1) applica-
tions of the corresponding predicate.

25.2.7 Find ﬁrst
template<class InputIterator, class ForwardIterator>

InputIterator

§ 25.2.7

[alg.ﬁnd.ﬁrst.of]

898

c(cid:13) ISO/IEC

N4296

find_first_of(InputIterator first1, InputIterator last1,

ForwardIterator first2, ForwardIterator last2);

template<class InputIterator, class ForwardIterator,

class BinaryPredicate>

InputIterator

find_first_of(InputIterator first1, InputIterator last1,

ForwardIterator first2, ForwardIterator last2,
BinaryPredicate pred);

1

2

3

1

2

1

2

Eﬀects: Finds an element that matches one of a set of values.
Returns: The ﬁrst iterator i in the range [first1,last1) such that for some iterator j in the range
[first2,last2) the following conditions hold: *i == *j, pred(*i,*j) != false. Returns last1
if [first2,last2) is empty or if no such iterator is found.
Complexity: At most (last1-first1) * (last2-first2) applications of the corresponding predi-
cate.

25.2.8 Adjacent ﬁnd
template<class ForwardIterator>

ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last);

[alg.adjacent.ﬁnd]

template<class ForwardIterator, class BinaryPredicate>

ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last,

BinaryPredicate pred);

Returns: The ﬁrst iterator i such that both i and i + 1 are in the range [first,last) for which the
following corresponding conditions hold: *i == *(i + 1), pred(*i, *(i + 1)) != false. Returns
last if no such iterator is found.
Complexity: For a nonempty range, exactly min((i - first) + 1, (last - first) - 1) applica-
tions of the corresponding predicate, where i is adjacent_find’s return value.

25.2.9 Count
template<class InputIterator, class T>

typename iterator_traits<InputIterator>::difference_type

count(InputIterator first, InputIterator last, const T& value);

[alg.count]

template<class InputIterator, class Predicate>

typename iterator_traits<InputIterator>::difference_type

count_if(InputIterator first, InputIterator last, Predicate pred);
Eﬀects: Returns the number of iterators i in the range [first,last) for which the following corre-
sponding conditions hold: *i == value, pred(*i) != false.
Complexity: Exactly last - first applications of the corresponding predicate.

25.2.10 Mismatch
template<class InputIterator1, class InputIterator2>

pair<InputIterator1, InputIterator2>

mismatch(InputIterator1 first1, InputIterator1 last1,

InputIterator2 first2);

[mismatch]

template<class InputIterator1, class InputIterator2,

class BinaryPredicate>

§ 25.2.10

899

c(cid:13) ISO/IEC

N4296

pair<InputIterator1, InputIterator2>

mismatch(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, BinaryPredicate pred);

template<class InputIterator1, class InputIterator2>

pair<InputIterator1, InputIterator2>

mismatch(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2);

template <class InputIterator1, class InputIterator2,

class BinaryPredicate>

pair<InputIterator1, InputIterator2>

mismatch(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
BinaryPredicate pred);

1

2

(2.1)

(2.2)

(2.3)

3

j is in the range [first2, last2).
!(*i == *(first2 + (i - first1)))
pred(*i, *(first2 + (i - first1))) == false

Remarks: If last2 was not given in the argument list, it denotes first2 + (last1 - first1) below.
Returns: A pair of iterators i and j such that j == first2 + (i - first1) and i is the ﬁrst iterator
in the range [first1,last1) for which the following corresponding conditions hold:
—
—
—
Returns the pair first1 + min(last1 - first1, last2 - first2) and first2 + min(last1 -
first1, last2 - first2) if such an iterator i is not found.
Complexity: At most min(last1 - first1, last2 - first2) applications of the corresponding
predicate.

25.2.11 Equal
template<class InputIterator1, class InputIterator2>

bool equal(InputIterator1 first1, InputIterator1 last1,

InputIterator2 first2);

[alg.equal]

template<class InputIterator1, class InputIterator2,

class BinaryPredicate>

bool equal(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, BinaryPredicate pred);

template<class InputIterator1, class InputIterator2>

bool equal(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2);

template<class InputIterator1, class InputIterator2,

class BinaryPredicate>

bool equal(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
BinaryPredicate pred);

1

2

Remarks: If last2 was not given in the argument list, it denotes first2 + (last1 - first1) below.
Returns: If last1 - first1 != last2 - first2, return false. Otherwise return true if for every
iterator i in the range [first1,last1) the following corresponding conditions hold: *i == *(first2
+ (i - first1)), pred(*i, *(first2 + (i - first1))) != false. Otherwise, returns false.

§ 25.2.11

900

c(cid:13) ISO/IEC

N4296

3

1

2

3

4

1

2

Complexity: No applications of the corresponding predicate if InputIterator1 and InputIterator2
meet the requirements of random access iterators and last1 - first1 != last2 - first2. Other-
wise, at most min(last1 - first1, last2 - first2) applications of the corresponding predicate.
[alg.is_permutation]

25.2.12 Is permutation
template<class ForwardIterator1, class ForwardIterator2>

bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,

template<class ForwardIterator1, class ForwardIterator2,

ForwardIterator2 first2);

class BinaryPredicate>

bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, BinaryPredicate pred);

template<class ForwardIterator1, class ForwardIterator2>

bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);

template<class ForwardIterator1, class ForwardIterator2,

class BinaryPredicate>

bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);

Requires: ForwardIterator1 and ForwardIterator2 shall have the same value type. The comparison
function shall be an equivalence relation.
Remarks: If last2 was not given in the argument list, it denotes first2 + (last1 - first1) below.
Returns: If last1 - first1 != last2 - first2, return false. Otherwise return true if there exists
a permutation of the elements in the range [first2,first2 + (last1 - first1)), beginning with
ForwardIterator2 begin, such that equal(first1, last1, begin) returns true or equal(first1,
last1, begin, pred) returns true; otherwise, returns false.
Complexity: No applications of the corresponding predicate if ForwardIterator1 and ForwardIter-
ator2 meet the requirements of random access iterators and last1 - first1 != last2 - first2.
Otherwise, exactly distance(first1, last1) applications of the corresponding predicate if equal(
first1, last1, first2, last2) would return true if pred was not given in the argument list or
equal(first1, last1, first2, last2, pred) would return true if pred was given in the argument
list; otherwise, at worst O(N 2), where N has the value distance(first1, last1).

25.2.13 Search
template<class ForwardIterator1, class ForwardIterator2>

ForwardIterator1

search(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);

[alg.search]

template<class ForwardIterator1, class ForwardIterator2,

class BinaryPredicate>

ForwardIterator1

search(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);

Eﬀects: Finds a subsequence of equal values in a sequence.
Returns: The ﬁrst iterator i in the range [first1,last1 - (last2-first2)) such that for every
non-negative integer n less than last2 - first2 the following corresponding conditions hold: *(i +

§ 25.2.13

901

c(cid:13) ISO/IEC

N4296

n) == *(first2 + n), pred(*(i + n), *(first2 + n)) != false. Returns first1 if [first2,
last2) is empty, otherwise returns last1 if no such iterator is found.
Complexity: At most (last1 - first1) * (last2 - first2) applications of the corresponding
predicate.

template<class ForwardIterator, class Size, class T>

ForwardIterator

search_n(ForwardIterator first, ForwardIterator last, Size count,

const T& value);

template<class ForwardIterator, class Size, class T,

class BinaryPredicate>

ForwardIterator

search_n(ForwardIterator first, ForwardIterator last, Size count,

const T& value, BinaryPredicate pred);

Requires: The type Size shall be convertible to integral type (4.7, 12.3).
Eﬀects: Finds a subsequence of equal values in a sequence.
Returns: The ﬁrst iterator i in the range [first,last-count) such that for every non-negative integer
n less than count the following corresponding conditions hold: *(i + n) == value, pred(*(i +
n),value) != false. Returns last if no such iterator is found.
Complexity: At most last - first applications of the corresponding predicate.

25.3 Mutating sequence operations
25.3.1 Copy
template<class InputIterator, class OutputIterator>

OutputIterator copy(InputIterator first, InputIterator last,

OutputIterator result);

[alg.modifying.operations]
[alg.copy]

Eﬀects: Copies elements in the range [first,last) into the range [result,result + (last -
first)) starting from first and proceeding to last. For each non-negative integer n < (last -
first), performs *(result + n) = *(first + n).
Returns: result + (last - first).
Requires: result shall not be in the range [first,last).
Complexity: Exactly last - first assignments.

template<class InputIterator, class Size, class OutputIterator>

OutputIterator copy_n(InputIterator first, Size n,

OutputIterator result);

Eﬀects: For each non-negative integer i < n, performs *(result + i) = *(first + i).
Returns: result + n.
Complexity: Exactly n assignments.

template<class InputIterator, class OutputIterator, class Predicate>

OutputIterator copy_if(InputIterator first, InputIterator last,
OutputIterator result, Predicate pred);

Requires: The ranges [first,last) and [result,result + (last - first)) shall not overlap.
Eﬀects: Copies all of the elements referred to by the iterator i in the range [first,last) for which
pred(*i) is true.

§ 25.3.1

902

3

4

5

6

7

1

2

3

4

5

6

7

8

9

c(cid:13) ISO/IEC

N4296

Returns: The end of the resulting range.
Complexity: Exactly last - first applications of the corresponding predicate.
Remarks: Stable (17.6.5.7).

template<class BidirectionalIterator1, class BidirectionalIterator2>

BidirectionalIterator2

copy_backward(BidirectionalIterator1 first,
BidirectionalIterator1 last,
BidirectionalIterator2 result);

Eﬀects: Copies elements in the range [first,last) into the range [result - (last-first),result
) starting from last - 1 and proceeding to first.269 For each positive integer n <= (last - first),
performs *(result - n) = *(last - n).
Requires: result shall not be in the range (first,last].
Returns: result - (last - first).
Complexity: Exactly last - first assignments.

25.3.2 Move
template<class InputIterator, class OutputIterator>

OutputIterator move(InputIterator first, InputIterator last,

OutputIterator result);

[alg.move]

Eﬀects: Moves elements in the range [first,last) into the range [result,result + (last -
first)) starting from ﬁrst and proceeding to last. For each non-negative integer n < (last-first),
performs *(result + n) = std::move(*(first + n)).
Returns: result + (last - first).
Requires: result shall not be in the range [first,last).
Complexity: Exactly last - first move assignments.

template<class BidirectionalIterator1, class BidirectionalIterator2>

BidirectionalIterator2

move_backward(BidirectionalIterator1 first,
BidirectionalIterator1 last,
BidirectionalIterator2 result);

Eﬀects: Moves elements in the range [first,last) into the range [result - (last-first),result
) starting from last - 1 and proceeding to ﬁrst.270 For each positive integer n <= (last - first),
performs *(result - n) = std::move(*(last - n)).
Requires: result shall not be in the range (first,last].
Returns: result - (last - first).
Complexity: Exactly last - first assignments.

10

11

12

13

14

15

16

1

2

3

4

5

6

7

8

swap

25.3.3
template<class ForwardIterator1, class ForwardIterator2>

ForwardIterator2

swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,

ForwardIterator2 first2);

[alg.swap]

269) copy_backward should be used instead of copy when last is in the range [result - (last - first),result).
270) move_backward should be used instead of move when last is in the range [result - (last - first),result).

§ 25.3.3

903

c(cid:13) ISO/IEC

N4296

Eﬀects: For each non-negative integer n < (last1 - first1) performs: swap(*(first1 + n),
*(first2 + n)).
Requires: The two ranges [first1,last1) and [first2,first2 + (last1 - first1)) shall not
overlap. *(first1 + n) shall be swappable with (17.6.3.2) *(first2 + n).
Returns: first2 + (last1 - first1).
Complexity: Exactly last1 - first1 swaps.

template<class ForwardIterator1, class ForwardIterator2>
void iter_swap(ForwardIterator1 a, ForwardIterator2 b);

Eﬀects: swap(*a, *b).
Requires: a and b shall be dereferenceable. *a shall be swappable with (17.6.3.2) *b.

25.3.4 Transform
template<class InputIterator, class OutputIterator,

class UnaryOperation>

OutputIterator

transform(InputIterator first, InputIterator last,

OutputIterator result, UnaryOperation op);

[alg.transform]

template<class InputIterator1, class InputIterator2,
class OutputIterator, class BinaryOperation>

OutputIterator

transform(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, OutputIterator result,
BinaryOperation binary_op);

Eﬀects: Assigns through every iterator i in the range [result,result + (last1 - first1)) a
new corresponding value equal to op(*(first1 + (i - result)) or binary_op(*(first1 + (i -
result)), *(first2 + (i - result))).
Requires: op and binary_op shall not invalidate iterators or subranges, or modify elements in the
ranges [first1,last1], [first2,first2 + (last1 - first1)], and [result,result + (last1 -
first1)].271
Returns: result + (last1 - first1).
Complexity: Exactly last1 - first1 applications of op or binary_op.
Remarks: result may be equal to first in case of unary transform, or to first1 or first2 in case
of binary transform.

1

2

3

4

5

6

1

2

3

4

5

25.3.5 Replace
template<class ForwardIterator, class T>

void replace(ForwardIterator first, ForwardIterator last,

const T& old_value, const T& new_value);

[alg.replace]

template<class ForwardIterator, class Predicate, class T>

void replace_if(ForwardIterator first, ForwardIterator last,

Predicate pred, const T& new_value);

1

Requires: The expression *first = new_value shall be valid.

271) The use of fully closed ranges is intentional.

§ 25.3.5

904

2

3

4

5

6

7

1

2

3

4

c(cid:13) ISO/IEC

N4296

Eﬀects: Substitutes elements referred by the iterator i in the range [first,last) with new_value,
when the following corresponding conditions hold: *i == old_value, pred(*i) != false.
Complexity: Exactly last - first applications of the corresponding predicate.

template<class InputIterator, class OutputIterator, class T>

OutputIterator

replace_copy(InputIterator first, InputIterator last,

OutputIterator result,
const T& old_value, const T& new_value);

template<class InputIterator, class OutputIterator, class Predicate, class T>

OutputIterator

replace_copy_if(InputIterator first, InputIterator last,

OutputIterator result,
Predicate pred, const T& new_value);

Requires: The results of the expressions *first and new_value shall be writable to the result output
iterator. The ranges [first,last) and [result,result + (last - first)) shall not overlap.
Eﬀects: Assigns to every iterator i in the range [result,result + (last - first)) either new_-
value or *(first + (i - result)) depending on whether the following corresponding conditions
hold:

*(first + (i - result)) == old_value
pred(*(first + (i - result))) != false

Returns: result + (last - first).
Complexity: Exactly last - first applications of the corresponding predicate.

25.3.6 Fill
template<class ForwardIterator, class T>

void fill(ForwardIterator first, ForwardIterator last, const T& value);

template<class OutputIterator, class Size, class T>

OutputIterator fill_n(OutputIterator first, Size n, const T& value);

[alg.ﬁll]

Requires: The expression value shall be writable to the output iterator. The type Size shall be
convertible to an integral type (4.7, 12.3).
Eﬀects: The ﬁrst algorithm assigns value through all the iterators in the range [first,last). The
second algorithm assigns value through all the iterators in the range [first,first + n) if n is
positive, otherwise it does nothing.
Returns: fill_n returns first + n for non-negative values of n and first for negative values.
Complexity: Exactly last - first, n, or 0 assignments, respectively.

25.3.7 Generate
template<class ForwardIterator, class Generator>

void generate(ForwardIterator first, ForwardIterator last,

Generator gen);

[alg.generate]

template<class OutputIterator, class Size, class Generator>

OutputIterator generate_n(OutputIterator first, Size n, Generator gen);

§ 25.3.7

905

1

2

3

4

1

2

3

4

5

6

7

8

9

10

11

c(cid:13) ISO/IEC

N4296

Eﬀects: The ﬁrst algorithm invokes the function object gen and assigns the return value of gen through
all the iterators in the range [first,last). The second algorithm invokes the function object gen
and assigns the return value of gen through all the iterators in the range [first,first + n) if n is
positive, otherwise it does nothing.
Requires: gen takes no arguments, Size shall be convertible to an integral type (4.7, 12.3).
Returns: generate_n returns first + n for non-negative values of n and first for negative values.
Complexity: Exactly last - first, n, or 0 invocations of gen and assignments, respectively.

25.3.8 Remove
template<class ForwardIterator, class T>

ForwardIterator remove(ForwardIterator first, ForwardIterator last,

const T& value);

[alg.remove]

template<class ForwardIterator, class Predicate>

ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,

Predicate pred);

Requires: The type of *first shall satisfy the MoveAssignable requirements (Table 22).
Eﬀects: Eliminates all the elements referred to by iterator i in the range [first,last) for which the
following corresponding conditions hold: *i == value, pred(*i) != false.
Returns: The end of the resulting range.
Remarks: Stable (17.6.5.7).
Complexity: Exactly last - first applications of the corresponding predicate.
Note: each element in the range [ret,last), where ret is the returned value, has a valid but unspeci-
ﬁed state, because the algorithms can eliminate elements by moving from elements that were originally
in that range.

template<class InputIterator, class OutputIterator, class T>

OutputIterator

remove_copy(InputIterator first, InputIterator last,
OutputIterator result, const T& value);

template<class InputIterator, class OutputIterator, class Predicate>

OutputIterator

remove_copy_if(InputIterator first, InputIterator last,
OutputIterator result, Predicate pred);

Requires: The ranges [first,last) and [result,result + (last - first)) shall not overlap. The
expression *result = *first shall be valid.
Eﬀects: Copies all the elements referred to by the iterator i in the range [first,last) for which the
following corresponding conditions do not hold: *i == value, pred(*i) != false.
Returns: The end of the resulting range.
Complexity: Exactly last - first applications of the corresponding predicate.
Remarks: Stable (17.6.5.7).

25.3.9 Unique
template<class ForwardIterator>

ForwardIterator unique(ForwardIterator first, ForwardIterator last);

§ 25.3.9

[alg.unique]

906

1

2

3

4

5

6

7

8

1

2

3

c(cid:13) ISO/IEC

N4296

template<class ForwardIterator, class BinaryPredicate>

ForwardIterator unique(ForwardIterator first, ForwardIterator last,

BinaryPredicate pred);

Eﬀects: For a nonempty range, eliminates all but the ﬁrst element from every consecutive group of
equivalent elements referred to by the iterator i in the range [first + 1,last) for which the following
conditions hold: *(i - 1) == *i or pred(*(i - 1), *i) != false.
Requires: The comparison function shall be an equivalence relation. The type of *first shall satisfy
the MoveAssignable requirements (Table 22).
Returns: The end of the resulting range.
Complexity: For nonempty ranges, exactly (last - first) - 1 applications of the corresponding
predicate.

template<class InputIterator, class OutputIterator>

OutputIterator

unique_copy(InputIterator first, InputIterator last,

OutputIterator result);

template<class InputIterator, class OutputIterator,

class BinaryPredicate>

OutputIterator

unique_copy(InputIterator first, InputIterator last,

OutputIterator result, BinaryPredicate pred);

Requires: The comparison function shall be an equivalence relation. The ranges [first,last) and
[result,result+(last-first)) shall not overlap. The expression *result = *first shall be valid.
If neither InputIterator nor OutputIterator meets the requirements of forward iterator then the
value type of InputIterator shall be CopyConstructible (Table 21) and CopyAssignable (Table 23).
Otherwise CopyConstructible is not required.
Eﬀects: Copies only the ﬁrst element from every consecutive group of equal elements referred to by
the iterator i in the range [first,last) for which the following corresponding conditions hold: *i
== *(i - 1) or pred(*i, *(i - 1)) != false.
Returns: The end of the resulting range.
Complexity: For nonempty ranges, exactly last - first - 1 applications of the corresponding pred-
icate.

25.3.10 Reverse
template<class BidirectionalIterator>

void reverse(BidirectionalIterator first, BidirectionalIterator last);

[alg.reverse]

Eﬀects: For each non-negative integer i < (last - first)/2, applies iter_swap to all pairs of iter-
ators first + i, (last - i) - 1.
Requires: *first shall be swappable (17.6.3.2).
Complexity: Exactly (last - first)/2 swaps.

template<class BidirectionalIterator, class OutputIterator>

OutputIterator

reverse_copy(BidirectionalIterator first,

BidirectionalIterator last, OutputIterator result);

§ 25.3.10

907

4

5

6

7

1

2

3

4

5

6

7

8

9

1

2

3

4

c(cid:13) ISO/IEC

N4296

Eﬀects: Copies the range [first,last) to the range [result,result+(last-first)) such that for
every non-negative integer i < (last - first) the following assignment takes place: *(result +
(last - first) - 1 - i) = *(first + i).
Requires: The ranges [first,last) and [result,result+(last-first)) shall not overlap.
Returns: result + (last - first).
Complexity: Exactly last - first assignments.

25.3.11 Rotate
template<class ForwardIterator>

ForwardIterator rotate(ForwardIterator first, ForwardIterator middle,

ForwardIterator last);

[alg.rotate]

Eﬀects: For each non-negative integer i < (last - first), places the element from the position
first + i into position first + (i + (last - middle)) % (last - first).
Returns: first + (last - middle).
Remarks: This is a left rotate.
Requires: [first,middle) and [middle,last) shall be valid ranges. ForwardIterator shall satisfy
the requirements of ValueSwappable (17.6.3.2). The type of *first shall satisfy the requirements of
MoveConstructible (Table 20) and the requirements of MoveAssignable (Table 22).
Complexity: At most last - first swaps.

template<class ForwardIterator, class OutputIterator>

OutputIterator

rotate_copy(ForwardIterator first, ForwardIterator middle,
ForwardIterator last, OutputIterator result);

Eﬀects: Copies the range [first,last) to the range [result,result + (last - first)) such that
for each non-negative integer i < (last - first) the following assignment takes place: *(result +
i) = *(first + (i + (middle - first)) % (last - first)).
Returns: result + (last - first).
Requires: The ranges [first,last) and [result,result + (last - first)) shall not overlap.
Complexity: Exactly last - first assignments.

25.3.12 Shuﬄe
template<class RandomAccessIterator, class UniformRandomNumberGenerator>

void shuffle(RandomAccessIterator first,

RandomAccessIterator last,
UniformRandomNumberGenerator&& g);

[alg.random.shuﬄe]

Eﬀects: Permutes the elements in the range [first,last) such that each possible permutation of
those elements has equal probability of appearance.
Requires: RandomAccessIterator shall satisfy the requirements of ValueSwappable (17.6.3.2). The
type UniformRandomNumberGenerator shall meet the requirements of a uniform random number gen-
erator (26.5.1.3) type whose return type is convertible to iterator_traits<RandomAccessItera-
tor>::difference_type.
Complexity: Exactly (last - first) - 1 swaps.
Remarks: To the extent that the implementation of this function makes use of random numbers, the
object g shall serve as the implementation’s source of randomness.

§ 25.3.12

908

c(cid:13) ISO/IEC

25.3.13 Partitions
template <class InputIterator, class Predicate>

bool is_partitioned(InputIterator first, InputIterator last, Predicate pred);

N4296

[alg.partitions]

Requires: InputIterator’s value type shall be convertible to Predicate’s argument type.
Returns: true if [first,last) is empty or if [first,last) is partitioned by pred, i.e. if all elements
that satisfy pred appear before those that do not.
Complexity: Linear. At most last - first applications of pred.

template<class ForwardIterator, class Predicate>

ForwardIterator

partition(ForwardIterator first,

ForwardIterator last, Predicate pred);

Eﬀects: Places all the elements in the range [first,last) that satisfy pred before all the elements
that do not satisfy it.
Returns: An iterator i such that for every iterator j in the range [first,i) pred(*j) != false,
and for every iterator k in the range [i,last), pred(*k) == false.
Requires: ForwardIterator shall satisfy the requirements of ValueSwappable (17.6.3.2).
Complexity: If ForwardIterator meets the requirements for a BidirectionalIterator, at most (last -
first) / 2 swaps are done; otherwise at most last - first swaps are done. Exactly last - first
applications of the predicate are done.

template<class BidirectionalIterator, class Predicate>

BidirectionalIterator

stable_partition(BidirectionalIterator first,

BidirectionalIterator last, Predicate pred);

Eﬀects: Places all the elements in the range [first,last) that satisfy pred before all the elements
that do not satisfy it.
Returns: An iterator i such that for every iterator j in the range [first,i), pred(*j) != false, and
for every iterator k in the range [i,last), pred(*k) == false. The relative order of the elements in
both groups is preserved.
Requires: BidirectionalIterator shall satisfy the requirements of ValueSwappable (17.6.3.2). The
type of *first shall satisfy the requirements of MoveConstructible (Table 20) and of MoveAssignable
(Table 22).
Complexity: At most (last - first) * log(last - first) swaps, but only linear number of swaps
if there is enough extra memory. Exactly last - first applications of the predicate.

template <class InputIterator, class OutputIterator1,

class OutputIterator2, class Predicate>

pair<OutputIterator1, OutputIterator2>
partition_copy(InputIterator first, InputIterator last,

OutputIterator1 out_true, OutputIterator2 out_false,
Predicate pred);

Requires: InputIterator’s value type shall be CopyAssignable, and shall be writable to the out_true
and out_false OutputIterators, and shall be convertible to Predicate’s argument type. The input
range shall not overlap with either of the output ranges.
Eﬀects: For each iterator i in [first,last), copies *i to the output range beginning with out_true
if pred(*i) is true, or to the output range beginning with out_false otherwise.

§ 25.3.13

909

1

2

3

4

5

6

7

8

9

10

11

12

13

c(cid:13) ISO/IEC

N4296

Returns: A pair p such that p.first is the end of the output range beginning at out_true and
p.second is the end of the output range beginning at out_false.
Complexity: Exactly last - first applications of pred.

template<class ForwardIterator, class Predicate>

ForwardIterator partition_point(ForwardIterator first,
ForwardIterator last,
Predicate pred);

Requires: ForwardIterator’s value type shall be convertible to Predicate’s argument type. [first,
last) shall be partitioned by pred, i.e. all elements that satisfy pred shall appear before those that
do not.
Returns: An iterator mid such that all_of(first, mid, pred) and none_of(mid, last, pred) are
both true.
Complexity: O(log(last − f irst)) applications of pred.

14

15

16

17

18

25.4 Sorting and related operations

[alg.sorting]
1 All the operations in 25.4 have two versions: one that takes a function object of type Compare and one that

uses an operator<.

2 Compare is a function object type (20.9). The return value of the function call operation applied to an
object of type Compare, when contextually converted to bool (Clause 4), yields true if the ﬁrst argument
of the call is less than the second, and false otherwise. Compare comp is used throughout for algorithms
assuming an ordering relation. It is assumed that comp will not apply any non-constant function through
the dereferenced iterator.

3 For all algorithms that take Compare, there is a version that uses operator< instead. That is, comp(*i,
*j) != false defaults to *i < *j != false. For algorithms other than those described in 25.4.3 to work
correctly, comp has to induce a strict weak ordering on the values.

4 The term strict refers to the requirement of an irreﬂexive relation (!comp(x, x) for all x), and the term weak
to requirements that are not as strong as those for a total ordering, but stronger than those for a partial
ordering. If we deﬁne equiv(a, b) as !comp(a, b) && !comp(b, a), then the requirements are that comp
and equiv both be transitive relations:

(4.1)

(4.2)

—
—

(4.2.1)

(4.2.2)

(4.2.3)

comp(a, b) && comp(b, c) implies comp(a, c)
equiv(a, b) && equiv(b, c) implies equiv(a, c) [ Note: Under these conditions, it can be shown
that
—
—
—

equiv is an equivalence relation
comp induces a well-deﬁned relation on the equivalence classes determined by equiv
The induced relation is a strict total ordering. — end note ]

5 A sequence is sorted with respect to a comparator comp if for every iterator i pointing to the sequence and
every non-negative integer n such that i + n is a valid iterator pointing to an element of the sequence,
comp(*(i + n), *i) == false.

7

6 A sequence [start,finish) is partitioned with respect to an expression f(e) if there exists an integer n

such that for all 0 <= i < distance(start, finish), f(*(start + i)) is true if and only if i < n.
In the descriptions of the functions that deal with ordering relationships we frequently use a notion of
equivalence to describe concepts such as stability. The equivalence to which we refer is not necessarily an
operator==, but an equivalence relation induced by the strict weak ordering. That is, two elements a and
b are considered equivalent if and only if !(a < b) && !(b < a).

§ 25.4

910

c(cid:13) ISO/IEC

25.4.1 Sorting
25.4.1.1 sort
template<class RandomAccessIterator>

void sort(RandomAccessIterator first, RandomAccessIterator last);

N4296

[alg.sort]
[sort]

template<class RandomAccessIterator, class Compare>

void sort(RandomAccessIterator first, RandomAccessIterator last,

Compare comp);

Eﬀects: Sorts the elements in the range [first,last).
Requires: RandomAccessIterator shall satisfy the requirements of ValueSwappable (17.6.3.2). The
type of *first shall satisfy the requirements of MoveConstructible (Table 20) and of MoveAssignable
(Table 22).
Complexity: O(N log(N)) (where N == last - first) comparisons.

25.4.1.2 stable_sort
template<class RandomAccessIterator>

void stable_sort(RandomAccessIterator first, RandomAccessIterator last);

[stable.sort]

template<class RandomAccessIterator, class Compare>

void stable_sort(RandomAccessIterator first, RandomAccessIterator last,

Compare comp);

Eﬀects: Sorts the elements in the range [first,last).
Requires: RandomAccessIterator shall satisfy the requirements of ValueSwappable (17.6.3.2). The
type of *first shall satisfy the requirements of MoveConstructible (Table 20) and of MoveAssignable
(Table 22).
Complexity: It does at most N log2(N) (where N == last - first) comparisons; if enough extra
memory is available, it is N log(N).
Remarks: Stable (17.6.5.7).

25.4.1.3 partial_sort
template<class RandomAccessIterator>

void partial_sort(RandomAccessIterator first,
RandomAccessIterator middle,
RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>

void partial_sort(RandomAccessIterator first,
RandomAccessIterator middle,
RandomAccessIterator last,
Compare comp);

[partial.sort]

Eﬀects: Places the ﬁrst middle - first sorted elements from the range [first,last) into the range
[first,middle). The rest of the elements in the range [middle,last) are placed in an unspeciﬁed
order.
Requires: RandomAccessIterator shall satisfy the requirements of ValueSwappable (17.6.3.2). The
type of *first shall satisfy the requirements of MoveConstructible (Table 20) and of MoveAssignable
(Table 22).
Complexity: It takes approximately (last - first) * log(middle - first) comparisons.

§ 25.4.1.3

911

1

2

3

1

2

3

4

1

2

3

c(cid:13) ISO/IEC

25.4.1.4 partial_sort_copy
template<class InputIterator, class RandomAccessIterator>

RandomAccessIterator

partial_sort_copy(InputIterator first, InputIterator last,

RandomAccessIterator result_first,
RandomAccessIterator result_last);

N4296

[partial.sort.copy]

template<class InputIterator, class RandomAccessIterator,

class Compare>
RandomAccessIterator

partial_sort_copy(InputIterator first, InputIterator last,

RandomAccessIterator result_first,
RandomAccessIterator result_last,
Compare comp);

1

2

3

4

1

2

3

4

Eﬀects: Places the ﬁrst min(last - first, result_last - result_first) sorted elements into the
range [result_first,result_first + min(last - first, result_last - result_first)).
Returns: The smaller of: result_last or result_first + (last - first).
Requires: RandomAccessIterator shall satisfy the requirements of ValueSwappable (17.6.3.2). The
type of *result_first shall satisfy the requirements of MoveConstructible (Table 20) and of Move-
Assignable (Table 22).
Complexity: Approximately (last - first) * log(min(last - first, result_last - result_-
first)) comparisons.

25.4.1.5 is_sorted
template<class ForwardIterator>

bool is_sorted(ForwardIterator first, ForwardIterator last);

Returns: is_sorted_until(first, last) == last

[is.sorted]

template<class ForwardIterator, class Compare>

bool is_sorted(ForwardIterator first, ForwardIterator last,

Compare comp);
Returns: is_sorted_until(first, last, comp) == last

template<class ForwardIterator>

ForwardIterator is_sorted_until(ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>

ForwardIterator is_sorted_until(ForwardIterator first, ForwardIterator last,

Compare comp);
Returns: If distance(first, last) < 2, returns last. Otherwise, returns the last iterator i in
[first,last] for which the range [first,i) is sorted.
Complexity: Linear.
25.4.2 Nth element
template<class RandomAccessIterator>

[alg.nth.element]

void nth_element(RandomAccessIterator first, RandomAccessIterator nth,

RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>

void nth_element(RandomAccessIterator first, RandomAccessIterator nth,

RandomAccessIterator last,

Compare comp);

§ 25.4.2

912

c(cid:13) ISO/IEC

N4296

1

2

3

After nth_element the element in the position pointed to by nth is the element that would be in that
position if the whole range were sorted, unless nth == last. Also for every iterator i in the range
[first,nth) and every iterator j in the range [nth,last) it holds that: !(*j < *i) or comp(*j,
*i) == false.
Requires: RandomAccessIterator shall satisfy the requirements of ValueSwappable (17.6.3.2). The
type of *first shall satisfy the requirements of MoveConstructible (Table 20) and of MoveAssignable
(Table 22).
Complexity: Linear on average.

25.4.3 Binary search

[alg.binary.search]
1 All of the algorithms in this section are versions of binary search and assume that the sequence being
searched is partitioned with respect to an expression formed by binding the search key to an argument of
the implied or explicit comparison function. They work on non-random access iterators minimizing the
number of comparisons, which will be logarithmic for all types of iterators. They are especially appropriate
for random access iterators, because these algorithms do a logarithmic number of steps through the data
structure. For non-random access iterators they execute a linear number of steps.
25.4.3.1 lower_bound
template<class ForwardIterator, class T>

[lower.bound]

ForwardIterator

lower_bound(ForwardIterator first, ForwardIterator last,

const T& value);

1

2

3

1

2

template<class ForwardIterator, class T, class Compare>

ForwardIterator

lower_bound(ForwardIterator first, ForwardIterator last,

const T& value, Compare comp);

Requires: The elements e of [first,last) shall be partitioned with respect to the expression e <
value or comp(e, value).
Returns: The furthermost iterator i in the range [first,last] such that for every iterator j in the
range [first,i) the following corresponding conditions hold: *j < value or comp(*j, value) !=
false.
Complexity: At most log2(last - first) + O(1) comparisons.

25.4.3.2 upper_bound
template<class ForwardIterator, class T>

ForwardIterator

upper_bound(ForwardIterator first, ForwardIterator last,

const T& value);

[upper.bound]

template<class ForwardIterator, class T, class Compare>

ForwardIterator

upper_bound(ForwardIterator first, ForwardIterator last,

const T& value, Compare comp);

Requires: The elements e of [first,last) shall be partitioned with respect to the expression !(value
< e) or !comp(value, e).
Returns: The furthermost iterator i in the range [first,last] such that for every iterator j in the
range [first,i) the following corresponding conditions hold: !(value < *j) or comp(value, *j)
== false.

§ 25.4.3.2

913

c(cid:13) ISO/IEC

3

Complexity: At most log2(last - first) + O(1) comparisons.

25.4.3.3 equal_range
template<class ForwardIterator, class T>
pair<ForwardIterator, ForwardIterator>

equal_range(ForwardIterator first,

ForwardIterator last, const T& value);

N4296

[equal.range]

1

2

3

1

2

3

template<class ForwardIterator, class T, class Compare>

pair<ForwardIterator, ForwardIterator>

equal_range(ForwardIterator first,

ForwardIterator last, const T& value,
Compare comp);

Requires: The elements e of [first,last) shall be partitioned with respect to the expressions e
< value and !(value < e) or comp(e, value) and !comp(value, e). Also, for all elements e of
[first, last), e < value shall imply !(value < e) or comp(e, value) shall imply !comp(value,
e).
Returns:

make_pair(lower_bound(first, last, value),
upper_bound(first, last, value))

or

make_pair(lower_bound(first, last, value, comp),
upper_bound(first, last, value, comp))

Complexity: At most 2 ∗ log2(last - first) + O(1) comparisons.

25.4.3.4 binary_search
template<class ForwardIterator, class T>

bool binary_search(ForwardIterator first, ForwardIterator last,

const T& value);

[binary.search]

template<class ForwardIterator, class T, class Compare>

bool binary_search(ForwardIterator first, ForwardIterator last,

const T& value, Compare comp);

Requires: The elements e of [first,last) are partitioned with respect to the expressions e < value
and !(value < e) or comp(e, value) and !comp(value, e). Also, for all elements e of [first,
last), e < value implies !(value < e) or comp(e, value) implies !comp(value, e).
Returns: true if there is an iterator i in the range [first,last) that satisﬁes the corresponding condi-
tions: !(*i < value) && !(value < *i) or comp(*i, value) == false && comp(value, *i) ==
false.
Complexity: At most log2(last - first) + O(1) comparisons.

25.4.4 Merge
template<class InputIterator1, class InputIterator2,

class OutputIterator>

OutputIterator

merge(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,

§ 25.4.4

[alg.merge]

914

c(cid:13) ISO/IEC

OutputIterator result);

N4296

template<class InputIterator1, class InputIterator2,

class OutputIterator, class Compare>

OutputIterator

merge(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);

1

2

3

4

5

6

7

8

9

Eﬀects: Copies all the elements of the two ranges [first1,last1) and [first2,last2) into the range
[result,result_last), where result_last is result + (last1 - first1) + (last2 - first2),
such that the resulting range satisﬁes is_sorted(result, result_last) or is_sorted(result,
result_last, comp), respectively.
Requires: The ranges [first1,last1) and [first2,last2) shall be sorted with respect to operator<
or comp. The resulting range shall not overlap with either of the original ranges.
Returns: result + (last1 - first1) + (last2 - first2).
Complexity: At most (last1 - first1) + (last2 - first2) - 1 comparisons.
Remarks: Stable (17.6.5.7).

template<class BidirectionalIterator>

void inplace_merge(BidirectionalIterator first,
BidirectionalIterator middle,
BidirectionalIterator last);

template<class BidirectionalIterator, class Compare>

void inplace_merge(BidirectionalIterator first,
BidirectionalIterator middle,
BidirectionalIterator last, Compare comp);

Eﬀects: Merges two sorted consecutive ranges [first,middle) and [middle,last), putting the result
of the merge into the range [first,last). The resulting range will be in non-decreasing order; that is,
for every iterator i in [first,last) other than first, the condition *i < *(i - 1) or, respectively,
comp(*i, *(i - 1)) will be false.
Requires: The ranges [first,middle) and [middle,last) shall be sorted with respect to operator<
or comp. BidirectionalIterator shall satisfy the requirements of ValueSwappable (17.6.3.2). The
type of *first shall satisfy the requirements of MoveConstructible (Table 20) and of MoveAssignable
(Table 22).
Complexity: When enough additional memory is available, (last - first) - 1 comparisons. If no
additional memory is available, an algorithm with complexity N log(N) (where N is equal to last -
first) may be used.
Remarks: Stable (17.6.5.7).

25.4.5 Set operations on sorted structures

[alg.set.operations]
1 This section deﬁnes all the basic set operations on sorted structures. They also work with multisets (23.4.7)
containing multiple copies of equivalent elements. The semantics of the set operations are generalized to
multisets in a standard way by deﬁning set_union() to contain the maximum number of occurrences of
every element, set_intersection() to contain the minimum, and so on.
25.4.5.1 includes
template<class InputIterator1, class InputIterator2>

[includes]

bool includes(InputIterator1 first1, InputIterator1 last1,

§ 25.4.5.1

915

c(cid:13) ISO/IEC

N4296

InputIterator2 first2, InputIterator2 last2);

template<class InputIterator1, class InputIterator2, class Compare>

bool includes(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
Compare comp);

Returns: true if [first2,last2) is empty or if every element in the range [first2,last2) is con-
tained in the range [first1,last1). Returns false otherwise.
Complexity: At most 2 * ((last1 - first1) + (last2 - first2)) - 1 comparisons.

25.4.5.2 set_union
template<class InputIterator1, class InputIterator2,

class OutputIterator>

OutputIterator

set_union(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);

[set.union]

template<class InputIterator1, class InputIterator2,

class OutputIterator, class Compare>

OutputIterator

set_union(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);

Eﬀects: Constructs a sorted union of the elements from the two ranges; that is, the set of elements
that are present in one or both of the ranges.
Requires: The resulting range shall not overlap with either of the original ranges.
Returns: The end of the constructed range.
Complexity: At most 2 * ((last1 - first1) + (last2 - first2)) - 1 comparisons.
Remarks: If [first1,last1) contains m elements that are equivalent to each other and [first2,
last2) contains n elements that are equivalent to them, then all m elements from the ﬁrst range shall
be copied to the output range, in order, and then max(n − m, 0) elements from the second range shall
be copied to the output range, in order.

25.4.5.3 set_intersection
template<class InputIterator1, class InputIterator2,

class OutputIterator>

OutputIterator

set_intersection(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);

[set.intersection]

template<class InputIterator1, class InputIterator2,

class OutputIterator, class Compare>

OutputIterator

set_intersection(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);

Eﬀects: Constructs a sorted intersection of the elements from the two ranges; that is, the set of elements
that are present in both of the ranges.

§ 25.4.5.3

916

1

2

1

2

3

4

5

1

c(cid:13) ISO/IEC

N4296

Requires: The resulting range shall not overlap with either of the original ranges.
Returns: The end of the constructed range.
Complexity: At most 2 * ((last1 - first1) + (last2 - first2)) - 1 comparisons.
Remarks: If [first1,last1) contains m elements that are equivalent to each other and [first2,
last2) contains n elements that are equivalent to them, the ﬁrst min(m, n) elements shall be copied
from the ﬁrst range to the output range, in order.

25.4.5.4 set_difference
template<class InputIterator1, class InputIterator2,

class OutputIterator>

OutputIterator

set_difference(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);

[set.diﬀerence]

template<class InputIterator1, class InputIterator2,

class OutputIterator, class Compare>

OutputIterator

set_difference(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);

Eﬀects: Copies the elements of the range [first1,last1) which are not present in the range [first2,
last2) to the range beginning at result. The elements in the constructed range are sorted.
Requires: The resulting range shall not overlap with either of the original ranges.
Returns: The end of the constructed range.
Complexity: At most 2 * ((last1 - first1) + (last2 - first2)) - 1 comparisons.
Remarks: If [first1,last1) contains m elements that are equivalent to each other and [first2,
last2) contains n elements that are equivalent to them, the last max(m−n, 0) elements from [first1,
last1) shall be copied to the output range.

25.4.5.5 set_symmetric_difference
template<class InputIterator1, class InputIterator2,

class OutputIterator>

OutputIterator

set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);

[set.symmetric.diﬀerence]

template<class InputIterator1, class InputIterator2,

class OutputIterator, class Compare>

OutputIterator

set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);

Eﬀects: Copies the elements of the range [first1,last1) that are not present in the range [first2,
last2), and the elements of the range [first2,last2) that are not present in the range [first1,
last1) to the range beginning at result. The elements in the constructed range are sorted.
Requires: The resulting range shall not overlap with either of the original ranges.
Returns: The end of the constructed range.

§ 25.4.5.5

917

2

3

4

5

1

2

3

4

5

1

2

3

c(cid:13) ISO/IEC

N4296

4

5

Complexity: At most 2 * ((last1 - first1) + (last2 - first2)) - 1 comparisons.
Remarks: If [first1,last1) contains m elements that are equivalent to each other and [first2,
last2) contains n elements that are equivalent to them, then |m− n| of those elements shall be copied
to the output range: the last m − n of these elements from [first1,last1) if m > n, and the last
n − m of these elements from [first2,last2) if m < n.

25.4.6 Heap operations

[alg.heap.operations]
1 A heap is a particular organization of elements in a range between two random access iterators [a,b). Its

two key properties are:
(1) There is no element greater than *a in the range and
(2) *a may be removed by pop_heap(), or a new element added by push_heap(), in O(log(N)) time.

2 These properties make heaps useful as priority queues.
3 make_heap() converts a range into a heap and sort_heap() turns a heap into a sorted sequence.

25.4.6.1 push_heap
template<class RandomAccessIterator>

void push_heap(RandomAccessIterator first, RandomAccessIterator last);

[push.heap]

template<class RandomAccessIterator, class Compare>

void push_heap(RandomAccessIterator first, RandomAccessIterator last,

Compare comp);

1

2

3

1

2

3

Eﬀects: Places the value in the location last - 1 into the resulting heap [first,last).
Requires: The range [first,last - 1) shall be a valid heap. The type of *first shall satisfy the
MoveConstructible requirements (Table 20) and the MoveAssignable requirements (Table 22).
Complexity: At most log(last - first) comparisons.

25.4.6.2 pop_heap
template<class RandomAccessIterator>

void pop_heap(RandomAccessIterator first, RandomAccessIterator last);

[pop.heap]

template<class RandomAccessIterator, class Compare>

void pop_heap(RandomAccessIterator first, RandomAccessIterator last,

Compare comp);

Requires: The range [first,last) shall be a valid non-empty heap. RandomAccessIterator shall sat-
isfy the requirements of ValueSwappable (17.6.3.2). The type of *first shall satisfy the requirements
of MoveConstructible (Table 20) and of MoveAssignable (Table 22).
Eﬀects: Swaps the value in the location first with the value in the location last - 1 and makes
[first,last - 1) into a heap.
Complexity: At most 2 * log(last - first) comparisons.

25.4.6.3 make_heap
template<class RandomAccessIterator>

void make_heap(RandomAccessIterator first, RandomAccessIterator last);

[make.heap]

template<class RandomAccessIterator, class Compare>

void make_heap(RandomAccessIterator first, RandomAccessIterator last,

Compare comp);

§ 25.4.6.3

918

1

2

3

1

2

3

1

2

3

4

1

2

3

c(cid:13) ISO/IEC

N4296

Eﬀects: Constructs a heap out of the range [first,last).
Requires: The type of *first shall satisfy the MoveConstructible requirements (Table 20) and the
MoveAssignable requirements (Table 22).
Complexity: At most 3 * (last - first) comparisons.

25.4.6.4 sort_heap
template<class RandomAccessIterator>

void sort_heap(RandomAccessIterator first, RandomAccessIterator last);

[sort.heap]

template<class RandomAccessIterator, class Compare>

void sort_heap(RandomAccessIterator first, RandomAccessIterator last,

Compare comp);

Eﬀects: Sorts elements in the heap [first,last).
Requires: The range [first,last) shall be a valid heap. RandomAccessIterator shall satisfy the
requirements of ValueSwappable (17.6.3.2). The type of *first shall satisfy the requirements of
MoveConstructible (Table 20) and of MoveAssignable (Table 22).
Complexity: At most N log(N) comparisons (where N == last - first).

25.4.6.5 is_heap

[is.heap]

template<class RandomAccessIterator>

bool is_heap(RandomAccessIterator first, RandomAccessIterator last);
Returns: is_heap_until(first, last) == last

template<class RandomAccessIterator, class Compare>

bool is_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);
Returns: is_heap_until(first, last, comp) == last

template<class RandomAccessIterator>

RandomAccessIterator is_heap_until(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>

RandomAccessIterator is_heap_until(RandomAccessIterator first, RandomAccessIterator last,

Compare comp);
Returns: If distance(first, last) < 2, returns last. Otherwise, returns the last iterator i in
[first,last] for which the range [first,i) is a heap.
Complexity: Linear.

25.4.7 Minimum and maximum
template<class T> constexpr const T& min(const T& a, const T& b);
template<class T, class Compare>

constexpr const T& min(const T& a, const T& b, Compare comp);

Requires: Type T is LessThanComparable (Table 18).
Returns: The smaller value.
Remarks: Returns the ﬁrst argument when the arguments are equivalent.

[alg.min.max]

template<class T>

constexpr T min(initializer_list<T> t);

template<class T, class Compare>

constexpr T min(initializer_list<T> t, Compare comp);

§ 25.4.7

919

c(cid:13) ISO/IEC

N4296

Requires: T is LessThanComparable and CopyConstructible and t.size() > 0.
Returns: The smallest value in the initializer_list.
Remarks: Returns a copy of the leftmost argument when several arguments are equivalent to the
smallest.

template<class T> constexpr const T& max(const T& a, const T& b);
template<class T, class Compare>

constexpr const T& max(const T& a, const T& b, Compare comp);

Requires: Type T is LessThanComparable (Table 18).
Returns: The larger value.
Remarks: Returns the ﬁrst argument when the arguments are equivalent.

template<class T>

constexpr T max(initializer_list<T> t);

template<class T, class Compare>

constexpr T max(initializer_list<T> t, Compare comp);

Requires: T is LessThanComparable and CopyConstructible and t.size() > 0.
Returns: The largest value in the initializer_list.
Remarks: Returns a copy of the leftmost argument when several arguments are equivalent to the
largest.

template<class T> constexpr pair<const T&, const T&> minmax(const T& a, const T& b);
template<class T, class Compare>

constexpr pair<const T&, const T&> minmax(const T& a, const T& b, Compare comp);

Requires: Type T shall be LessThanComparable (Table 18).
Returns: pair<const T&, const T&>(b, a) if b is smaller than a, and pair<const T&, const
T&>(a, b) otherwise.
Remarks: Returns pair<const T&, const T&>(a, b) when the arguments are equivalent.
Complexity: Exactly one comparison.

template<class T>

constexpr pair<T, T> minmax(initializer_list<T> t);

template<class T, class Compare>

constexpr pair<T, T> minmax(initializer_list<T> t, Compare comp);

Requires: T is LessThanComparable and CopyConstructible and t.size() > 0.
Returns: pair<T, T>(x, y), where x has the smallest and y has the largest value in the initializer
list.
Remarks: x is a copy of the leftmost argument when several arguments are equivalent to the smallest.
y is a copy of the rightmost argument when several arguments are equivalent to the largest.
Complexity: At most (3/2) * t.size() applications of the corresponding predicate.

template<class ForwardIterator>

ForwardIterator min_element(ForwardIterator first, ForwardIterator last);

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

template<class ForwardIterator, class Compare>

ForwardIterator min_element(ForwardIterator first, ForwardIterator last,

Compare comp);

§ 25.4.7

920

21

22

23

24

25

26

1

2

3

c(cid:13) ISO/IEC

N4296

Returns: The ﬁrst iterator i in the range [first,last) such that for every iterator j in the range
[first,last) the following corresponding conditions hold: !(*j < *i) or comp(*j, *i) == false.
Returns last if first == last.
Complexity: Exactly max((last - first) - 1, 0) applications of the corresponding comparisons.

template<class ForwardIterator>

ForwardIterator max_element(ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>

ForwardIterator max_element(ForwardIterator first, ForwardIterator last,

Compare comp);

Returns: The ﬁrst iterator i in the range [first,last) such that for every iterator j in the range
[first,last) the following corresponding conditions hold: !(*i < *j) or comp(*i, *j) == false.
Returns last if first == last.
Complexity: Exactly max((last - first) - 1, 0) applications of the corresponding comparisons.

template<class ForwardIterator>

pair<ForwardIterator, ForwardIterator>

minmax_element(ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>

pair<ForwardIterator, ForwardIterator>

minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);
Returns: make_pair(first, first) if [first,last) is empty, otherwise make_pair(m, M), where m
is the ﬁrst iterator in [first,last) such that no iterator in the range refers to a smaller element, and
where M is the last iterator 272 in [first,last) such that no iterator in the range refers to a larger
element.
Complexity: At most max(b 3
distance(first, last).

2(N − 1)c, 0) applications of the corresponding predicate, where N is

25.4.8 Lexicographical comparison
template<class InputIterator1, class InputIterator2>

[alg.lex.comparison]

bool

bool

lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2);

template<class InputIterator1, class InputIterator2, class Compare>

lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
Compare comp);

Returns: true if the sequence of elements deﬁned by the range [first1,last1) is lexicographically
less than the sequence of elements deﬁned by the range [first2,last2) and false otherwise.
Complexity: At most 2*min((last1 - first1), (last2 - first2)) applications of the correspond-
ing comparison.
Remarks: If two sequences have the same number of elements and their corresponding elements are
equivalent, then neither sequence is lexicographically less than the other. If one sequence is a preﬁx
of the other, then the shorter sequence is lexicographically less than the longer sequence. Otherwise,
the lexicographical comparison of the sequences yields the same result as the comparison of the ﬁrst
corresponding pair of elements that are not equivalent.

272) This behavior intentionally diﬀers from max_element().

§ 25.4.8

921

c(cid:13) ISO/IEC

N4296

for ( ; first1 != last1 && first2 != last2 ; ++first1, ++first2) {

if (*first1 < *first2) return true;
if (*first2 < *first1) return false;

}
return first1 == last1 && first2 != last2;

4

1

2

3

4

5

6

7

Remarks: An empty sequence is lexicographically less than any non-empty sequence, but not less than
any empty sequence.

25.4.9 Permutation generators
template<class BidirectionalIterator>

bool next_permutation(BidirectionalIterator first,
BidirectionalIterator last);

template<class BidirectionalIterator, class Compare>
bool next_permutation(BidirectionalIterator first,

BidirectionalIterator last, Compare comp);

[alg.permutation.generators]

Eﬀects: Takes a sequence deﬁned by the range [first,last) and transforms it into the next permu-
tation. The next permutation is found by assuming that the set of all permutations is lexicographically
sorted with respect to operator< or comp. If such a permutation exists, it returns true. Otherwise, it
transforms the sequence into the smallest permutation, that is, the ascendingly sorted one, and returns
false.
Requires: BidirectionalIterator shall satisfy the requirements of ValueSwappable (17.6.3.2).
Complexity: At most (last - first)/2 swaps.

template<class BidirectionalIterator>

bool prev_permutation(BidirectionalIterator first,
BidirectionalIterator last);

template<class BidirectionalIterator, class Compare>
bool prev_permutation(BidirectionalIterator first,

BidirectionalIterator last, Compare comp);

Eﬀects: Takes a sequence deﬁned by the range [first,last) and transforms it into the previous
permutation. The previous permutation is found by assuming that the set of all permutations is
lexicographically sorted with respect to operator< or comp.
Returns: true if such a permutation exists. Otherwise, it transforms the sequence into the largest
permutation, that is, the descendingly sorted one, and returns false.
Requires: BidirectionalIterator shall satisfy the requirements of ValueSwappable (17.6.3.2).
Complexity: At most (last - first)/2 swaps.

25.5 C library algorithms

1 Table 113 describes some of the contents of the header <cstdlib>.

[alg.c.library]

Table 113 — Header <cstdlib> synopsis

Type

Name(s)

Type:
Functions:

size_t
bsearch

qsort

2 The contents are the same as the Standard C library header <stdlib.h> with the following exceptions:

§ 25.5

922

c(cid:13) ISO/IEC

3 The function signature:

bsearch(const void *, const void *, size_t, size_t,

int (*)(const void *, const void *));

is replaced by the two declarations:

N4296

extern "C" void* bsearch(const void* key, const void* base,

extern "C++" void* bsearch(const void* key, const void* base,

size_t nmemb, size_t size,
int (*compar)(const void*, const void*));

size_t nmemb, size_t size,
int (*compar)(const void*, const void*));

both of which have the same behavior as the original declaration.

4 The function signature:

qsort(void *, size_t, size_t,

int (*)(const void *, const void *));

is replaced by the two declarations:

extern "C" void qsort(void* base, size_t nmemb, size_t size,

int (*compar)(const void*, const void*));
extern "C++" void qsort(void* base, size_t nmemb, size_t size,

int (*compar)(const void*, const void*));

both of which have the same behavior as the original declaration. The behavior is undeﬁned unless the
objects in the array pointed to by base are of trivial type.
[ Note: Because the function argument compar() may throw an exception, bsearch() and qsort() are
allowed to propagate the exception (17.6.5.12). — end note ]
See also: ISO C 7.10.5.

§ 25.5

923

c(cid:13) ISO/IEC

26 Numerics library
26.1 General

N4296

[numerics]
[numerics.general]

1 This Clause describes components that C++ programs may use to perform seminumerical operations.
2 The following subclauses describe components for complex number types, random number generation, nu-
meric (n-at-a-time) arrays, generalized numeric algorithms, and facilities included from the ISO C library,
as summarized in Table 114.

Table 114 — Numerics library summary

Subclause

26.2 Requirements
26.3 Floating-Point Environment
26.4 Complex Numbers
26.5 Random number generation
26.6 Numeric arrays
26.7 Generalized numeric operations
26.8 C library

Header(s)

<cfenv>
<complex>
<random>
<valarray>
<numeric>
<cmath>
<ctgmath>
<tgmath.h>
<cstdlib>

26.2 Numeric type requirements

[numeric.requirements]
1 The complex and valarray components are parameterized by the type of information they contain and
manipulate. A C++ program shall instantiate these components only with a type T that satisﬁes the following
requirements:273

(1.1)

(1.2)

(1.3)

(1.4)

(1.5)

(1.6)

(1.7)

(1.8)

—
—
—
—
—
—
—

T is not an abstract class (it has no pure virtual member functions);
T is not a reference type;
T is not cv-qualiﬁed;
If T is a class, it has a public default constructor;
If T is a class, it has a public copy constructor with the signature T::T(const T&)
If T is a class, it has a public destructor;
If T is a class, it has a public assignment operator whose signature is either T& T::operator=(const
T&) or T& T::operator=(T)
If T is a class, its assignment operator, copy and default constructors, and destructor shall correspond
to each other in the following sense: Initialization of raw storage using the default constructor, followed
by assignment, is semantically equivalent to initialization of raw storage using the copy constructor.
273) In other words, value types. These include arithmetic types, pointers, the library class complex, and instantiations of
valarray for value types.

—

§ 26.2

924

c(cid:13) ISO/IEC

N4296

Destruction of an object, followed by initialization of its raw storage using the copy constructor, is
semantically equivalent to assignment to the original object.
[ Note: This rule states that there shall not be any subtle diﬀerences in the semantics of initialization
versus assignment. This gives an implementation considerable ﬂexibility in how arrays are initialized.
[ Example: An implementation is allowed to initialize a valarray by allocating storage using the new
operator (which implies a call to the default constructor for each element) and then assigning each
element its value. Or the implementation can allocate raw storage and use the copy constructor to
initialize each element. — end example ]
If the distinction between initialization and assignment is important for a class, or if it fails to satisfy any
of the other conditions listed above, the programmer should use vector (23.3.6) instead of valarray
for that class; — end note ]
If T is a class, it does not overload unary operator&.

(1.9)

—

2

3

4

If any operation on T throws an exception the eﬀects are undeﬁned.
In addition, many member and related functions of valarray<T> can be successfully instantiated and will
exhibit well-deﬁned behavior if and only if T satisﬁes additional requirements speciﬁed for each such member
or related function.
[ Example:
It is valid to instantiate valarray<complex>, but operator>() will not be successfully in-
stantiated for valarray<complex> operands, since complex does not have any ordering operators. — end
example ]
26.3 The ﬂoating-point environment
26.3.1 Header <cfenv> synopsis

[cfenv]
[cfenv.syn]

namespace std {

// types
typedef object type
typedef integer type fexcept_t;

fenv_t;

// functions
int feclearexcept(int except);
int fegetexceptflag(fexcept_t* pflag, int except);
int feraiseexcept(int except);
int fesetexceptflag(const fexcept_t* pflag, int except);
int fetestexcept(int except);

int fegetround(void);
int fesetround(int mode);

int fegetenv(fenv_t* penv);
int feholdexcept(fenv_t* penv);
int fesetenv(const fenv_t* penv);
int feupdateenv(const fenv_t* penv);

}

1 The header also deﬁnes the macros:

FE_ALL_EXCEPT
FE_DIVBYZERO
FE_INEXACT
FE_INVALID
FE_OVERFLOW

§ 26.3.1

925

c(cid:13) ISO/IEC

FE_UNDERFLOW

FE_DOWNWARD
FE_TONEAREST
FE_TOWARDZERO
FE_UPWARD

FE_DFL_ENV

N4296

2 The header deﬁnes all functions, types, and macros the same as Clause 7.6 of the C standard.
3 The ﬂoating-point environment has thread storage duration (3.7.2). The initial state for a thread’s ﬂoating-
point environment is the state of the ﬂoating-point environment of the thread that constructs the correspond-
ing std::thread object (30.3.1) at the time it constructed the object. [ Note: That is, the child thread gets
the ﬂoating-point state of the parent thread at the time of the child’s creation. — end note ]

4 A separate ﬂoating-point environment shall be maintained for each thread. Each function accesses the

environment corresponding to its calling thread.
26.4 Complex numbers

[complex.numbers]
1 The header <complex> deﬁnes a class template, and numerous functions for representing and manipulating

complex numbers.

2 The eﬀect of instantiating the template complex for any type other than float, double, or long double
is unspeciﬁed. The specializations complex<float>, complex<double>, and complex<long double> are
literal types (3.9).
If the result of a function is not mathematically deﬁned or not in the range of representable values for its
type, the behavior is undeﬁned.
If z is an lvalue expression of type cv std::complex<T> then:

4

3

(4.1)

(4.2)

(4.3)

(4.4)

(4.5)

—
—
—

the expression reinterpret_cast<cv T(&)[2]>(z) shall be well-formed,
reinterpret_cast<cv T(&)[2]>(z)[0] shall designate the real part of z, and
reinterpret_cast<cv T(&)[2]>(z)[1] shall designate the imaginary part of z.

Moreover, if a is an expression of type cv std::complex<T>* and the expression a[i] is well-deﬁned for an
integer expression i, then:

—
—

reinterpret_cast<cv T*>(a)[2*i] shall designate the real part of a[i], and
reinterpret_cast<cv T*>(a)[2*i + 1] shall designate the imaginary part of a[i].

26.4.1 Header <complex> synopsis

namespace std {

template<class T> class complex;
template<> class complex<float>;
template<> class complex<double>;
template<> class complex<long double>;

[complex.syn]

// 26.4.6, operators:
template<class T>

complex<T> operator+(const complex<T>&, const complex<T>&);

template<class T> complex<T> operator+(const complex<T>&, const T&);
template<class T> complex<T> operator+(const T&, const complex<T>&);

§ 26.4.1

926

c(cid:13) ISO/IEC

N4296

template<class T> complex<T> operator-(
const complex<T>&, const complex<T>&);

template<class T> complex<T> operator-(const complex<T>&, const T&);
template<class T> complex<T> operator-(const T&, const complex<T>&);

template<class T> complex<T> operator*(
const complex<T>&, const complex<T>&);

template<class T> complex<T> operator*(const complex<T>&, const T&);
template<class T> complex<T> operator*(const T&, const complex<T>&);

template<class T> complex<T> operator/(
const complex<T>&, const complex<T>&);

template<class T> complex<T> operator/(const complex<T>&, const T&);
template<class T> complex<T> operator/(const T&, const complex<T>&);

template<class T> complex<T> operator+(const complex<T>&);
template<class T> complex<T> operator-(const complex<T>&);

template<class T> constexpr bool operator==(

const complex<T>&, const complex<T>&);

template<class T> constexpr bool operator==(const complex<T>&, const T&);
template<class T> constexpr bool operator==(const T&, const complex<T>&);

template<class T> constexpr bool operator!=(const complex<T>&, const complex<T>&);
template<class T> constexpr bool operator!=(const complex<T>&, const T&);
template<class T> constexpr bool operator!=(const T&, const complex<T>&);

template<class T, class charT, class traits>
basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>&, complex<T>&);

template<class T, class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>&, const complex<T>&);

// 26.4.7, values:
template<class T> constexpr T real(const complex<T>&);
template<class T> constexpr T imag(const complex<T>&);

template<class T> T abs(const complex<T>&);
template<class T> T arg(const complex<T>&);
template<class T> T norm(const complex<T>&);

template<class T> complex<T> conj(const complex<T>&);
template <class T> complex<T> proj(const complex<T>&);
template<class T> complex<T> polar(const T&, const T& = 0);

// 26.4.8, transcendentals:
template<class T> complex<T> acos(const complex<T>&);
template<class T> complex<T> asin(const complex<T>&);
template<class T> complex<T> atan(const complex<T>&);

template<class T> complex<T> acosh(const complex<T>&);
template<class T> complex<T> asinh(const complex<T>&);
template<class T> complex<T> atanh(const complex<T>&);

§ 26.4.1

927

c(cid:13) ISO/IEC

N4296

template<class T> complex<T> cos
(const complex<T>&);
template<class T> complex<T> cosh (const complex<T>&);
(const complex<T>&);
template<class T> complex<T> exp
template<class T> complex<T> log
(const complex<T>&);
template<class T> complex<T> log10(const complex<T>&);

template<class T> complex<T> pow(const complex<T>&, const T&);
template<class T> complex<T> pow(const complex<T>&, const complex<T>&);
template<class T> complex<T> pow(const T&, const complex<T>&);

template<class T> complex<T> sin
(const complex<T>&);
template<class T> complex<T> sinh (const complex<T>&);
template<class T> complex<T> sqrt (const complex<T>&);
template<class T> complex<T> tan
(const complex<T>&);
template<class T> complex<T> tanh (const complex<T>&);

// 26.4.10, complex literals:
inline namespace literals {

inline namespace complex_literals {

constexpr complex<long double> operator""il(long double);
constexpr complex<long double> operator""il(unsigned long long);
constexpr complex<double> operator""i(long double);
constexpr complex<double> operator""i(unsigned long long);
constexpr complex<float> operator""if(long double);
constexpr complex<float> operator""if(unsigned long long);

}

}

}

26.4.2 Class template complex

[complex]

namespace std {

template<class T>
class complex {
public:

typedef T value_type;

constexpr complex(const T& re = T(), const T& im = T());
constexpr complex(const complex&);
template<class X> constexpr complex(const complex<X>&);

constexpr T real() const;
void real(T);
constexpr T imag() const;
void imag(T);

complex<T>& operator= (const T&);
complex<T>& operator+=(const T&);
complex<T>& operator-=(const T&);
complex<T>& operator*=(const T&);
complex<T>& operator/=(const T&);

complex& operator=(const complex&);
template<class X> complex<T>& operator= (const complex<X>&);
template<class X> complex<T>& operator+=(const complex<X>&);

§ 26.4.2

928

c(cid:13) ISO/IEC

N4296

template<class X> complex<T>& operator-=(const complex<X>&);
template<class X> complex<T>& operator*=(const complex<X>&);
template<class X> complex<T>& operator/=(const complex<X>&);

};

}

1 The class complex describes an object that can store the Cartesian components, real() and imag(), of a

complex number.
26.4.3 complex specializations

[complex.special]

namespace std {

template<> class complex<float> {
public:

typedef float value_type;

constexpr complex(float re = 0.0f, float im = 0.0f);
constexpr explicit complex(const complex<double>&);
constexpr explicit complex(const complex<long double>&);

constexpr float real() const;
void real(float);
constexpr float imag() const;
void imag(float);

complex<float>& operator= (float);
complex<float>& operator+=(float);
complex<float>& operator-=(float);
complex<float>& operator*=(float);
complex<float>& operator/=(float);

complex<float>& operator=(const complex<float>&);
template<class X> complex<float>& operator= (const complex<X>&);
template<class X> complex<float>& operator+=(const complex<X>&);
template<class X> complex<float>& operator-=(const complex<X>&);
template<class X> complex<float>& operator*=(const complex<X>&);
template<class X> complex<float>& operator/=(const complex<X>&);

};

template<> class complex<double> {
public:

typedef double value_type;

constexpr complex(double re = 0.0, double im = 0.0);
constexpr complex(const complex<float>&);
constexpr explicit complex(const complex<long double>&);

constexpr double real() const;
void real(double);
constexpr double imag() const;
void imag(double);

complex<double>& operator= (double);
complex<double>& operator+=(double);
complex<double>& operator-=(double);
complex<double>& operator*=(double);

§ 26.4.3

929

c(cid:13) ISO/IEC

N4296

complex<double>& operator/=(double);

complex<double>& operator=(const complex<double>&);
template<class X> complex<double>& operator= (const complex<X>&);
template<class X> complex<double>& operator+=(const complex<X>&);
template<class X> complex<double>& operator-=(const complex<X>&);
template<class X> complex<double>& operator*=(const complex<X>&);
template<class X> complex<double>& operator/=(const complex<X>&);

};

template<> class complex<long double> {
public:

typedef long double value_type;

constexpr complex(long double re = 0.0L, long double im = 0.0L);
constexpr complex(const complex<float>&);
constexpr complex(const complex<double>&);

constexpr long double real() const;
void real(long double);
constexpr long double imag() const;
void imag(long double);

complex<long double>& operator=(const complex<long double>&);
complex<long double>& operator= (long double);
complex<long double>& operator+=(long double);
complex<long double>& operator-=(long double);
complex<long double>& operator*=(long double);
complex<long double>& operator/=(long double);

template<class X> complex<long double>& operator= (const complex<X>&);
template<class X> complex<long double>& operator+=(const complex<X>&);
template<class X> complex<long double>& operator-=(const complex<X>&);
template<class X> complex<long double>& operator*=(const complex<X>&);
template<class X> complex<long double>& operator/=(const complex<X>&);

};

}

26.4.4 complex member functions
template<class T> constexpr complex(const T& re = T(), const T& im = T());

[complex.members]

1

2

Eﬀects: Constructs an object of class complex.
Postcondition: real() == re && imag() == im.

constexpr T real() const;

Returns: The value of the real component.

void real(T val);

Eﬀects: Assigns val to the real component.

constexpr T imag() const;

Returns: The value of the imaginary component.

§ 26.4.4

930

c(cid:13) ISO/IEC

void imag(T val);

Eﬀects: Assigns val to the imaginary component.

26.4.5 complex member operators
complex<T>& operator+=(const T& rhs);

N4296

[complex.member.ops]

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

Eﬀects: Adds the scalar value rhs to the real part of the complex value *this and stores the result in
the real part of *this, leaving the imaginary part unchanged.
Returns: *this.

complex<T>& operator-=(const T& rhs);

Eﬀects: Subtracts the scalar value rhs from the real part of the complex value *this and stores the
result in the real part of *this, leaving the imaginary part unchanged.
Returns: *this.

complex<T>& operator*=(const T& rhs);

Eﬀects: Multiplies the scalar value rhs by the complex value *this and stores the result in *this.
Returns: *this.

complex<T>& operator/=(const T& rhs);

Eﬀects: Divides the scalar value rhs into the complex value *this and stores the result in *this.
Returns: *this.

template<class X> complex<T>& operator+=(const complex<X>& rhs);

Eﬀects: Adds the complex value rhs to the complex value *this and stores the sum in *this.
Returns: *this.

template<class X> complex<T>& operator-=(const complex<X>& rhs);

Eﬀects: Subtracts the complex value rhs from the complex value *this and stores the diﬀerence in
*this.
Returns: *this.

template<class X> complex<T>& operator*=(const complex<X>& rhs);

Eﬀects: Multiplies the complex value rhs by the complex value *this and stores the product in *this.
Returns: *this.

template<class X> complex<T>& operator/=(const complex<X>& rhs);

Eﬀects: Divides the complex value rhs into the complex value *this and stores the quotient in *this.
Returns: *this.

§ 26.4.5

931

1

2

3

4

5

6

7

8

9

10

11

c(cid:13) ISO/IEC

26.4.6 complex non-member operations
template<class T> complex<T> operator+(const complex<T>& lhs);

Remarks: unary operator.
Returns: complex<T>(lhs).

N4296

[complex.ops]

template<class T>

complex<T> operator+(const complex<T>& lhs, const complex<T>& rhs);

template<class T> complex<T> operator+(const complex<T>& lhs, const T& rhs);
template<class T> complex<T> operator+(const T& lhs, const complex<T>& rhs);

Returns: complex<T>(lhs) += rhs.

template<class T> complex<T> operator-(const complex<T>& lhs);

Remarks: unary operator.
Returns: complex<T>(-lhs.real(),-lhs.imag()).

template<class T>

complex<T> operator-(const complex<T>& lhs, const complex<T>& rhs);

template<class T> complex<T> operator-(const complex<T>& lhs, const T& rhs);
template<class T> complex<T> operator-(const T& lhs, const complex<T>& rhs);

Returns: complex<T>(lhs) -= rhs.

template<class T>

complex<T> operator*(const complex<T>& lhs, const complex<T>& rhs);

template<class T> complex<T> operator*(const complex<T>& lhs, const T& rhs);
template<class T> complex<T> operator*(const T& lhs, const complex<T>& rhs);

Returns: complex<T>(lhs) *= rhs.

template<class T>

complex<T> operator/(const complex<T>& lhs, const complex<T>& rhs);

template<class T> complex<T> operator/(const complex<T>& lhs, const T& rhs);
template<class T> complex<T> operator/(const T& lhs, const complex<T>& rhs);

Returns: complex<T>(lhs) /= rhs.

template<class T>

constexpr bool operator==(const complex<T>& lhs, const complex<T>& rhs);

template<class T> constexpr bool operator==(const complex<T>& lhs, const T& rhs);
template<class T> constexpr bool operator==(const T& lhs, const complex<T>& rhs);

Returns: lhs.real() == rhs.real() && lhs.imag() == rhs.imag().
Remarks: The imaginary part is assumed to be T(), or 0.0, for the T arguments.

template<class T>

constexpr bool operator!=(const complex<T>& lhs, const complex<T>& rhs);

template<class T> constexpr bool operator!=(const complex<T>& lhs, const T& rhs);
template<class T> constexpr bool operator!=(const T& lhs, const complex<T>& rhs);

Returns: rhs.real() != lhs.real() || rhs.imag() != lhs.imag().

template<class T, class charT, class traits>
basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, complex<T>& x);

§ 26.4.6

932

12

13

14

15

16

17

1

2

3

4

5

6

c(cid:13) ISO/IEC

N4296

Eﬀects: Extracts a complex number x of the form: u, (u), or (u,v), where u is the real part and v is
the imaginary part (27.7.2.2).
Requires: The input values shall be convertible to T.
If bad input is encountered, calls is.setstate(ios_base::failbit) (which may throw ios::failure
(27.5.5.4)).
Returns: is.
Remarks: This extraction is performed as a series of simpler extractions. Therefore, the skipping of
whitespace is speciﬁed to be the same for each of the simpler extractions.

template<class T, class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& o, const complex<T>& x);

Eﬀects: inserts the complex number x onto the stream o as if it were implemented as follows:

template<class T, class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& o, const complex<T>& x) {

basic_ostringstream<charT, traits> s;
s.flags(o.flags());
s.imbue(o.getloc());
s.precision(o.precision());
s << ’(’ << x.real() << "," << x.imag() << ’)’;
return o << s.str();

}

Note: In a locale in which comma is used as a decimal point character, the use of comma as a ﬁeld
separator can be ambiguous. Inserting std::showpoint into the output stream forces all outputs to
show an explicit decimal point character; as a result, all inserted sequences of complex numbers can
be extracted unambiguously.

[complex.value.ops]

26.4.7 complex value operations
template<class T> constexpr T real(const complex<T>& x);

Returns: x.real().

template<class T> constexpr T imag(const complex<T>& x);

Returns: x.imag().

template<class T> T abs(const complex<T>& x);

Returns: The magnitude of x.

template<class T> T arg(const complex<T>& x);

Returns: The phase angle of x, or atan2(imag(x), real(x)).

template<class T> T norm(const complex<T>& x);

Returns: The squared magnitude of x.

template<class T> complex<T> conj(const complex<T>& x);

Returns: The complex conjugate of x.

§ 26.4.7

933

c(cid:13) ISO/IEC

N4296

template<class T> complex<T> proj(const complex<T>& x);

Returns: The projection of x onto the Riemann sphere.
Remarks: Behaves the same as the C function cproj, deﬁned in 7.3.9.4.

template<class T> complex<T> polar(const T& rho, const T& theta = 0);

Returns: The complex value corresponding to a complex number whose magnitude is rho and whose
phase angle is theta.

26.4.8 complex transcendentals
template<class T> complex<T> acos(const complex<T>& x);

Returns: The complex arc cosine of x.
Remarks: Behaves the same as C function cacos, deﬁned in 7.3.5.1.

[complex.transcendentals]

template<class T> complex<T> asin(const complex<T>& x);

Returns: The complex arc sine of x.
Remarks: Behaves the same as C function casin, deﬁned in 7.3.5.2.

template<class T> complex<T> atan(const complex<T>& x);

Returns: The complex arc tangent of x.
Remarks: Behaves the same as C function catan, deﬁned in 7.3.5.3.

template<class T> complex<T> acosh(const complex<T>& x);

Returns: The complex arc hyperbolic cosine of x.
Remarks: Behaves the same as C function cacosh, deﬁned in 7.3.6.1.

template<class T> complex<T> asinh(const complex<T>& x);

Returns: The complex arc hyperbolic sine of x.
Remarks: Behaves the same as C function casinh, deﬁned in 7.3.6.2.

template<class T> complex<T> atanh(const complex<T>& x);

Returns: The complex arc hyperbolic tangent of x.
Remarks: Behaves the same as C function catanh, deﬁned in 7.3.6.3.

template<class T> complex<T> cos(const complex<T>& x);

Returns: The complex cosine of x.

template<class T> complex<T> cosh(const complex<T>& x);

Returns: The complex hyperbolic cosine of x.

template<class T> complex<T> exp(const complex<T>& x);

Returns: The complex base e exponential of x.

template<class T> complex<T> log(const complex<T>& x);

7

8

9

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

§ 26.4.8

934

c(cid:13) ISO/IEC

N4296

Remarks: the branch cuts are along the negative real axis.
Returns: The complex natural (base e) logarithm of x, in the range of a strip mathematically un-
bounded along the real axis and in the interval [-i times pi,i times pi] along the imaginary axis.
When x is a negative real number, imag(log(x)) is pi.

template<class T> complex<T> log10(const complex<T>& x);

Remarks: the branch cuts are along the negative real axis.
Returns: The complex common (base 10) logarithm of x, deﬁned as log(x)/log(10).

template<class T>

complex<T> pow(const complex<T>& x, const complex<T>& y);

template<class T> complex<T> pow
template<class T> complex<T> pow

(const complex<T>& x, const T& y);
(const T& x, const complex<T>& y);

Remarks: the branch cuts are along the negative real axis.
Returns: The complex power of base x raised to the y-th power, deﬁned as exp(y*log(x)). The value
returned for pow(0,0) is implementation-deﬁned.

template<class T> complex<T> sin

(const complex<T>& x);

Returns: The complex sine of x.

template<class T> complex<T> sinh (const complex<T>& x);

Returns: The complex hyperbolic sine of x.

template<class T> complex<T> sqrt (const complex<T>& x);

Remarks: the branch cuts are along the negative real axis.
Returns: The complex square root of x, in the range of the right half-plane.
negative real number, the value returned lies on the positive imaginary axis.

If the argument is a

template<class T> complex<T> tan

(const complex<T>& x);

Returns: The complex tangent of x.

template<class T> complex<T> tanh (const complex<T>& x);

Returns: The complex hyperbolic tangent of x.

16

17

18

19

20

21

22

23

24

25

26

27

26.4.9 Additional overloads

1 The following function templates shall have additional overloads:

[cmplx.over]

arg
conj
imag

norm
proj
real

2 The additional overloads shall be suﬃcient to ensure:

1. If the argument has type long double, then it is eﬀectively cast to complex<long double>.
2. Otherwise, if the argument has type double or an integer type, then it is eﬀectively cast to complex<

double>.

3. Otherwise, if the argument has type float, then it is eﬀectively cast to complex<float>.

§ 26.4.9

935

c(cid:13) ISO/IEC

N4296

3 Function template pow shall have additional overloads suﬃcient to ensure, for a call with at least one

argument of type complex<T>:

1. If either argument has type complex<long double> or type long double, then both arguments are

eﬀectively cast to complex<long double>.

2. Otherwise, if either argument has type complex<double>, double, or an integer type, then both

arguments are eﬀectively cast to complex<double>.

3. Otherwise, if either argument has type complex<float> or float, then both arguments are eﬀectively

cast to complex<float>.

26.4.10 Suﬃxes for complex number literals

[complex.literals]
1 This section describes literal suﬃxes for constructing complex number literals. The suﬃxes i, il, and
if create complex numbers of the types complex<double>, complex<long double>, and complex<float>
respectively, with their imaginary part denoted by the given literal number and the real part being zero.

constexpr complex<long double> operator""il(long double d);
constexpr complex<long double> operator""il(unsigned long long d);

Returns: complex<long double>{0.0L, static_cast<long double>(d)}.

constexpr complex<double> operator""i(long double d);
constexpr complex<double> operator""i(unsigned long long d);

Returns: complex<double>{0.0, static_cast<double>(d)}.

constexpr complex<float> operator""if(long double d);
constexpr complex<float> operator""if(unsigned long long d);

Returns: complex<float>{0.0f, static_cast<float>(d)}.

2

3

4

26.4.11 Header <ccomplex>

1 The header behaves as if it simply includes the header <complex>.

26.5 Random number generation

[ccmplx]

[rand]

1 This subclause deﬁnes a facility for generating (pseudo-)random numbers.
2

In addition to a few utilities, four categories of entities are described: uniform random number generators,
random number engines, random number engine adaptors, and random number distributions. These catego-
rizations are applicable to types that satisfy the corresponding requirements, to objects instantiated from
such types, and to templates producing such types when instantiated. [ Note: These entities are speciﬁed in
such a way as to permit the binding of any uniform random number generator object e as the argument to
any random number distribution object d, thus producing a zero-argument function object such as given by
bind(d,e). — end note ]

3 Each of the entities speciﬁed via this subclause has an associated arithmetic type (3.9.1) identiﬁed as
result_type. With T as the result_type thus associated with such an entity, that entity is character-
ized:

a) as boolean or equivalently as boolean-valued, if T is bool;
b) otherwise as integral or equivalently as integer-valued, if numeric_limits<T>::is_integer is true;
c) otherwise as ﬂoating or equivalently as real-valued.

§ 26.5

936

c(cid:13) ISO/IEC

N4296

If integer-valued, an entity may optionally be further characterized as signed or unsigned, according to
numeric_limits<T>::is_signed.

4 Unless otherwise speciﬁed, all descriptions of calculations in this subclause use mathematical real numbers.
5 Throughout this subclause, the operators bitand , bitor , and xor denote the respective conventional bitwise

operations. Further:

a) the operator rshift denotes a bitwise right shift with zero-valued bits appearing in the high bits of the

result, and

b) the operator lshiftw denotes a bitwise left shift with zero-valued bits appearing in the low bits of the

result, and whose result is always taken modulo 2w.

26.5.1 Requirements
26.5.1.1 General requirements

1 Throughout this subclause 26.5, the eﬀect of instantiating a template:

[rand.req]
[rand.req.genl]

a) that has a template type parameter named Sseq is undeﬁned unless the corresponding template argu-

ment is cv-unqualiﬁed and satisﬁes the requirements of seed sequence (26.5.1.2).

b) that has a template type parameter named URNG is undeﬁned unless the corresponding template argu-
ment is cv-unqualiﬁed and satisﬁes the requirements of uniform random number generator (26.5.1.3).
c) that has a template type parameter named Engine is undeﬁned unless the corresponding template

argument is cv-unqualiﬁed and satisﬁes the requirements of random number engine (26.5.1.4).

d) that has a template type parameter named RealType is undeﬁned unless the corresponding template

argument is cv-unqualiﬁed and is one of float, double, or long double.

e) that has a template type parameter named IntType is undeﬁned unless the corresponding template
argument is cv-unqualiﬁed and is one of short, int, long, long long, unsigned short, unsigned
int, unsigned long, or unsigned long long.

f) that has a template type parameter named UIntType is undeﬁned unless the corresponding template
argument is cv-unqualiﬁed and is one of unsigned short, unsigned int, unsigned long, or unsigned
long long.

2 Throughout this subclause 26.5, phrases of the form “x is an iterator of a speciﬁc kind” shall be interpreted
as equivalent to the more formal requirement that “x is a value of a type satisfying the requirements of the
speciﬁed iterator type.”

3 Throughout this subclause 26.5, any constructor that can be called with a single argument and that satisﬁes

a requirement speciﬁed in this subclause shall be declared explicit.
26.5.1.2 Seed sequence requirements

[rand.req.seedseq]
1 A seed sequence is an object that consumes a sequence of integer-valued data and produces a requested
number of unsigned integer values i, 0 ≤ i < 232, based on the consumed data.
[ Note: Such an object
provides a mechanism to avoid replication of streams of random variates. This can be useful, for example,
in applications requiring large numbers of random number engines. — end note ]

2 A class S satisﬁes the requirements of a seed sequence if the expressions shown in Table 115 are valid and
have the indicated semantics, and if S also satisﬁes all other requirements of this section 26.5.1.2. In that
Table and throughout this section:

a) T is the type named by S’s associated result_type;

§ 26.5.1.2

937

c(cid:13) ISO/IEC

N4296

b) q is a value of S and r is a possibly const value of S;
c) ib and ie are input iterators with an unsigned integer value_type of at least 32 bits;
d) rb and re are mutable random access iterators with an unsigned integer value_type of at least 32

bits;

e) ob is an output iterator; and
f) il is a value of initializer_list<T>.

Table 115 — Seed sequence requirements

Expression
S::result_type

T

Return type

S()

S(ib,ie)

S(il)

q.generate(rb,re)

void

r.size()

size_t

r.param(ob)

void

Complexity
compile-time

constant

O(ie − ib)

same as
S(il.begin(),
il.end())
O(re − rb)

constant

O(r.size())

Pre/post-condition

T is an unsigned integer
type (3.9.1) of at least 32 bits.
Creates a seed sequence with
the same initial state as all
other default-constructed seed
sequences of type S.
Creates a seed sequence having
internal state that depends on
some or all of the bits of the
supplied sequence [ib, ie).
Same as S(il.begin(),
il.end()).

Does nothing if rb == re.
Otherwise, ﬁlls the supplied
sequence [rb, re) with 32-bit
quantities that depend on the
sequence supplied to the
constructor and possibly also
depend on the history of
generate’s previous
invocations.
The number of 32-bit units that
would be copied by a call to
r.param.
Copies to the given destination
a sequence of 32-bit units that
can be provided to the
constructor of a second object
of type S, and that would
reproduce in that second object
a state indistinguishable from
the state of the ﬁrst object.

§ 26.5.1.2

938

c(cid:13) ISO/IEC

N4296

26.5.1.3 Uniform random number generator requirements

[rand.req.urng]
1 A uniform random number generator g of type G is a function object returning unsigned integer values such
that each value in the range of possible results has (ideally) equal probability of being returned. [ Note: The
degree to which g’s results approximate the ideal is often determined statistically. — end note ]

2 A class G satisﬁes the requirements of a uniform random number generator if the expressions shown in
Table 116 are valid and have the indicated semantics, and if G also satisﬁes all other requirements of this
section 26.5.1.3. In that Table and throughout this section:

a) T is the type named by G’s associated result_type, and
b) g is a value of G.

Table 116 — Uniform random number generator requirements

Return type

Expression
G::result_type

g()

G::min()

G::max()

T

T

T

T

Pre/post-condition

T is an unsigned integer
type (3.9.1).
Returns a value in the closed
interval [G::min(), G::max()].
Denotes the least value
potentially returned by
operator().
Denotes the greatest value
potentially returned by
operator().

Complexity
compile-time

amortized
constant
compile-time

compile-time

3 The following relation shall hold: G::min() < G::max().

26.5.1.4 Random number engine requirements

[rand.req.eng]
1 A random number engine (commonly shortened to engine) e of type E is a uniform random number generator
that additionally meets the requirements (e.g., for seeding and for input/output) speciﬁed in this section.
2 At any given time, e has a state ei for some integer i ≥ 0. Upon construction, e has an initial state e0. An
engine’s state may be established via a constructor, a seed function, assignment, or a suitable operator>>.

3 E’s speciﬁcation shall deﬁne:

a) the size of E’s state in multiples of the size of result_type, given as an integral constant expression;
b) the transition algorithm TA by which e’s state ei is advanced to its successor state ei+1; and
c) the generation algorithm GA by which an engine’s state is mapped to a value of type result_type.

4 A class E that satisﬁes the requirements of a uniform random number generator (26.5.1.3) also satisﬁes
the requirements of a random number engine if the expressions shown in Table 117 are valid and have the
indicated semantics, and if E also satisﬁes all other requirements of this section 26.5.1.4. In that Table and
throughout this section:

a) T is the type named by E’s associated result_type;
b) e is a value of E, v is an lvalue of E, x and y are (possibly const) values of E;

§ 26.5.1.4

939

c(cid:13) ISO/IEC

N4296

c) s is a value of T;
d) q is an lvalue satisfying the requirements of a seed sequence (26.5.1.2);
e) z is a value of type unsigned long long;
f) os is an lvalue of the type of some class template specialization basic_ostream<charT, traits>; and
g) is is an lvalue of the type of some class template specialization basic_istream<charT, traits>;

where charT and traits are constrained according to Clause 21 and Clause 27.

Table 117 — Random number engine requirements

Expression

Return type

E()

E(x)

E(s)

E(q)274

e.seed()
e.seed(s)
e.seed(q)
e()

e.discard(z) 275

x == y

void
void
void
T

void

bool

x != y

bool

Pre/post-condition
Creates an engine with the
same initial state as all other
default-constructed engines of
type E.
Creates an engine that
compares equal to x.
Creates an engine with initial
state determined by s.
Creates an engine with an
initial state that depends on a
sequence produced by one call
to q.generate.

post: e == E().
post: e == E(s).
post: e == E(q).
Advances e’s state ei to ei+1
= TA(ei) and returns GA(ei).
Advances e’s state ei to ei+z by
any means equivalent to z
consecutive calls e().

This operator is an equivalence
relation. With Sx and Sy as the
inﬁnite sequences of values that
would be generated by repeated
future calls to x() and y(),
respectively, returns true if
Sx = Sy; else returns false.
!(x == y).

Complexity
O(size of state)

O(size of state)

O(size of state)

same as
complexity of
q.generate
called on a
sequence whose
length is size of
state
same as E()
same as E(s)
same as E(q)
per Table 116

no worse than
the complexity
of z consecutive
calls e()
O(size of state)

O(size of state)

274) This constructor (as well as the subsequent corresponding seed() function) may be particularly useful to applications
requiring a large number of independent random sequences.
275) This operation is common in user code, and can often be implemented in an engine-speciﬁc manner so as to provide
signiﬁcant performance improvements over an equivalent naive loop that makes z consecutive calls e().

§ 26.5.1.4

940

c(cid:13) ISO/IEC

Expression

os << x

Return type

reference to the type of
os

is >> v

reference to the type of
is

N4296

Complexity
O(size of state)

O(size of state)

Pre/post-condition

With os.fmtﬂags set to ios_-
base::dec|ios_base::left
and the ﬁll character set to the
space character, writes to os
the textual representation of x’s
current state. In the output,
adjacent numbers are separated
by one or more space
characters.
post: The os.fmtﬂags and ﬁll
character are unchanged.
With is.fmtflags set to
ios_base::dec, sets v’s state
as determined by reading its
textual representation from is.
If bad input is encountered,
ensures that v’s state is
unchanged by the operation
and calls
is.setstate(ios::failbit)
(which may throw
ios::failure [27.5.5.4]). If a
textual representation written
via os << x was subsequently
read via is >> v, then x == v
provided that there have been
no intervening invocations of x
or of v.
pre: is provides a textual
representation that was
previously written using an
output stream whose imbued
locale was the same as that of
is, and whose type’s template
specialization arguments charT
and traits were respectively
the same as those of is.
post: The is.fmtﬂags are
unchanged.

5 E shall meet the requirements of CopyConstructible (Table 21) and CopyAssignable (Table 23) types.

These operations shall each be of complexity no worse than O(size of state).
26.5.1.5 Random number engine adaptor requirements

[rand.req.adapt]
1 A random number engine adaptor (commonly shortened to adaptor) a of type A is a random number engine
that takes values produced by some other random number engine, and applies an algorithm to those values
in order to deliver a sequence of values with diﬀerent randomness properties. An engine b of type B adapted
in this way is termed a base engine in this context. The expression a.base() shall be valid and shall return
a const reference to a’s base engine.

§ 26.5.1.5

941

c(cid:13) ISO/IEC

N4296

2 The requirements of a random number engine type shall be interpreted as follows with respect to a random

number engine adaptor type.

A::A();

Eﬀects: The base engine is initialized as if by its default constructor.

bool operator==(const A& a1, const A& a2);

Returns: true if a1’s base engine is equal to a2’s base engine. Otherwise returns false.

A::A(result_type s);

Eﬀects: The base engine is initialized with s.

template<class Sseq> void A::A(Sseq& q);

Eﬀects: The base engine is initialized with q.

void seed();

Eﬀects: With b as the base engine, invokes b.seed().

void seed(result_type s);

Eﬀects: With b as the base engine, invokes b.seed(s).

3

4

5

6

7

8

template<class Sseq> void seed(Sseq& q);

Eﬀects: With b as the base engine, invokes b.seed(q).

9
10 A shall also satisfy the following additional requirements:

a) The complexity of each function shall not exceed the complexity of the corresponding function applied

to the base engine.

b) The state of A shall include the state of its base engine. The size of A’s state shall be no less than the

size of the base engine.

c) Copying A’s state (e.g., during copy construction or copy assignment) shall include copying the state

of the base engine of A.

d) The textual representation of A shall include the textual representation of its base engine.

26.5.1.6 Random number distribution requirements

[rand.req.dist]
1 A random number distribution (commonly shortened to distribution) d of type D is a function object returning
values that are distributed according to an associated mathematical probability density function p(z) or
according to an associated discrete probability function P(zi). A distribution’s speciﬁcation identiﬁes its
associated probability function p(z) or P(zi).

2 An associated probability function is typically expressed using certain externally-supplied quantities known
as the parameters of the distribution. Such distribution parameters are identiﬁed in this context by writing,
for example, p(z | a, b) or P(zi | a, b), to name speciﬁc parameters, or by writing, for example, p(z |{p}) or
P(zi |{p}), to denote a distribution’s parameters p taken as a whole.

3 A class D satisﬁes the requirements of a random number distribution if the expressions shown in Table 118 are
valid and have the indicated semantics, and if D and its associated types also satisfy all other requirements
of this section 26.5.1.6. In that Table and throughout this section,

a) T is the type named by D’s associated result_type;

§ 26.5.1.6

942

c(cid:13) ISO/IEC

N4296

b) P is the type named by D’s associated param_type;
c) d is a value of D, and x and y are (possibly const) values of D;
d) glb and lub are values of T respectively corresponding to the greatest lower bound and the least upper
bound on the values potentially returned by d’s operator(), as determined by the current values of
d’s parameters;

e) p is a (possibly const) value of P;
f) g, g1, and g2 are lvalues of a type satisfying the requirements of a uniform random number generator

[26.5.1.3];

g) os is an lvalue of the type of some class template specialization basic_ostream<charT, traits>; and
h) is is an lvalue of the type of some class template specialization basic_istream<charT, traits>;

where charT and traits are constrained according to Clauses 21 and 27.

Table 118 — Random number distribution requirements

Expression
D::result_type
D::param_type
D()

T
P

Return type

D(p)

d.reset()

x.param()

d.param(p)

d(g)

void

P

void

T

Pre/post-condition

T is an arithmetic type (3.9.1).

Creates a distribution whose
behavior is indistinguishable
from that of any other newly
default-constructed distribution
of type D.
Creates a distribution whose
behavior is indistinguishable
from that of a distribution
newly constructed directly from
the values used to construct p.
Subsequent uses of d do not
depend on values produced by
any engine prior to invoking
reset.
Returns a value p such that
D(p).param() == p.

post: d.param() == p.

With p = d.param(), the
sequence of numbers returned
by successive invocations with
the same object g is randomly
distributed according to the
associated p(z |{p}) or
P(zi |{p}) function.

Complexity
compile-time
compile-time
constant

same as p’s
construction

constant

no worse than
the complexity
of D(p)
no worse than
the complexity
of D(p)
amortized
constant
number of
invocations of g

§ 26.5.1.6

943

c(cid:13) ISO/IEC

Expression

Return type

d(g,p)

T

x.min()
x.max()
x == y

T
T
bool

x != y

os << x

is >> d

bool

reference to the type of
os

reference to the type of
is

N4296

Complexity
amortized
constant
number of
invocations of g

constant
constant
constant

same as x ==
y.

Pre/post-condition

The sequence of numbers
returned by successive
invocations with the same
objects g and p is randomly
distributed according to the
associated p(z |{p}) or
P(zi |{p}) function.
Returns glb.
Returns lub.
This operator is an equivalence
relation. Returns true if
x.param() == y.param() and
S1 = S2, where S1 and S2 are
the inﬁnite sequences of values
that would be generated,
respectively, by repeated future
calls to x(g1) and y(g2)
whenever g1 == g2. Otherwise
returns false.
!(x == y).

Writes to os a textual
representation for the
parameters and the additional
internal data of x.
post: The os.fmtﬂags and ﬁll
character are unchanged.
Restores from is the
parameters and additional
internal data of the lvalue d. If
bad input is encountered,
ensures that d is unchanged by
the operation and calls
is.setstate(ios::failbit)
(which may throw
ios::failure [27.5.5.4]).
pre: is provides a textual
representation that was
previously written using an os
whose imbued locale and whose
type’s template specialization
arguments charT and traits
were the same as those of is.
post: The is.fmtﬂags are
unchanged.

4 D shall satisfy the requirements of CopyConstructible (Table 21) and CopyAssignable (Table 23) types.
5 The sequence of numbers produced by repeated invocations of d(g) shall be independent of any invocation

§ 26.5.1.6

944

c(cid:13) ISO/IEC

N4296

6

7

of os << d or of any const member function of D between any of the invocations d(g).
If a textual representation is written using os << x and that representation is restored into the same or
a diﬀerent object y of the same type using is >> y, repeated invocations of y(g) shall produce the same
sequence of numbers as would repeated invocations of x(g).
It is unspeciﬁed whether D::param_type is declared as a (nested) class or via a typedef. In this subclause
26.5, declarations of D::param_type are in the form of typedefs for convenience of exposition only.

8 P shall satisfy the requirements of CopyConstructible (Table 21), CopyAssignable (Table 23), and EqualityComparable

(Table 17) types.

9 For each of the constructors of D taking arguments corresponding to parameters of the distribution, P
shall have a corresponding constructor subject to the same requirements and taking arguments identical
in number, type, and default values. Moreover, for each of the member functions of D that return values
corresponding to parameters of the distribution, P shall have a corresponding member function with the
identical name, type, and semantics.
10 P shall have a declaration of the form

typedef D distribution_type;

26.5.2 Header <random> synopsis

#include <initializer_list>

namespace std {

// 26.5.3.1, class template linear_congruential_engine
template<class UIntType, UIntType a, UIntType c, UIntType m>

class linear_congruential_engine;

[rand.synopsis]

// 26.5.3.2, class template mersenne_twister_engine
template<class UIntType, size_t w, size_t n, size_t m, size_t r,

UIntType a, size_t u, UIntType d, size_t s,
UIntType b, size_t t,
UIntType c, size_t l, UIntType f>

class mersenne_twister_engine;

// 26.5.3.3, class template subtract_with_carry_engine
template<class UIntType, size_t w, size_t s, size_t r>

class subtract_with_carry_engine;

// 26.5.4.2, class template discard_block_engine
template<class Engine, size_t p, size_t r>

class discard_block_engine;

// 26.5.4.3, class template independent_bits_engine
template<class Engine, size_t w, class UIntType>

class independent_bits_engine;

// 26.5.4.4, class template shuﬄe_order_engine
template<class Engine, size_t k>

class shuffle_order_engine;

// 26.5.5, engines and engine adaptors with predeﬁned parameters
typedef see below minstd_rand0;
typedef see below minstd_rand;

§ 26.5.2

945

c(cid:13) ISO/IEC

N4296

typedef see below mt19937;
typedef see below mt19937_64;
typedef see below ranlux24_base;
typedef see below ranlux48_base;
typedef see below ranlux24;
typedef see below ranlux48;
typedef see below knuth_b;
typedef see below default_random_engine;

// 26.5.6, class random_device
class random_device;

// 26.5.7.1, class seed_seq
class seed_seq;

// 26.5.7.2, function template generate_canonical
template<class RealType, size_t bits, class URNG>

RealType generate_canonical(URNG& g);

// 26.5.8.2.1, class template uniform_int_distribution
template<class IntType = int>

class uniform_int_distribution;

// 26.5.8.2.2, class template uniform_real_distribution
template<class RealType = double>
class uniform_real_distribution;

// 26.5.8.3.1, class bernoulli_distribution
class bernoulli_distribution;

// 26.5.8.3.2, class template binomial_distribution
template<class IntType = int>
class binomial_distribution;

// 26.5.8.3.3, class template geometric_distribution
template<class IntType = int>

class geometric_distribution;

// 26.5.8.3.4, class template negative_binomial_distribution
template<class IntType = int>

class negative_binomial_distribution;

// 26.5.8.4.1, class template poisson_distribution
template<class IntType = int>
class poisson_distribution;

// 26.5.8.4.2, class template exponential_distribution
template<class RealType = double>
class exponential_distribution;

// 26.5.8.4.3, class template gamma_distribution
template<class RealType = double>

class gamma_distribution;

// 26.5.8.4.4, class template weibull_distribution

§ 26.5.2

946

c(cid:13) ISO/IEC

N4296

template<class RealType = double>

class weibull_distribution;

// 26.5.8.4.5, class template extreme_value_distribution
template<class RealType = double>

class extreme_value_distribution;

// 26.5.8.5.1, class template normal_distribution
template<class RealType = double>

class normal_distribution;

// 26.5.8.5.2, class template lognormal_distribution
template<class RealType = double>

class lognormal_distribution;

// 26.5.8.5.3, class template chi_squared_distribution
template<class RealType = double>
class chi_squared_distribution;

// 26.5.8.5.4, class template cauchy_distribution
template<class RealType = double>

class cauchy_distribution;

// 26.5.8.5.5, class template ﬁsher_f_distribution
template<class RealType = double>

class fisher_f_distribution;

// 26.5.8.5.6, class template student_t_distribution
template<class RealType = double>

class student_t_distribution;

// 26.5.8.6.1, class template discrete_distribution
template<class IntType = int>
class discrete_distribution;

// 26.5.8.6.2, class template piecewise_constant_distribution
template<class RealType = double>

class piecewise_constant_distribution;

// 26.5.8.6.3, class template piecewise_linear_distribution
template<class RealType = double>

class piecewise_linear_distribution;

} // namespace std

26.5.3 Random number engine class templates

[rand.eng]
1 Each type instantiated from a class template speciﬁed in this section 26.5.3 satisﬁes the requirements of a

random number engine (26.5.1.4) type.

2 Except where speciﬁed otherwise, the complexity of each function speciﬁed in this section 26.5.3 is constant.
3 Except where speciﬁed otherwise, no function described in this section 26.5.3 throws an exception.
4 Descriptions are provided in this section 26.5.3 only for engine operations that are not described in 26.5.1.4
or for operations where there is additional semantic information. In particular, declarations for copy con-
structors, for copy assignment operators, for streaming operators, and for equality and inequality operators

§ 26.5.3

947

c(cid:13) ISO/IEC

are not shown in the synopses.

N4296

5 Each template speciﬁed in this section 26.5.3 requires one or more relationships, involving the value(s) of
its non-type template parameter(s), to hold. A program instantiating any of these templates is ill-formed if
any such required relationship fails to hold.

6 For every random number engine and for every random number engine adaptor X deﬁned in this sub-

clause (26.5.3) and in sub-clause 26.5.4:

(6.1)

—

if the constructor

template <class Sseq> explicit X(Sseq& q);

is called with a type Sseq that does not qualify as a seed sequence, then this constructor shall not
participate in overload resolution;
if the member function

(6.2)

—

template <class Sseq> void seed(Sseq& q);

is called with a type Sseq that does not qualify as a seed sequence, then this function shall not
participate in overload resolution.

The extent to which an implementation determines that a type cannot be a seed sequence is unspeciﬁed,
except that as a minimum a type shall not qualify as a seed sequence if it is implicitly convertible to
X::result_type.
26.5.3.1 Class template linear_congruential_engine

[rand.eng.lcong]
1 A linear_congruential_engine random number engine produces unsigned integer random numbers. The
state xi of a linear_congruential_engine object x is of size 1 and consists of a single integer. The
transition algorithm is a modular linear function of the form TA(xi) = (a · xi + c) mod m; the generation
algorithm is GA(xi) = xi+1.

template<class UIntType, UIntType a, UIntType c, UIntType m>
class linear_congruential_engine
{
public:
// types
typedef UIntType result_type;

// engine characteristics
static constexpr result_type multiplier = a;
static constexpr result_type increment = c;
static constexpr result_type modulus = m;
static constexpr result_type min() { return c == 0u ? 1u: 0u; }
static constexpr result_type max() { return m - 1u; }
static constexpr result_type default_seed = 1u;

// constructors and seeding functions
explicit linear_congruential_engine(result_type s = default_seed);
template<class Sseq> explicit linear_congruential_engine(Sseq& q);
void seed(result_type s = default_seed);
template<class Sseq> void seed(Sseq& q);

// generating functions
result_type operator()();
void discard(unsigned long long z);
};

§ 26.5.3.1

948

c(cid:13) ISO/IEC

N4296

If the template parameter m is 0, the modulus m used throughout this section 26.5.3.1 is numeric_-
limits<result_type>::max() plus 1. [ Note: m need not be representable as a value of type result_type.
— end note ]
If the template parameter m is not 0, the following relations shall hold: a < m and c < m.

3
4 The textual representation consists of the value of xi.

explicit linear_congruential_engine(result_type s = default_seed);

2

5

6

Eﬀects: Constructs a linear_congruential_engine object. If c mod m is 0 and s mod m is 0, sets
the engine’s state to 1, otherwise sets the engine’s state to s mod m.

template<class Sseq> explicit linear_congruential_engine(Sseq& q);

Eﬀects: Constructs a linear_congruential_engine object. With k = l log2 m
(cid:16)Pk−1
j=0 aj+3 · 232j(cid:17) mod m.

(or equivalent) of length k + 3, invokes q.generate(a + 0, a + k + 3) and then computes S =
If c mod m is 0 and S is 0, sets the engine’s state to 1, else sets the

m and a an array

32

engine’s state to S.

26.5.3.2 Class template mersenne_twister_engine

[rand.eng.mers]
1 A mersenne_twister_engine random number engine276 produces unsigned integer random numbers in the
closed interval [0, 2w − 1]. The state xi of a mersenne_twister_engine object x is of size n and consists of
a sequence X of n values of the type delivered by x; all subscripts applied to X are to be taken modulo n.
2 The transition algorithm employs a twisted generalized feedback shift register deﬁned by shift values n and
m, a twist value r, and a conditional xor-mask a. To improve the uniformity of the result, the bits of the
raw shift register are additionally tempered (i.e., scrambled) according to a bit-scrambling matrix deﬁned
by values u, d, s, b, t, c, and ‘.
The state transition is performed as follows:

a) Concatenate the upper w−r bits of Xi−n with the lower r bits of Xi+1−n to obtain an unsigned integer

value Y .

b) With α = a · (Y bitand 1), set Xi to Xi+m−n xor (Y rshift 1) xor α.

The sequence X is initialized with the help of an initialization multiplier f.

3 The generation algorithm determines the unsigned integer values z1, z2, z3, z4 as follows, then delivers z4 as

its result:

a) Let z1 = Xi xor(cid:0)(Xi rshift u) bitand d(cid:1).
b) Let z2 = z1 xor(cid:0)(z1 lshiftw s) bitand b(cid:1).
c) Let z3 = z2 xor(cid:0)(z2 lshiftw t) bitand c(cid:1).

d) Let z4 = z3 xor (z3 rshift ‘).

template<class UIntType, size_t w, size_t n, size_t m, size_t r,

UIntType a, size_t u, UIntType d, size_t s,
UIntType b, size_t t,

276) The name of this engine refers, in part, to a property of its period: For properly-selected values of the parameters, the
period is closely related to a large Mersenne prime number.

§ 26.5.3.2

949

c(cid:13) ISO/IEC

N4296

UIntType c, size_t l, UIntType f>

class mersenne_twister_engine
{
public:
// types
typedef UIntType result_type;

// engine characteristics
static constexpr size_t word_size = w;
static constexpr size_t state_size = n;
static constexpr size_t shift_size = m;
static constexpr size_t mask_bits = r;
static constexpr UIntType xor_mask = a;
static constexpr size_t tempering_u = u;
static constexpr UIntType tempering_d = d;
static constexpr size_t tempering_s = s;
static constexpr UIntType tempering_b = b;
static constexpr size_t tempering_t = t;
static constexpr UIntType tempering_c = c;
static constexpr size_t tempering_l = l;
static constexpr UIntType initialization_multiplier = f;
static constexpr result_type min() { return 0; }
static constexpr result_type max() { return 2w − 1; }
static constexpr result_type default_seed = 5489u;

// constructors and seeding functions
explicit mersenne_twister_engine(result_type value = default_seed);
template<class Sseq> explicit mersenne_twister_engine(Sseq& q);
void seed(result_type value = default_seed);
template<class Sseq> void seed(Sseq& q);

// generating functions
result_type operator()();
void discard(unsigned long long z);
};

4 The following relations shall hold: 0 < m, m <= n, 2u < w, r <= w, u <= w, s <= w, t <= w, l <= w, w <=
numeric_limits<UIntType>::digits, a <= (1u<<w) - 1u, b <= (1u<<w) - 1u, c <= (1u<<w) - 1u, d
<= (1u<<w) - 1u, and f <= (1u<<w) - 1u.

5 The textual representation of xi consists of the values of Xi−n, . . . , Xi−1, in that order.

explicit mersenne_twister_engine(result_type value = default_seed);

Eﬀects: Constructs a mersenne_twister_engine object. Sets X−n to value mod 2w. Then, itera-
tively for i = 1−n, . . . ,−1, sets Xi to

(cid:2)f ·(cid:0)Xi−1 xor(cid:0)Xi−1 rshift (w − 2)(cid:1)(cid:1) + i mod n(cid:3) mod 2w .

Complexity: O(n).

template<class Sseq> explicit mersenne_twister_engine(Sseq& q);

6

7

8

sets Xi to(cid:16)Pk−1

Eﬀects: Constructs a mersenne_twister_engine object. With k = dw/32e and a an array (or equiv-
alent) of length n · k, invokes q.generate(a + 0, a + n · k) and then, iteratively for i = −n, . . . ,−1,

j=0 ak(i+n)+j · 232j(cid:17) mod 2w. Finally, if the most signiﬁcant w − r bits of X−n are zero,

and if each of the other resulting Xi is 0, changes X−n to 2w−1.

§ 26.5.3.2

950

c(cid:13) ISO/IEC

N4296

26.5.3.3 Class template subtract_with_carry_engine

[rand.eng.sub]

1 A subtract_with_carry_engine random number engine produces unsigned integer random numbers.
2 The state xi of a subtract_with_carry_engine object x is of size O(r), and consists of a sequence X of
r integer values 0 ≤ Xi < m = 2w; all subscripts applied to X are to be taken modulo r. The state xi
additionally consists of an integer c (known as the carry) whose value is either 0 or 1.

3 The state transition is performed as follows:

a) Let Y = Xi−s − Xi−r − c.
b) Set Xi to y = Y mod m. Set c to 1 if Y < 0, otherwise set c to 0.

[ Note: This algorithm corresponds to a modular linear function of the form TA(xi) = (a · xi) mod b, where
b is of the form mr − ms + 1 and a = b − (b − 1)/m. — end note ]

4 The generation algorithm is given by GA(xi) = y, where y is the value produced as a result of advancing the

engine’s state as described above.

template<class UIntType, size_t w, size_t s, size_t r>
class subtract_with_carry_engine
{
public:
// types
typedef UIntType result_type;

// engine characteristics
static constexpr size_t word_size = w;
static constexpr size_t short_lag = s;
static constexpr size_t long_lag = r;
static constexpr result_type min() { return 0; }
static constexpr result_type max() { return m − 1; }
static constexpr result_type default_seed = 19780503u;

// constructors and seeding functions
explicit subtract_with_carry_engine(result_type value = default_seed);
template<class Sseq> explicit subtract_with_carry_engine(Sseq& q);
void seed(result_type value = default_seed);
template<class Sseq> void seed(Sseq& q);

// generating functions
result_type operator()();
void discard(unsigned long long z);
};

5 The following relations shall hold: 0u < s, s < r, 0 < w, and w <= numeric_limits<UIntType>::digits.
6 The textual representation consists of the values of Xi−r, . . . , Xi−1, in that order, followed by c.

explicit subtract_with_carry_engine(result_type value = default_seed);

7

Eﬀects: Constructs a subtract_with_carry_engine object. Sets the values of X−r, . . . , X−1, in that
order, as speciﬁed below. If X−1 is then 0, sets c to 1; otherwise sets c to 0.
To set the values Xk, ﬁrst construct e, a linear_congruential_engine object, as if by the following
deﬁnition:

linear_congruential_engine<result_type,

40014u,0u,2147483563u> e(value == 0u ? default_seed : value);

§ 26.5.3.3

951

c(cid:13) ISO/IEC

N4296

Then, to set each Xk, obtain new values z0, . . . , zn−1 from n = dw/32e successive invocations of e

taken modulo 232. Set Xk to(cid:16)Pn−1

j=0 zj · 232j(cid:17) mod m.

Complexity: Exactly n · r invocations of e.

8

9

template<class Sseq> explicit subtract_with_carry_engine(Sseq& q);

sets Xi to(cid:16)Pk−1

Eﬀects: Constructs a subtract_with_carry_engine object. With k = dw/32e and a an array (or
equivalent) of length r·k, invokes q.generate(a+0, a+r·k) and then, iteratively for i = −r, . . . ,−1,

j=0 ak(i+r)+j · 232j(cid:17) mod m. If X−1 is then 0, sets c to 1; otherwise sets c to 0.

26.5.4 Random number engine adaptor class templates
26.5.4.1

[rand.adapt]
[rand.adapt.general]
1 Each type instantiated from a class template speciﬁed in this section 26.5.3 satisﬁes the requirements of a

In general

random number engine adaptor (26.5.1.5) type.

2 Except where speciﬁed otherwise, the complexity of each function speciﬁed in this section 26.5.4 is constant.
3 Except where speciﬁed otherwise, no function described in this section 26.5.4 throws an exception.
4 Descriptions are provided in this section 26.5.4 only for adaptor operations that are not described in sec-
tion 26.5.1.5 or for operations where there is additional semantic information. In particular, declarations for
copy constructors, for copy assignment operators, for streaming operators, and for equality and inequality
operators are not shown in the synopses.

5 Each template speciﬁed in this section 26.5.4 requires one or more relationships, involving the value(s) of
its non-type template parameter(s), to hold. A program instantiating any of these templates is ill-formed if
any such required relationship fails to hold.
26.5.4.2 Class template discard_block_engine

[rand.adapt.disc]
1 A discard_block_engine random number engine adaptor produces random numbers selected from those
produced by some base engine e. The state xi of a discard_block_engine engine adaptor object x consists
of the state ei of its base engine e and an additional integer n. The size of the state is the size of e’s state
plus 1.

2 The transition algorithm discards all but r > 0 values from each block of p ≥ r values delivered by e. The
state transition is performed as follows: If n ≥ r, advance the state of e from ei to ei+p−r and set n to 0.
In any case, then increment n and advance e’s then-current state ej to ej+1.

3 The generation algorithm yields the value returned by the last invocation of e() while advancing e’s state

as described above.

template<class Engine, size_t p, size_t r>
class discard_block_engine
{
public:
// types
typedef typename Engine::result_type result_type;

// engine characteristics
static constexpr size_t block_size = p;
static constexpr size_t used_block = r;
static constexpr result_type min() { return Engine::min(); }
static constexpr result_type max() { return Engine::max(); }

// constructors and seeding functions
discard_block_engine();

§ 26.5.4.2

952

c(cid:13) ISO/IEC

N4296

explicit discard_block_engine(const Engine& e);
explicit discard_block_engine(Engine&& e);
explicit discard_block_engine(result_type s);
template<class Sseq> explicit discard_block_engine(Sseq& q);
void seed();
void seed(result_type s);
template<class Sseq> void seed(Sseq& q);

// generating functions
result_type operator()();
void discard(unsigned long long z);

// property functions
const Engine& base() const noexcept { return e; };

private:
Engine e;
int n;
};

// exposition only
// exposition only

4 The following relations shall hold: 0 < r and r <= p.
5 The textual representation consists of the textual representation of e followed by the value of n.
6

In addition to its behavior pursuant to section 26.5.1.5, each constructor that is not a copy constructor sets
n to 0.
26.5.4.3 Class template independent_bits_engine

[rand.adapt.ibits]
1 An independent_bits_engine random number engine adaptor combines random numbers that are produced
by some base engine e, so as to produce random numbers with a speciﬁed number of bits w. The state xi of
an independent_bits_engine engine adaptor object x consists of the state ei of its base engine e; the size
of the state is the size of e’s state.

2 The transition and generation algorithms are described in terms of the following integral constants:

a) Let R = e.max() - e.min() + 1 and m = blog2 Rc.
b) With n as determined below, let w0 = bw/nc, n0 = n − w mod n, y0 = 2w0 bR/2w0c, and y1 =

2w0+1(cid:4)R/2w0+1(cid:5).

c) Let n = dw/me if and only if the relation R − y0 ≤ by0/nc holds as a result. Otherwise let n =

1 + dw/me.

[ Note: The relation w = n0w0 + (n − n0)(w0 + 1) always holds. — end note ]

3 The transition algorithm is carried out by invoking e() as often as needed to obtain n0 values less than y0

+e.min() and n − n0 values less than y1 + e.min().

4 The generation algorithm uses the values produced while advancing the state as described above to yield a

quantity S obtained as if by the following algorithm:

S = 0;
for (k = 0; k 6= n0; k += 1)
do u = e() - e.min(); while (u ≥ y0);
S = 2w0 · S + u mod 2w0;
}
for (k = n0; k 6= n; k += 1)

{

{

§ 26.5.4.3

953

c(cid:13) ISO/IEC

N4296

do u = e() - e.min(); while (u ≥ y1);
S = 2w0+1 · S + u mod 2w0+1;
}

template<class Engine, size_t w, class UIntType>
class independent_bits_engine
{
public:
// types
typedef UIntType result_type;

// engine characteristics
static constexpr result_type min() { return 0; }
static constexpr result_type max() { return 2w − 1; }

// constructors and seeding functions
independent_bits_engine();
explicit independent_bits_engine(const Engine& e);
explicit independent_bits_engine(Engine&& e);
explicit independent_bits_engine(result_type s);
template<class Sseq> explicit independent_bits_engine(Sseq& q);
void seed();
void seed(result_type s);
template<class Sseq> void seed(Sseq& q);

// generating functions
result_type operator()();
void discard(unsigned long long z);

// property functions
const Engine& base() const noexcept { return e; };

private:
Engine e;
};

// exposition only

5 The following relations shall hold: 0 < w and w <= numeric_limits<result_type>::digits.
6 The textual representation consists of the textual representation of e.

26.5.4.4 Class template shuffle_order_engine

[rand.adapt.shuf]
1 A shuffle_order_engine random number engine adaptor produces the same random numbers that are
produced by some base engine e, but delivers them in a diﬀerent sequence. The state xi of a shuffle_-
order_engine engine adaptor object x consists of the state ei of its base engine e, an additional value Y of
the type delivered by e, and an additional sequence V of k values also of the type delivered by e. The size
of the state is the size of e’s state plus k + 1.

2 The transition algorithm permutes the values produced by e. The state transition is performed as follows:

a) Calculate an integer j =j k·(Y −emin)

emax−emin+1

k.

b) Set Y to Vj and then set Vj to e().

3 The generation algorithm yields the last value of Y produced while advancing e’s state as described above.

§ 26.5.4.4

954

c(cid:13) ISO/IEC

N4296

template<class Engine, size_t k>
class shuffle_order_engine
{
public:
// types
typedef typename Engine::result_type result_type;

// engine characteristics
static constexpr size_t table_size = k;
static constexpr result_type min() { return Engine::min(); }
static constexpr result_type max() { return Engine::max(); }

// constructors and seeding functions
shuffle_order_engine();
explicit shuffle_order_engine(const Engine& e);
explicit shuffle_order_engine(Engine&& e);
explicit shuffle_order_engine(result_type s);
template<class Sseq> explicit shuffle_order_engine(Sseq& q);
void seed();
void seed(result_type s);
template<class Sseq> void seed(Sseq& q);

// generating functions
result_type operator()();
void discard(unsigned long long z);

// property functions
const Engine& base() const noexcept { return e; };

private:
Engine e;
result_type Y;
result_type V[k];
};

// exposition only
// exposition only
// exposition only

4 The following relation shall hold: 0 < k.
5 The textual representation consists of the textual representation of e, followed by the k values of V , followed

by the value of Y .
In addition to its behavior pursuant to section 26.5.1.5, each constructor that is not a copy constructor
initializes V[0], . . . , V[k-1] and Y , in that order, with values returned by successive invocations of e().
26.5.5 Engines and engine adaptors with predeﬁned parameters
typedef linear_congruential_engine<uint_fast32_t, 16807, 0, 2147483647>

[rand.predef]

6

1

2

minstd_rand0;

Required behavior: The 10000 th consecutive invocation of a default-constructed object of type minstd_-
rand0 shall produce the value 1043618065.

typedef linear_congruential_engine<uint_fast32_t, 48271, 0, 2147483647>

minstd_rand;

Required behavior: The 10000 th consecutive invocation of a default-constructed object of type minstd_-
rand shall produce the value 399268537.

§ 26.5.5

955

3

4

5

6

7

8

9

10

c(cid:13) ISO/IEC

N4296

typedef mersenne_twister_engine<uint_fast32_t,

32,624,397,31,0x9908b0df,11,0xffffffff,7,0x9d2c5680,15,0xefc60000,18,1812433253>
mt19937;

Required behavior: The 10000 th consecutive invocation of a default-constructed object of type mt19937
shall produce the value 4123659995.

typedef mersenne_twister_engine<uint_fast64_t,

64,312,156,31,0xb5026f5aa96619e9,29,
0x5555555555555555,17,
0x71d67fffeda60000,37,
0xfff7eee000000000,43,
6364136223846793005>
mt19937_64;

Required behavior: The 10000 th consecutive invocation of a default-constructed object of type mt19937_-
64 shall produce the value 9981545732273789042.

typedef subtract_with_carry_engine<uint_fast32_t, 24, 10, 24>

ranlux24_base;

Required behavior: The 10000 th consecutive invocation of a default-constructed object of type ranlux24_-
base shall produce the value 7937952.

typedef subtract_with_carry_engine<uint_fast64_t, 48, 5, 12>

ranlux48_base;

Required behavior: The 10000 th consecutive invocation of a default-constructed object of type ranlux48_-
base shall produce the value 61839128582725.

typedef discard_block_engine<ranlux24_base, 223, 23>

ranlux24;

Required behavior: The 10000 th consecutive invocation of a default-constructed object of type ranlux24
shall produce the value 9901578.

typedef discard_block_engine<ranlux48_base, 389, 11>

ranlux48;

Required behavior: The 10000 th consecutive invocation of a default-constructed object of type ranlux48
shall produce the value 249142670248501.

typedef shuffle_order_engine<minstd_rand0,256>

knuth_b;

Required behavior: The 10000 th consecutive invocation of a default-constructed object of type knuth_b
shall produce the value 1112339016.

typedef implementation-defined
default_random_engine;

Remark: The choice of engine type named by this typedef is implementation-deﬁned.
[ Note: The
implementation may select this type on the basis of performance, size, quality, or any combination of
such factors, so as to provide at least acceptable engine behavior for relatively casual, inexpert, and/or
lightweight use. Because diﬀerent implementations may select diﬀerent underlying engine types, code
that uses this typedef need not generate identical sequences across implementations. — end note ]

§ 26.5.5

956

c(cid:13) ISO/IEC

26.5.6 Class random_device

N4296

[rand.device]

1 A random_device uniform random number generator produces non-deterministic random numbers.
2

If implementation limitations prevent generating non-deterministic random numbers, the implementation
may employ a random number engine.

class random_device
{
public:
// types
typedef unsigned int result_type;

// generator characteristics
static constexpr result_type min() { return numeric_limits<result_type>::min(); }
static constexpr result_type max() { return numeric_limits<result_type>::max(); }

// constructors
explicit random_device(const string& token = implementation-defined );

// generating functions
result_type operator()();

// property functions
double entropy() const noexcept;

// no copy functions
random_device(const random_device& ) = delete;
void operator=(const random_device& ) = delete;
};

3

4

5

6

7

explicit random_device(const string& token = implementation-defined );

Eﬀects: Constructs a random_device non-deterministic uniform random number generator object.
The semantics and default value of the token parameter are implementation-deﬁned.277
Throws: A value of an implementation-deﬁned type derived from exception if the random_device
could not be initialized.

double entropy() const noexcept;

Returns: If the implementation employs a random number engine, returns 0.0. Otherwise, returns
an entropy estimate278 for the random numbers returned by operator(), in the range min() to
log2(max() + 1).

result_type operator()();

Returns: A non-deterministic random value, uniformly distributed between min() and max(), inclusive.
It is implementation-deﬁned how these values are generated.
Throws: A value of an implementation-deﬁned type derived from exception if a random number could
not be obtained.

277) The parameter is intended to allow an implementation to diﬀerentiate between diﬀerent sources of randomness.
278) If a device has n states whose respective probabilities are P0, . . . , Pn−1, the device entropy S is deﬁned as

S = −Pn−1

i=0 Pi · log Pi.

§ 26.5.6

957

c(cid:13) ISO/IEC

26.5.7 Utilities
26.5.7.1 Class seed_seq

class seed_seq
{
public:
// types
typedef uint_least32_t result_type;

N4296

[rand.util]
[rand.util.seedseq]

// constructors
seed_seq();
template<class T>

seed_seq(initializer_list<T> il);

template<class InputIterator>

seed_seq(InputIterator begin, InputIterator end);

// generating functions
template<class RandomAccessIterator>

void generate(RandomAccessIterator begin, RandomAccessIterator end);

// property functions
size_t size() const;
template<class OutputIterator>

void param(OutputIterator dest) const;

// no copy functions
seed_seq(const seed_seq& ) = delete;
void operator=(const seed_seq& ) = delete;

private:
vector<result_type> v;
};

// exposition only

1

2

3

4

5

6

seed_seq();

Eﬀects: Constructs a seed_seq object as if by default-constructing its member v.
Throws: Nothing.

template<class T>
seed_seq(initializer_list<T> il);

Requires: T shall be an integer type.
Eﬀects: Same as seed_seq(il.begin(), il.end()).

template<class InputIterator>

seed_seq(InputIterator begin, InputIterator end);

Requires: InputIterator shall satisfy the requirements of an input iterator (Table 107) type. More-
over, iterator_traits<InputIterator>::value_type shall denote an integer type.
Eﬀects: Constructs a seed_seq object by the following algorithm:

for( InputIterator s = begin; s != end; ++s)
v.push_back((*s)mod232);

template<class RandomAccessIterator>

void generate(RandomAccessIterator begin, RandomAccessIterator end);

§ 26.5.7.1

958

7

8

9

10

11

12

13

14

15

c(cid:13) ISO/IEC

N4296

Requires: RandomAccessIterator shall meet the requirements of a mutable random access iterator
(Table 111) type. Moreover, iterator_traits<RandomAccessIterator>::value_type shall denote
an unsigned integer type capable of accommodating 32-bit quantities.
Eﬀects: Does nothing if begin == end. Otherwise, with s = v.size() and n = end − begin, ﬁlls
the supplied range [begin, end) according to the following algorithm in which each operation is to be
carried out modulo 232, each indexing operator applied to begin is to be taken modulo n, and T(x) is
deﬁned as x xor (x rshift 27):

a) By way of initialization, set each element of the range to the value 0x8b8b8b8b. Additionally, for

use in subsequent steps, let p = (n − t)/2 and let q = p + t, where

t = (n ≥ 623) ? 11 : (n ≥ 68) ? 7 : (n ≥ 39) ? 5 : (n ≥ 7) ? 3 : (n − 1)/2;

b) With m as the larger of s + 1 and n, transform the elements of the range:

iteratively for k =

0, . . . , m − 1, calculate values

r1 = 1664525 · T (begin[k] xor begin[k + p] xor begin[k − 1])

r2 = r1 +

k mod n + v[k − 1] , 0 < k ≤ s



s

k mod n

, k = 0

, s < k

and, in order, increment begin[k + p] by r1, increment begin[k + q] by r2, and set begin[k]
to r2.

c) Transform the elements of the range again, beginning where the previous step ended: iteratively

for k = m, . . . , m+n−1, calculate values

r3 = 1566083941 · T (begin[k] + begin[k + p] + begin[k − 1])
r4 = r3 − (k mod n)

and, in order, update begin[k + p] by xoring it with r3, update begin[k + q] by xoring it with
r4, and set begin[k] to r4.

Throws: What and when RandomAccessIterator operations of begin and end throw.

size_t size() const;

Returns: The number of 32-bit units that would be returned by a call to param().
Throws: Nothing.
Complexity: Constant time.

template<class OutputIterator>

void param(OutputIterator dest) const;

Requires: OutputIterator shall satisfy the requirements of an output iterator (Table 108) type. More-
over, the expression *dest = rt shall be valid for a value rt of type result_type.
Eﬀects: Copies the sequence of prepared 32-bit units to the given destination, as if by executing the
following statement:

copy(v.begin(), v.end(), dest);

Throws: What and when OutputIterator operations of dest throw.

§ 26.5.7.1

959

c(cid:13) ISO/IEC

N4296

26.5.7.2 Function template generate_canonical

[rand.util.canonical]
1 Each function instantiated from the template described in this section 26.5.7.2 maps the result of one or
more invocations of a supplied uniform random number generator g to one member of the speciﬁed RealType
such that, if the values gi produced by g are uniformly distributed, the instantiation’s results tj, 0 ≤ tj < 1,
are distributed as uniformly as possible as speciﬁed below.
[ Note: Obtaining a value in this way can be a useful step in the process of transforming a value generated
by a uniform random number generator into a value that can be delivered by a random number distribution.
— end note ]

2

template<class RealType, size_t bits, class URNG>
RealType generate_canonical(URNG& g);

Complexity: Exactly k = max(1,db/ log2 Re) invocations of g, where b279 is the lesser of numeric_-
limits<RealType>::digits and bits, and R is the value of g.max() − g.min() + 1.
Eﬀects: Invokes g() k times to obtain values g0, . . . , gk−1, respectively. Calculates a quantity

k−1X

S =

(gi − g.min()) · Ri

3

4

5

6

i=0

using arithmetic of type RealType.
Returns: S/Rk.
Throws: What and when g throws.

26.5.8 Random number distribution class templates
26.5.8.1

[rand.dist]
[rand.dist.general]
1 Each type instantiated from a class template speciﬁed in this section 26.5.8 satisﬁes the requirements of a

In general

random number distribution (26.5.1.6) type.

2 Descriptions are provided in this section 26.5.8 only for distribution operations that are not described in
26.5.1.6 or for operations where there is additional semantic information.
In particular, declarations for
copy constructors, for copy assignment operators, for streaming operators, and for equality and inequality
operators are not shown in the synopses.

3 The algorithms for producing each of the speciﬁed distributions are implementation-deﬁned.
4 The value of each probability density function p(z) and of each discrete probability function P(zi) speciﬁed

in this section is 0 everywhere outside its stated domain.
26.5.8.2 Uniform distributions
26.5.8.2.1 Class template uniform_int_distribution

[rand.dist.uni]
[rand.dist.uni.int]
1 A uniform_int_distribution random number distribution produces random integers i, a ≤ i ≤ b, dis-

tributed according to the constant discrete probability function

P(i| a, b) = 1/(b − a + 1) .

template<class IntType = int>
class uniform_int_distribution
{
public:
// types

279) b is introduced to avoid any attempt to produce more bits of randomness than can be held in RealType.

§ 26.5.8.2.1

960

c(cid:13) ISO/IEC

typedef IntType result_type;
typedef unspecified param_type;

N4296

// constructors and reset functions
explicit uniform_int_distribution(IntType a = 0, IntType b = numeric_limits<IntType>::max());
explicit uniform_int_distribution(const param_type& parm);
void reset();

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

result_type operator()(URNG& g, const param_type& parm);

// property functions
result_type a() const;
result_type b() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

explicit uniform_int_distribution(IntType a = 0, IntType b = numeric_limits<IntType>::max());

Requires: a ≤ b.
Eﬀects: Constructs a uniform_int_distribution object; a and b correspond to the respective pa-
rameters of the distribution.

result_type a() const;

Returns: The value of the a parameter with which the object was constructed.

result_type b() const;

Returns: The value of the b parameter with which the object was constructed.

2

3

4

5

26.5.8.2.2 Class template uniform_real_distribution

[rand.dist.uni.real]
1 A uniform_real_distribution random number distribution produces random numbers x, a ≤ x < b,

distributed according to the constant probability density function
p(x| a, b) = 1/(b − a) .

template<class RealType = double>
class uniform_real_distribution
{
public:
// types
typedef RealType result_type;
typedef unspecified param_type;

// constructors and reset functions
explicit uniform_real_distribution(RealType a = 0.0, RealType b = 1.0);
explicit uniform_real_distribution(const param_type& parm);
void reset();

§ 26.5.8.2.2

961

c(cid:13) ISO/IEC

N4296

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

result_type operator()(URNG& g, const param_type& parm);

// property functions
result_type a() const;
result_type b() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

explicit uniform_real_distribution(RealType a = 0.0, RealType b = 1.0);

Requires: a ≤ b and b − a ≤ numeric_limits<RealType>::max().
Eﬀects: Constructs a uniform_real_distribution object; a and b correspond to the respective
parameters of the distribution.

result_type a() const;

Returns: The value of the a parameter with which the object was constructed.

result_type b() const;

Returns: The value of the b parameter with which the object was constructed.

2

3

4

5

26.5.8.3 Bernoulli distributions
26.5.8.3.1 Class bernoulli_distribution

[rand.dist.bern]
[rand.dist.bern.bernoulli]
1 A bernoulli_distribution random number distribution produces bool values b distributed according to

(cid:26) p

if
1 − p if

b = true
b = false

.

the discrete probability function

P(b| p) =

class bernoulli_distribution
{
public:
// types
typedef bool result_type;
typedef unspecified param_type;

// constructors and reset functions
explicit bernoulli_distribution(double p = 0.5);
explicit bernoulli_distribution(const param_type& parm);
void reset();

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

§ 26.5.8.3.1

962

c(cid:13) ISO/IEC

N4296

result_type operator()(URNG& g, const param_type& parm);

// property functions
double p() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

explicit bernoulli_distribution(double p = 0.5);

Requires: 0 ≤ p ≤ 1.
Eﬀects: Constructs a bernoulli_distribution object; p corresponds to the parameter of the distri-
bution.

double p() const;

Returns: The value of the p parameter with which the object was constructed.

2

3

4

26.5.8.3.2 Class template binomial_distribution

[rand.dist.bern.bin]
1 A binomial_distribution random number distribution produces integer values i ≥ 0 distributed according

(cid:18)t

(cid:19)

i

· pi · (1 − p)t−i .

to the discrete probability function

P(i| t, p) =

template<class IntType = int>
class binomial_distribution
{
public:
// types
typedef IntType result_type;
typedef unspecified param_type;

// constructors and reset functions
explicit binomial_distribution(IntType t = 1, double p = 0.5);
explicit binomial_distribution(const param_type& parm);
void reset();

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

result_type operator()(URNG& g, const param_type& parm);

// property functions
IntType t() const;
double p() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

§ 26.5.8.3.2

963

c(cid:13) ISO/IEC

N4296

explicit binomial_distribution(IntType t = 1, double p = 0.5);

Requires: 0 ≤ p ≤ 1 and 0 ≤ t.
Eﬀects: Constructs a binomial_distribution object; t and p correspond to the respective parameters
of the distribution.

IntType t() const;

Returns: The value of the t parameter with which the object was constructed.

double p() const;

Returns: The value of the p parameter with which the object was constructed.

2

3

4

5

26.5.8.3.3 Class template geometric_distribution

[rand.dist.bern.geo]
1 A geometric_distribution random number distribution produces integer values i ≥ 0 distributed accord-

ing to the discrete probability function

P(i| p) = p · (1 − p)i .

template<class IntType = int>
class geometric_distribution
{
public:
// types
typedef IntType result_type;
typedef unspecified param_type;

// constructors and reset functions
explicit geometric_distribution(double p = 0.5);
explicit geometric_distribution(const param_type& parm);
void reset();

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

result_type operator()(URNG& g, const param_type& parm);

// property functions
double p() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

explicit geometric_distribution(double p = 0.5);

Requires: 0 < p < 1.
Eﬀects: Constructs a geometric_distribution object; p corresponds to the parameter of the distri-
bution.

double p() const;

Returns: The value of the p parameter with which the object was constructed.

2

3

4

§ 26.5.8.3.3

964

c(cid:13) ISO/IEC

N4296

26.5.8.3.4 Class template negative_binomial_distribution

[rand.dist.bern.negbin]
1 A negative_binomial_distribution random number distribution produces random integers i ≥ 0 dis-

tributed according to the discrete probability function

(cid:18)k + i − 1
(cid:19)

i

· pk · (1 − p)i .

P(i| k, p) =

template<class IntType = int>
class negative_binomial_distribution
{
public:
// types
typedef IntType
typedef unspecified param_type;

result_type;

// constructor and reset functions
explicit negative_binomial_distribution(IntType k = 1, double p = 0.5);
explicit negative_binomial_distribution(const param_type& parm);
void reset();

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

result_type operator()(URNG& g, const param_type& parm);

// property functions
IntType k() const;
double p() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

explicit negative_binomial_distribution(IntType k = 1, double p = 0.5);

Requires: 0 < p ≤ 1 and 0 < k.
Eﬀects: Constructs a negative_binomial_distribution object; k and p correspond to the respective
parameters of the distribution.

IntType k() const;

Returns: The value of the k parameter with which the object was constructed.

double p() const;

Returns: The value of the p parameter with which the object was constructed.

2

3

4

5

26.5.8.4 Poisson distributions
26.5.8.4.1 Class template poisson_distribution

[rand.dist.pois]
[rand.dist.pois.poisson]
1 A poisson_distribution random number distribution produces integer values i ≥ 0 distributed according

to the discrete probability function

P(i| µ) = e−µµi
i !

.

§ 26.5.8.4.1

965

c(cid:13) ISO/IEC

N4296

The distribution parameter µ is also known as this distribution’s mean .

template<class IntType = int>
class poisson_distribution
{
public:
// types
typedef IntType result_type;
typedef unspecified param_type;

// constructors and reset functions
explicit poisson_distribution(double mean = 1.0);
explicit poisson_distribution(const param_type& parm);
void reset();

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

result_type operator()(URNG& g, const param_type& parm);

// property functions
double mean() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

explicit poisson_distribution(double mean = 1.0);

Requires: 0 < mean.
Eﬀects: Constructs a poisson_distribution object; mean corresponds to the parameter of the dis-
tribution.

double mean() const;

Returns: The value of the mean parameter with which the object was constructed.

2

3

4

26.5.8.4.2 Class template exponential_distribution

[rand.dist.pois.exp]
1 An exponential_distribution random number distribution produces random numbers x > 0 distributed

according to the probability density function

p(x| λ) = λe−λx .

template<class RealType = double>
class exponential_distribution
{
public:
// types
typedef RealType result_type;
typedef unspecified param_type;

// constructors and reset functions
explicit exponential_distribution(RealType lambda = 1.0);

§ 26.5.8.4.2

966

c(cid:13) ISO/IEC

N4296

explicit exponential_distribution(const param_type& parm);
void reset();

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

result_type operator()(URNG& g, const param_type& parm);

// property functions
RealType lambda() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

explicit exponential_distribution(RealType lambda = 1.0);

Requires: 0 < lambda.
Eﬀects: Constructs a exponential_distribution object; lambda corresponds to the parameter of the
distribution.

RealType lambda() const;

Returns: The value of the lambda parameter with which the object was constructed.

2

3

4

26.5.8.4.3 Class template gamma_distribution

[rand.dist.pois.gamma]
1 A gamma_distribution random number distribution produces random numbers x > 0 distributed according

to the probability density function

p(x| α, β) = e−x/β

βα · Γ(α) · x α−1 .

template<class RealType = double>
class gamma_distribution
{
public:
// types
typedef RealType result_type;
typedef unspecified param_type;

// constructors and reset functions
explicit gamma_distribution(RealType alpha = 1.0, RealType beta = 1.0);
explicit gamma_distribution(const param_type& parm);
void reset();

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

result_type operator()(URNG& g, const param_type& parm);

// property functions

§ 26.5.8.4.3

967

c(cid:13) ISO/IEC

N4296

RealType alpha() const;
RealType beta() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

explicit gamma_distribution(RealType alpha = 1.0, RealType beta = 1.0);

Requires: 0 < alpha and 0 < beta.
Eﬀects: Constructs a gamma_distribution object; alpha and beta correspond to the parameters of
the distribution.

RealType alpha() const;

Returns: The value of the alpha parameter with which the object was constructed.

RealType beta() const;

Returns: The value of the beta parameter with which the object was constructed.

2

3

4

5

26.5.8.4.4 Class template weibull_distribution

[rand.dist.pois.weibull]
1 A weibull_distribution random number distribution produces random numbers x ≥ 0 distributed ac-

·(cid:16) x

(cid:17)a−1 · exp(cid:16)−(cid:16) x

b

(cid:17)a(cid:17) .

b

cording to the probability density function

p(x| a, b) = a
b

template<class RealType = double>
class weibull_distribution
{
public:
// types
typedef RealType result_type;
typedef unspecified param_type;

// constructor and reset functions
explicit weibull_distribution(RealType a = 1.0, RealType b = 1.0);
explicit weibull_distribution(const param_type& parm);
void reset();

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

result_type operator()(URNG& g, const param_type& parm);

// property functions
RealType a() const;
RealType b() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

§ 26.5.8.4.4

968

c(cid:13) ISO/IEC

N4296

explicit weibull_distribution(RealType a = 1.0, RealType b = 1.0);

Requires: 0 < a and 0 < b.
Eﬀects: Constructs a weibull_distribution object; a and b correspond to the respective parameters
of the distribution.

RealType a() const;

Returns: The value of the a parameter with which the object was constructed.

RealType b() const;

Returns: The value of the b parameter with which the object was constructed.

2

3

4

5

26.5.8.4.5 Class template extreme_value_distribution

[rand.dist.pois.extreme]
1 An extreme_value_distribution random number distribution produces random numbers x distributed

(cid:18) a − x

b

− exp

(cid:18) a − x

(cid:19)(cid:19)

b

.

according to the probability density function280

p(x| a, b) = 1

b

· exp

template<class RealType = double>
class extreme_value_distribution
{
public:
// types
typedef RealType result_type;
typedef unspecified param_type;

// constructor and reset functions
explicit extreme_value_distribution(RealType a = 0.0, RealType b = 1.0);
explicit extreme_value_distribution(const param_type& parm);
void reset();

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

result_type operator()(URNG& g, const param_type& parm);

// property functions
RealType a() const;
RealType b() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

explicit extreme_value_distribution(RealType a = 0.0, RealType b = 1.0);

280) The distribution corresponding to this probability density function is also known (with a possible change of variable) as
the Gumbel Type I, the log-Weibull, or the Fisher-Tippett Type I distribution.

§ 26.5.8.4.5

969

c(cid:13) ISO/IEC

N4296

Requires: 0 < b.
Eﬀects: Constructs an extreme_value_distribution object; a and b correspond to the respective
parameters of the distribution.

RealType a() const;

Returns: The value of the a parameter with which the object was constructed.

RealType b() const;

Returns: The value of the b parameter with which the object was constructed.

2

3

4

5

26.5.8.5 Normal distributions
26.5.8.5.1 Class template normal_distribution

[rand.dist.norm]
[rand.dist.norm.normal]
1 A normal_distribution random number distribution produces random numbers x distributed according

to the probability density function

p(x| µ, σ) = 1
√
2π

σ

· exp

− (x − µ)2
2σ2

(cid:18)

(cid:19)

.

The distribution parameters µ and σ are also known as this distribution’s mean and standard deviation .

template<class RealType = double>
class normal_distribution
{
public:
// types
typedef RealType result_type;
typedef unspecified param_type;

// constructors and reset functions
explicit normal_distribution(RealType mean = 0.0, RealType stddev = 1.0);
explicit normal_distribution(const param_type& parm);
void reset();

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

result_type operator()(URNG& g, const param_type& parm);

// property functions
RealType mean() const;
RealType stddev() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

explicit normal_distribution(RealType mean = 0.0, RealType stddev = 1.0);

2

3

Requires: 0 < stddev.
Eﬀects: Constructs a normal_distribution object; mean and stddev correspond to the respective
parameters of the distribution.

§ 26.5.8.5.1

970

c(cid:13) ISO/IEC

RealType mean() const;

4

5

Returns: The value of the mean parameter with which the object was constructed.

RealType stddev() const;

Returns: The value of the stddev parameter with which the object was constructed.

N4296

26.5.8.5.2 Class template lognormal_distribution

[rand.dist.norm.lognormal]
1 A lognormal_distribution random number distribution produces random numbers x > 0 distributed

(cid:18)

− (ln x − m)2

2s2

(cid:19)

.

according to the probability density function

p(x| m, s) =

1
√
sx

2π

· exp

template<class RealType = double>
class lognormal_distribution
{
public:
// types
typedef RealType result_type;
typedef unspecified param_type;

// constructor and reset functions
explicit lognormal_distribution(RealType m = 0.0, RealType s = 1.0);
explicit lognormal_distribution(const param_type& parm);
void reset();

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

result_type operator()(URNG& g, const param_type& parm);

// property functions
RealType m() const;
RealType s() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

explicit lognormal_distribution(RealType m = 0.0, RealType s = 1.0);

Requires: 0 < s.
Eﬀects: Constructs a lognormal_distribution object; m and s correspond to the respective param-
eters of the distribution.

RealType m() const;

Returns: The value of the m parameter with which the object was constructed.

RealType s() const;

Returns: The value of the s parameter with which the object was constructed.

2

3

4

5

§ 26.5.8.5.2

971

c(cid:13) ISO/IEC

N4296

26.5.8.5.3 Class template chi_squared_distribution

[rand.dist.norm.chisq]
1 A chi_squared_distribution random number distribution produces random numbers x > 0 distributed

according to the probability density function

p(x| n) = x(n/2)−1 · e−x/2
Γ(n/2) · 2n/2

.

template<class RealType = double>
class chi_squared_distribution
{
public:
// types
typedef RealType result_type;
typedef unspecified param_type;

// constructor and reset functions
explicit chi_squared_distribution(RealType n = 1);
explicit chi_squared_distribution(const param_type& parm);
void reset();

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

result_type operator()(URNG& g, const param_type& parm);

// property functions
RealType n() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

explicit chi_squared_distribution(RealType n = 1);

Requires: 0 < n.
Eﬀects: Constructs a chi_squared_distribution object; n corresponds to the parameter of the
distribution.

RealType n() const;

Returns: The value of the n parameter with which the object was constructed.

2

3

4

26.5.8.5.4 Class template cauchy_distribution

[rand.dist.norm.cauchy]
1 A cauchy_distribution random number distribution produces random numbers x distributed according

to the probability density function

 

 

(cid:18) x − a

(cid:19)2!!−1

.

p(x| a, b) =

πb

1 +

b

§ 26.5.8.5.4

972

c(cid:13) ISO/IEC

N4296

template<class RealType = double>
class cauchy_distribution
{
public:
// types
typedef RealType result_type;
typedef unspecified param_type;

// constructor and reset functions
explicit cauchy_distribution(RealType a = 0.0, RealType b = 1.0);
explicit cauchy_distribution(const param_type& parm);
void reset();

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

result_type operator()(URNG& g, const param_type& parm);

// property functions
RealType a() const;
RealType b() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

explicit cauchy_distribution(RealType a = 0.0, RealType b = 1.0);

Requires: 0 < b.
Eﬀects: Constructs a cauchy_distribution object; a and b correspond to the respective parameters
of the distribution.

RealType a() const;

Returns: The value of the a parameter with which the object was constructed.

RealType b() const;

Returns: The value of the b parameter with which the object was constructed.

2

3

4

5

26.5.8.5.5 Class template fisher_f_distribution

[rand.dist.norm.f]
1 A fisher_f_distribution random number distribution produces random numbers x ≥ 0 distributed ac-

cording to the probability density function

.

973

Γ(cid:0)(m + n)/2(cid:1)
Γ(m/2) Γ(n/2) ·(cid:16) m

n

(cid:17)m/2 · x(m/2)−1 ·(cid:16)1 + mx

(cid:17)−(m+n)/2

n

p(x| m, n) =

template<class RealType = double>
class fisher_f_distribution
{
public:
// types
typedef RealType result_type;

§ 26.5.8.5.5

c(cid:13) ISO/IEC

N4296

typedef unspecified param_type;

// constructor and reset functions
explicit fisher_f_distribution(RealType m = 1, RealType n = 1);
explicit fisher_f_distribution(const param_type& parm);
void reset();

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

result_type operator()(URNG& g, const param_type& parm);

// property functions
RealType m() const;
RealType n() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

explicit fisher_f_distribution(RealType m = 1, RealType n = 1);

Requires: 0 < m and 0 < n.
Eﬀects: Constructs a fisher_f_distribution object; m and n correspond to the respective parameters
of the distribution.

RealType m() const;

Returns: The value of the m parameter with which the object was constructed.

RealType n() const;

Returns: The value of the n parameter with which the object was constructed.

2

3

4

5

26.5.8.5.6 Class template student_t_distribution

[rand.dist.norm.t]
1 A student_t_distribution random number distribution produces random numbers x distributed according

· Γ(cid:0)(n + 1)/2(cid:1)

Γ(n/2)

·

(cid:18)
1 + x2

n

(cid:19)−(n+1)/2

.

to the probability density function

p(x| n) = 1√

nπ

template<class RealType = double>
class student_t_distribution
{
public:
// types
typedef RealType result_type;
typedef unspecified param_type;

// constructor and reset functions
explicit student_t_distribution(RealType n = 1);
explicit student_t_distribution(const param_type& parm);
void reset();

§ 26.5.8.5.6

974

c(cid:13) ISO/IEC

N4296

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

result_type operator()(URNG& g, const param_type& parm);

// property functions
RealType n() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

explicit student_t_distribution(RealType n = 1);

Requires: 0 < n.
Eﬀects: Constructs a student_t_distribution object; n corresponds to the parameter of the distri-
bution.

RealType n() const;

Returns: The value of the n parameter with which the object was constructed.

2

3

4

26.5.8.6 Sampling distributions
26.5.8.6.1 Class template discrete_distribution

[rand.dist.samp]
[rand.dist.samp.discrete]
1 A discrete_distribution random number distribution produces random integers i, 0 ≤ i < n, distributed

according to the discrete probability function

P(i| p0, . . . , pn−1) = pi .

2 Unless speciﬁed otherwise, the distribution parameters are calculated as: pk = wk/S for k = 0, . . . , n−1 ,
in which the values wk, commonly known as the weights , shall be non-negative, non-NaN, and non-inﬁnity.
Moreover, the following relation shall hold: 0 < S = w0 + ··· + wn−1.

template<class IntType = int>
class discrete_distribution
{
public:
// types
typedef IntType result_type;
typedef unspecified param_type;

// constructor and reset functions
discrete_distribution();
template<class InputIterator>

explicit discrete_distribution(const param_type& parm);
void reset();

discrete_distribution(InputIterator firstW, InputIterator lastW);

discrete_distribution(initializer_list<double> wl);
template<class UnaryOperation>

discrete_distribution(size_t nw, double xmin, double xmax, UnaryOperation fw);

§ 26.5.8.6.1

975

c(cid:13) ISO/IEC

N4296

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

result_type operator()(URNG& g, const param_type& parm);

// property functions
vector<double> probabilities() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

discrete_distribution();

Eﬀects: Constructs a discrete_distribution object with n = 1 and p0 = 1. [ Note: Such an object
will always deliver the value 0. — end note ]

template<class InputIterator>

discrete_distribution(InputIterator firstW, InputIterator lastW);

Requires: InputIterator shall satisfy the requirements of an input iterator (Table 107) type. More-
over, iterator_traits<InputIterator>::value_type shall denote a type that is convertible to

double. If firstW == lastW, let n = 1 and w0 = 1. Otherwise, (cid:2)firstW, lastW(cid:1) shall form a se-

quence w of length n > 0.
Eﬀects: Constructs a discrete_distribution object with probabilities given by the formula above.

discrete_distribution(initializer_list<double> wl);

Eﬀects: Same as discrete_distribution(wl.begin(), wl.end()).

template<class UnaryOperation>

discrete_distribution(size_t nw, double xmin, double xmax, UnaryOperation fw);

Requires: Each instance of type UnaryOperation shall be a function object (20.9) whose return type
shall be convertible to double. Moreover, double shall be convertible to the type of UnaryOperation’s
sole parameter. If nw = 0, let n = 1, otherwise let n = nw. The relation 0 < δ = (xmax − xmin)/n shall
hold.
Eﬀects: Constructs a discrete_distribution object with probabilities given by the formula above,
using the following values: If nw = 0, let w0 = 1. Otherwise, let wk = fw(xmin + k · δ + δ/2) for
k = 0, . . . , n−1.
Complexity: The number of invocations of fw shall not exceed n.

3

4

5

6

7

8

9

vector<double> probabilities() const;

10

Returns: A vector<double> whose size member returns n and whose operator[] member returns
pk when invoked with argument k for k = 0, . . . , n−1.

26.5.8.6.2 Class template piecewise_constant_distribution

[rand.dist.samp.pconst]
1 A piecewise_constant_distribution random number distribution produces random numbers x, b0 ≤ x <

bn, uniformly distributed over each subinterval [bi, bi+1) according to the probability density function

p(x| b0, . . . , bn, ρ0, . . . , ρn−1) = ρi , for bi ≤ x < bi+1 .

§ 26.5.8.6.2

976

c(cid:13) ISO/IEC

N4296

2 The n + 1 distribution parameters bi, also known as this distribution’s interval boundaries , shall satisfy the
relation bi < bi+1 for i = 0, . . . , n−1. Unless speciﬁed otherwise, the remaining n distribution parameters
are calculated as:

ρk =

wk

S · (bk+1 − bk) for k = 0, . . . , n−1,

in which the values wk, commonly known as the weights , shall be non-negative, non-NaN, and non-inﬁnity.
Moreover, the following relation shall hold: 0 < S = w0 + ··· + wn−1.

template<class RealType = double>
class piecewise_constant_distribution
{
public:
// types
typedef RealType result_type;
typedef unspecified param_type;

// constructor and reset functions
piecewise_constant_distribution();
template<class InputIteratorB, class InputIteratorW>

piecewise_constant_distribution(InputIteratorB firstB, InputIteratorB lastB,

InputIteratorW firstW);

template<class UnaryOperation>

template<class UnaryOperation>

piecewise_constant_distribution(initializer_list<RealType> bl, UnaryOperation fw);

piecewise_constant_distribution(size_t nw, RealType xmin, RealType xmax, UnaryOperation fw);

explicit piecewise_constant_distribution(const param_type& parm);
void reset();

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

result_type operator()(URNG& g, const param_type& parm);

// property functions
vector<result_type> intervals() const;
vector<result_type> densities() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

piecewise_constant_distribution();

3

4

Eﬀects: Constructs a piecewise_constant_distribution object with n = 1, ρ0 = 1, b0 = 0, and
b1 = 1.

template<class InputIteratorB, class InputIteratorW>
piecewise_constant_distribution(InputIteratorB firstB, InputIteratorB lastB,

InputIteratorW firstW);

Requires: InputIteratorB and InputIteratorW shall each satisfy the requirements of an input itera-
tor (Table 107) type. Moreover, iterator_traits<InputIteratorB>::value_type and iterator_-
traits<InputIteratorW>::value_type shall each denote a type that is convertible to double.
If
firstB == lastB or ++firstB == lastB, let n = 1, w0 = 1, b0 = 0, and b1 = 1. Otherwise,

§ 26.5.8.6.2

977

c(cid:13) ISO/IEC

(cid:2)firstB, lastB(cid:1) shall form a sequence b of length n + 1, the length of the sequence w starting from

firstW shall be at least n, and any wk for k ≥ n shall be ignored by the distribution.
Eﬀects: Constructs a piecewise_constant_distribution object with parameters as speciﬁed above.

N4296

template<class UnaryOperation>
piecewise_constant_distribution(initializer_list<RealType> bl, UnaryOperation fw);

Requires: Each instance of type UnaryOperation shall be a function object (20.9) whose return type
shall be convertible to double. Moreover, double shall be convertible to the type of UnaryOperation’s
sole parameter.
Eﬀects: Constructs a piecewise_constant_distribution object with parameters taken or calculated
from the following values: If bl.size() < 2, let n = 1, w0 = 1, b0 = 0, and b1 = 1. Otherwise, let

(cid:2)bl.begin(), bl.end()(cid:1) form a sequence b0, . . . , bn, and let wk = fw(cid:0)(cid:0)bk+1+bk

(cid:1)/2(cid:1) for k = 0, . . . , n−1.

Complexity: The number of invocations of fw shall not exceed n.

template<class UnaryOperation>
piecewise_constant_distribution(size_t nw, RealType xmin, RealType xmax, UnaryOperation fw);

Requires: Each instance of type UnaryOperation shall be a function object (20.9) whose return type
shall be convertible to double. Moreover, double shall be convertible to the type of UnaryOperation’s
sole parameter. If nw = 0, let n = 1, otherwise let n = nw. The relation 0 < δ = (xmax − xmin)/n shall
hold.
Eﬀects: Constructs a piecewise_constant_distribution object with parameters taken or calculated
from the following values: Let bk = xmin+k·δ for k = 0, . . . , n, and wk = fw(bk+δ/2) for k = 0, . . . , n−1.
Complexity: The number of invocations of fw shall not exceed n.

vector<result_type> intervals() const;

Returns: A vector<result_type> whose size member returns n + 1 and whose operator[] member
returns bk when invoked with argument k for k = 0, . . . , n.

vector<result_type> densities() const;

Returns: A vector<result_type> whose size member returns n and whose operator[] member
returns ρk when invoked with argument k for k = 0, . . . , n−1.
26.5.8.6.3 Class template piecewise_linear_distribution

[rand.dist.samp.plinear]
1 A piecewise_linear_distribution random number distribution produces random numbers x, b0 ≤ x < bn,

distributed over each subinterval [bi, bi+1) according to the probability density function

5

6

7

8

9

10

11

12

13

p(x| b0, . . . , bn, ρ0, . . . , ρn) = ρi · bi+1 − x
bi+1 − bi

+ ρi+1 · x − bi
bi+1 − bi

, for bi ≤ x < bi+1 .

2 The n + 1 distribution parameters bi, also known as this distribution’s interval boundaries , shall satisfy the
relation bi < bi+1 for i = 0, . . . , n−1. Unless speciﬁed otherwise, the remaining n+1 distribution parameters
are calculated as ρk = wk/S for k = 0, . . . , n, in which the values wk, commonly known as the weights at
boundaries , shall be non-negative, non-NaN, and non-inﬁnity. Moreover, the following relation shall hold:

0 < S = 1

(wk + wk+1) · (bk+1 − bk) .

2 · n−1X

k=0

§ 26.5.8.6.3

978

c(cid:13) ISO/IEC

N4296

template<class RealType = double>
class piecewise_linear_distribution
{
public:
// types
typedef RealType result_type;
typedef unspecified param_type;

// constructor and reset functions
piecewise_linear_distribution();
template<class InputIteratorB, class InputIteratorW>

piecewise_linear_distribution(InputIteratorB firstB, InputIteratorB lastB,

InputIteratorW firstW);

template<class UnaryOperation>

template<class UnaryOperation>

piecewise_linear_distribution(initializer_list<RealType> bl, UnaryOperation fw);

piecewise_linear_distribution(size_t nw, RealType xmin, RealType xmax, UnaryOperation fw);

explicit piecewise_linear_distribution(const param_type& parm);
void reset();

// generating functions
template<class URNG>

result_type operator()(URNG& g);

template<class URNG>

result_type operator()(URNG& g, const param_type& parm);

// property functions
vector<result_type> intervals() const;
vector<result_type> densities() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
};

piecewise_linear_distribution();

3

4

5

Eﬀects: Constructs a piecewise_linear_distribution object with n = 1, ρ0 = ρ1 = 1, b0 = 0, and
b1 = 1.

template<class InputIteratorB, class InputIteratorW>
piecewise_linear_distribution(InputIteratorB firstB, InputIteratorB lastB,

InputIteratorW firstW);

(cid:2)firstB, lastB(cid:1) shall form a sequence b of length n + 1, the length of the sequence w starting from

Requires: InputIteratorB and InputIteratorW shall each satisfy the requirements of an input itera-
tor (Table 107) type. Moreover, iterator_traits<InputIteratorB>::value_type and iterator_-
traits<InputIteratorW>::value_type shall each denote a type that is convertible to double.
If
firstB == lastB or ++firstB == lastB, let n = 1, ρ0 = ρ1 = 1, b0 = 0, and b1 = 1. Otherwise,
firstW shall be at least n + 1, and any wk for k ≥ n + 1 shall be ignored by the distribution.
Eﬀects: Constructs a piecewise_linear_distribution object with parameters as speciﬁed above.

template<class UnaryOperation>
piecewise_linear_distribution(initializer_list<RealType> bl, UnaryOperation fw);

§ 26.5.8.6.3

979

c(cid:13) ISO/IEC

N4296

6

7

8

9

10

11

12

13

Requires: Each instance of type UnaryOperation shall be a function object (20.9) whose return type
shall be convertible to double. Moreover, double shall be convertible to the type of UnaryOperation’s
sole parameter.
Eﬀects: Constructs a piecewise_linear_distribution object with parameters taken or calculated
from the following values: If bl.size() < 2, let n = 1, ρ0 = ρ1 = 1, b0 = 0, and b1 = 1. Otherwise,

let(cid:2)bl.begin(),bl.end()(cid:1) form a sequence b0, . . . , bn, and let wk = fw(bk) for k = 0, . . . , n.

Complexity: The number of invocations of fw shall not exceed n + 1.

template<class UnaryOperation>
piecewise_linear_distribution(size_t nw, RealType xmin, RealType xmax, UnaryOperation fw);

Requires: Each instance of type UnaryOperation shall be a function object (20.9) whose return type
shall be convertible to double. Moreover, double shall be convertible to the type of UnaryOperation’s
sole parameter. If nw = 0, let n = 1, otherwise let n = nw. The relation 0 < δ = (xmax − xmin)/n shall
hold.
Eﬀects: Constructs a piecewise_linear_distribution object with parameters taken or calculated
from the following values: Let bk = xmin + k · δ for k = 0, . . . , n, and wk = fw(bk) for k = 0, . . . , n.
Complexity: The number of invocations of fw shall not exceed n + 1.

vector<result_type> intervals() const;

Returns: A vector<result_type> whose size member returns n + 1 and whose operator[] member
returns bk when invoked with argument k for k = 0, . . . , n.

vector<result_type> densities() const;

Returns: A vector<result_type> whose size member returns n and whose operator[] member
returns ρk when invoked with argument k for k = 0, . . . , n.

26.6 Numeric arrays
26.6.1 Header <valarray> synopsis

#include <initializer_list>

namespace std {

[numarray]
[valarray.syn]

template<class T> class valarray;
class slice;
template<class T> class slice_array;
class gslice;
template<class T> class gslice_array;
template<class T> class mask_array;
template<class T> class indirect_array;

// An array of type T
// a BLAS-like slice out of an array

// a generalized slice out of an array

// a masked array
// an indirected array

template<class T> void swap(valarray<T>&, valarray<T>&) noexcept;

template<class T> valarray<T> operator* (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator* (const valarray<T>&, const T&);
template<class T> valarray<T> operator* (const T&, const valarray<T>&);

template<class T> valarray<T> operator/ (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator/ (const valarray<T>&, const T&);
template<class T> valarray<T> operator/ (const T&, const valarray<T>&);

§ 26.6.1

980

c(cid:13) ISO/IEC

N4296

template<class T> valarray<T> operator% (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator% (const valarray<T>&, const T&);
template<class T> valarray<T> operator% (const T&, const valarray<T>&);

template<class T> valarray<T> operator+ (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator+ (const valarray<T>&, const T&);
template<class T> valarray<T> operator+ (const T&, const valarray<T>&);

template<class T> valarray<T> operator- (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator- (const valarray<T>&, const T&);
template<class T> valarray<T> operator- (const T&, const valarray<T>&);

template<class T> valarray<T> operator^ (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator^ (const valarray<T>&, const T&);
template<class T> valarray<T> operator^ (const T&, const valarray<T>&);

template<class T> valarray<T> operator& (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator& (const valarray<T>&, const T&);
template<class T> valarray<T> operator& (const T&, const valarray<T>&);

template<class T> valarray<T> operator| (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator| (const valarray<T>&, const T&);
template<class T> valarray<T> operator| (const T&, const valarray<T>&);

template<class T> valarray<T> operator<<(const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator<<(const valarray<T>&, const T&);
template<class T> valarray<T> operator<<(const T&, const valarray<T>&);

template<class T> valarray<T> operator>>(const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator>>(const valarray<T>&, const T&);
template<class T> valarray<T> operator>>(const T&, const valarray<T>&);

template<class T> valarray<bool> operator&&(const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator&&(const valarray<T>&, const T&);
template<class T> valarray<bool> operator&&(const T&, const valarray<T>&);

template<class T> valarray<bool> operator||(const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator||(const valarray<T>&, const T&);
template<class T> valarray<bool> operator||(const T&, const valarray<T>&);

template<class T>

valarray<bool> operator==(const valarray<T>&, const valarray<T>&);

template<class T> valarray<bool> operator==(const valarray<T>&, const T&);
template<class T> valarray<bool> operator==(const T&, const valarray<T>&);
template<class T>

valarray<bool> operator!=(const valarray<T>&, const valarray<T>&);

template<class T> valarray<bool> operator!=(const valarray<T>&, const T&);
template<class T> valarray<bool> operator!=(const T&, const valarray<T>&);

template<class T>

valarray<bool> operator< (const valarray<T>&, const valarray<T>&);

template<class T> valarray<bool> operator< (const valarray<T>&, const T&);
template<class T> valarray<bool> operator< (const T&, const valarray<T>&);
template<class T>

valarray<bool> operator> (const valarray<T>&, const valarray<T>&);

§ 26.6.1

981

c(cid:13) ISO/IEC

N4296

template<class T> valarray<bool> operator> (const valarray<T>&, const T&);
template<class T> valarray<bool> operator> (const T&, const valarray<T>&);
template<class T>

valarray<bool> operator<=(const valarray<T>&, const valarray<T>&);

template<class T> valarray<bool> operator<=(const valarray<T>&, const T&);
template<class T> valarray<bool> operator<=(const T&, const valarray<T>&);
template<class T>

valarray<bool> operator>=(const valarray<T>&, const valarray<T>&);

template<class T> valarray<bool> operator>=(const valarray<T>&, const T&);
template<class T> valarray<bool> operator>=(const T&, const valarray<T>&);

template<class T> valarray<T> abs (const valarray<T>&);
template<class T> valarray<T> acos (const valarray<T>&);
template<class T> valarray<T> asin (const valarray<T>&);
template<class T> valarray<T> atan (const valarray<T>&);

template<class T> valarray<T> atan2(const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> atan2(const valarray<T>&, const T&);
template<class T> valarray<T> atan2(const T&, const valarray<T>&);

template<class T> valarray<T> cos (const valarray<T>&);
template<class T> valarray<T> cosh (const valarray<T>&);
template<class T> valarray<T> exp (const valarray<T>&);
template<class T> valarray<T> log (const valarray<T>&);
template<class T> valarray<T> log10(const valarray<T>&);

template<class T> valarray<T> pow(const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> pow(const valarray<T>&, const T&);
template<class T> valarray<T> pow(const T&, const valarray<T>&);

template<class T> valarray<T> sin (const valarray<T>&);
template<class T> valarray<T> sinh (const valarray<T>&);
template<class T> valarray<T> sqrt (const valarray<T>&);
template<class T> valarray<T> tan (const valarray<T>&);
template<class T> valarray<T> tanh (const valarray<T>&);

template <class T> unspecified 1 begin(valarray<T>& v);
template <class T> unspecified 2 begin(const valarray<T>& v);
template <class T> unspecified 1 end(valarray<T>& v);
template <class T> unspecified 2 end(const valarray<T>& v);

}

1 The header <valarray> deﬁnes ﬁve class templates (valarray, slice_array, gslice_array, mask_array,
and indirect_array), two classes (slice and gslice), and a series of related function templates for rep-
resenting and manipulating arrays of values.

2 The valarray array classes are deﬁned to be free of certain forms of aliasing, thus allowing operations on

these classes to be optimized.

3 Any function returning a valarray<T> is permitted to return an object of another type, provided all the
const member functions of valarray<T> are also applicable to this type. This return type shall not add
more than two levels of template nesting over the most deeply nested argument type.281
281) Clause 18.3.2 recommends a minimum number of recursively nested template instantiations. This requirement thus
indirectly suggests a minimum allowable complexity for valarray expressions.

§ 26.6.1

982

c(cid:13) ISO/IEC

N4296

4

Implementations introducing such replacement types shall provide additional functions and operators as
follows:

(4.1)

(4.2)

—

—

for every function taking a const valarray<T>& other than begin and end (26.6.10), identical func-
tions taking the replacement types shall be added;
for every function taking two const valarray<T>& arguments, identical functions taking every com-
bination of const valarray<T>& and replacement types shall be added.

5

In particular, an implementation shall allow a valarray<T> to be constructed from such replacement types
and shall allow assignments and computed assignments of such types to valarray<T>, slice_array<T>,
gslice_array<T>, mask_array<T> and indirect_array<T> objects.

6 These library functions are permitted to throw a bad_alloc (18.6.2.1) exception if there are not suﬃcient

resources available to carry out the operation. Note that the exception is not mandated.
26.6.2 Class template valarray
26.6.2.1 Class template valarray overview

[template.valarray]
[template.valarray.overview]

namespace std {

template<class T> class valarray {
public:

typedef T value_type;

// 26.6.2.2 construct/destroy:
valarray();
explicit valarray(size_t);
valarray(const T&, size_t);
valarray(const T*, size_t);
valarray(const valarray&);
valarray(valarray&&) noexcept;
valarray(const slice_array<T>&);
valarray(const gslice_array<T>&);
valarray(const mask_array<T>&);
valarray(const indirect_array<T>&);
valarray(initializer_list<T>);
~valarray();

// 26.6.2.3 assignment:
valarray<T>& operator=(const valarray<T>&);
valarray<T>& operator=(valarray<T>&&) noexcept;
valarray& operator=(initializer_list<T>);
valarray<T>& operator=(const T&);
valarray<T>& operator=(const slice_array<T>&);
valarray<T>& operator=(const gslice_array<T>&);
valarray<T>& operator=(const mask_array<T>&);
valarray<T>& operator=(const indirect_array<T>&);

// 26.6.2.4 element access:
const T&
T&

operator[](size_t) const;
operator[](size_t);

// 26.6.2.5 subset operations:
valarray<T>
slice_array<T>
valarray<T>

operator[](slice) const;
operator[](slice);
operator[](const gslice&) const;

§ 26.6.2.1

983

c(cid:13) ISO/IEC

N4296

gslice_array<T>
valarray<T>
mask_array<T>
valarray<T>
indirect_array<T> operator[](const valarray<size_t>&);

operator[](const gslice&);
operator[](const valarray<bool>&) const;
operator[](const valarray<bool>&);
operator[](const valarray<size_t>&) const;

// 26.6.2.6 unary operators:
valarray<T> operator+() const;
valarray<T> operator-() const;
valarray<T> operator~() const;
valarray<bool> operator!() const;

// 26.6.2.7 computed assignment:
valarray<T>& operator*= (const T&);
valarray<T>& operator/= (const T&);
valarray<T>& operator%= (const T&);
valarray<T>& operator+= (const T&);
valarray<T>& operator-= (const T&);
valarray<T>& operator^= (const T&);
valarray<T>& operator&= (const T&);
valarray<T>& operator|= (const T&);
valarray<T>& operator<<=(const T&);
valarray<T>& operator>>=(const T&);

valarray<T>& operator*= (const valarray<T>&);
valarray<T>& operator/= (const valarray<T>&);
valarray<T>& operator%= (const valarray<T>&);
valarray<T>& operator+= (const valarray<T>&);
valarray<T>& operator-= (const valarray<T>&);
valarray<T>& operator^= (const valarray<T>&);
valarray<T>& operator|= (const valarray<T>&);
valarray<T>& operator&= (const valarray<T>&);
valarray<T>& operator<<=(const valarray<T>&);
valarray<T>& operator>>=(const valarray<T>&);

// 26.6.2.8 member functions:
void swap(valarray&) noexcept;

size_t size() const;

T sum() const;
T min() const;
T max() const;

valarray<T> shift (int) const;
valarray<T> cshift(int) const;
valarray<T> apply(T func(T)) const;
valarray<T> apply(T func(const T&)) const;
void resize(size_t sz, T c = T());

};

}

1 The class template valarray<T> is a one-dimensional smart array, with elements numbered sequentially
from zero.
It is a representation of the mathematical concept of an ordered set of values. The illusion
of higher dimensionality may be produced by the familiar idiom of computed indices, together with the

§ 26.6.2.1

984

c(cid:13) ISO/IEC

N4296

powerful subsetting capabilities provided by the generalized subscript operators.282

2 An implementation is permitted to qualify any of the functions declared in <valarray> as inline.

26.6.2.2 valarray constructors
valarray();

[valarray.cons]

Eﬀects: Constructs an object of class valarray<T>283 which has zero length.284

explicit valarray(size_t);

The array created by this constructor has a length equal to the value of the argument. The elements
of the array are value-initialized (8.5).

valarray(const T&, size_t);

The array created by this constructor has a length equal to the second argument. The elements of the
array are initialized with the value of the ﬁrst argument.

valarray(const T*, size_t);

The array created by this constructor has a length equal to the second argument n. The values of the
elements of the array are initialized with the ﬁrst n values pointed to by the ﬁrst argument.285 If the
value of the second argument is greater than the number of values pointed to by the ﬁrst argument,
the behavior is undeﬁned.

valarray(const valarray<T>&);

The array created by this constructor has the same length as the argument array. The elements are
initialized with the values of the corresponding elements of the argument array.286

valarray(valarray<T>&& v) noexcept;

The array created by this constructor has the same length as the argument array. The elements are
initialized with the values of the corresponding elements of the argument array.
Complexity: Constant.

valarray(initializer_list<T> il);

Eﬀects: Same as valarray(il.begin(), il.size()).

valarray(const slice_array<T>&);
valarray(const gslice_array<T>&);
valarray(const mask_array<T>&);
valarray(const indirect_array<T>&);

These conversion constructors convert one of the four reference templates to a valarray.

1

2

3

4

5

6

7

8

9

~valarray();

10

The destructor is applied to every element of *this; an implementation may return all allocated
memory.

282) The intent is to specify an array template that has the minimum functionality necessary to address aliasing ambiguities
and the proliferation of temporaries. Thus, the valarray template is neither a matrix class nor a ﬁeld class. However, it is a
very useful building block for designing such classes.
283) For convenience, such objects are referred to as “arrays” throughout the remainder of 26.6.
284) This default constructor is essential, since arrays of valarray may be useful. After initialization, the length of an empty
array can be increased with the resize member function.
285) This constructor is the preferred method for converting a C array to a valarray object.
286) This copy constructor creates a distinct array rather than an alias. Implementations in which arrays share storage are
permitted, but they shall implement a copy-on-reference mechanism to ensure that arrays are conceptually distinct.

§ 26.6.2.2

985

c(cid:13) ISO/IEC

26.6.2.3 valarray assignment
valarray<T>& operator=(const valarray<T>& v);

N4296

[valarray.assign]

Each element of the *this array is assigned the value of the corresponding element of the argument
array. If the length of v is not equal to the length of *this , resizes *this to make the two arrays the
same length, as if by calling resize(v.size()), before performing the assignment.
Postcondition: size() == v.size().

valarray<T>& operator=(valarray<T>&& v) noexcept;

Eﬀects: *this obtains the value of v. The value of v after the assignment is not speciﬁed.
Complexity: Linear.

valarray& operator=(initializer_list<T> il);

Eﬀects: *this = valarray(il).
Returns: *this.

valarray<T>& operator=(const T&);

The scalar assignment operator causes each element of the *this array to be assigned the value of the
argument.

valarray<T>& operator=(const slice_array<T>&);
valarray<T>& operator=(const gslice_array<T>&);
valarray<T>& operator=(const mask_array<T>&);
valarray<T>& operator=(const indirect_array<T>&);

Requires: The length of the array to which the argument refers equals size().
These operators allow the results of a generalized subscripting operation to be assigned directly to a
valarray.
If the value of an element in the left-hand side of a valarray assignment operator depends on the value
of another element in that left-hand side, the resulting behavior is undeﬁned.

26.6.2.4 valarray element access
const T&
operator[](size_t) const;
T& operator[](size_t);

[valarray.access]

The subscript operator returns a reference to the corresponding element of the array.
Thus, the expression (a[i] = q, a[i]) == q evaluates as true for any non-constant valarray<T> a,
any T q, and for any size_t i such that the value of i is less than the length of a.
The expression &a[i+j] == &a[i] + j evaluates as true for all size_t i and size_t j such that
i+j is less than the length of the array a.
Likewise, the expression &a[i] != &b[j] evaluates as true for any two arrays a and b and for any
size_t i and size_t j such that i is less than the length of a and j is less than the length of b. This
property indicates an absence of aliasing and may be used to advantage by optimizing compilers.287
The reference returned by the subscript operator for an array shall be valid until the member function
resize(size_t, T) (26.6.2.8) is called for that array or until the lifetime of that array ends, whichever
happens ﬁrst.
If the subscript operator is invoked with a size_t argument whose value is not less than the length of
the array, the behavior is undeﬁned.

287) Compilers may take advantage of inlining, constant propagation, loop fusion, tracking of pointers obtained from operator
new, and other techniques to generate eﬃcient valarrays.

§ 26.6.2.4

986

1

2

3

4

5

6

7

8

9

10

1

2

3

4

5

6

c(cid:13) ISO/IEC

N4296

26.6.2.5 valarray subset operations

[valarray.sub]
1 The member operator[] is overloaded to provide several ways to select sequences of elements from among
those controlled by *this. Each of these operations returns a subset of the array. The const-qualiﬁed versions
return this subset as a new valarray object. The non-const versions return a class template object which
has reference semantics to the original array, working in conjunction with various overloads of operator=
and other assigning operators to allow selective replacement (slicing) of the controlled sequence. In each
case the selected element(s) must exist.

2

3

4

5

valarray<T> operator[](slice slicearr) const;

Returns: An object of class valarray<T> containing those elements of the controlled sequence desig-
nated by slicearr. [ Example:

const valarray<char> v0("abcdefghijklmnop", 16);
// v0[slice(2, 5, 3)] returns valarray<char>("cfilo", 5)

— end example ]

slice_array<T> operator[](slice slicearr);

Returns: An object that holds references to elements of the controlled sequence selected by slicearr.
[ Example:

valarray<char> v0("abcdefghijklmnop", 16);
valarray<char> v1("ABCDE", 5);
v0[slice(2, 5, 3)] = v1;
// v0 == valarray<char>("abAdeBghCjkDmnEp", 16);

— end example ]

valarray<T> operator[](const gslice& gslicearr) const;

Returns: An object of class valarray<T> containing those elements of the controlled sequence desig-
nated by gslicearr. [ Example:

const valarray<char> v0("abcdefghijklmnop", 16);
const size_t lv[] = { 2, 3 };
const size_t dv[] = { 7, 2 };
const valarray<size_t> len(lv, 2), str(dv, 2);
// v0[gslice(3, len, str)] returns
// valarray<char>("dfhkmo", 6)

— end example ]

gslice_array<T> operator[](const gslice& gslicearr);

Returns: An object that holds references to elements of the controlled sequence selected by gslicearr.
[ Example:

valarray<char> v0("abcdefghijklmnop", 16);
valarray<char> v1("ABCDE", 5);
const size_t lv[] = { 2, 3 };
const size_t dv[] = { 7, 2 };
const valarray<size_t> len(lv, 2), str(dv, 2);
v0[gslice(3, len, str)] = v1;
// v0 == valarray<char>("abcAeBgCijDlEnFp", 16)

— end example ]

§ 26.6.2.5

987

c(cid:13) ISO/IEC

N4296

valarray<T> operator[](const valarray<bool>& boolarr) const;

Returns: An object of class valarray<T> containing those elements of the controlled sequence desig-
nated by boolarr. [ Example:

const valarray<char> v0("abcdefghijklmnop", 16);
const bool vb[] = { false, false, true, true, false, true };
// v0[valarray<bool>(vb, 6)] returns
// valarray<char>("cdf", 3)

— end example ]

mask_array<T> operator[](const valarray<bool>& boolarr);

Returns: An object that holds references to elements of the controlled sequence selected by boolarr.
[ Example:

valarray<char> v0("abcdefghijklmnop", 16);
valarray<char> v1("ABC", 3);
const bool vb[] = { false, false, true, true, false, true };
v0[valarray<bool>(vb, 6)] = v1;
// v0 == valarray<char>("abABeCghijklmnop", 16)

— end example ]

valarray<T> operator[](const valarray<size_t>& indarr) const;

Returns: An object of class valarray<T> containing those elements of the controlled sequence desig-
nated by indarr. [ Example:

const valarray<char> v0("abcdefghijklmnop", 16);
const size_t vi[] = { 7, 5, 2, 3, 8 };
// v0[valarray<size_t>(vi, 5)] returns
// valarray<char>("hfcdi", 5)

— end example ]

indirect_array<T> operator[](const valarray<size_t>& indarr);

Returns: An object that holds references to elements of the controlled sequence selected by indarr.
[ Example:

6

7

8

9

valarray<char> v0("abcdefghijklmnop", 16);
valarray<char> v1("ABCDE", 5);
const size_t vi[] = { 7, 5, 2, 3, 8 };
v0[valarray<size_t>(vi, 5)] = v1;
// v0 == valarray<char>("abCDeBgAEjklmnop", 16)

— end example ]

26.6.2.6 valarray unary operators
valarray<T> operator+() const;
valarray<T> operator-() const;
valarray<T> operator~() const;
valarray<bool> operator!() const;

[valarray.unary]

§ 26.6.2.6

988

1

2

1

2

3

4

5

6

7

8

c(cid:13) ISO/IEC

N4296

Each of these operators may only be instantiated for a type T to which the indicated operator can be
applied and for which the indicated operator returns a value which is of type T (bool for operator!)
or which may be unambiguously implicitly converted to type T (bool for operator!).
Each of these operators returns an array whose length is equal to the length of the array. Each
element of the returned array is initialized with the result of applying the indicated operator to the
corresponding element of the array.

26.6.2.7 valarray computed assignment
valarray<T>& operator*= (const valarray<T>&);
valarray<T>& operator/= (const valarray<T>&);
valarray<T>& operator%= (const valarray<T>&);
valarray<T>& operator+= (const valarray<T>&);
valarray<T>& operator-= (const valarray<T>&);
valarray<T>& operator^= (const valarray<T>&);
valarray<T>& operator&= (const valarray<T>&);
valarray<T>& operator|= (const valarray<T>&);
valarray<T>& operator<<=(const valarray<T>&);
valarray<T>& operator>>=(const valarray<T>&);

[valarray.cassign]

Each of these operators may only be instantiated for a type T to which the indicated operator can
be applied. Each of these operators performs the indicated operation on each of its elements and the
corresponding element of the argument array.
The array is then returned by reference.
If the array and the argument array do not have the same length, the behavior is undeﬁned. The
appearance of an array on the left-hand side of a computed assignment does not invalidate references
or pointers.
If the value of an element in the left-hand side of a valarray computed assignment operator depends
on the value of another element in that left hand side, the resulting behavior is undeﬁned.

valarray<T>& operator*= (const T&);
valarray<T>& operator/= (const T&);
valarray<T>& operator%= (const T&);
valarray<T>& operator+= (const T&);
valarray<T>& operator-= (const T&);
valarray<T>& operator^= (const T&);
valarray<T>& operator&= (const T&);
valarray<T>& operator|= (const T&);
valarray<T>& operator<<=(const T&);
valarray<T>& operator>>=(const T&);

Each of these operators may only be instantiated for a type T to which the indicated operator can be
applied.
Each of these operators applies the indicated operation to each element of the array and the non-array
argument.
The array is then returned by reference.
The appearance of an array on the left-hand side of a computed assignment does not invalidate refer-
ences or pointers to the elements of the array.

26.6.2.8 valarray member functions
void swap(valarray& v) noexcept;

§ 26.6.2.8

[valarray.members]

989

c(cid:13) ISO/IEC

N4296

1

2

3

4

5

6

7

8

9

10

11

12

Eﬀects: *this obtains the value of v. v obtains the value of *this.
Complexity: Constant.

size_t size() const;

Returns: The number of elements in the array.
Complexity: Constant time.

T sum() const;

This function may only be instantiated for a type T to which operator+= can be applied. This function
returns the sum of all the elements of the array.
If the array has length 0, the behavior is undeﬁned. If the array has length 1, sum() returns the value
of element 0. Otherwise, the returned value is calculated by applying operator+= to a copy of an
element of the array and all other elements of the array in an unspeciﬁed order.

T min() const;

This function returns the minimum value contained in *this. The value returned for an array of
length 0 is undeﬁned. For an array of length 1, the value of element 0 is returned. For all other array
lengths, the determination is made using operator<.

T max() const;

This function returns the maximum value contained in *this. The value returned for an array of
length 0 is undeﬁned. For an array of length 1, the value of element 0 is returned. For all other array
lengths, the determination is made using operator<.

valarray<T> shift(int n) const;

This function returns an object of class valarray<T> of length size(), each of whose elements I is
(*this)[I + n] if I + n is non-negative and less than size(), otherwise T(). Thus if element zero
is taken as the leftmost element, a positive value of n shifts the elements left n places, with zero ﬁll.
[ Example:
If the argument has the value -2, the ﬁrst two elements of the result will be value-
initialized (8.5); the third element of the result will be assigned the value of the ﬁrst element of
the argument; etc. — end example ]

valarray<T> cshift(int n) const;
This function returns an object of class valarray<T> of length size() that is a circular shift of *this.
If element zero is taken as the leftmost element, a non-negative value of n shifts the elements circularly
left n places and a negative value of n shifts the elements circularly right -n places.

valarray<T> apply(T func(T)) const;
valarray<T> apply(T func(const T&)) const;

These functions return an array whose length is equal to the array. Each element of the returned array
is assigned the value returned by applying the argument function to the corresponding element of the
array.

void resize(size_t sz, T c = T());
This member function changes the length of the *this array to sz and then assigns to each element
the value of the second argument. Resizing invalidates all pointers and references to elements in the
array.

§ 26.6.2.8

990

c(cid:13) ISO/IEC

26.6.3 valarray non-member operations
26.6.3.1 valarray binary operators
template<class T> valarray<T> operator*

(const valarray<T>&, const valarray<T>&);

template<class T> valarray<T> operator/

(const valarray<T>&, const valarray<T>&);

template<class T> valarray<T> operator%

(const valarray<T>&, const valarray<T>&);

template<class T> valarray<T> operator+

(const valarray<T>&, const valarray<T>&);

template<class T> valarray<T> operator-

(const valarray<T>&, const valarray<T>&);

template<class T> valarray<T> operator^

(const valarray<T>&, const valarray<T>&);

template<class T> valarray<T> operator&

(const valarray<T>&, const valarray<T>&);

template<class T> valarray<T> operator|

(const valarray<T>&, const valarray<T>&);

template<class T> valarray<T> operator<<

(const valarray<T>&, const valarray<T>&);

template<class T> valarray<T> operator>>

N4296

[valarray.nonmembers]
[valarray.binary]

(const valarray<T>&, const valarray<T>&);
Each of these operators may only be instantiated for a type T to which the indicated operator can
be applied and for which the indicated operator returns a value which is of type T or which can be
unambiguously implicitly converted to type T.
Each of these operators returns an array whose length is equal to the lengths of the argument arrays.
Each element of the returned array is initialized with the result of applying the indicated operator to
the corresponding elements of the argument arrays.
If the argument arrays do not have the same length, the behavior is undeﬁned.

1

2

3

template<class T> valarray<T> operator* (const valarray<T>&, const T&);
template<class T> valarray<T> operator* (const T&, const valarray<T>&);
template<class T> valarray<T> operator/ (const valarray<T>&, const T&);
template<class T> valarray<T> operator/ (const T&, const valarray<T>&);
template<class T> valarray<T> operator% (const valarray<T>&, const T&);
template<class T> valarray<T> operator% (const T&, const valarray<T>&);
template<class T> valarray<T> operator+ (const valarray<T>&, const T&);
template<class T> valarray<T> operator+ (const T&, const valarray<T>&);
template<class T> valarray<T> operator- (const valarray<T>&, const T&);
template<class T> valarray<T> operator- (const T&, const valarray<T>&);
template<class T> valarray<T> operator^ (const valarray<T>&, const T&);
template<class T> valarray<T> operator^ (const T&, const valarray<T>&);
template<class T> valarray<T> operator& (const valarray<T>&, const T&);
template<class T> valarray<T> operator& (const T&, const valarray<T>&);
template<class T> valarray<T> operator| (const valarray<T>&, const T&);
template<class T> valarray<T> operator| (const T&, const valarray<T>&);
template<class T> valarray<T> operator<<(const valarray<T>&, const T&);
template<class T> valarray<T> operator<<(const T&, const valarray<T>&);
template<class T> valarray<T> operator>>(const valarray<T>&, const T&);
template<class T> valarray<T> operator>>(const T&, const valarray<T>&);

4

Each of these operators may only be instantiated for a type T to which the indicated operator can
be applied and for which the indicated operator returns a value which is of type T or which can be

§ 26.6.3.1

991

c(cid:13) ISO/IEC

N4296

unambiguously implicitly converted to type T.
Each of these operators returns an array whose length is equal to the length of the array argument.
Each element of the returned array is initialized with the result of applying the indicated operator to
the corresponding element of the array argument and the non-array argument.

26.6.3.2 valarray logical operators
template<class T> valarray<bool> operator==

[valarray.comparison]

(const valarray<T>&, const valarray<T>&);

template<class T> valarray<bool> operator!=

(const valarray<T>&, const valarray<T>&);

template<class T> valarray<bool> operator<

(const valarray<T>&, const valarray<T>&);

template<class T> valarray<bool> operator>

(const valarray<T>&, const valarray<T>&);

template<class T> valarray<bool> operator<=

(const valarray<T>&, const valarray<T>&);

template<class T> valarray<bool> operator>=

(const valarray<T>&, const valarray<T>&);

template<class T> valarray<bool> operator&&

(const valarray<T>&, const valarray<T>&);

template<class T> valarray<bool> operator||

(const valarray<T>&, const valarray<T>&);
Each of these operators may only be instantiated for a type T to which the indicated operator can be
applied and for which the indicated operator returns a value which is of type bool or which can be
unambiguously implicitly converted to type bool.
Each of these operators returns a bool array whose length is equal to the length of the array arguments.
Each element of the returned array is initialized with the result of applying the indicated operator to
the corresponding elements of the argument arrays.
If the two array arguments do not have the same length, the behavior is undeﬁned.

template<class T> valarray<bool> operator==(const valarray<T>&, const T&);
template<class T> valarray<bool> operator==(const T&, const valarray<T>&);
template<class T> valarray<bool> operator!=(const valarray<T>&, const T&);
template<class T> valarray<bool> operator!=(const T&, const valarray<T>&);
template<class T> valarray<bool> operator< (const valarray<T>&, const T&);
template<class T> valarray<bool> operator< (const T&, const valarray<T>&);
template<class T> valarray<bool> operator> (const valarray<T>&, const T&);
template<class T> valarray<bool> operator> (const T&, const valarray<T>&);
template<class T> valarray<bool> operator<=(const valarray<T>&, const T&);
template<class T> valarray<bool> operator<=(const T&, const valarray<T>&);
template<class T> valarray<bool> operator>=(const valarray<T>&, const T&);
template<class T> valarray<bool> operator>=(const T&, const valarray<T>&);
template<class T> valarray<bool> operator&&(const valarray<T>&, const T&);
template<class T> valarray<bool> operator&&(const T&, const valarray<T>&);
template<class T> valarray<bool> operator||(const valarray<T>&, const T&);
template<class T> valarray<bool> operator||(const T&, const valarray<T>&);

Each of these operators may only be instantiated for a type T to which the indicated operator can be
applied and for which the indicated operator returns a value which is of type bool or which can be
unambiguously implicitly converted to type bool.
Each of these operators returns a bool array whose length is equal to the length of the array argument.
Each element of the returned array is initialized with the result of applying the indicated operator to
the corresponding element of the array and the non-array argument.

§ 26.6.3.2

992

5

1

2

3

4

5

N4296

[valarray.transcend]

c(cid:13) ISO/IEC

26.6.3.3 valarray transcendentals
template<class T> valarray<T> abs
(const valarray<T>&);
template<class T> valarray<T> acos (const valarray<T>&);
template<class T> valarray<T> asin (const valarray<T>&);
template<class T> valarray<T> atan (const valarray<T>&);
template<class T> valarray<T> atan2

(const valarray<T>&, const valarray<T>&);

template<class T> valarray<T> atan2(const valarray<T>&, const T&);
template<class T> valarray<T> atan2(const T&, const valarray<T>&);
template<class T> valarray<T> cos
(const valarray<T>&);
template<class T> valarray<T> cosh (const valarray<T>&);
(const valarray<T>&);
template<class T> valarray<T> exp
template<class T> valarray<T> log
(const valarray<T>&);
template<class T> valarray<T> log10(const valarray<T>&);
template<class T> valarray<T> pow

(const valarray<T>&, const valarray<T>&);

template<class T> valarray<T> pow
(const valarray<T>&, const T&);
template<class T> valarray<T> pow
(const T&, const valarray<T>&);
template<class T> valarray<T> sin
(const valarray<T>&);
template<class T> valarray<T> sinh (const valarray<T>&);
template<class T> valarray<T> sqrt (const valarray<T>&);
template<class T> valarray<T> tan
(const valarray<T>&);
template<class T> valarray<T> tanh (const valarray<T>&);

1

1

Each of these functions may only be instantiated for a type T to which a unique function with the
indicated name can be applied (unqualiﬁed). This function shall return a value which is of type T or
which can be unambiguously implicitly converted to type T.

26.6.3.4 valarray specialized algorithms
template <class T> void swap(valarray<T>& x, valarray<T>& y) noexcept;

[valarray.special]

Eﬀects: x.swap(y).
26.6.4 Class slice
26.6.4.1 Class slice overview

namespace std {
class slice {
public:

slice();
slice(size_t, size_t, size_t);

size_t start() const;
size_t size() const;
size_t stride() const;

};

}

[class.slice]
[class.slice.overview]

1 The slice class represents a BLAS-like slice from an array. Such a slice is speciﬁed by a starting index, a

length, and a stride.288
26.6.4.2 slice constructors

[cons.slice]

288) BLAS stands for Basic Linear Algebra Subprograms. C++ programs may instantiate this class. See, for example, Dongarra,
Du Croz, Duﬀ, and Hammerling: A set of Level 3 Basic Linear Algebra Subprograms; Technical Report MCS-P1-0888, Argonne
National Laboratory (USA), Mathematics and Computer Science Division, August, 1988.

§ 26.6.4.2

993

c(cid:13) ISO/IEC

N4296

slice();
slice(size_t start, size_t length, size_t stride);
slice(const slice&);

The default constructor is equivalent to slice(0, 0, 0). A default constructor is provided only to
permit the declaration of arrays of slices. The constructor with arguments for a slice takes a start,
length, and stride parameter.
[ Example: slice(3, 8, 2) constructs a slice which selects elements 3, 5, 7, ... 17 from an array.
— end example ]

26.6.4.3 slice access functions
size_t start() const;
size_t size() const;
size_t stride() const;

[slice.access]

Returns: The start, length, or stride speciﬁed by a slice object.
Complexity: Constant time.

26.6.5 Class template slice_array
26.6.5.1 Class template slice_array overview

[template.slice.array]
[template.slice.array.overview]

1

2

1

2

namespace std {

template <class T> class slice_array {
public:

typedef T value_type;

void operator=
(const valarray<T>&) const;
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;

slice_array(const slice_array&);
~slice_array();
const slice_array& operator=(const slice_array&) const;

void operator=(const T&) const;

slice_array() = delete;

// as implied by declaring copy constructor above

};

}

1 The slice_array template is a helper template used by the slice subscript operator

slice_array<T> valarray<T>::operator[](slice);

2

It has reference semantics to a subset of an array speciﬁed by a slice object.
[ Example: The expression a[slice(1, 5, 3)] = b; has the eﬀect of assigning the elements of b to a slice
of the elements in a. For the slice shown, the elements selected from a are 1, 4, ..., 13. — end example ]
26.6.5.2 slice_array assignment

[slice.arr.assign]

§ 26.6.5.2

994

1

1

1

c(cid:13) ISO/IEC

N4296

void operator=(const valarray<T>&) const;
const slice_array& operator=(const slice_array&) const;

These assignment operators have reference semantics, assigning the values of the argument array
elements to selected elements of the valarray<T> object to which the slice_array object refers.

26.6.5.3 slice_array computed assignment
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;

[slice.arr.comp.assign]

These computed assignments have reference semantics, applying the indicated operation to the elements
of the argument array and selected elements of the valarray<T> object to which the slice_array
object refers.

26.6.5.4 slice_array ﬁll function
void operator=(const T&) const;

[slice.arr.ﬁll]

This function has reference semantics, assigning the value of its argument to the elements of the
valarray<T> object to which the slice_array object refers.

26.6.6 The gslice class
26.6.6.1 The gslice class overview

[class.gslice]
[class.gslice.overview]

namespace std {
class gslice {
public:

gslice();
gslice(size_t s, const valarray<size_t>& l, const valarray<size_t>& d);

size_t
start() const;
valarray<size_t> size() const;
valarray<size_t> stride() const;

};

}

1 This class represents a generalized slice out of an array. A gslice is deﬁned by a starting oﬀset (s), a set

of lengths (lj), and a set of strides (dj). The number of lengths shall equal the number of strides.

2 A gslice represents a mapping from a set of indices (ij), equal in number to the number of strides, to a
single index k. It is useful for building multidimensional array classes using the valarray template, which
is one-dimensional. The set of one-dimensional index values speciﬁed by a gslice are

k = s +X

ijdj

where the multidimensional indices ij range in value from 0 to lij − 1.
[ Example: The gslice speciﬁcation

3

j

§ 26.6.6.1

995

c(cid:13) ISO/IEC

= 3

start
length = {2, 4, 3}
stride = {19, 4, 1}

yields the sequence of one-dimensional indices

k = 3 + (0, 1) × 19 + (0, 1, 2, 3) × 4 + (0, 1, 2) × 1

which are ordered as shown in the following table:

N4296

(i0,

i1,
(0,
(0,
(0,
(0,
(0,
(0,
(0,
(0,
(0,
(0,
(0,
(0,
(1,
(1,
. . .
(1,

i2,
0,
0,
0,
1,
1,
1,
2,
2,
2,
3,
3,
3,
0,
0,

3,

k) =
3),
0,
4),
1,
2,
5),
7),
0,
8),
1,
2,
9),
11),
0,
1,
12),
13),
2,
15),
0,
16),
1,
2,
17),
22),
0,
1,
23),

2,

36)

That is, the highest-ordered index turns fastest. — end example ]
It is possible to have degenerate generalized slices in which an address is repeated.
[ Example: If the stride parameters in the previous example are changed to {1, 1, 1}, the ﬁrst few elements
of the resulting sequence of indices will be

0,
0,
0,
1,
1,
1,

0,
1,
2,
0,
1,
2,

3),
4),
5),
4),
5),
6),

(0,
(0,
(0,
(0,
(0,
(0,
. . .
— end example ]
If a degenerate slice is used as the argument to the non-const version of operator[](const gslice&), the
resulting behavior is undeﬁned.
26.6.6.2 gslice constructors
gslice();
gslice(size_t start, const valarray<size_t>& lengths,

[gslice.cons]

const valarray<size_t>& strides);

gslice(const gslice&);

4

5

6

§ 26.6.6.2

996

1

1

2

c(cid:13) ISO/IEC

N4296

The default constructor is equivalent to gslice(0, valarray<size_t>(), valarray<size_t>()).
The constructor with arguments builds a gslice based on a speciﬁcation of start, lengths, and strides,
as explained in the previous section.

26.6.6.3 gslice access functions
size_t
valarray<size_t> size() const;
valarray<size_t> stride() const;

start()

const;

[gslice.access]

Returns: The representation of the start, lengths, or strides speciﬁed for the gslice.
Complexity: start() is constant time. size() and stride() are linear in the number of strides.

26.6.7 Class template gslice_array
26.6.7.1 Class template gslice_array overview

[template.gslice.array]
[template.gslice.array.overview]

namespace std {

template <class T> class gslice_array {
public:

typedef T value_type;

void operator=
(const valarray<T>&) const;
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;

gslice_array(const gslice_array&);
~gslice_array();
const gslice_array& operator=(const gslice_array&) const;
void operator=(const T&) const;

gslice_array() = delete;

// as implied by declaring copy constructor above

};

}

1 This template is a helper template used by the slice subscript operator

gslice_array<T> valarray<T>::operator[](const gslice&);

2

3

1

It has reference semantics to a subset of an array speciﬁed by a gslice object.
Thus, the expression a[gslice(1, length, stride)] = b has the eﬀect of assigning the elements of
b to a generalized slice of the elements in a.

26.6.7.2 gslice_array assignment
void operator=(const valarray<T>&) const;
const gslice_array& operator=(const gslice_array&) const;

[gslice.array.assign]

These assignment operators have reference semantics, assigning the values of the argument array
elements to selected elements of the valarray<T> object to which the gslice_array refers.

§ 26.6.7.2

997

N4296

[gslice.array.comp.assign]

c(cid:13) ISO/IEC

26.6.7.3 gslice_array
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;

1

1

These computed assignments have reference semantics, applying the indicated operation to the elements
of the argument array and selected elements of the valarray<T> object to which the gslice_array
object refers.

26.6.7.4 gslice_array ﬁll function
void operator=(const T&) const;

[gslice.array.ﬁll]

This function has reference semantics, assigning the value of its argument to the elements of the
valarray<T> object to which the gslice_array object refers.

26.6.8 Class template mask_array
26.6.8.1 Class template mask_array overview

[template.mask.array]
[template.mask.array.overview]

namespace std {

template <class T> class mask_array {
public:

typedef T value_type;

void operator=
(const valarray<T>&) const;
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;

mask_array(const mask_array&);
~mask_array();
const mask_array& operator=(const mask_array&) const;
void operator=(const T&) const;

mask_array() = delete;

// as implied by declaring copy constructor above

};

}

1 This template is a helper template used by the mask subscript operator:

mask_array<T> valarray<T>::operator[](const valarray<bool>&).

§ 26.6.8.1

998

2

1

1

1

c(cid:13) ISO/IEC

N4296

It has reference semantics to a subset of an array speciﬁed by a boolean mask. Thus, the expression
a[mask] = b; has the eﬀect of assigning the elements of b to the masked elements in a (those for
which the corresponding element in mask is true.)

26.6.8.2 mask_array assignment
void operator=(const valarray<T>&) const;
const mask_array& operator=(const mask_array&) const;

[mask.array.assign]

These assignment operators have reference semantics, assigning the values of the argument array
elements to selected elements of the valarray<T> object to which it refers.

[mask.array.comp.assign]

26.6.8.3 mask_array computed assignment
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;

These computed assignments have reference semantics, applying the indicated operation to the elements
of the argument array and selected elements of the valarray<T> object to which the mask object refers.
[mask.array.ﬁll]

26.6.8.4 mask_array ﬁll function
void operator=(const T&) const;

This function has reference semantics, assigning the value of its argument to the elements of the
valarray<T> object to which the mask_array object refers.

26.6.9 Class template indirect_array
26.6.9.1 Class template indirect_array overview

[template.indirect.array]
[template.indirect.array.overview]

namespace std {

template <class T> class indirect_array {
public:

typedef T value_type;

void operator=
(const valarray<T>&) const;
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;

indirect_array(const indirect_array&);
~indirect_array();
const indirect_array& operator=(const indirect_array&) const;

§ 26.6.9.1

999

c(cid:13) ISO/IEC

N4296

void operator=(const T&) const;

indirect_array() = delete;

// as implied by declaring copy constructor above

};

}

1 This template is a helper template used by the indirect subscript operator

indirect_array<T> valarray<T>::operator[](const valarray<size_t>&).

2

1

2

3

1

2

1

It has reference semantics to a subset of an array speciﬁed by an indirect_array. Thus the expression
a[indirect] = b; has the eﬀect of assigning the elements of b to the elements in a whose indices
appear in indirect.

26.6.9.2 indirect_array assignment
void operator=(const valarray<T>&) const;
const indirect_array& operator=(const indirect_array&) const;

[indirect.array.assign]

These assignment operators have reference semantics, assigning the values of the argument array
elements to selected elements of the valarray<T> object to which it refers.
If the indirect_array speciﬁes an element in the valarray<T> object to which it refers more than
once, the behavior is undeﬁned.
[ Example:

int addr[] = {2, 3, 1, 4, 4};
valarray<size_t> indirect(addr, 5);
valarray<double> a(0., 10), b(1., 5);
a[indirect] = b;

results in undeﬁned behavior since element 4 is speciﬁed twice in the indirection. — end example ]

[indirect.array.comp.assign]

26.6.9.3 indirect_array computed assignment
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;

These computed assignments have reference semantics, applying the indicated operation to the elements
of the argument array and selected elements of the valarray<T> object to which the indirect_array
object refers.
If the indirect_array speciﬁes an element in the valarray<T> object to which it refers more than
once, the behavior is undeﬁned.

26.6.9.4 indirect_array ﬁll function
void operator=(const T&) const;

[indirect.array.ﬁll]

This function has reference semantics, assigning the value of its argument to the elements of the
valarray<T> object to which the indirect_array object refers.

§ 26.6.9.4

1000

c(cid:13) ISO/IEC

N4296

1

[valarray.range]
26.6.10 valarray range access
In the begin and end function templates that follow, unspecified 1 is a type that meets the requirements
of a mutable random access iterator (24.2.7) and of a contiguous iterator (24.2.1) whose value_type is the
template parameter T and whose reference type is T&. unspecified 2 is a type that meets the requirements
of a constant random access iterator (24.2.7) and of a contiguous iterator (24.2.1) whose value_type is the
template parameter T and whose reference type is const T&.

2 The iterators returned by begin and end for an array are guaranteed to be valid until the member function
resize(size_t, T) (26.6.2.8) is called for that array or until the lifetime of that array ends, whichever
happens ﬁrst.

template <class T> unspecified 1 begin(valarray<T>& v);
template <class T> unspecified 2 begin(const valarray<T>& v);

Returns: An iterator referencing the ﬁrst value in the numeric array.

template <class T> unspecified 1 end(valarray<T>& v);
template <class T> unspecified 2 end(const valarray<T>& v);

Returns: An iterator referencing one past the last value in the numeric array.

3

4

26.7 Generalized numeric operations
26.7.1 Header <numeric> synopsis

[numeric.ops]
[numeric.ops.overview]

namespace std {

template <class InputIterator, class T>

T accumulate(InputIterator first, InputIterator last, T init);

template <class InputIterator, class T, class BinaryOperation>
T accumulate(InputIterator first, InputIterator last, T init,

BinaryOperation binary_op);

template <class InputIterator1, class InputIterator2, class T>
T inner_product(InputIterator1 first1, InputIterator1 last1,

InputIterator2 first2, T init);

template <class InputIterator1, class InputIterator2, class T,

class BinaryOperation1, class BinaryOperation2>

T inner_product(InputIterator1 first1, InputIterator1 last1,

InputIterator2 first2, T init,
BinaryOperation1 binary_op1,
BinaryOperation2 binary_op2);

template <class InputIterator, class OutputIterator>

OutputIterator partial_sum(InputIterator first,
InputIterator last,
OutputIterator result);
template <class InputIterator, class OutputIterator,

class BinaryOperation>

OutputIterator partial_sum(InputIterator first,
InputIterator last,
OutputIterator result,
BinaryOperation binary_op);

template <class InputIterator, class OutputIterator>

OutputIterator adjacent_difference(InputIterator first,
InputIterator last,
OutputIterator result);

§ 26.7.1

1001

c(cid:13) ISO/IEC

N4296

template <class InputIterator, class OutputIterator,

class BinaryOperation>

OutputIterator adjacent_difference(InputIterator first,
InputIterator last,
OutputIterator result,
BinaryOperation binary_op);

template <class ForwardIterator, class T>

void iota(ForwardIterator first, ForwardIterator last, T value);

}

1 The requirements on the types of algorithms’ arguments that are described in the introduction to Clause 25

also apply to the following algorithms.
26.7.2 Accumulate
template <class InputIterator, class T>

T accumulate(InputIterator first, InputIterator last, T init);

template <class InputIterator, class T, class BinaryOperation>
T accumulate(InputIterator first, InputIterator last, T init,

BinaryOperation binary_op);

[accumulate]

1

2

1

2

Eﬀects: Computes its result by initializing the accumulator acc with the initial value init and then
modiﬁes it with acc = acc + *i or acc = binary_op(acc, *i) for every iterator i in the range
[first,last) in order.289
Requires: T shall meet the requirements of CopyConstructible (Table 21) and CopyAssignable (Ta-
ble 23) types. In the range [first,last], binary_op shall neither modify elements nor invalidate
iterators or subranges.290

Inner product

26.7.3
template <class InputIterator1, class InputIterator2, class T>
T inner_product(InputIterator1 first1, InputIterator1 last1,

InputIterator2 first2, T init);

template <class InputIterator1, class InputIterator2, class T,

class BinaryOperation1, class BinaryOperation2>

T inner_product(InputIterator1 first1, InputIterator1 last1,

InputIterator2 first2, T init,
BinaryOperation1 binary_op1,
BinaryOperation2 binary_op2);

[inner.product]

Eﬀects: Computes its result by initializing the accumulator acc with the initial value init and
then modifying it with acc = acc + (*i1) * (*i2) or acc = binary_op1(acc, binary_op2(*i1,
*i2)) for every iterator i1 in the range [first1,last1) and iterator i2 in the range [first2,first2
+ (last1 - first1)) in order.
Requires: T shall meet the requirements of CopyConstructible (Table 21) and CopyAssignable (Ta-
ble 23) types. In the ranges [first1,last1] and [first2,first2 + (last1 - first1)] binary_-
op1 and binary_op2 shall neither modify elements nor invalidate iterators or subranges.291

26.7.4 Partial sum

[partial.sum]

289) accumulate is similar to the APL reduction operator and Common Lisp reduce function, but it avoids the diﬃculty of
deﬁning the result of reduction on an empty sequence by always requiring an initial value.
290) The use of fully closed ranges is intentional
291) The use of fully closed ranges is intentional

§ 26.7.4

1002

c(cid:13) ISO/IEC

N4296

template <class InputIterator, class OutputIterator>

OutputIterator partial_sum(

InputIterator first, InputIterator last,
OutputIterator result);

template

<class InputIterator, class OutputIterator, class BinaryOperation>

OutputIterator partial_sum(

InputIterator first, InputIterator last,
OutputIterator result, BinaryOperation binary_op);
Eﬀects: For a non-empty range, the function creates an accumulator acc whose type is InputIterator’s
value type, initializes it with *first, and assigns the result to *result. For every iterator i in [first
+ 1,last) in order, acc is then modiﬁed by acc = acc + *i or acc = binary_op(acc, *i) and the
result is assigned to *(result + (i - first)).
Returns: result + (last - first).
Complexity: Exactly (last - first) - 1 applications of the binary operation.
Requires: InputIterator’s value type shall be constructible from the type of *first. The result of
the expression acc + *i or binary_op(acc, *i) shall be implicitly convertible to InputIterator’s
value type. acc shall be writable to the result output iterator. In the ranges [first,last] and
[result,result + (last - first)] binary_op shall neither modify elements nor invalidate itera-
tors or subranges.292
Remarks: result may be equal to first.

[adjacent.diﬀerence]

26.7.5 Adjacent diﬀerence
template <class InputIterator, class OutputIterator>

OutputIterator adjacent_difference(

InputIterator first, InputIterator last,
OutputIterator result);

template <class InputIterator, class OutputIterator, class BinaryOperation>

OutputIterator adjacent_difference(

InputIterator first, InputIterator last,
OutputIterator result,
BinaryOperation binary_op);
Eﬀects: For a non-empty range, the function creates an accumulator acc whose type is InputIterator’s
value type, initializes it with *first, and assigns the result to *result. For every iterator i in [first
+ 1,last) in order, creates an object val whose type is InputIterator’s value type, initializes it with
*i, computes val - acc or binary_op(val, acc), assigns the result to *(result + (i - first)),
and move assigns from val to acc.
Requires: InputIterator’s value type shall be MoveAssignable (Table 22) and shall be constructible
from the type of *first. acc shall be writable to the result output iterator. The result of the
expression val - acc or binary_op(val, acc) shall be writable to the result output iterator. In
the ranges [first,last] and [result,result + (last - first)], binary_op shall neither modify
elements nor invalidate iterators or subranges.293
Remarks: result may be equal to first.
Returns: result + (last - first).
Complexity: Exactly (last - first) - 1 applications of the binary operation.

292) The use of fully closed ranges is intentional.
293) The use of fully closed ranges is intentional.

§ 26.7.5

1003

1

2

3

4

5

1

2

3

4

5

c(cid:13) ISO/IEC

Iota

26.7.6
template <class ForwardIterator, class T>

void iota(ForwardIterator first, ForwardIterator last, T value);

N4296

[numeric.iota]

1

2

3

Requires: T shall be convertible to ForwardIterator’s value type. The expression ++val, where val
has type T, shall be well formed.
Eﬀects: For each element referred to by the iterator i in the range [first,last), assigns *i = value
and increments value as if by ++value.
Complexity: Exactly last - first increments and assignments.

26.8 C library

[c.math]

1 The header <ctgmath> simply includes the headers <ccomplex> and <cmath>.
2

[ Note: The overloads provided in C by type-generic macros are already provided in <ccomplex> and <cmath>
by “suﬃcient” additional overloads. — end note ]

3 Tables 119 and 120 describe headers <cmath> and <cstdlib>, respectively.

Table 119 — Header <cmath> synopsis

Name(s)

HUGE_VALL
INFINITY
NAN

MATH_ERRNO
MATH_ERREXCEPT
math_errhandling

logb
lrint
lround
modf
nan
nanf
nanl
nearbyint
nextafter
nexttoward
pow
remainder

remquo
rint
round
scalbln
scalbn
sin
sinh
sqrt
tan
tanh
tgamma
trunc

isnan
isnormal

isunordered
signbit

FP_SUBNORMAL
FP_ZERO
HUGE_VAL
HUGE_VALF
float_t

FP_ILOGBNAN
FP_INFINITE
FP_NAN
FP_NORMAL
double_t

Type
Macros:
FP_FAST_FMA
FP_FAST_FMAF
FP_FAST_FMAL
FP_ILOGB0
Types:
Math Functions:
abs
fmod
acos
frexp
acosh
hypot
asin
ilogb
asinh
ldexp
atan
lgamma
atan2
llrint
atanh
llround
cbrt
log
ceil
log10
copysign
log1p
cos
log2
Classiﬁcation/comparison Functions:
fpclassify
isfinite
isgreater

cosh
erf
erfc
exp2
exp
expm1
fabs
fdim
floor
fma
fmax
fmin

isgreaterequal
isinf
isless

islessequal
islessgreater

4 The contents of these headers are the same as the Standard C library headers <math.h> and <stdlib.h>

respectively, with the following changes:

5 The rand function has the semantics speciﬁed in the C standard, except that the implementation may specify
that particular library functions may call rand. It is implementation-deﬁned whether the rand function may
introduce data races (17.6.5.9). [ Note: The random number generation (26.5) facilities in this standard are

§ 26.8

1004

c(cid:13) ISO/IEC

N4296

Table 120 — Header <cstdlib> synopsis

Type
Macro:
Types:
div_t
Functions:
abs
div
labs

Name(s)

RAND_MAX

ldiv_t

lldiv_t

ldiv
llabs
lldiv

rand
srand

often preferable to rand, because rand’s underlying algorithm is unspeciﬁed. Use of rand therefore continues
to be nonportable, with unpredictable and oft-questionable quality and performance. — end note ]
In addition to the int versions of certain math functions in <cstdlib>, C++ adds long and long long
overloaded versions of these functions, with the same semantics.

6

7 The added signatures are:

// labs()
long abs(long);
// llabs()
long long abs(long long);
// ldiv()
ldiv_t div(long, long);
lldiv_t div(long long, long long); // lldiv()

8

In addition to the double versions of the math functions in <cmath>, C++ adds float and long double
overloaded versions of these functions, with the same semantics.

9 The added signatures are:

float abs(float);
float acos(float);
float acosh(float);
float asin(float);
float asinh(float);
float atan(float);
float atan2(float, float);
float atanh(float);
float cbrt(float);
float ceil(float);
float copysign(float, float);
float cos(float);
float cosh(float);
float erf(float);
float erfc(float);
float exp(float);
float exp2(float);
float expm1(float);
float fabs(float);
float fdim(float, float);
float floor(float);
float fma(float, float, float);
float fmax(float, float);
float fmin(float, float);
float fmod(float, float);
float frexp(float, int*);
float hypot(float, float);

§ 26.8

1005

c(cid:13) ISO/IEC

N4296

int ilogb(float);
float ldexp(float, int);
float lgamma(float);
long long llrint(float);
long long llround(float);
float log(float);
float log10(float);
float log1p(float);
float log2(float);
float logb(float);
long lrint(float);
long lround(float);
float modf(float, float*);
float nearbyint(float);
float nextafter(float, float);
float nexttoward(float, long double);
float pow(float, float);
float remainder(float, float);
float remquo(float, float, int *);
float rint(float);
float round(float);
float scalbln(float, long);
float scalbn(float, int);
float sin(float);
float sinh(float);
float sqrt(float);
float tan(float);
float tanh(float);
float tgamma(float);
float trunc(float);

double abs(double);

// fabs()

long double abs(long double);
long double acos(long double);
long double acosh(long double);
long double asin(long double);
long double asinh(long double);
long double atan(long double);
long double atan2(long double, long double);
long double atanh(long double);
long double cbrt(long double);
long double ceil(long double);
long double copysign(long double, long double);
long double cos(long double);
long double cosh(long double);
long double erf(long double);
long double erfc(long double);
long double exp(long double);
long double exp2(long double);
long double expm1(long double);
long double fabs(long double);
long double fdim(long double, long double);
long double floor(long double);
long double fma(long double, long double, long double);

§ 26.8

1006

c(cid:13) ISO/IEC

N4296

long double fmax(long double, long double);
long double fmin(long double, long double);
long double fmod(long double, long double);
long double frexp(long double, int*);
long double hypot(long double, long double);
int ilogb(long double);
long double ldexp(long double, int);
long double lgamma(long double);
long long llrint(long double);
long long llround(long double);
long double log(long double);
long double log10(long double);
long double log1p(long double);
long double log2(long double);
long double logb(long double);
long lrint(long double);
long lround(long double);
long double modf(long double, long double*);
long double nearbyint(long double);
long double nextafter(long double, long double);
long double nexttoward(long double, long double);
long double pow(long double, long double);
long double remainder(long double, long double);
long double remquo(long double, long double, int *);
long double rint(long double);
long double round(long double);
long double scalbln(long double, long);
long double scalbn(long double, int);
long double sin(long double);
long double sinh(long double);
long double sqrt(long double);
long double tan(long double);
long double tanh(long double);
long double tgamma(long double);
long double trunc(long double);

10 The classiﬁcation/comparison functions behave the same as the C macros with the corresponding names
deﬁned in 7.12.3, Classiﬁcation macros, and 7.12.14, Comparison macros in the C Standard. Each function
is overloaded for the three ﬂoating-point types, as follows:

int fpclassify(float x);
bool isfinite(float x);
bool isinf(float x);
bool isnan(float x);
bool isnormal(float x);
bool signbit(float x);

bool isgreater(float x, float y);
bool isgreaterequal(float x, float y);
bool isless(float x, float y);
bool islessequal(float x, float y);
bool islessgreater(float x, float y);
bool isunordered(float x, float y);

int fpclassify(double x);
bool isfinite(double x);

§ 26.8

1007

N4296

c(cid:13) ISO/IEC

bool isinf(double x);
bool isnan(double x);
bool isnormal(double x);
bool signbit(double x);

bool isgreater(double x, double y);
bool isgreaterequal(double x, double y);
bool isless(double x, double y);
bool islessequal(double x, double y);
bool islessgreater(double x, double y);
bool isunordered(double x, double y);

int fpclassify(long double x);
bool isfinite(long double x);
bool isinf(long double x);
bool isnan(long double x);
bool isnormal(long double x);
bool signbit(long double x);

bool isgreater(long double x, long double y);
bool isgreaterequal(long double x, long double y);
bool isless(long double x, long double y);
bool islessequal(long double x, long double y);
bool islessgreater(long double x, long double y);
bool isunordered(long double x, long double y);

11 Moreover, there shall be additional overloads suﬃcient to ensure:

1. If any arithmetic argument corresponding to a double parameter has type long double, then all

arithmetic arguments corresponding to double parameters are eﬀectively cast to long double.

2. Otherwise, if any arithmetic argument corresponding to a double parameter has type double or an
integer type, then all arithmetic arguments corresponding to double parameters are eﬀectively cast to
double.

3. Otherwise, all arithmetic arguments corresponding to double parameters have type float.

See also: ISO C 7.5, 7.10.2, 7.10.6.

§ 26.8

1008

c(cid:13) ISO/IEC

N4296

27 Input/output library
27.1 General

[input.output]
[input.output.general]

1 This Clause describes components that C++ programs may use to perform input/output operations.
2 The following subclauses describe requirements for stream parameters, and components for forward declara-
tions of iostreams, predeﬁned iostreams objects, base iostreams classes, stream buﬀering, stream formatting
and manipulators, string streams, and ﬁle streams, as summarized in Table 121.

Table 121 — Input/output library summary

Subclause

27.2 Requirements
27.3 Forward declarations
27.4
27.5
27.6
27.7 Formatting and manipulators

Standard iostream objects
Iostreams base classes
Stream buﬀers

String streams

27.8
27.9 File streams

Header(s)

<iosfwd>
<iostream>
<ios>
<streambuf>
<istream>
<ostream>
<iomanip>
<sstream>
<fstream>
<cstdio>
<cinttypes>

3 Figure 7 illustrates relationships among various types described in this clause. A line from A to B indicates

that A is an alias (e.g. a typedef) for B or that A is deﬁned in terms of B.

Figure 7 — Stream position, oﬀset, and size types [non-normative]

§ 27.1

1009

char_traits<char>::pos_typestreampos iostreams.limits.poschar_traits<wchar_t>::pos_typewstreampos iostreams.limits.posfpos<mbstate_t> iostream.forward iostream.forwardchar_traits<char>::off_typestreamoff iostreams.limits.poschar_traits<wchar_t>::off_type iostreams.limits.possigned integer typesufficient for O/S maximum file size stream.typesstreamsizesigned integer typerepresents characters xferedor buffer sizes stream.typesc(cid:13) ISO/IEC

N4296

Imbue limitations

27.2 Iostreams requirements
27.2.1

[iostreams.requirements]
[iostream.limits.imbue]
1 No function described in Clause 27 except for ios_base::imbue and basic_filebuf::pubimbue causes any
instance of basic_ios::imbue or basic_streambuf::imbue to be called. If any user function called from
a function declared in Clause 27 or as an overriding virtual function of any class declared in Clause 27 calls
imbue, the behavior is undeﬁned.
27.2.2 Positioning type limitations

[iostreams.limits.pos]
1 The classes of Clause 27 with template arguments charT and traits behave as described if traits::pos_-
type and traits::off_type are streampos and streamoff respectively. Except as noted explicitly below,
their behavior when traits::pos_type and traits::off_type are other types is implementation-deﬁned.
In the classes of Clause 27, a template parameter with name charT represents a member of the set of
types containing char, wchar_t, and any other implementation-deﬁned character types that satisfy the
requirements for a character on which any of the iostream components can be instantiated.
27.2.3 Thread safety

2

2

[iostreams.threadsafety]
1 Concurrent access to a stream object (27.8, 27.9), stream buﬀer object (27.6), or C Library stream (27.9.2)
[ Note: Data races

by multiple threads may result in a data race (1.10) unless otherwise speciﬁed (27.4).
result in undeﬁned behavior (1.10). — end note ]
If one thread makes a library call a that writes a value to a stream and, as a result, another thread reads
this value from the stream through a library call b such that this does not result in a data race, then a’s
write synchronizes with b’s read.
27.3 Forward declarations
Header <iosfwd> synopsis

[iostream.forward]

namespace std {

template<class charT> class char_traits;
template<> class char_traits<char>;
template<> class char_traits<char16_t>;
template<> class char_traits<char32_t>;
template<> class char_traits<wchar_t>;

template<class T> class allocator;

template <class charT, class traits = char_traits<charT> >

template <class charT, class traits = char_traits<charT> >

class basic_ios;

class basic_streambuf;

class basic_istream;

class basic_ostream;

class basic_iostream;

template <class charT, class traits = char_traits<charT> >

template <class charT, class traits = char_traits<charT> >

template <class charT, class traits = char_traits<charT> >

template <class charT, class traits = char_traits<charT>,

class Allocator = allocator<charT> >

class basic_stringbuf;

template <class charT, class traits = char_traits<charT>,

class Allocator = allocator<charT> >

class basic_istringstream;

§ 27.3

1010

c(cid:13) ISO/IEC

N4296

template <class charT, class traits = char_traits<charT>,

class Allocator = allocator<charT> >

class basic_ostringstream;

template <class charT, class traits = char_traits<charT>,

class Allocator = allocator<charT> >

class basic_stringstream;

template <class charT, class traits = char_traits<charT> >

template <class charT, class traits = char_traits<charT> >

class basic_filebuf;

class basic_ifstream;

class basic_ofstream;

class basic_fstream;

template <class charT, class traits = char_traits<charT> >

template <class charT, class traits = char_traits<charT> >

template <class charT, class traits = char_traits<charT> >

template <class charT, class traits = char_traits<charT> >

class istreambuf_iterator;

class ostreambuf_iterator;

typedef basic_ios<char>
typedef basic_ios<wchar_t>

ios;
wios;

typedef basic_streambuf<char> streambuf;
typedef basic_istream<char>
typedef basic_ostream<char>
typedef basic_iostream<char>

istream;
ostream;
iostream;

typedef basic_stringbuf<char>
typedef basic_istringstream<char> istringstream;
typedef basic_ostringstream<char> ostringstream;
typedef basic_stringstream<char>
stringstream;

stringbuf;

typedef basic_filebuf<char>
filebuf;
typedef basic_ifstream<char> ifstream;
typedef basic_ofstream<char> ofstream;
typedef basic_fstream<char>
fstream;

typedef basic_streambuf<wchar_t> wstreambuf;
typedef basic_istream<wchar_t>
typedef basic_ostream<wchar_t>
typedef basic_iostream<wchar_t>

wistream;
wostream;
wiostream;

typedef basic_stringbuf<wchar_t>
typedef basic_istringstream<wchar_t> wistringstream;
typedef basic_ostringstream<wchar_t> wostringstream;
typedef basic_stringstream<wchar_t> wstringstream;

wstringbuf;

typedef basic_filebuf<wchar_t>
wfilebuf;
typedef basic_ifstream<wchar_t> wifstream;
typedef basic_ofstream<wchar_t> wofstream;
typedef basic_fstream<wchar_t>
wfstream;

template <class state> class fpos;

§ 27.3

1011

c(cid:13) ISO/IEC

N4296

streampos;
typedef fpos<char_traits<char>::state_type>
typedef fpos<char_traits<wchar_t>::state_type> wstreampos;

}

2

1 Default template arguments are described as appearing both in <iosfwd> and in the synopsis of other

headers but it is well-formed to include both <iosfwd> and one or more of the other headers.294
[ Note: The class template specialization basic_ios<charT,traits> serves as a virtual base class for the
class templates basic_istream, basic_ostream, and class templates derived from them. basic_iostream
is a class template derived from both basic_istream<charT,traits> and basic_ostream<charT,traits>.
3 The class template specialization basic_streambuf<charT,traits> serves as a base class for class templates

basic_stringbuf and basic_filebuf.

4 The class template specialization basic_istream<charT,traits> serves as a base class for class templates

basic_istringstream and basic_ifstream.

5 The class template specialization basic_ostream<charT,traits> serves as a base class for class templates

basic_ostringstream and basic_ofstream.

6 The class template specialization basic_iostream<charT,traits> serves as a base class for class templates

basic_stringstream and basic_fstream.

7 Other typedefs deﬁne instances of class templates specialized for char or wchar_t types.
8 Specializations of the class template fpos are used for specifying ﬁle position information.
9 The types streampos and wstreampos are used for positioning streams specialized on char and wchar_t

respectively.

10 This synopsis suggests a circularity between streampos and char_traits<char>. An implementation can

avoid this circularity by substituting equivalent types. One way to do this might be

template<class stateT> class fpos { ... };
typedef ... _STATE;

// implementation private declaration of stateT

// depends on nothing

typedef fpos<_STATE> streampos;

template<> struct char_traits<char> {

typedef streampos
pos_type;

}

— end note ]
27.4 Standard iostream objects
27.4.1 Overview
Header <iostream> synopsis

#include <ios>
#include <streambuf>
#include <istream>
#include <ostream>

namespace std {

extern istream cin;

[iostream.objects]
[iostream.objects.overview]

294) It is the implementation’s responsibility to implement headers so that including <iosfwd> and other headers does not
violate the rules about multiple occurrences of default arguments.

§ 27.4.1

1012

c(cid:13) ISO/IEC

extern ostream cout;
extern ostream cerr;
extern ostream clog;

extern wistream wcin;
extern wostream wcout;
extern wostream wcerr;
extern wostream wclog;

}

N4296

1 The header <iostream> declares objects that associate objects with the standard C streams provided for by

the functions declared in <cstdio> (27.9.2), and includes all the headers necessary to use these objects.

2 The objects are constructed and the associations are established at some time prior to or during the ﬁrst
time an object of class ios_base::Init is constructed, and in any case before the body of main begins exe-
cution.295 The objects are not destroyed during program execution.296 The results of including <iostream>
in a translation unit shall be as if <iostream> deﬁned an instance of ios_base::Init with static storage
duration. Similarly, the entire program shall behave as if there were at least one instance of ios_base::Init
with static storage duration.

3 Mixing operations on corresponding wide- and narrow-character streams follows the same semantics as

mixing such operations on FILEs, as speciﬁed in Amendment 1 of the ISO C standard.

4 Concurrent access to a synchronized (27.5.3.4) standard iostream object’s formatted and unformatted in-
put (27.7.2.1) and output (27.7.3.1) functions or a standard C stream by multiple threads shall not result
in a data race (1.10).
[ Note: Users must still synchronize concurrent use of these objects and streams by
multiple threads if they wish to avoid interleaved characters. — end note ]
27.4.2 Narrow stream objects
istream cin;

[narrow.stream.objects]

1

2

3

4

5

6

The object cin controls input from a stream buﬀer associated with the object stdin, declared in
<cstdio>.
After the object cin is initialized, cin.tie() returns &cout. Its state is otherwise the same as required
for basic_ios<char>::init (27.5.5.2).

ostream cout;

The object cout controls output to a stream buﬀer associated with the object stdout, declared in
<cstdio> (27.9.2).

ostream cerr;

The object cerr controls output to a stream buﬀer associated with the object stderr, declared in
<cstdio> (27.9.2).
After the object cerr is initialized, cerr.flags() & unitbuf is nonzero and cerr.tie() returns
&cout. Its state is otherwise the same as required for basic_ios<char>::init (27.5.5.2).

ostream clog;

The object clog controls output to a stream buﬀer associated with the object stderr, declared in
<cstdio> (27.9.2).

295) If it is possible for them to do so, implementations are encouraged to initialize the objects earlier than required.
296) Constructors and destructors for static objects can access these objects to read input from stdin or write output to stdout
or stderr.

§ 27.4.2

1013

c(cid:13) ISO/IEC

27.4.3 Wide stream objects
wistream wcin;

N4296

[wide.stream.objects]

1

2

3

4

5

6

The object wcin controls input from a stream buﬀer associated with the object stdin, declared in
<cstdio>.
After the object wcin is initialized, wcin.tie() returns &wcout. Its state is otherwise the same as
required for basic_ios<wchar_t>::init (27.5.5.2).

wostream wcout;

The object wcout controls output to a stream buﬀer associated with the object stdout, declared in
<cstdio> (27.9.2).

wostream wcerr;

The object wcerr controls output to a stream buﬀer associated with the object stderr, declared in
<cstdio> (27.9.2).
After the object wcerr is initialized, wcerr.flags() & unitbuf is nonzero and wcerr.tie() returns
&wcout. Its state is otherwise the same as required for basic_ios<wchar_t>::init (27.5.5.2).

wostream wclog;

The object wclog controls output to a stream buﬀer associated with the object stderr, declared in
<cstdio> (27.9.2).

[iostreams.base]
[iostreams.base.overview]

27.5 Iostreams base classes
27.5.1 Overview
Header <ios> synopsis

#include <iosfwd>

namespace std {

typedef implementation-defined streamoff;
typedef implementation-defined streamsize;
template <class stateT> class fpos;

class ios_base;
template <class charT, class traits = char_traits<charT> >

class basic_ios;

// 27.5.6, manipulators:
ios_base& boolalpha
(ios_base& str);
ios_base& noboolalpha(ios_base& str);

ios_base& showbase
(ios_base& str);
ios_base& noshowbase (ios_base& str);

ios_base& showpoint
(ios_base& str);
ios_base& noshowpoint(ios_base& str);

ios_base& showpos
ios_base& noshowpos

(ios_base& str);
(ios_base& str);

ios_base& skipws
ios_base& noskipws

(ios_base& str);
(ios_base& str);

§ 27.5.1

1014

c(cid:13) ISO/IEC

N4296

ios_base& uppercase
(ios_base& str);
ios_base& nouppercase(ios_base& str);

ios_base& unitbuf
ios_base& nounitbuf

(ios_base& str);
(ios_base& str);

// 27.5.6.2 adjustﬁeld:
ios_base& internal
ios_base& left
ios_base& right

// 27.5.6.3 baseﬁeld:
ios_base& dec
ios_base& hex
ios_base& oct

(ios_base& str);
(ios_base& str);
(ios_base& str);

(ios_base& str);
(ios_base& str);
(ios_base& str);

// 27.5.6.4 ﬂoatﬁeld:
(ios_base& str);
ios_base& fixed
ios_base& scientific (ios_base& str);
ios_base& hexfloat
(ios_base& str);
ios_base& defaultfloat(ios_base& str);

// 27.5.6.5 error reporting:
enum class io_errc {

stream = 1

};

template <> struct is_error_code_enum<io_errc> : public true_type { };
error_code make_error_code(io_errc e) noexcept;
error_condition make_error_condition(io_errc e) noexcept;
const error_category& iostream_category() noexcept;

}

27.5.2 Types
typedef implementation-defined streamoff;

[stream.types]

1

2

The type streamoff is a synonym for one of the signed basic integral types of suﬃcient size to represent
the maximum possible ﬁle size for the operating system.297

typedef implementation-defined streamsize;

The type streamsize is a synonym for one of the signed basic integral types. It is used to represent
the number of characters transferred in an I/O operation, or the size of I/O buﬀers.298

27.5.3 Class ios_base

[ios.base]

namespace std {

class ios_base {
public:

class failure;

297) Typically long long.
298) streamsize is used in most places where ISO C would use size_t. Most of the uses of streamsize could use size_t,
except for the strstreambuf constructors, which require negative values. It should probably be the signed type corresponding
to size_t (which is what Posix.2 calls ssize_t).

§ 27.5.3

1015

c(cid:13) ISO/IEC

N4296

// 27.5.3.1.2 fmtflags
typedef T1 fmtflags;
static constexpr fmtflags boolalpha = unspecified ;
static constexpr fmtflags dec = unspecified ;
static constexpr fmtflags fixed = unspecified ;
static constexpr fmtflags hex = unspecified ;
static constexpr fmtflags internal = unspecified ;
static constexpr fmtflags left = unspecified ;
static constexpr fmtflags oct = unspecified ;
static constexpr fmtflags right = unspecified ;
static constexpr fmtflags scientific = unspecified ;
static constexpr fmtflags showbase = unspecified ;
static constexpr fmtflags showpoint = unspecified ;
static constexpr fmtflags showpos = unspecified ;
static constexpr fmtflags skipws = unspecified ;
static constexpr fmtflags unitbuf = unspecified ;
static constexpr fmtflags uppercase = unspecified ;
static constexpr fmtflags adjustfield = see below ;
static constexpr fmtflags basefield = see below ;
static constexpr fmtflags floatfield = see below ;

// 27.5.3.1.3 iostate
typedef T2 iostate;
static constexpr iostate badbit = unspecified ;
static constexpr iostate eofbit = unspecified ;
static constexpr iostate failbit = unspecified ;
static constexpr iostate goodbit = see below ;

// 27.5.3.1.4 openmode
typedef T3 openmode;
static constexpr openmode app = unspecified ;
static constexpr openmode ate = unspecified ;
static constexpr openmode binary = unspecified ;
static constexpr openmode in = unspecified ;
static constexpr openmode out = unspecified ;
static constexpr openmode trunc = unspecified ;

// 27.5.3.1.5 seekdir
typedef T4 seekdir;
static constexpr seekdir beg = unspecified ;
static constexpr seekdir cur = unspecified ;
static constexpr seekdir end = unspecified ;

class Init;

// 27.5.3.2 fmtﬂags state:
fmtflags flags() const;
fmtflags flags(fmtflags fmtfl);
fmtflags setf(fmtflags fmtfl);
fmtflags setf(fmtflags fmtfl, fmtflags mask);
void unsetf(fmtflags mask);

streamsize precision() const;
streamsize precision(streamsize prec);

§ 27.5.3

1016

c(cid:13) ISO/IEC

N4296

streamsize width() const;
streamsize width(streamsize wide);

// 27.5.3.3 locales:
locale imbue(const locale& loc);
locale getloc() const;

// 27.5.3.5 storage:
static int xalloc();
iword(int index);
long&
void*& pword(int index);

// destructor
virtual ~ios_base();

// 27.5.3.6 callbacks;
enum event { erase_event, imbue_event, copyfmt_event };
typedef void (*event_callback)(event, ios_base&, int index);
void register_callback(event_callback fn, int index);

ios_base(const ios_base&) = delete;
ios_base& operator=(const ios_base&) = delete;

static bool sync_with_stdio(bool sync = true);

protected:

ios_base();

private:

static int index; // exposition only
// exposition only
long* iarray;
// exposition only
void** parray;

};

}

1 ios_base deﬁnes several member types:

(1.1)

(1.2)

(1.3)

(1.4)

—
—
—
—

a class failure derived from system_error;
a class Init;
three bitmask types, fmtflags, iostate, and openmode;
an enumerated type, seekdir.

2

It maintains several kinds of data:

(2.1)

(2.2)

(2.3)

—
—

—

state information that reﬂects the integrity of the stream buﬀer;
control information that inﬂuences how to interpret (format) input sequences and how to generate
(format) output sequences;
additional information that is stored by the program for its private use.

3

[ Note: For the sake of exposition, the maintained data is presented here as:

§ 27.5.3

1017

c(cid:13) ISO/IEC

N4296

(3.1)

(3.2)

(3.3)

—

—

—

static int index, speciﬁes the next available unique index for the integer or pointer arrays main-
tained for the private use of the program, initialized to an unspeciﬁed value;
long* iarray, points to the ﬁrst element of an arbitrary-length long array maintained for the private
use of the program;
void** parray, points to the ﬁrst element of an arbitrary-length pointer array maintained for the
private use of the program. — end note ]

27.5.3.1 Types
27.5.3.1.1 Class ios_base::failure

[ios.types]
[ios::failure]

namespace std {

class ios_base::failure : public system_error {
public:

explicit failure(const string& msg, const error_code& ec = io_errc::stream);
explicit failure(const char* msg, const error_code& ec = io_errc::stream);

};

}

1 The class failure deﬁnes the base class for the types of all objects thrown as exceptions, by functions in

the iostreams library, to report errors detected during stream buﬀer operations.

2 When throwing ios_base::failure exceptions, implementations should provide values of ec that identify
the speciﬁc reason for the failure.
[ Note: Errors arising from the operating system would typically be
reported as system_category() errors with an error value of the error number reported by the operating
system. Errors arising from within the stream library would typically be reported as error_code(io_-
errc::stream, iostream_category()). — end note ]

explicit failure(const string& msg, const error_code& ec = io_errc::stream);

Eﬀects: Constructs an object of class failure by constructing the base class with msg and ec.

explicit failure(const char* msg, const error_code& ec = io_errc::stream);

Eﬀects: Constructs an object of class failure by constructing the base class with msg and ec.

27.5.3.1.2 Type ios_base::fmtflags
typedef T1 fmtflags;

[ios::fmtﬂags]

The type fmtflags is a bitmask type (17.5.2.1.3). Setting its elements has the eﬀects indicated in
Table 122.
Type fmtflags also deﬁnes the constants indicated in Table 123.

27.5.3.1.3 Type ios_base::iostate
typedef T2 iostate;

[ios::iostate]

The type iostate is a bitmask type (17.5.2.1.3) that contains the elements indicated in Table 124.
Type iostate also deﬁnes the constant:
—

goodbit, the value zero.

3

4

1

2

1

2

(2.1)

27.5.3.1.4 Type ios_base::openmode
typedef T3 openmode;

[ios::openmode]

1

The type openmode is a bitmask type (17.5.2.1.3). It contains the elements indicated in Table 125.

§ 27.5.3.1.4

1018

c(cid:13) ISO/IEC

N4296

Element
boolalpha
dec
fixed
hex
internal

left
oct
right
scientific
showbase
showpoint

showpos
skipws
unitbuf
uppercase

Table 122 — fmtflags eﬀects
Eﬀect(s) if set

insert and extract bool type in alphabetic format
converts integer input or generates integer output in decimal base
generate ﬂoating-point output in ﬁxed-point notation
converts integer input or generates integer output in hexadecimal base
adds ﬁll characters at a designated internal point in certain generated out-
put, or identical to right if no such point is designated
adds ﬁll characters on the right (ﬁnal positions) of certain generated output
converts integer input or generates integer output in octal base
adds ﬁll characters on the left (initial positions) of certain generated output
generates ﬂoating-point output in scientiﬁc notation
generates a preﬁx indicating the numeric base of generated integer output
generates a decimal-point character unconditionally in generated ﬂoating-
point output
generates a + sign in non-negative generated numeric output
skips leading whitespace before certain input operations
ﬂushes output after each output operation
replaces certain lowercase letters with their uppercase equivalents in gen-
erated output

Table 123 — fmtflags constants
Allowable values

Constant
adjustfield
basefield
floatfield

left | right | internal
dec | oct | hex
scientific | fixed

Element
badbit

eofbit
failbit

Element
app
ate
binary
in
out
trunc

Table 124 — iostate eﬀects
Eﬀect(s) if set

indicates a loss of integrity in an input or output sequence (such as an
irrecoverable read error from a ﬁle);
indicates that an input operation reached the end of an input sequence;
indicates that an input operation failed to read the expected characters, or
that an output operation failed to generate the desired characters.

Table 125 — openmode eﬀects
Eﬀect(s) if set

seek to end before each write
open and seek to end immediately after opening
perform input and output in binary mode (as opposed to text mode)
open for input
open for output
truncate an existing stream when opening

§ 27.5.3.1.4

1019

c(cid:13) ISO/IEC

27.5.3.1.5 Type ios_base::seekdir
typedef T4 seekdir;

N4296

[ios::seekdir]

1

The type seekdir is an enumerated type (17.5.2.1.2) that contains the elements indicated in Table 126.

Element
beg

cur
end

Table 126 — seekdir eﬀects

Meaning

request a seek (for subsequent input or output) relative to the beginning of
the stream
request a seek relative to the current position within the sequence
request a seek relative to the current end of the sequence

27.5.3.1.6 Class ios_base::Init

[ios::Init]

namespace std {

class ios_base::Init {
public:

static int init_cnt; // exposition only

Init();
~Init();
private:

};

}

1 The class Init describes an object whose construction ensures the construction of the eight objects declared
in <iostream> (27.4) that associate ﬁle stream buﬀers with the standard C streams provided for by the
functions declared in <cstdio> (27.9.2).

2 For the sake of exposition, the maintained data is presented here as:

(2.1)

—

static int init_cnt, counts the number of constructor and destructor calls for class Init, initialized
to zero.

3

4

1

2

3

Init();

Eﬀects: Constructs an object of class Init. Constructs and initializes the objects cin, cout, cerr,
clog, wcin, wcout, wcerr, and wclog if they have not already been constructed and initialized.

~Init();

Eﬀects: Destroys an object of class Init. If there are no other instances of the class still in existence,
calls cout.flush(), cerr.flush(), clog.flush(), wcout.flush(), wcerr.flush(), wclog.flush().
[fmtﬂags.state]

27.5.3.2 ios_base state functions
fmtflags flags() const;

Returns: The format control information for both input and output.

fmtflags flags(fmtflags fmtfl);

Postcondition: fmtfl == flags().
Returns: The previous value of flags().

fmtflags setf(fmtflags fmtfl);

§ 27.5.3.2

1020

c(cid:13) ISO/IEC

N4296

4

5

6

7

8

9

10

11

12

13

14

1

2

3

4

1

2

3

Eﬀects: Sets fmtfl in flags().
Returns: The previous value of flags().

fmtflags setf(fmtflags fmtfl, fmtflags mask);

Eﬀects: Clears mask in flags(), sets fmtfl & mask in flags().
Returns: The previous value of flags().

void unsetf(fmtflags mask);

Eﬀects: Clears mask in flags().

streamsize precision() const;

Returns: The precision to generate on certain output conversions.

streamsize precision(streamsize prec);

Postcondition: prec == precision().
Returns: The previous value of precision().

streamsize width() const;

Returns: The minimum ﬁeld width (number of characters) to generate on certain output conversions.

streamsize width(streamsize wide);

Postcondition: wide == width().
Returns: The previous value of width().

27.5.3.3 ios_base functions
locale imbue(const locale& loc);

[ios.base.locales]

Eﬀects: Calls each registered callback pair (fn,index) (27.5.3.6) as (*fn)(imbue_event,*this,index)
at such a time that a call to ios_base::getloc() from within fn returns the new locale value loc.
Returns: The previous value of getloc().
Postcondition: loc == getloc().

locale getloc() const;

Returns: If no locale has been imbued, a copy of the global C++ locale, locale(), in eﬀect at the time
of construction. Otherwise, returns the imbued locale, to be used to perform locale-dependent input
and output operations.

27.5.3.4 ios_base static members
bool sync_with_stdio(bool sync = true);

[ios.members.static]

Returns: true if the previous state of the standard iostream objects (27.4) was synchronized and
otherwise returns false. The ﬁrst time it is called, the function returns true.
Eﬀects: If any input or output operation has occurred using the standard streams prior to the call,
the eﬀect is implementation-deﬁned. Otherwise, called with a false argument, it allows the standard
streams to operate independently of the standard C streams.
When a standard iostream object str is synchronized with a standard stdio stream f, the eﬀect of
inserting a character c by

§ 27.5.3.4

1021

c(cid:13) ISO/IEC

fputc(f, c);

is the same as the eﬀect of
str.rdbuf()->sputc(c);

for any sequences of characters; the eﬀect of extracting a character c by

c = fgetc(f);

is the same as the eﬀect of

c = str.rdbuf()->sbumpc();

for any sequences of characters; and the eﬀect of pushing back a character c by

ungetc(c, f);

is the same as the eﬀect of

str.rdbuf()->sputbackc(c);

for any sequence of characters.299

27.5.3.5 ios_base storage functions
static int xalloc();

N4296

[ios.base.storage]

1

2

3

4

5

Returns: index ++.
Remarks: Concurrent access to this function by multiple threads shall not result in a data race (1.10).

long& iword(int idx);

Eﬀects: If iarray is a null pointer, allocates an array of long of unspeciﬁed size and stores a pointer
to its ﬁrst element in iarray. The function then extends the array pointed at by iarray as necessary
to include the element iarray[idx]. Each newly allocated element of the array is initialized to zero.
The reference returned is invalid after any other operations on the object.300 However, the value of the
storage referred to is retained, so that until the next call to copyfmt, calling iword with the same index
yields another reference to the same value. If the function fails301 and *this is a base subobject of a
basic_ios<> object or subobject, the eﬀect is equivalent to calling basic_ios<>::setstate(badbit)
on the derived object (which may throw failure).
Returns: On success iarray[idx]. On failure, a valid long& initialized to 0.

void*& pword(int idx);

Eﬀects: If parray is a null pointer, allocates an array of pointers to void of unspeciﬁed size and
stores a pointer to its ﬁrst element in parray. The function then extends the array pointed at by
parray as necessary to include the element parray[idx]. Each newly allocated element of the array
is initialized to a null pointer. The reference returned is invalid after any other operations on the
object. However, the value of the storage referred to is retained, so that until the next call to copyfmt,
calling pword with the same index yields another reference to the same value. If the function fails302
299) This implies that operations on a standard iostream object can be mixed arbitrarily with operations on the corresponding
stdio stream. In practical terms, synchronization usually means that a standard iostream object and a standard stdio object
share a buﬀer.
300) An implementation is free to implement both the integer array pointed at by iarray and the pointer array pointed at by
parray as sparse data structures, possibly with a one-element cache for each.
301) for example, because it cannot allocate space.
302) for example, because it cannot allocate space.

§ 27.5.3.5

1022

6

7

1

2

1

2

1

2

c(cid:13) ISO/IEC

N4296

and *this is a base subobject of a basic_ios<> object or subobject, the eﬀect is equivalent to calling
basic_ios<>::setstate(badbit) on the derived object (which may throw failure).
Returns: On success parray[idx]. On failure a valid void*& initialized to 0.
Remarks: After a subsequent call to pword(int) for the same object, the earlier return value may no
longer be valid.

27.5.3.6 ios_base callbacks
void register_callback(event_callback fn, int index);

[ios.base.callback]

Eﬀects: Registers the pair (fn,index) such that during calls to imbue() (27.5.3.3), copyfmt(), or
~ios_base() (27.5.3.7), the function fn is called with argument index. Functions registered are called
when an event occurs, in opposite order of registration. Functions registered while a callback function
is active are not called until the next event.
Requires: The function fn shall not throw exceptions.
Remarks: Identical pairs are not merged. A function registered twice will be called twice.

27.5.3.7 ios_base constructors/destructor
ios_base();

[ios.base.cons]

Eﬀects: Each ios_base member has an indeterminate value after construction. The object’s members
shall be initialized by calling basic_ios::init before the object’s ﬁrst use or before it is destroyed,
whichever comes ﬁrst; otherwise the behavior is undeﬁned.

~ios_base();

Eﬀects: Destroys an object of class ios_base. Calls each registered callback pair (fn, index) (27.5.3.6)
as (*fn)(erase_event, *this, index) at such time that any ios_base member function called from
within fn has well deﬁned results.

27.5.4 Class template fpos

[fpos]

namespace std {

template <class stateT> class fpos {
public:

// 27.5.4.1 Members
stateT state() const;
void state(stateT);

private;

stateT st; // exposition only

};

}

27.5.4.1 fpos members
void state(stateT s);

Eﬀects: Assign s to st.

stateT state() const;

Returns: Current value of st.

[fpos.members]

§ 27.5.4.1

1023

N4296

[fpos.operations]

c(cid:13) ISO/IEC

27.5.4.2 fpos requirements

1 Operations speciﬁed in Table 127 are permitted. In that table,

(1.1)

(1.2)

(1.3)

(1.4)

(1.5)

(1.6)

—
—
—
—
—
—

P refers to an instance of fpos,
p and q refer to values of type P,
O refers to type streamoff,
o refers to a value of type streamoff,
sz refers to a value of type streamsize and
i refers to a value of type int.

Table 127 — Position type requirements

Expression

Return type

Operational
semantics

P(i)

P p(i);
P p = i;
P(o)
O(p)
p == q
p != q
q = p + o
p += o
q = p - o
p -= o
o = p - q
streamsize(o)
O(sz)

fpos
streamoﬀ
convertible to bool
convertible to bool
fpos

fpos

streamoﬀ
streamsize
streamoﬀ

converts from offset
converts to offset

!(p == q)
+ oﬀset

- oﬀset

distance
converts
converts

Assertion/note

pre-/post-condition

p == P(i)
note: a destructor is assumed.
post: p == P(i).

P(O(p)) == p
== is an equivalence relation

q - o == p

q + o == p

q + o == p
streamsize(O(sz)) == sz
streamsize(O(sz)) == sz

2

[ Note: Every implementation is required to supply overloaded operators on fpos objects to satisfy the
requirements of 27.5.4.2. It is unspeciﬁed whether these operators are members of fpos, global operators,
or provided in some other way. — end note ]

3 Stream operations that return a value of type traits::pos_type return P(O(-1)) as an invalid value to
signal an error. If this value is used as an argument to any istream, ostream, or streambuf member that
accepts a value of type traits::pos_type then the behavior of that function is undeﬁned.
27.5.5 Class template basic_ios
27.5.5.1 Overview

[ios]
[ios.overview]

namespace std {

template <class charT, class traits = char_traits<charT> >
class basic_ios : public ios_base {
public:

// types:

§ 27.5.5.1

1024

c(cid:13) ISO/IEC

N4296

char_type;
typedef charT
typedef typename traits::int_type int_type;
typedef typename traits::pos_type pos_type;
typedef typename traits::off_type off_type;
typedef traits

traits_type;

explicit operator bool() const;
bool operator!() const;
iostate rdstate() const;
void clear(iostate state = goodbit);
void setstate(iostate state);
bool good() const;
bool eof()
const;
bool fail() const;
bool bad()
const;

iostate exceptions() const;
void exceptions(iostate except);

// 27.5.5.2 Constructor/destructor:
explicit basic_ios(basic_streambuf<charT,traits>* sb);
virtual ~basic_ios();

// 27.5.5.3 Members:
basic_ostream<charT,traits>* tie() const;
basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);

basic_streambuf<charT,traits>* rdbuf() const;
basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);

basic_ios& copyfmt(const basic_ios& rhs);

char_type fill() const;
char_type fill(char_type ch);

locale imbue(const locale& loc);

char
char_type widen(char c) const;

narrow(char_type c, char dfault) const;

basic_ios(const basic_ios&) = delete;
basic_ios& operator=(const basic_ios&) = delete;

protected:

basic_ios();
void init(basic_streambuf<charT,traits>* sb);
void move(basic_ios& rhs);
void move(basic_ios&& rhs);
void swap(basic_ios& rhs) noexcept;
void set_rdbuf(basic_streambuf<charT, traits>* sb);

};

}

27.5.5.2 basic_ios constructors

§ 27.5.5.2

[basic.ios.cons]

1025

1

2

3

1

2

3

4

5

c(cid:13) ISO/IEC

N4296

explicit basic_ios(basic_streambuf<charT,traits>* sb);

Eﬀects: Constructs an object of class basic_ios, assigning initial values to its member objects by
calling init(sb).

basic_ios();

Eﬀects: Constructs an object of class basic_ios (27.5.3.7) leaving its member objects uninitialized.
The object shall be initialized by calling basic_ios::init before its ﬁrst use or before it is destroyed,
whichever comes ﬁrst; otherwise the behavior is undeﬁned.

~basic_ios();

Remarks: The destructor does not destroy rdbuf().

void init(basic_streambuf<charT,traits>* sb);

Postconditions: The postconditions of this function are indicated in Table 128.

Table 128 — basic_ios::init() eﬀects

Element

rdbuf()
tie()
rdstate()

exceptions()
flags()
width()
precision()
fill()
getloc()
iarray
parray

Value

sb
0
goodbit if sb is not a null pointer, otherwise
badbit.
goodbit
skipws | dec
0
6
widen(’ ’);
a copy of the value returned by locale()
a null pointer
a null pointer

27.5.5.3 Member functions
basic_ostream<charT,traits>* tie() const;

[basic.ios.members]

Returns: An output sequence that is tied to (synchronized with) the sequence controlled by the stream
buﬀer.

basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);

Requires: If tiestr is not null, tiestr must not be reachable by traversing the linked list of tied
stream objects starting from tiestr->tie().
Postcondition: tiestr == tie().
Returns: The previous value of tie().

basic_streambuf<charT,traits>* rdbuf() const;

Returns: A pointer to the streambuf associated with the stream.

basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);

§ 27.5.5.3

1026

c(cid:13) ISO/IEC

N4296

6

7

8

9

10

11

12

13

14

15

16

(16.1)
(16.2)

(16.3)

17

18

19

Postcondition: sb == rdbuf().
Eﬀects: Calls clear().
Returns: The previous value of rdbuf().

locale imbue(const locale& loc);

Eﬀects: Calls ios_base::imbue(loc) (27.5.3.3) and if rdbuf()!=0 then rdbuf()->pubimbue(loc)
(27.6.3.2.1).
Returns: The prior value of ios_base::imbue().

char narrow(char_type c, char dfault) const;

Returns: use_facet< ctype<char_type> >(getloc()).narrow(c,dfault)

char_type widen(char c) const;

Returns: use_facet< ctype<char_type> >(getloc()).widen(c)

char_type fill() const;

Returns: The character used to pad (ﬁll) an output conversion to the speciﬁed ﬁeld width.

char_type fill(char_type fillch);

Postcondition: traits::eq(fillch, fill())
Returns: The previous value of fill().

basic_ios& copyfmt(const basic_ios& rhs);

Eﬀects: If (this == &rhs) does nothing. Otherwise assigns to the member objects of *this the
corresponding member objects of rhs as follows:

1. calls each registered callback pair (fn, index) as (*fn)(erase_event, *this, index);
2. assigns to the member objects of *this the corresponding member objects of rhs, except that

—
—

—

rdstate(), rdbuf(), and exceptions() are left unchanged;
the contents of arrays pointed at by pword and iword are copied, not the pointers them-
selves;303 and
if any newly stored pointer values in *this point at objects stored outside the object rhs
and those objects are destroyed when rhs is destroyed, the newly stored pointer values are
altered to point at newly constructed copies of the objects;

3. calls each callback pair that was copied from rhs as (*fn)(copyfmt_event, *this, index);
4. calls exceptions(rhs.except()).

Note: The second pass through the callback pairs permits a copied pword value to be zeroed, or to
have its referent deep copied or reference counted, or to have other special action taken.
Postconditions: The postconditions of this function are indicated in Table 129.
Returns: *this.

void move(basic_ios& rhs);
void move(basic_ios&& rhs);

303) This suggests an inﬁnite amount of copying, but the implementation can keep track of the maximum element of the arrays
that is non-zero.

§ 27.5.5.3

1027

c(cid:13) ISO/IEC

N4296

Table 129 — basic_ios::copyfmt() eﬀects

Element

rdbuf()
tie()
rdstate()
exceptions()
flags()
width()
precision()
fill()
getloc()

Value

unchanged
rhs.tie()
unchanged
rhs.exceptions()
rhs.flags()
rhs.width()
rhs.precision()
rhs.fill()
rhs.getloc()

20

21

22

23

24

25

1

2

3

4

5

Postconditions: *this shall have the state that rhs had before the function call, except that rdbuf()
shall return 0. rhs shall be in a valid but unspeciﬁed state, except that rhs.rdbuf() shall return the
same value as it returned before the function call, and rhs.tie() shall return 0.

void swap(basic_ios& rhs) noexcept;

Eﬀects: The states of *this and rhs shall be exchanged, except that rdbuf() shall return the same
value as it returned before the function call, and rhs.rdbuf() shall return the same value as it returned
before the function call.

void set_rdbuf(basic_streambuf<charT, traits>* sb);

Requires: sb != nullptr.
Eﬀects: Associates the basic_streambuf object pointed to by sb with this stream without calling
clear().
Postconditions: rdbuf() == sb.
Throws: Nothing.

27.5.5.4 basic_ios ﬂags functions
explicit operator bool() const;

Returns: !fail().

bool operator!() const;

Returns: fail().

iostate rdstate() const;

Returns: The error state of the stream buﬀer.

void clear(iostate state = goodbit);

[iostate.ﬂags]

Postcondition: If rdbuf()!=0 then state == rdstate(); otherwise rdstate()==(state | ios_base
::badbit).
badbit)) & exceptions()) == 0, returns. Oth-
Eﬀects: If ((state | (rdbuf() ?
erwise, the function throws an object fail of class basic_ios::failure (27.5.3.1.1), constructed with
implementation-deﬁned argument values.

goodbit :

void setstate(iostate state);

§ 27.5.5.4

1028

6

7

8

9

10

11

12

13

1

2

3

4

5

6

7

8

9

10

c(cid:13) ISO/IEC

N4296

Eﬀects: Calls clear(rdstate() | state) (which may throw basic_ios::failure (27.5.3.1.1)).

bool good() const;

Returns: rdstate() == 0

bool eof() const;

Returns: true if eofbit is set in rdstate().

bool fail() const;

Returns: true if failbit or badbit is set in rdstate().304

bool bad() const;

Returns: true if badbit is set in rdstate().

iostate exceptions() const;

Returns: A mask that determines what elements set in rdstate() cause exceptions to be thrown.

void exceptions(iostate except);

Postcondition: except == exceptions().
Eﬀects: Calls clear(rdstate()).
27.5.6 ios_base manipulators
27.5.6.1 fmtflags manipulators
ios_base& boolalpha(ios_base& str);

Eﬀects: Calls str.setf(ios_base::boolalpha).
Returns: str.

ios_base& noboolalpha(ios_base& str);

Eﬀects: Calls str.unsetf(ios_base::boolalpha).
Returns: str.

ios_base& showbase(ios_base& str);

Eﬀects: Calls str.setf(ios_base::showbase).
Returns: str.

ios_base& noshowbase(ios_base& str);

Eﬀects: Calls str.unsetf(ios_base::showbase).
Returns: str.

ios_base& showpoint(ios_base& str);

Eﬀects: Calls str.setf(ios_base::showpoint).
Returns: str.

ios_base& noshowpoint(ios_base& str);

304) Checking badbit also for fail() is historical practice.

§ 27.5.6.1

[std.ios.manip]
[fmtﬂags.manip]

1029

c(cid:13) ISO/IEC

N4296

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

1

2

3

4

5

6

Eﬀects: Calls str.unsetf(ios_base::showpoint).
Returns: str.

ios_base& showpos(ios_base& str);

Eﬀects: Calls str.setf(ios_base::showpos).
Returns: str.

ios_base& noshowpos(ios_base& str);

Eﬀects: Calls str.unsetf(ios_base::showpos).
Returns: str.

ios_base& skipws(ios_base& str);

Eﬀects: Calls str.setf(ios_base::skipws).
Returns: str.

ios_base& noskipws(ios_base& str);

Eﬀects: Calls str.unsetf(ios_base::skipws).
Returns: str.

ios_base& uppercase(ios_base& str);

Eﬀects: Calls str.setf(ios_base::uppercase).
Returns: str.

ios_base& nouppercase(ios_base& str);

Eﬀects: Calls str.unsetf(ios_base::uppercase).
Returns: str.

ios_base& unitbuf(ios_base& str);

Eﬀects: Calls str.setf(ios_base::unitbuf).
Returns: str.

ios_base& nounitbuf(ios_base& str);

Eﬀects: Calls str.unsetf(ios_base::unitbuf).
Returns: str.

27.5.6.2 adjustfield manipulators
ios_base& internal(ios_base& str);

[adjustﬁeld.manip]

Eﬀects: Calls str.setf(ios_base::internal, ios_base::adjustfield).
Returns: str.

ios_base& left(ios_base& str);

Eﬀects: Calls str.setf(ios_base::left, ios_base::adjustfield).
Returns: str.

ios_base& right(ios_base& str);

Eﬀects: Calls str.setf(ios_base::right, ios_base::adjustfield).
Returns: str.

§ 27.5.6.2

1030

c(cid:13) ISO/IEC

27.5.6.3 basefield manipulators
ios_base& dec(ios_base& str);

Eﬀects: Calls str.setf(ios_base::dec, ios_base::basefield).
Returns: str305.

ios_base& hex(ios_base& str);

Eﬀects: Calls str.setf(ios_base::hex, ios_base::basefield).
Returns: str.

ios_base& oct(ios_base& str);

Eﬀects: Calls str.setf(ios_base::oct, ios_base::basefield).
Returns: str.

27.5.6.4 floatfield manipulators
ios_base& fixed(ios_base& str);

Eﬀects: Calls str.setf(ios_base::fixed, ios_base::floatfield).
Returns: str.

ios_base& scientific(ios_base& str);

Eﬀects: Calls str.setf(ios_base::scientific, ios_base::floatfield).
Returns: str.

N4296

[baseﬁeld.manip]

[ﬂoatﬁeld.manip]

ios_base& hexfloat(ios_base& str);

Eﬀects: Calls str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield).
Returns: str.

[ Note: The more obvious use of ios_base::hex to specify hexadecimal ﬂoating-point format would change
the meaning of existing well deﬁned programs. C++2003 gives no meaning to the combination of fixed
and scientific. — end note ]

ios_base& defaultfloat(ios_base& str);

Eﬀects: Calls str.unsetf(ios_base::floatfield).
Returns: str.

27.5.6.5 Error reporting
error_code make_error_code(io_errc e) noexcept;

Returns: error_code(static_cast<int>(e), iostream_category()).

error_condition make_error_condition(io_errc e) noexcept;

Returns: error_condition(static_cast<int>(e), iostream_category()).

const error_category& iostream_category() noexcept;

[error.reporting]

1

2

3

4

5

6

1

2

3

4

5

6

7

8

9

1

2

function

signature

305) The
basic_ostream&
stream::operator<<(ios_base& (*)(ios_base&)) to permit expressions of the form cout <<dec to change the format
ﬂags stored in cout.

dec(ios_base&)

signature

be

called

the

function

can

by

§ 27.5.6.5

1031

c(cid:13) ISO/IEC

N4296

3

4

Returns: A reference to an object of a type derived from class error_category.
The object’s default_error_condition and equivalent virtual functions shall behave as speciﬁed
for the class error_category. The object’s name virtual function shall return a pointer to the string
"iostream".

27.6 Stream buﬀers
27.6.1 Overview
Header <streambuf> synopsis

[stream.buﬀers]
[stream.buﬀers.overview]

namespace std {

template <class charT, class traits = char_traits<charT> >

class basic_streambuf;

typedef basic_streambuf<char>
streambuf;
typedef basic_streambuf<wchar_t> wstreambuf;

}

1 The header <streambuf> deﬁnes types that control input from and output to character sequences.

27.6.2 Stream buﬀer requirements

[streambuf.reqts]

1 Stream buﬀers can impose various constraints on the sequences they control. Some constraints are:

(1.1)

(1.2)

(1.3)

(1.4)

(1.5)

—
—
—

—
—

The controlled input sequence can be not readable.
The controlled output sequence can be not writable.
The controlled sequences can be associated with the contents of other representations for character
sequences, such as external ﬁles.
The controlled sequences can support operations directly to or from associated sequences.
The controlled sequences can impose limitations on how the program can read characters from a
sequence, write characters to a sequence, put characters back into an input sequence, or alter the
stream position.

2 Each sequence is characterized by three pointers which, if non-null, all point into the same charT array object.
The array object represents, at any moment, a (sub)sequence of characters from the sequence. Operations
performed on a sequence alter the values stored in these pointers, perform reads and writes directly to or
from associated sequences, and alter “the stream position” and conversion state as needed to maintain this
subsequence relationship. The three pointers are:

(2.1)

(2.2)

(2.3)

—
—

—

the beginning pointer, or lowest element address in the array (called xbeg here);
the next pointer, or next element address that is a current candidate for reading or writing (called
xnext here);
the end pointer, or ﬁrst element address beyond the end of the array (called xend here).

3 The following semantic constraints shall always apply for any set of three pointers for a sequence, using the

pointer names given immediately above:

(3.1)

—

If xnext is not a null pointer, then xbeg and xend shall also be non-null pointers into the same charT
array, as described above; otherwise, xbeg and xend shall also be null.

§ 27.6.2

1032

c(cid:13) ISO/IEC

N4296

(3.2)

(3.3)

(3.4)

—

—

—

If xnext is not a null pointer and xnext < xend for an output sequence, then a write position is
available. In this case, *xnext shall be assignable as the next element to write (to put, or to store a
character value, into the sequence).
If xnext is not a null pointer and xbeg < xnext for an input sequence, then a putback position is
available. In this case, xnext[-1] shall have a deﬁned value and is the next (preceding) element to
store a character that is put back into the input sequence.
If xnext is not a null pointer and xnext < xend for an input sequence, then a read position is available.
In this case, *xnext shall have a deﬁned value and is the next element to read (to get, or to obtain a
character value, from the sequence).

27.6.3 Class template basic_streambuf<charT,traits>

[streambuf]

namespace std {

template <class charT, class traits = char_traits<charT> >
class basic_streambuf {
public:

// types:
typedef charT
char_type;
typedef typename traits::int_type int_type;
typedef typename traits::pos_type pos_type;
typedef typename traits::off_type off_type;
typedef traits

traits_type;

virtual ~basic_streambuf();

// 27.6.3.2.1 locales:
locale
locale

pubimbue(const locale& loc);
getloc() const;

// 27.6.3.2.2 buﬀer and positioning:
basic_streambuf<char_type,traits>*

pubsetbuf(char_type* s, streamsize n);

pos_type pubseekoff(off_type off, ios_base::seekdir way,

ios_base::openmode which =

ios_base::in | ios_base::out);

pos_type pubseekpos(pos_type sp,

ios_base::openmode which =

ios_base::in | ios_base::out);

int

pubsync();

// Get and put areas:
// 27.6.3.2.3 Get area:
streamsize in_avail();
int_type snextc();
int_type sbumpc();
int_type sgetc();
streamsize sgetn(char_type* s, streamsize n);

// 27.6.3.2.4 Putback:
int_type sputbackc(char_type c);
int_type sungetc();

// 27.6.3.2.5 Put area:

§ 27.6.3

1033

c(cid:13) ISO/IEC

N4296

int_type
streamsize sputn(const char_type* s, streamsize n);

sputc(char_type c);

protected:

basic_streambuf();
basic_streambuf(const basic_streambuf& rhs);
basic_streambuf& operator=(const basic_streambuf& rhs);

void swap(basic_streambuf& rhs);

// 27.6.3.3.2 Get area:
char_type* eback() const;
char_type* gptr()
const;
char_type* egptr() const;
void
gbump(int n);
setg(char_type* gbeg, char_type* gnext, char_type* gend);
void

// 27.6.3.3.3 Put area:
char_type* pbase() const;
char_type* pptr() const;
char_type* epptr() const;
pbump(int n);
void
void
setp(char_type* pbeg, char_type* pend);

// 27.6.3.4 virtual functions:
// 27.6.3.4.1 Locales:
virtual void imbue(const locale& loc);

// 27.6.3.4.2 Buﬀer management and positioning:
virtual basic_streambuf<char_type,traits>*

setbuf(char_type* s, streamsize n);

virtual pos_type seekoff(off_type off, ios_base::seekdir way,
ios_base::openmode which = ios_base::in | ios_base::out);

virtual pos_type seekpos(pos_type sp,

ios_base::openmode which = ios_base::in | ios_base::out);

virtual int

sync();

// 27.6.3.4.3 Get area:
virtual streamsize showmanyc();
virtual streamsize xsgetn(char_type* s, streamsize n);
virtual int_type
virtual int_type

underflow();
uflow();

// 27.6.3.4.4 Putback:
virtual int_type

pbackfail(int_type c = traits::eof());

// 27.6.3.4.5 Put area:
virtual streamsize xsputn(const char_type* s, streamsize n);
virtual int_type

overflow (int_type c = traits::eof());

};

}

1 The class template basic_streambuf<charT,traits> serves as an abstract base class for deriving various

stream buﬀers whose objects each control two character sequences:

(1.1)

—

a character input sequence;

§ 27.6.3

1034

c(cid:13) ISO/IEC

(1.2)

—

a character output sequence.

27.6.3.1 basic_streambuf constructors
basic_streambuf();

N4296

[streambuf.cons]

1

(1.1)

(1.2)

2

3

4
(4.1)

(4.2)

(4.3)

(4.4)

(4.5)

(4.6)

(4.7)

5

1

2

3

4

all its pointer member objects to null pointers,
the getloc() member to a copy the global locale, locale(), at the time of construction.

Eﬀects: Constructs an object of class basic_streambuf<charT,traits> and initializes:306
—
—
Remarks: Once the getloc() member is initialized, results of calling locale member functions, and of
members of facets so obtained, can safely be cached until the next time the member imbue is called.

basic_streambuf(const basic_streambuf& rhs);

Eﬀects: Constructs a copy of rhs.
Postconditions:
—
—
—
—
—
—
—

eback() == rhs.eback()
gptr() == rhs.gptr()
egptr() == rhs.egptr()
pbase() == rhs.pbase()
pptr() == rhs.pptr()
epptr() == rhs.epptr()
getloc() == rhs.getloc()

~basic_streambuf();
Eﬀects: None.

27.6.3.2 basic_streambuf public member functions
27.6.3.2.1 Locales
locale pubimbue(const locale& loc);

Postcondition: loc == getloc().
Eﬀects: Calls imbue(loc).
Returns: Previous value of getloc().

locale getloc() const;

[streambuf.members]
[streambuf.locales]

Returns: If pubimbue() has ever been called, then the last value of loc supplied, otherwise the current
global locale, locale(), in eﬀect at the time of construction. If called after pubimbue() has been called
but before pubimbue has returned (i.e., from within the call of imbue()) then it returns the previous
value.

306) The default constructor is protected for class basic_streambuf to assure that only objects for classes derived from this
class may be constructed.

§ 27.6.3.2.1

1035

c(cid:13) ISO/IEC

N4296

27.6.3.2.2 Buﬀer management and positioning
basic_streambuf<char_type,traits>* pubsetbuf(char_type* s, streamsize n);

[streambuf.buﬀer]

Returns: setbuf(s, n).

pos_type pubseekoff(off_type off, ios_base::seekdir way,

ios_base::openmode which = ios_base::in | ios_base::out);

Returns: seekoff(off, way, which).

pos_type pubseekpos(pos_type sp,

ios_base::openmode which = ios_base::in | ios_base::out);

Returns: seekpos(sp, which).

int pubsync();

Returns: sync().
27.6.3.2.3 Get area
streamsize in_avail();

[streambuf.pub.get]

Returns: If a read position is available, returns egptr() - gptr(). Otherwise returns showmanyc()
(27.6.3.4.3).

int_type snextc();

Eﬀects: Calls sbumpc().
Returns: If that function returns traits::eof(), returns traits::eof(). Otherwise, returns sgetc().

int_type sbumpc();

Returns: If the input sequence read position is not available, returns uflow(). Otherwise, returns
traits::to_int_type(*gptr()) and increments the next pointer for the input sequence.

int_type sgetc();

Returns: If the input sequence read position is not available, returns underflow(). Otherwise, returns
traits::to_int_type(*gptr()).

streamsize sgetn(char_type* s, streamsize n);

Returns: xsgetn(s, n).

27.6.3.2.4 Putback
int_type sputbackc(char_type c);

[streambuf.pub.pback]

Returns: If the input sequence putback position is not available, or if traits::eq(c,gptr()[-1]) is
false, returns pbackfail(traits::to_int_type(c)). Otherwise, decrements the next pointer for the
input sequence and returns traits::to_int_type(*gptr()).

int_type sungetc();

Returns: If the input sequence putback position is not available, returns pbackfail(). Otherwise,
decrements the next pointer for the input sequence and returns traits::to_int_type(*gptr()).

§ 27.6.3.2.4

1036

1

2

3

4

1

2

3

4

5

6

1

2

c(cid:13) ISO/IEC

27.6.3.2.5 Put area
int_type sputc(char_type c);

N4296

[streambuf.pub.put]

Returns: If the output sequence write position is not available, returns overflow(traits::to_int_-
type(c)). Otherwise, stores c at the next pointer for the output sequence, increments the pointer,
and returns traits::to_int_type(c).

streamsize sputn(const char_type* s, streamsize n);

Returns: xsputn(s,n).

27.6.3.3 basic_streambuf protected member functions
27.6.3.3.1 Assignment
basic_streambuf& operator=(const basic_streambuf& rhs);

Eﬀects: Assigns the data members of rhs to *this.
Postconditions:
—
—
—
—
—
—
—
Returns: *this.

eback() == rhs.eback()
gptr() == rhs.gptr()
egptr() == rhs.egptr()
pbase() == rhs.pbase()
pptr() == rhs.pptr()
epptr() == rhs.epptr()
getloc() == rhs.getloc()

void swap(basic_streambuf& rhs);

Eﬀects: Swaps the data members of rhs and *this.

27.6.3.3.2 Get area access
char_type* eback() const;

Returns: The beginning pointer for the input sequence.

char_type* gptr() const;

Returns: The next pointer for the input sequence.

char_type* egptr() const;

Returns: The end pointer for the input sequence.

void gbump(int n);

Eﬀects: Adds n to the next pointer for the input sequence.

[streambuf.protected]
[streambuf.assign]

[streambuf.get.area]

void setg(char_type* gbeg, char_type* gnext, char_type* gend);

Postconditions: gbeg == eback(), gnext == gptr(), and gend == egptr().

§ 27.6.3.3.2

1037

1

2

1

2
(2.1)

(2.2)

(2.3)

(2.4)

(2.5)

(2.6)

(2.7)
3

4

1

2

3

4

5

N4296

[streambuf.put.area]

c(cid:13) ISO/IEC

27.6.3.3.3 Put area access
char_type* pbase() const;

Returns: The beginning pointer for the output sequence.

char_type* pptr() const;

Returns: The next pointer for the output sequence.

char_type* epptr() const;

Returns: The end pointer for the output sequence.

void pbump(int n);

Eﬀects: Adds n to the next pointer for the output sequence.

void setp(char_type* pbeg, char_type* pend);

Postconditions: pbeg == pbase(), pbeg == pptr(), and pend == epptr().

27.6.3.4 basic_streambuf virtual functions
27.6.3.4.1 Locales
void imbue(const locale&);

[streambuf.virtuals]
[streambuf.virt.locales]

Eﬀects: Change any translations based on locale.
Remarks: Allows the derived class to be informed of changes in locale at the time they occur. Between
invocations of this function a class derived from streambuf can safely cache results of calls to locale
functions and to members of facets so obtained.
Default behavior: Does nothing.

27.6.3.4.2 Buﬀer management and positioning
basic_streambuf* setbuf(char_type* s, streamsize n);

[streambuf.virt.buﬀer]

Eﬀects: Inﬂuences stream buﬀering in a way that is deﬁned separately for each class derived from
basic_streambuf in this Clause (27.8.2.4, 27.9.1.5).
Default behavior: Does nothing. Returns this.

pos_type seekoff(off_type off, ios_base::seekdir way,

ios_base::openmode which
= ios_base::in | ios_base::out);

Eﬀects: Alters the stream positions within one or more of the controlled sequences in a way that is
deﬁned separately for each class derived from basic_streambuf in this Clause (27.8.2.4, 27.9.1.5).
Default behavior: Returns pos_type(off_type(-1)).

pos_type seekpos(pos_type sp,

ios_base::openmode which
= ios_base::in | ios_base::out);

Eﬀects: Alters the stream positions within one or more of the controlled sequences in a way that is
deﬁned separately for each class derived from basic_streambuf in this Clause (27.8.2, 27.9.1.1).
Default behavior: Returns pos_type(off_type(-1)).

int sync();

§ 27.6.3.4.2

1038

1

2

3

4

5

1

2

3

1

2

3

4

5

6

c(cid:13) ISO/IEC

N4296

7

8

9

1

2

3

4

5

6

7

8

9

10

11

Eﬀects: Synchronizes the controlled sequences with the arrays. That is, if pbase() is non-null the
characters between pbase() and pptr() are written to the controlled sequence. The pointers may
then be reset as appropriate.
Returns:-1 on failure. What constitutes failure is determined by each derived class (27.9.1.5).
Default behavior: Returns zero.

27.6.3.4.3 Get area
streamsize showmanyc();307

[streambuf.virt.get]

Returns: An estimate of the number of characters available in the sequence, or -1.
If it returns a
positive value, then successive calls to underflow() will not return traits::eof() until at least that
number of characters have been extracted from the stream. If showmanyc() returns -1, then calls to
underflow() or uflow() will fail.308
Default behavior: Returns zero.
Remarks: Uses traits::eof().

streamsize xsgetn(char_type* s, streamsize n);

Eﬀects: Assigns up to n characters to successive elements of the array whose ﬁrst element is designated
by s. The characters assigned are read from the input sequence as if by repeated calls to sbumpc().
Assigning stops when either n characters have been assigned or a call to sbumpc() would return
traits::eof().
Returns: The number of characters assigned.309
Remarks: Uses traits::eof().

int_type underflow();

Remarks: The public members of basic_streambuf call this virtual function only if gptr() is null or
gptr() >= egptr()
Returns: traits::to_int_type(c), where c is the ﬁrst character of the pending sequence, without
moving the input sequence position past it. If the pending sequence is null then the function returns
traits::eof() to indicate failure.
The pending sequence of characters is deﬁned as the concatenation of:

a) If gptr() is non-null, then the egptr() - gptr() characters starting at gptr(), otherwise the

empty sequence.

b) Some sequence (possibly empty) of characters read from the input sequence.

The result character is

a) If the pending sequence is non-empty, the ﬁrst character of the sequence.
b) If the pending sequence is empty then the next character that would be read from the input

sequence.

The backup sequence is deﬁned as the concatenation of:

307) The morphemes of showmanyc are “es-how-many-see”, not “show-manic”.
308) underflow or uflow might fail by throwing an exception prematurely. The intention is not only that the calls will not
return eof() but that they will return “immediately.”
309) Classes derived from basic_streambuf can provide more eﬃcient ways to implement xsgetn() and xsputn() by overriding
these deﬁnitions from the base class.

§ 27.6.3.4.3

1039

c(cid:13) ISO/IEC

N4296

a) If eback() is null then empty,
b) Otherwise the gptr() - eback() characters beginning at eback().
Eﬀects: The function sets up the gptr() and egptr() satisfying one of:

a) If the pending sequence is non-empty, egptr() is non-null and egptr() - gptr() characters

starting at gptr() are the characters in the pending sequence

b) If the pending sequence is empty, either gptr() is null or gptr() and egptr() are set to the

same non-null pointer value.

If eback() and gptr() are non-null then the function is not constrained as to their contents, but the
“usual backup condition” is that either:

a) If the backup sequence contains at least gptr() - eback() characters, then the gptr() - eback()
characters starting at eback() agree with the last gptr() - eback() characters of the backup
sequence.

b) Or the n characters starting at gptr() - n agree with the backup sequence (where n is the length

of the backup sequence)

Default behavior: Returns traits::eof().

int_type uflow();

Requires: The constraints are the same as for underflow(), except that the result character shall be
transferred from the pending sequence to the backup sequence, and the pending sequence shall not be
empty before the transfer.
Default behavior: Calls underflow(). If underflow() returns traits::eof(), returns traits::eof().
Otherwise, returns the value of traits::to_int_type(*gptr()) and increment the value of the next
pointer for the input sequence.
Returns: traits::eof() to indicate failure.

27.6.3.4.4 Putback
int_type pbackfail(int_type c = traits::eof());

[streambuf.virt.pback]

Remarks: The public functions of basic_streambuf call this virtual function only when gptr() is
null, gptr() == eback(), or traits::eq(traits::to_char_type(c),gptr()[-1]) returns false.
Other calls shall also satisfy that constraint.
The pending sequence is deﬁned as for underflow(), with the modiﬁcations that
—

If traits::eq_int_type(c,traits::eof()) returns true, then the input sequence is backed up
one character before the pending sequence is determined.
If traits::eq_int_type(c,traits::eof()) returns false, then c is prepended. Whether the
input sequence is backed up or modiﬁed in any other way is unspeciﬁed.

—

Postcondition: On return, the constraints of gptr(), eback(), and pptr() are the same as for
underflow().
Returns: traits::eof() to indicate failure. Failure may occur because the input sequence could not
be backed up, or if for some other reason the pointers could not be set consistent with the constraints.
pbackfail() is called only when put back has really failed.
Returns some value other than traits::eof() to indicate success.
Default behavior: Returns traits::eof().

§ 27.6.3.4.4

1040

12

13

14

15

16

17

1

(1.1)

(1.2)

2

3

4

5

c(cid:13) ISO/IEC

27.6.3.4.5 Put area
streamsize xsputn(const char_type* s, streamsize n);

N4296

[streambuf.virt.put]

1

2

3

4

5

6

7

Eﬀects: Writes up to n characters to the output sequence as if by repeated calls to sputc(c). The
characters written are obtained from successive elements of the array whose ﬁrst element is designated
by s. Writing stops when either n characters have been written or a call to sputc(c) would return
traits::eof(). Is is unspeciﬁed whether the function calls overflow() when pptr() == epptr()
becomes true or whether it achieves the same eﬀects by other means.
Returns: The number of characters written.

int_type overflow(int_type c = traits::eof());

Eﬀects: Consumes some initial subsequence of the characters of the pending sequence. The pending
sequence is deﬁned as the concatenation of

a) if pbase() is null then the empty sequence otherwise, pptr() - pbase() characters beginning

at pbase().

b) if traits::eq_int_type(c,traits::eof()) returns true, then the empty sequence otherwise,

the sequence consisting of c.

Remarks: The member functions sputc() and sputn() call this function in case that no room can be
found in the put buﬀer enough to accommodate the argument character sequence.
Requires: Every overriding deﬁnition of this virtual function shall obey the following constraints:

1) The eﬀect of consuming a character on the associated output sequence is speciﬁed310
2) Let r be the number of characters in the pending sequence not consumed. If r is non-zero then
pbase() and pptr() shall be set so that: pptr() - pbase() == r and the r characters starting
at pbase() are the associated output stream. In case r is zero (all characters of the pending
sequence have been consumed) then either pbase() is set to nullptr, or pbase() and pptr()
are both set to the same non-null value.

3) The function may fail if either appending some character to the associated output stream fails or

if it is unable to establish pbase() and pptr() according to the above rules.

Returns: traits::eof() or throws an exception if the function fails.
Otherwise, returns some value other than traits::eof() to indicate success.311
Default behavior: Returns traits::eof().

27.7 Formatting and manipulators
27.7.1 Overview
Header <istream> synopsis

[iostream.format]
[iostream.format.overview]

namespace std {

template <class charT, class traits = char_traits<charT> >

class basic_istream;

typedef basic_istream<char>
istream;
typedef basic_istream<wchar_t> wistream;

310) That is, for each class derived from an instance of basic_streambuf in this Clause (27.8.2, 27.9.1.1), a speciﬁcation of how
consuming a character eﬀects the associated output sequence is given. There is no requirement on a program-deﬁned class.
311) Typically, overflow returns c to indicate success, except when traits::eq_int_type(c,traits::eof()) returns true, in
which case it returns traits::not_eof(c).

§ 27.7.1

1041

c(cid:13) ISO/IEC

N4296

template <class charT, class traits = char_traits<charT> >

class basic_iostream;

typedef basic_iostream<char>
iostream;
typedef basic_iostream<wchar_t> wiostream;

template <class charT, class traits>

basic_istream<charT,traits>& ws(basic_istream<charT,traits>& is);

template <class charT, class traits, class T>

basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>&& is, T& x);

}

Header <ostream> synopsis

namespace std {

template <class charT, class traits = char_traits<charT> >

class basic_ostream;

typedef basic_ostream<char>
ostream;
typedef basic_ostream<wchar_t> wostream;

template <class charT, class traits>

basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);

template <class charT, class traits>

basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);

template <class charT, class traits>

basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);

template <class charT, class traits, class T>

basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>&& os, const T& x);

}

Header <iomanip> synopsis

namespace std {

// types T1, T2, ... are unspeciﬁed implementation types
T1 resetiosflags(ios_base::fmtflags mask);
T2 setiosflags
(ios_base::fmtflags mask);
T3 setbase(int base);
template<charT> T4 setfill(charT c);
T5 setprecision(int n);
T6 setw(int n);
template <class moneyT> T7 get_money(moneyT& mon, bool intl = false);
template <class moneyT> T8 put_money(const moneyT& mon, bool intl = false);
template <class charT> T9 get_time(struct tm* tmb, const charT* fmt);
template <class charT> T10 put_time(const struct tm* tmb, const charT* fmt);

template <class charT>

T11 quoted(const charT* s, charT delim=charT(’"’), charT escape=charT(’\\’));

template <class charT, class traits, class Allocator>

T12 quoted(const basic_string<charT, traits, Allocator>& s,

charT delim=charT(’"’), charT escape=charT(’\\’));

template <class charT, class traits, class Allocator>

§ 27.7.1

1042

c(cid:13) ISO/IEC

N4296

T13 quoted(basic_string<charT, traits, Allocator>& s,

charT delim=charT(’"’), charT escape=charT(’\\’));

}

27.7.2

[input.streams]
1 The header <istream> deﬁnes two types and a function signature that control input from a stream buﬀer

Input streams

[istream]

along with a function template that extracts from stream rvalues.
27.7.2.1 Class template basic_istream

namespace std {

template <class charT, class traits = char_traits<charT> >
class basic_istream : virtual public basic_ios<charT,traits> {
public:

// types (inherited from basic_ios (27.5.5)):
typedef charT
char_type;
typedef typename traits::int_type int_type;
typedef typename traits::pos_type pos_type;
typedef typename traits::off_type off_type;
typedef traits

traits_type;

// 27.7.2.1.1 Constructor/destructor:
explicit basic_istream(basic_streambuf<charT,traits>* sb);
virtual ~basic_istream();

// 27.7.2.1.3 Preﬁx/suﬃx:
class sentry;

// 27.7.2.2 Formatted input:
basic_istream<charT,traits>& operator>>(

basic_istream<charT,traits>& (*pf)(basic_istream<charT,traits>&));

basic_istream<charT,traits>& operator>>(

basic_ios<charT,traits>& (*pf)(basic_ios<charT,traits>&));

basic_istream<charT,traits>& operator>>(

ios_base& (*pf)(ios_base&));

basic_istream<charT,traits>& operator>>(bool& n);
basic_istream<charT,traits>& operator>>(short& n);
basic_istream<charT,traits>& operator>>(unsigned short& n);
basic_istream<charT,traits>& operator>>(int& n);
basic_istream<charT,traits>& operator>>(unsigned int& n);
basic_istream<charT,traits>& operator>>(long& n);
basic_istream<charT,traits>& operator>>(unsigned long& n);
basic_istream<charT,traits>& operator>>(long long& n);
basic_istream<charT,traits>& operator>>(unsigned long long& n);
basic_istream<charT,traits>& operator>>(float& f);
basic_istream<charT,traits>& operator>>(double& f);
basic_istream<charT,traits>& operator>>(long double& f);

basic_istream<charT,traits>& operator>>(void*& p);
basic_istream<charT,traits>& operator>>(
basic_streambuf<char_type,traits>* sb);

// 27.7.2.3 Unformatted input:
streamsize gcount() const;

§ 27.7.2.1

1043

c(cid:13) ISO/IEC

N4296

int_type get();
basic_istream<charT,traits>& get(char_type& c);
basic_istream<charT,traits>& get(char_type* s, streamsize n);
basic_istream<charT,traits>& get(char_type* s, streamsize n,

basic_istream<charT,traits>& get(basic_streambuf<char_type,traits>& sb);
basic_istream<charT,traits>& get(basic_streambuf<char_type,traits>& sb,

char_type delim);

char_type delim);

basic_istream<charT,traits>& getline(char_type* s, streamsize n);
basic_istream<charT,traits>& getline(char_type* s, streamsize n,

char_type delim);

basic_istream<charT,traits>& ignore(

streamsize n = 1, int_type delim = traits::eof());

int_type
basic_istream<charT,traits>& read
streamsize

peek();

(char_type* s, streamsize n);
readsome(char_type* s, streamsize n);

basic_istream<charT,traits>& putback(char_type c);
basic_istream<charT,traits>& unget();
int sync();

pos_type tellg();
basic_istream<charT,traits>& seekg(pos_type);
basic_istream<charT,traits>& seekg(off_type, ios_base::seekdir);

protected:

basic_istream(const basic_istream& rhs) = delete;
basic_istream(basic_istream&& rhs);

// 27.7.2.1.2 Assign/swap:
basic_istream& operator=(const basic_istream& rhs) = delete;
basic_istream& operator=(basic_istream&& rhs);
void swap(basic_istream& rhs);

};

// 27.7.2.2.3 character extraction templates:
template<class charT, class traits>

basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&,

basic_istream<char,traits>& operator>>(basic_istream<char,traits>&,

template<class traits>

template<class traits>

basic_istream<char,traits>& operator>>(basic_istream<char,traits>&,

template<class charT, class traits>

basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&,

template<class traits>

basic_istream<char,traits>& operator>>(basic_istream<char,traits>&,

charT&);

unsigned char&);

signed char&);

charT*);

unsigned char*);

template<class traits>

§ 27.7.2.1

1044

c(cid:13) ISO/IEC

N4296

basic_istream<char,traits>& operator>>(basic_istream<char,traits>&,

signed char*);

}

1 The class basic_istream deﬁnes a number of member function signatures that assist in reading and inter-

preting input from sequences controlled by a stream buﬀer.

3

4

2 Two groups of member function signatures share common properties: the formatted input functions (or
extractors) and the unformatted input functions. Both groups of input functions are described as if they
obtain (or extract) input characters by calling rdbuf()->sbumpc() or rdbuf()->sgetc(). They may use
other public members of istream.
If rdbuf()->sbumpc() or rdbuf()->sgetc() returns traits::eof(), then the input function, except as
explicitly noted otherwise, completes its actions and does setstate(eofbit), which may throw ios_-
base::failure (27.5.5.4), before returning.
If one of these called functions throws an exception, then unless explicitly noted otherwise, the input function
sets badbit in error state.
If badbit is on in exceptions(), the input function rethrows the exception
without completing its actions, otherwise it does not throw anything and proceeds as if the called function
had returned a failure indication.
27.7.2.1.1 basic_istream constructors
explicit basic_istream(basic_streambuf<charT,traits>* sb);

[istream.cons]

1

2

3

4

5

1

2

3

Eﬀects: Constructs an object of class basic_istream, assigning initial values to the base class by
calling basic_ios::init(sb) (27.5.5.2).
Postcondition: gcount() == 0

basic_istream(basic_istream&& rhs);

Eﬀects: Move constructs from the rvalue rhs. This is accomplished by default constructing the base
class, copying the gcount() from rhs, calling basic_ios<charT, traits>::move(rhs) to initialize
the base class, and setting the gcount() for rhs to 0.

virtual ~basic_istream();

Eﬀects: Destroys an object of class basic_istream.
Remarks: Does not perform any operations of rdbuf().

27.7.2.1.2 Class basic_istream assign and swap
basic_istream& operator=(basic_istream&& rhs);

Eﬀects: swap(rhs);.
Returns: *this.

void swap(basic_istream& rhs);

[istream.assign]

Eﬀects: Calls basic_ios<charT, traits>::swap(rhs). Exchanges the values returned by gcount()
and rhs.gcount().

27.7.2.1.3 Class basic_istream::sentry

[istream::sentry]

namespace std {

template <class charT,class traits = char_traits<charT> >
class basic_istream<charT,traits>::sentry {

typedef traits traits_type;
bool ok_; // exposition only

§ 27.7.2.1.3

1045

c(cid:13) ISO/IEC

N4296

explicit sentry(basic_istream<charT,traits>& is, bool noskipws = false);
~sentry();
explicit operator bool() const { return ok_; }
sentry(const sentry&) = delete;
sentry& operator=(const sentry&) = delete;

public:

};

}

1

2

3

4

5

6

7

The class sentry deﬁnes a class that is responsible for doing exception safe preﬁx and suﬃx operations.

explicit sentry(basic_istream<charT,traits>& is, bool noskipws = false);

Eﬀects: If is.good() is false, calls is.setstate(failbit). Otherwise, prepares for formatted or
unformatted input. First, if is.tie() is not a null pointer, the function calls is.tie()->flush()
to synchronize the output sequence with any associated external C stream. Except that this call can
be suppressed if the put area of is.tie() is empty. Further an implementation is allowed to defer
the call to flush until a call of is.rdbuf()->underflow() occurs. If no such call occurs before the
sentry object is destroyed, the call to flush may be eliminated entirely.312 If noskipws is zero and
is.flags() & ios_base::skipws is nonzero, the function extracts and discards each character as
long as the next available input character c is a whitespace character.
If is.rdbuf()->sbumpc()
or is.rdbuf()->sgetc() returns traits::eof(), the function calls setstate(failbit | eofbit)
(which may throw ios_base::failure).
Remarks: The constructor explicit sentry(basic_istream<charT,traits>& is, bool noskipws
= false) uses the currently imbued locale in is, to determine whether the next input character is
whitespace or not.
To decide if the character c is a whitespace character, the constructor performs as if it executes the
following code fragment:

const ctype<charT>& ctype = use_facet<ctype<charT> >(is.getloc());
if (ctype.is(ctype.space,c)!=0)

// c is a whitespace character.

If, after any preparation is completed, is.good() is true, ok_ != false otherwise, ok_ == false.
During preparation, the constructor may call setstate(failbit) (which may throw ios_base::
failure (27.5.5.4))313

~sentry();

Eﬀects: None.

explicit operator bool() const;

Eﬀects: Returns ok_.

27.7.2.2 Formatted input functions
27.7.2.2.1 Common requirements

[istream.formatted]
[istream.formatted.reqmts]
1 Each formatted input function begins execution by constructing an object of class sentry with the noskipws
(second) argument false. If the sentry object returns true, when converted to a value of type bool, the
function endeavors to obtain the requested input. If an exception is thrown during input then ios::badbit
312) This will be possible only in functions that are part of the library. The semantics of the constructor used in user code is
as speciﬁed.
313) The sentry constructor and destructor can also perform additional implementation-dependent operations.

§ 27.7.2.2.1

1046

c(cid:13) ISO/IEC

N4296

is turned on314 in *this’s error state. If (exceptions()&badbit) != 0 then the exception is rethrown.
In any case, the formatted input function destroys the sentry object. If no exception has been thrown, it
returns *this.
27.7.2.2.2 Arithmetic extractors
operator>>(unsigned short& val);
operator>>(unsigned int& val);
operator>>(long& val);
operator>>(unsigned long& val);
operator>>(long long& val);
operator>>(unsigned long long& val);
operator>>(float& val);
operator>>(double& val);
operator>>(long double& val);
operator>>(bool& val);
operator>>(void*& val);

[istream.formatted.arithmetic]

As in the case of the inserters, these extractors depend on the locale’s num_get<> (22.4.2.1) object
to perform parsing the input stream data. These extractors behave as formatted input functions (as
described in 27.7.2.2.1). After a sentry object is constructed, the conversion occurs as if performed by
the following code fragment:

typedef num_get< charT,istreambuf_iterator<charT,traits> > numget;
iostate err = iostate::goodbit;
use_facet< numget >(loc).get(*this, 0, *this, err, val);
setstate(err);

[ Note: The ﬁrst
In the above fragment, loc stands for the private member of the basic_ios class.
argument provides an object of the istreambuf_iterator class which is an iterator pointed to an
input stream. It bypasses istreams and uses streambufs directly. — end note ] Class locale relies on
this type as its interface to istream, so that it does not need to depend directly on istream.

operator>>(short& val);

The conversion occurs as if performed by the following code fragment (using the same notation as for
the preceding code fragment):

1

2

typedef num_get<charT,istreambuf_iterator<charT,traits> > numget;
iostate err = ios_base::goodbit;
long lval;
use_facet<numget>(loc).get(*this, 0, *this, err, lval);
if (lval < numeric_limits<short>::min()) {

err |= ios_base::failbit;
val = numeric_limits<short>::min();

} else if (numeric_limits<short>::max() < lval) {

err |= ios_base::failbit;
val = numeric_limits<short>::max();
else
val = static_cast<short>(lval);

}

setstate(err);

operator>>(int& val);

314) This is done without causing an ios::failure to be thrown.

§ 27.7.2.2.2

1047

3

1

2

3

4

5

6

7

c(cid:13) ISO/IEC

N4296

The conversion occurs as if performed by the following code fragment (using the same notation as for
the preceding code fragment):

typedef num_get<charT,istreambuf_iterator<charT,traits> > numget;
iostate err = ios_base::goodbit;
long lval;
use_facet<numget>(loc).get(*this, 0, *this, err, lval);
if (lval < numeric_limits<int>::min()) {

err |= ios_base::failbit;
val = numeric_limits<int>::min();

} else if (numeric_limits<int>::max() < lval) {

err |= ios_base::failbit;
val = numeric_limits<int>::max();
else
val = static_cast<int>(lval);

}

setstate(err);

27.7.2.2.3 basic_istream::operator>>
basic_istream<charT,traits>& operator>>

[istream::extractors]

(basic_istream<charT,traits>& (*pf)(basic_istream<charT,traits>&));
Eﬀects: None. This extractor does not behave as a formatted input function (as described in 27.7.2.2.1.)
Returns: pf(*this).315

basic_istream<charT,traits>& operator>>

(basic_ios<charT,traits>& (*pf)(basic_ios<charT,traits>&));
Eﬀects: Calls pf(*this). This extractor does not behave as a formatted input function (as described
in 27.7.2.2.1).
Returns: *this.

basic_istream<charT,traits>& operator>>

(ios_base& (*pf)(ios_base&));
Eﬀects: Calls pf(*this).316 This extractor does not behave as a formatted input function (as de-
scribed in 27.7.2.2.1).
Returns: *this.

template<class charT, class traits>

basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>& in,

basic_istream<char,traits>& operator>>(basic_istream<char,traits>& in,

template<class traits>

template<class traits>

basic_istream<char,traits>& operator>>(basic_istream<char,traits>& in,

charT* s);

unsigned char* s);

signed char* s);

Eﬀects: Behaves like a formatted input member (as described in 27.7.2.2.1) of in. After a sentry
object is constructed, operator>> extracts characters and stores them into successive locations of an
array whose ﬁrst element is designated by s. If width() is greater than zero, n is width(). Otherwise

315) See, for example, the function signature ws(basic_istream&) (27.7.2.4).
316) See, for example, the function signature dec(ios_base&) (27.5.6.3).

§ 27.7.2.2.3

1048

8

(8.1)

(8.2)

(8.3)

9

10

11

12

13

14

(14.1)

(14.2)

(14.3)

15

16

c(cid:13) ISO/IEC

N4296

n is the number of elements of the largest array of char_type that can store a terminating charT().
n is the maximum number of characters stored.
Characters are extracted and stored until any of the following occurs:
—
—
—

n-1 characters are stored;
end of ﬁle occurs on the input sequence;
ct.is(ct.space,c) is true for the next available input character c, where ct is use_facet<ctype<
charT> >(in.getloc()).

operator>> then stores a null byte (charT()) in the next position, which may be the ﬁrst position if
no characters were extracted. operator>> then calls width(0).
If the function extracted no characters, it calls setstate(failbit), which may throw ios_base::
failure (27.5.5.4).
Returns: in.

template<class charT, class traits>

basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>& in,

charT& c);

unsigned char& c);

signed char& c);

basic_istream<char,traits>& operator>>(basic_istream<char,traits>& in,

template<class traits>

template<class traits>

basic_istream<char,traits>& operator>>(basic_istream<char,traits>& in,

Eﬀects: Behaves like a formatted input member (as described in 27.7.2.2.1) of in. After a sentry
object is constructed a character is extracted from in, if one is available, and stored in c. Otherwise,
the function calls in.setstate(failbit).
Returns: in.

basic_istream<charT,traits>& operator>>
(basic_streambuf<charT,traits>* sb);

end-of-ﬁle occurs on the input sequence;
inserting in the output sequence fails (in which case the character to be inserted is not extracted);
an exception occurs (in which case the exception is caught).

Eﬀects: Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1). If sb is null,
calls setstate(failbit), which may throw ios_base::failure (27.5.5.4). After a sentry object is
constructed, extracts characters from *this and inserts them in the output sequence controlled by sb.
Characters are extracted and inserted until any of the following occurs:
—
—
—
If the function inserts no characters,
it calls setstate(failbit), which may throw ios_base::
failure (27.5.5.4). If it inserted no characters because it caught an exception thrown while extracting
characters from *this and failbit is on in exceptions() (27.5.5.4), then the caught exception is
rethrown.
Returns: *this.

§ 27.7.2.2.3

1049

c(cid:13) ISO/IEC

N4296

27.7.2.3 Unformatted input functions

[istream.unformatted]
1 Each unformatted input function begins execution by constructing an object of class sentry with the default
argument noskipws (second) argument true. If the sentry object returns true, when converted to a value
of type bool, the function endeavors to obtain the requested input. Otherwise, if the sentry constructor exits
by throwing an exception or if the sentry object returns false, when converted to a value of type bool, the
function returns without attempting to obtain any input. In either case the number of extracted characters
is set to 0; unformatted input functions taking a character array of non-zero size as an argument shall also
store a null character (using charT()) in the ﬁrst location of the array. If an exception is thrown during input
then ios::badbit is turned on317 in *this’s error state. (Exceptions thrown from basic_ios<>::clear()
are not caught or rethrown.)
It also
counts the number of characters extracted. If no exception has been thrown it ends by storing the count
in a member object and returning the value speciﬁed. In any event the sentry object is destroyed before
leaving the unformatted input function.

If (exceptions()&badbit) != 0 then the exception is rethrown.

streamsize gcount() const;

Eﬀects: None. This member function does not behave as an unformatted input function (as described
in 27.7.2.3, paragraph 1).
Returns: The number of characters extracted by the last unformatted input member function called
for the object.

int_type get();

Eﬀects: Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1). After
constructing a sentry object, extracts a character c, if one is available. Otherwise, the function calls
setstate(failbit), which may throw ios_base::failure (27.5.5.4),
Returns: c if available, otherwise traits::eof().

basic_istream<charT,traits>& get(char_type& c);

Eﬀects: Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1). After
constructing a sentry object, extracts a character, if one is available, and assigns it to c.318 Otherwise,
the function calls setstate(failbit) (which may throw ios_base::failure (27.5.5.4)).
Returns: *this.

basic_istream<charT,traits>& get(char_type* s, streamsize n,

char_type delim );

Eﬀects: Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1). After
constructing a sentry object, extracts characters and stores them into successive locations of an array
whose ﬁrst element is designated by s.319 Characters are extracted and stored until any of the following
occurs:
—
—
—
If the function stores no characters,
failure (27.5.5.4)).
next successive location of the array.
Returns: *this.

n is less than one or n - 1 characters are stored;
end-of-ﬁle occurs on the input sequence (in which case the function calls setstate(eofbit));
traits::eq(c, delim) for the next available input character c (in which case c is not extracted).
it calls setstate(failbit) (which may throw ios_base::
In any case, if n is greater than zero it then stores a null character into the

2

3

4

5

6

7

8

(8.1)

(8.2)

(8.3)

9

10

317) This is done without causing an ios::failure to be thrown.
318) Note that this function is not overloaded on types signed char and unsigned char.
319) Note that this function is not overloaded on types signed char and unsigned char.

§ 27.7.2.3

1050

11

12

13

(13.1)

(13.2)

(13.3)

(13.4)

14

15

16

17

18

19

20

21

22

23

c(cid:13) ISO/IEC

N4296

basic_istream<charT,traits>& get(char_type* s, streamsize n);

Eﬀects: Calls get(s,n,widen(’\n’))
Returns: Value returned by the call.

basic_istream<charT,traits>& get(basic_streambuf<char_type,traits>& sb,

char_type delim );

Eﬀects: Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1). After
constructing a sentry object, extracts characters and inserts them in the output sequence controlled
by sb. Characters are extracted and inserted until any of the following occurs:
—
—
—
—
If the function inserts no characters,
failure (27.5.5.4).
Returns: *this.

end-of-ﬁle occurs on the input sequence;
inserting in the output sequence fails (in which case the character to be inserted is not extracted);
traits::eq(c, delim) for the next available input character c (in which case c is not extracted);
an exception occurs (in which case, the exception is caught but not rethrown).

it calls setstate(failbit), which may throw ios_base::

basic_istream<charT,traits>& get(basic_streambuf<char_type,traits>& sb);

Eﬀects: Calls get(sb, widen(’\n’))
Returns: Value returned by the call.

basic_istream<charT,traits>& getline(char_type* s, streamsize n,

char_type delim);

Eﬀects: Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1). After
constructing a sentry object, extracts characters and stores them into successive locations of an array
whose ﬁrst element is designated by s.320 Characters are extracted and stored until one of the following
occurs:

1. end-of-ﬁle occurs on the input sequence (in which case the function calls setstate(eofbit));
2. traits::eq(c, delim) for the next available input character c (in which case the input character

is extracted but not stored);321

3. n is less than one or n - 1 characters are stored (in which case the function calls setstate(

failbit)).

These conditions are tested in the order shown.322
If the function extracts no characters, it calls setstate(failbit) (which may throw ios_base::
failure (27.5.5.4)).323
In any case, if n is greater than zero, it then stores a null character (using charT()) into the next
successive location of the array.
Returns: *this.
[ Example:

320) Note that this function is not overloaded on types signed char and unsigned char.
321) Since the ﬁnal input character is “extracted,” it is counted in the gcount(), even though it is not stored.
322) This allows an input line which exactly ﬁlls the buﬀer, without setting failbit. This is diﬀerent behavior than the
historical AT&T implementation.
323) This implies an empty input line will not cause failbit to be set.

§ 27.7.2.3

1051

c(cid:13) ISO/IEC

N4296

#include <iostream>

int main() {

using namespace std;
const int line_buffer_size = 100;

char buffer[line_buffer_size];
int line_number = 0;
while (cin.getline(buffer, line_buffer_size, ’\n’) || cin.gcount()) {

int count = cin.gcount();
if (cin.eof())

else if (cin.fail()) {

cout << "Partial final line";

// cin.fail() is false

cout << "Partial long line";
cin.clear(cin.rdstate() & ~ios_base::failbit);

} else {

count--;
cout << "Line " << ++line_number;

// Don’t include newline in count

}
cout << " (" << count << " chars): " << buffer << endl;

}

}

24

25

(25.1)

(25.2)

(25.3)

26

27

28

29

— end example ]

basic_istream<charT,traits>& getline(char_type* s, streamsize n);

Returns: getline(s,n,widen(’\n’))

basic_istream<charT,traits>&

ignore(streamsize n = 1, int_type delim = traits::eof());
Eﬀects: Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1). After
constructing a sentry object, extracts characters and discards them. Characters are extracted until
any of the following occurs:
—

n != numeric_limits<streamsize>::max() (18.3.2) and n characters have been extracted so
far
end-of-ﬁle occurs on the input sequence (in which case the function calls setstate(eofbit),
which may throw ios_base::failure (27.5.5.4));
traits::eq_int_type(traits::to_int_type(c), delim) for the next available input charac-
ter c (in which case c is extracted).

—

—

Remarks: The last condition will never occur if traits::eq_int_type(delim, traits::eof()).
Returns: *this.

int_type peek();

Eﬀects: Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1). After
constructing a sentry object, reads but does not extract the current input character.
Returns: traits::eof() if good() is false. Otherwise, returns rdbuf()->sgetc().

basic_istream<charT,traits>& read(char_type* s, streamsize n);

§ 27.7.2.3

1052

c(cid:13) ISO/IEC

N4296

30

(30.1)

(30.2)

31

32

(32.1)

(32.2)

33

34

35

36

37

38

Eﬀects: Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1). After
constructing a sentry object, if !good() calls setstate(failbit) which may throw an exception, and
return. Otherwise extracts characters and stores them into successive locations of an array whose ﬁrst
element is designated by s.324 Characters are extracted and stored until either of the following occurs:
—
—

n characters are stored;
end-of-ﬁle occurs on the input sequence (in which case the function calls setstate(failbit |
eofbit), which may throw ios_base::failure (27.5.5.4)).

Returns: *this.

streamsize readsome(char_type* s, streamsize n);

Eﬀects: Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1). After
constructing a sentry object, if !good() calls setstate(failbit) which may throw an exception, and
return. Otherwise extracts characters and stores them into successive locations of an array whose ﬁrst
element is designated by s.
If rdbuf()->in_avail() == -1, calls setstate(eofbit) (which may
throw ios_base::failure (27.5.5.4)), and extracts no characters;
—
—
Returns: The number of characters extracted.

If rdbuf()->in_avail() == 0, extracts no characters
If rdbuf()->in_avail() > 0, extracts min(rdbuf()->in_avail(),n)).

basic_istream<charT,traits>& putback(char_type c);

Eﬀects: Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1), except that
the function ﬁrst clears eofbit. After constructing a sentry object, if !good() calls setstate(failbit)
which may throw an exception, and return.
If
rdbuf() is null, or if sputbackc() returns traits::eof(), calls setstate(badbit) (which may throw
ios_base::failure (27.5.5.4)). [ Note: This function extracts no characters, so the value returned by
the next call to gcount() is 0. — end note ]
Returns: *this.

If rdbuf() is not null, calls rdbuf->sputbackc().

basic_istream<charT,traits>& unget();

Eﬀects: Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1), except that
the function ﬁrst clears eofbit. After constructing a sentry object, if !good() calls setstate(failbit)
which may throw an exception, and return.
If
rdbuf() is null, or if sungetc() returns traits::eof(), calls setstate(badbit) (which may throw
ios_base::failure (27.5.5.4)). [ Note: This function extracts no characters, so the value returned by
the next call to gcount() is 0. — end note ]
Returns: *this.

If rdbuf() is not null, calls rdbuf()->sungetc().

int sync();

Eﬀects: Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1), except
that it does not count the number of characters extracted and does not aﬀect the value returned by
subsequent calls to gcount(). After constructing a sentry object, if rdbuf() is a null pointer, returns
-1 . Otherwise, calls rdbuf()->pubsync() and, if that function returns -1 calls setstate(badbit)
(which may throw ios_base::failure (27.5.5.4), and returns -1. Otherwise, returns zero.

pos_type tellg();

324) Note that this function is not overloaded on types signed char and unsigned char.

§ 27.7.2.3

1053

39

40

41

42

43

44

1

2

c(cid:13) ISO/IEC

N4296

Eﬀects: Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1), except
that it does not count the number of characters extracted and does not aﬀect the value returned by
subsequent calls to gcount().
Returns: After constructing a sentry object, if fail() != false, returns pos_type(-1) to indicate
failure. Otherwise, returns rdbuf()->pubseekoff(0, cur, in).

basic_istream<charT,traits>& seekg(pos_type pos);

Eﬀects: Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1), except that
the function ﬁrst clears eofbit, it does not count the number of characters extracted, and it does not
aﬀect the value returned by subsequent calls to gcount(). After constructing a sentry object, if fail()
!= true, executes rdbuf()->pubseekpos(pos, ios_base::in). In case of failure, the function calls
setstate(failbit) (which may throw ios_base::failure).
Returns: *this.

basic_istream<charT,traits>& seekg(off_type off, ios_base::seekdir dir);

Eﬀects: Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1), except
that it does not count the number of characters extracted and does not aﬀect the value returned
by subsequent calls to gcount(). After constructing a sentry object, if fail() != true, executes
rdbuf()->pubseekoff(off, dir, ios_base::in). In case of failure, the function calls setstate(
failbit) (which may throw ios_base::failure).
Returns: *this.

27.7.2.4 Standard basic_istream manipulators
namespace std {

template <class charT, class traits>

basic_istream<charT,traits>& ws(basic_istream<charT,traits>& is);

}

[istream.manip]

Eﬀects: Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1), except
that it does not count the number of characters extracted and does not aﬀect the value returned by
subsequent calls to is.gcount(). After constructing a sentry object extracts characters as long as the next
available character c is whitespace or until there are no more characters in the sequence. Whitespace
characters are distinguished with the same criterion as used by sentry::sentry (27.7.2.1.3). If ws
stops extracting characters because there are no more available it sets eofbit, but not failbit.
Returns: is.

27.7.2.5 Class template basic_iostream

[iostreamclass]

namespace std {

template <class charT, class traits = char_traits<charT> >
class basic_iostream :

public basic_istream<charT,traits>,
public basic_ostream<charT,traits> {

public:

// types:
typedef charT
char_type;
typedef typename traits::int_type int_type;
typedef typename traits::pos_type pos_type;
typedef typename traits::off_type off_type;
typedef traits

traits_type;

// constructor/destructor

§ 27.7.2.5

1054

c(cid:13) ISO/IEC

N4296

explicit basic_iostream(basic_streambuf<charT,traits>* sb);
virtual ~basic_iostream();

protected:

basic_iostream(const basic_iostream& rhs) = delete;
basic_iostream(basic_iostream&& rhs);

// assign/swap
basic_iostream& operator=(const basic_iostream& rhs) = delete;
basic_iostream& operator=(basic_iostream&& rhs);
void swap(basic_iostream& rhs);

};

}

1 The class basic_iostream inherits a number of functions that allow reading input and writing output to

sequences controlled by a stream buﬀer.
27.7.2.5.1 basic_iostream constructors
explicit basic_iostream(basic_streambuf<charT,traits>* sb);

[iostream.cons]

1

2

3

1

2

1

2

1

2

Eﬀects: Constructs an object of class basic_iostream, assigning initial values to the base classes
by calling basic_istream<charT,traits>(sb) (27.7.2.1) and basic_ostream<charT,traits>(sb)
(27.7.3.1)
Postcondition: rdbuf()==sb and gcount()==0.

basic_iostream(basic_iostream&& rhs);

Eﬀects: Move constructs from the rvalue rhs by constructing the basic_istream base class with
move(rhs).

27.7.2.5.2 basic_iostream destructor
virtual ~basic_iostream();

Eﬀects: Destroys an object of class basic_iostream.
Remarks: Does not perform any operations on rdbuf().

27.7.2.5.3 basic_iostream assign and swap
basic_iostream& operator=(basic_iostream&& rhs);

Eﬀects: swap(rhs).

void swap(basic_iostream& rhs);

Eﬀects: Calls basic_istream<charT, traits>::swap(rhs).

27.7.2.6 Rvalue stream extraction
template <class charT, class traits, class T>

basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>&& is, T& x);

Eﬀects: is >>x
Returns: is

§ 27.7.2.6

[iostream.dest]

[iostream.assign]

[istream.rvalue]

1055

c(cid:13) ISO/IEC

N4296

27.7.3 Output streams

[output.streams]
1 The header <ostream> deﬁnes a type and several function signatures that control output to a stream buﬀer

[ostream]

along with a function template that inserts into stream rvalues.
27.7.3.1 Class template basic_ostream

namespace std {

template <class charT, class traits = char_traits<charT> >
class basic_ostream : virtual public basic_ios<charT,traits> {
public:

// types (inherited from basic_ios (27.5.5)):
typedef charT
char_type;
typedef typename traits::int_type int_type;
typedef typename traits::pos_type pos_type;
typedef typename traits::off_type off_type;
typedef traits

traits_type;

// 27.7.3.2 Constructor/destructor:
explicit basic_ostream(basic_streambuf<char_type,traits>* sb);
virtual ~basic_ostream();

// 27.7.3.4 Preﬁx/suﬃx:
class sentry;

// 27.7.3.6 Formatted output:
basic_ostream<charT,traits>& operator<<(

basic_ostream<charT,traits>& (*pf)(basic_ostream<charT,traits>&));

basic_ostream<charT,traits>& operator<<(

basic_ios<charT,traits>& (*pf)(basic_ios<charT,traits>&));

basic_ostream<charT,traits>& operator<<(

ios_base& (*pf)(ios_base&));

basic_ostream<charT,traits>& operator<<(bool n);
basic_ostream<charT,traits>& operator<<(short n);
basic_ostream<charT,traits>& operator<<(unsigned short n);
basic_ostream<charT,traits>& operator<<(int n);
basic_ostream<charT,traits>& operator<<(unsigned int n);
basic_ostream<charT,traits>& operator<<(long n);
basic_ostream<charT,traits>& operator<<(unsigned long n);
basic_ostream<charT,traits>& operator<<(long long n);
basic_ostream<charT,traits>& operator<<(unsigned long long n);
basic_ostream<charT,traits>& operator<<(float f);
basic_ostream<charT,traits>& operator<<(double f);
basic_ostream<charT,traits>& operator<<(long double f);

basic_ostream<charT,traits>& operator<<(const void* p);
basic_ostream<charT,traits>& operator<<(
basic_streambuf<char_type,traits>* sb);

// 27.7.3.7 Unformatted output:
basic_ostream<charT,traits>& put(char_type c);
basic_ostream<charT,traits>& write(const char_type* s, streamsize n);

basic_ostream<charT,traits>& flush();

// 27.7.3.5 seeks:

§ 27.7.3.1

1056

c(cid:13) ISO/IEC

N4296

pos_type tellp();
basic_ostream<charT,traits>& seekp(pos_type);
basic_ostream<charT,traits>& seekp(off_type, ios_base::seekdir);

protected:

basic_ostream(const basic_ostream& rhs) = delete;
basic_ostream(basic_ostream&& rhs);

// 27.7.3.3 Assign/swap
basic_ostream& operator=(const basic_ostream& rhs) = delete;
basic_ostream& operator=(basic_ostream&& rhs);
void swap(basic_ostream& rhs);

};

// 27.7.3.6.4 character inserters
template<class charT, class traits>

basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&,

template<class charT, class traits>

basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&,

template<class traits>

basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,

// signed and unsigned
template<class traits>

template<class traits>

basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,

basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,

charT);

char);

char);

signed char);

unsigned char);

const charT*);

const char*);

const char*);

template<class charT, class traits>

basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&,

template<class charT, class traits>

basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&,

template<class traits>

basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,

// signed and unsigned
template<class traits>

template<class traits>

basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,

const signed char*);

basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,

const unsigned char*);

}

1 The class basic_ostream deﬁnes a number of member function signatures that assist in formatting and

writing output to output sequences controlled by a stream buﬀer.

2 Two groups of member function signatures share common properties: the formatted output functions (or
inserters) and the unformatted output functions. Both groups of output functions generate (or insert)

§ 27.7.3.1

1057

c(cid:13) ISO/IEC

N4296

output characters by actions equivalent to calling rdbuf()->sputc(int_type). They may use other public
members of basic_ostream except that they shall not invoke any virtual members of rdbuf() except
overflow(), xsputn(), and sync().
If one of these called functions throws an exception, then unless explicitly noted otherwise the output function
sets badbit in error state. If badbit is on in exceptions(), the output function rethrows the exception
without completing its actions, otherwise it does not throw anything and treat as an error.
27.7.3.2 basic_ostream constructors
explicit basic_ostream(basic_streambuf<charT,traits>* sb);

[ostream.cons]

Eﬀects: Constructs an object of class basic_ostream, assigning initial values to the base class by
calling basic_ios<charT,traits>::init(sb) (27.5.5.2).
Postcondition: rdbuf() == sb.
virtual ~basic_ostream();
Eﬀects: Destroys an object of class basic_ostream.
Remarks: Does not perform any operations on rdbuf().

basic_ostream(basic_ostream&& rhs);

Eﬀects: Move constructs from the rvalue rhs. This is accomplished by default constructing the base
class and calling basic_ios<charT, traits>::move(rhs) to initialize the base class.

27.7.3.3 Class basic_ostream assign and swap
basic_ostream& operator=(basic_ostream&& rhs);

Eﬀects: swap(rhs).
Returns: *this.

void swap(basic_ostream& rhs);

Eﬀects: Calls basic_ios<charT, traits>::swap(rhs).

[ostream.assign]

27.7.3.4 Class basic_ostream::sentry

[ostream::sentry]

3

1

2

3

4

5

1

2

3

namespace std {

template <class charT,class traits = char_traits<charT> >
class basic_ostream<charT,traits>::sentry {

bool ok_; // exposition only

public:

explicit sentry(basic_ostream<charT,traits>& os);
~sentry();
explicit operator bool() const { return ok_; }

sentry(const sentry&) = delete;
sentry& operator=(const sentry&) = delete;

};

}

1 The class sentry deﬁnes a class that is responsible for doing exception safe preﬁx and suﬃx operations.

explicit sentry(basic_ostream<charT,traits>& os);

§ 27.7.3.4

1058

c(cid:13) ISO/IEC

N4296

If os.good() is nonzero, prepares for formatted or unformatted output. If os.tie() is not a null
pointer, calls os.tie()->flush().325
If, after any preparation is completed, os.good() is true, ok_ == true otherwise, ok_ == false.
During preparation, the constructor may call setstate(failbit) (which may throw ios_base::
failure (27.5.5.4))326

~sentry();

If ((os.flags() & ios_base::unitbuf) && !uncaught_exception() && os.good()) is true, calls
os.rdbuf()->pubsync(). If that function returns -1, sets badbit in os.rdstate() without propa-
gating an exception.

explicit operator bool() const;

Eﬀects: Returns ok_.

27.7.3.5 basic_ostream seek members

2

3

4

5

[ostream.seeks]
It returns by

1 Each seek member function begins execution by constructing an object of class sentry.

destroying the sentry object.

pos_type tellp();

2

3

4

5

6

Returns: If fail() != false, returns pos_type(-1) to indicate failure. Otherwise, returns rdbuf()->
pubseekoff(0, cur, out).

basic_ostream<charT,traits>& seekp(pos_type pos);
Eﬀects: If fail() != true, executes rdbuf()->pubseekpos(pos, ios_base::out). In case of fail-
ure, the function calls setstate(failbit) (which may throw ios_base::failure).
Returns: *this.

basic_ostream<charT,traits>& seekp(off_type off, ios_base::seekdir dir);

Eﬀects: If fail() != true, executes rdbuf()->pubseekoff(off, dir, ios_base::out). In case of
failure, the function calls setstate(failbit) (which may throw ios_base::failure).
Returns: *this.

27.7.3.6 Formatted output functions
27.7.3.6.1 Common requirements

[ostream.formatted]
[ostream.formatted.reqmts]
1 Each formatted output function begins execution by constructing an object of class sentry. If this object
returns true when converted to a value of type bool, the function endeavors to generate the requested
output. If the generation fails, then the formatted output function does setstate(ios_base::failbit),
which might throw an exception. If an exception is thrown during output, then ios::badbit is turned on327
in *this’s error state. If (exceptions()&badbit) != 0 then the exception is rethrown. Whether or not
an exception is thrown, the sentry object is destroyed before leaving the formatted output function. If no
exception is thrown, the result of the formatted output function is *this.

3

2 The descriptions of the individual formatted output functions describe how they perform output and do not

mention the sentry object.
If a formatted output function of a stream os determines padding, it does so as follows. Given a charT
character sequence seq where charT is the character type of the stream, if the length of seq is less than
325) The call os.tie()->flush() does not necessarily occur if the function can determine that no synchronization is necessary.
326) The sentry constructor and destructor can also perform additional implementation-dependent operations.
327) without causing an ios::failure to be thrown.

§ 27.7.3.6.1

1059

c(cid:13) ISO/IEC

N4296

os.width(), then enough copies of os.fill() are added to this sequence as necessary to pad to a width of
os.width() characters. If (os.flags() & ios_base::adjustfield) == ios_base::left is true, the ﬁll
characters are placed after the character sequence; otherwise, they are placed before the character sequence.
27.7.3.6.2 Arithmetic inserters
[ostream.inserters.arithmetic]
operator<<(bool val);
operator<<(short val);
operator<<(unsigned short val);
operator<<(int val);
operator<<(unsigned int val);
operator<<(long val);
operator<<(unsigned long val);
operator<<(long long val);
operator<<(unsigned long long val);
operator<<(float val);
operator<<(double val);
operator<<(long double val);
operator<<(const void* val);

1

Eﬀects: The classes num_get<> and num_put<> handle locale-dependent numeric formatting and pars-
ing. These inserter functions use the imbued locale value to perform numeric formatting. When val
is of type bool, long, unsigned long, long long, unsigned long long, double, long double, or
const void*, the formatting conversion occurs as if it performed the following code fragment:

bool failed = use_facet<

num_put<charT,ostreambuf_iterator<charT,traits> >

>(getloc()).put(*this, *this, fill(), val).failed();

When val is of type short the formatting conversion occurs as if it performed the following code
fragment:

ios_base::fmtflags baseflags = ios_base::flags() & ios_base::basefield;
bool failed = use_facet<

num_put<charT,ostreambuf_iterator<charT,traits> >

>(getloc()).put(*this, *this, fill(),
baseflags == ios_base::oct || baseflags == ios_base::hex
? static_cast<long>(static_cast<unsigned short>(val))
: static_cast<long>(val)).failed();

When val is of type int the formatting conversion occurs as if it performed the following code frag-
ment:

ios_base::fmtflags baseflags = ios_base::flags() & ios_base::basefield;
bool failed = use_facet<

num_put<charT,ostreambuf_iterator<charT,traits> >

>(getloc()).put(*this, *this, fill(),
baseflags == ios_base::oct || baseflags == ios_base::hex

? static_cast<long>(static_cast<unsigned int>(val))
: static_cast<long>(val)).failed();

When val is of type unsigned short or unsigned int the formatting conversion occurs as if it
performed the following code fragment:

bool failed = use_facet<

num_put<charT,ostreambuf_iterator<charT,traits> >

>(getloc()).put(*this, *this, fill(),

static_cast<unsigned long>(val)).failed();

§ 27.7.3.6.2

1060

c(cid:13) ISO/IEC

N4296

When val is of type float the formatting conversion occurs as if it performed the following code
fragment:

bool failed = use_facet<

num_put<charT,ostreambuf_iterator<charT,traits> >

>(getloc()).put(*this, *this, fill(),
static_cast<double>(val)).failed();

The ﬁrst argument provides an object of the ostreambuf_iterator<> class which is an iterator for
class basic_ostream<>. It bypasses ostreams and uses streambufs directly. Class locale relies on
these types as its interface to iostreams, since for ﬂexibility it has been abstracted away from direct
dependence on ostream. The second parameter is a reference to the base subobject of type ios_base.
It provides formatting speciﬁcations such as ﬁeld width, and a locale from which to obtain other facets.
If failed is true then does setstate(badbit), which may throw an exception, and returns.
Returns: *this.

27.7.3.6.3 basic_ostream::operator<<
basic_ostream<charT,traits>& operator<<

[ostream.inserters]

(basic_ostream<charT,traits>& (*pf)(basic_ostream<charT,traits>&));
Eﬀects: None. Does not behave as a formatted output function (as described in 27.7.3.6.1).
Returns: pf(*this).328

basic_ostream<charT,traits>& operator<<

(basic_ios<charT,traits>& (*pf)(basic_ios<charT,traits>&));
Eﬀects: Calls pf(*this). This inserter does not behave as a formatted output function (as described
in 27.7.3.6.1).
Returns: *this.329

basic_ostream<charT,traits>& operator<<

(ios_base& (*pf)(ios_base&));
Eﬀects: Calls pf(*this). This inserter does not behave as a formatted output function (as described
in 27.7.3.6.1).
Returns: *this.

basic_ostream<charT,traits>& operator<<
(basic_streambuf<charT,traits>* sb);
Eﬀects: Behaves as an unformatted output function (as described in 27.7.3.7, paragraph 1). Af-
ter the sentry object is constructed, if sb is null calls setstate(badbit) (which may throw ios_-
base::failure).
Gets characters from sb and inserts them in *this. Characters are read from sb and inserted until
any of the following occurs:
—
—
—

end-of-ﬁle occurs on the input sequence;
inserting in the output sequence fails (in which case the character to be inserted is not extracted);
an exception occurs while getting a character from sb.

328) See, for example, the function signature endl(basic_ostream&) (27.7.3.8).
329) See, for example, the function signature dec(ios_base&) (27.5.6.3).

§ 27.7.3.6.3

1061

2

3

1

2

3

4

5

6

7

8

(8.1)

(8.2)

(8.3)

c(cid:13) ISO/IEC

N4296

9

10

If the function inserts no characters, it calls setstate(failbit) (which may throw ios_base::
failure (27.5.5.4)). If an exception was thrown while extracting a character, the function sets failbit
in error state, and if failbit is on in exceptions() the caught exception is rethrown.
Returns: *this.

27.7.3.6.4 Character inserter function templates
template<class charT, class traits>

basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>& out,

[ostream.inserters.character]

template<class charT, class traits>

basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>& out,

// specialization

template<class traits>

// signed and unsigned
template<class traits>

template<class traits>

charT c);

char c);

char c);

signed char c);

unsigned char c);

basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>& out,

basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>& out,

basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>& out,

1

2

3

4

(4.1)

Eﬀects: Behaves as a formatted output function ( 27.7.3.6.1) of out. Constructs a character sequence
seq.
If c has type char and the character type of the stream is not char, then seq consists of
out.widen(c); otherwise seq consists of c. Determines padding for seq as described in 27.7.3.6.1.
Inserts seq into out. Calls os.width(0).
Returns: out.

template<class charT, class traits>

basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>& out,

template<class charT, class traits>

basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>& out,

template<class traits>

template<class traits>

template<class traits>

basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>& out,

basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>& out,

const signed char* s);

basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>& out,

const unsigned char* s);

const charT* s);

const char* s);

const char* s);

Requires: s shall not be a null pointer.
Eﬀects: Behaves like a formatted inserter (as described in 27.7.3.6.1) of out. Creates a character
sequence seq of n characters starting at s, each widened using out.widen() (27.5.5.3), where n is the
number that would be computed as if by:
—

traits::length(s) for the overload where the ﬁrst argument is of type basic_ostream<charT,
traits>& and the second is of type const charT*, and also for the overload where the ﬁrst
argument is of type basic_ostream<char, traits>& and the second is of type const char*,

§ 27.7.3.6.4

1062

c(cid:13) ISO/IEC

N4296

(4.2)

(4.3)

5

—

std::char_traits<char>::length(s) for the overload where the ﬁrst argument is of type
basic_ostream<charT, traits>& and the second is of type const char*,
traits::length(reinterpret_cast<const char*>(s)) for the other two overloads.

—
Determines padding for seq as described in 27.7.3.6.1. Inserts seq into out. Calls width(0).
Returns: out.

27.7.3.7 Unformatted output functions

[ostream.unformatted]
1 Each unformatted output function begins execution by constructing an object of class sentry. If this object
returns true, while converting to a value of type bool, the function endeavors to generate the requested
output. If an exception is thrown during output, then ios::badbit is turned on330 in *this’s error state.
If (exceptions() & badbit) != 0 then the exception is rethrown. In any case, the unformatted output
function ends by destroying the sentry object, then, if no exception was thrown, returning the value speciﬁed
for the unformatted output function.

basic_ostream<charT,traits>& put(char_type c);

Eﬀects: Behaves as an unformatted output function (as described in 27.7.3.7, paragraph 1). After
constructing a sentry object, inserts the character c, if possible.331
Otherwise, calls setstate(badbit) (which may throw ios_base::failure (27.5.5.4)).
Returns: *this.

basic_ostream& write(const char_type* s, streamsize n);

Eﬀects: Behaves as an unformatted output function (as described in 27.7.3.7, paragraph 1). After
constructing a sentry object, obtains characters to insert from successive locations of an array whose
ﬁrst element is designated by s.332 Characters are inserted until either of the following occurs:
—
—

n characters are inserted;
inserting in the output sequence fails (in which case the function calls setstate(badbit), which
may throw ios_base::failure (27.5.5.4)).

Returns: *this.

basic_ostream& flush();

Eﬀects: Behaves as an unformatted output function (as described in 27.7.3.6.1, paragraph 1).
If
rdbuf() is not a null pointer, constructs a sentry object. If this object returns true when converted
to a value of type bool the function calls rdbuf()->pubsync().
If that function returns -1 calls
setstate(badbit) (which may throw ios_base::failure (27.5.5.4)). Otherwise, if the sentry object
returns false, does nothing.
Returns: *this.

2

3

4

5

(5.1)

(5.2)

6

7

8

27.7.3.8 Standard basic_ostream manipulators
namespace std {

template <class charT, class traits>

basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);

}

[ostream.manip]

330) without causing an ios::failure to be thrown.
331) Note that this function is not overloaded on types signed char and unsigned char.
332) Note that this function is not overloaded on types signed char and unsigned char.

§ 27.7.3.8

1063

c(cid:13) ISO/IEC

N4296

Eﬀects: Calls os.put(os.widen(’\n’)), then os.flush().
Returns: os.

namespace std {

template <class charT, class traits>

basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);

}

}

1

2

3

4

5

6

1

2

Eﬀects: Inserts a null character into the output sequence: calls os.put(charT()).
Returns: os.

namespace std {

template <class charT, class traits>

basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);

Eﬀects: Calls os.flush().
Returns: os.

27.7.3.9 Rvalue stream insertion
template <class charT, class traits, class T>

basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>&& os, const T& x);

Eﬀects: os << x
Returns: os

[ostream.rvalue]

27.7.4 Standard manipulators

[std.manip]
1 The header <iomanip> deﬁnes several functions that support extractors and inserters that alter information

maintained by class ios_base and its derived classes.

unspecified

resetiosflags(ios_base::fmtflags mask);

2

Returns: An object of unspeciﬁed type such that if out is an object of type basic_ostream<charT,
traits> then the expression out << resetiosflags(mask) behaves as if it called f(out, mask), or if
in is an object of type basic_istream<charT, traits> then the expression in >> resetiosflags(
mask) behaves as if it called f(in, mask), where the function f is deﬁned as:333

void f(ios_base& str, ios_base::fmtflags mask) {

// reset speciﬁed ﬂags
str.setf(ios_base::fmtflags(0), mask);

}

The expression out << resetiosflags(mask) shall have type basic_ostream<charT,traits>& and
value out. The expression in >> resetiosflags(mask) shall have type basic_istream<charT,
traits>& and value in.

unspecified

setiosflags(ios_base::fmtflags mask);

333) The expression cin >>resetiosflags(ios_base::skipws) clears ios_base::skipws in the format ﬂags stored in the
basic_istream<charT,traits> object cin (the same as cin >>noskipws), and the expression cout <<resetiosflags(ios_-
base::showbase) clears ios_base::showbase in the format ﬂags stored in the basic_ostream<charT,traits> object cout (the
same as cout <<noshowbase).

§ 27.7.4

1064

3

4

5

6

}

}

c(cid:13) ISO/IEC

N4296

Returns: An object of unspeciﬁed type such that if out is an object of type basic_ostream<charT,
traits> then the expression out << setiosflags(mask) behaves as if it called f(out, mask), or if in
is an object of type basic_istream<charT, traits> then the expression in >> setiosflags(mask)
behaves as if it called f(in, mask), where the function f is deﬁned as:

void f(ios_base& str, ios_base::fmtflags mask) {

// set speciﬁed ﬂags
str.setf(mask);

}

The expression out << setiosflags(mask) shall have type basic_ostream<charT, traits>& and
value out. The expression in >> setiosflags(mask) shall have type basic_istream<charT,
traits>& and value in.

unspecified

setbase(int base);

Returns: An object of unspeciﬁed type such that if out is an object of type basic_ostream<charT,
traits> then the expression out << setbase(base) behaves as if it called f(out, base), or if in is
an object of type basic_istream<charT, traits> then the expression in >> setbase(base) behaves
as if it called f(in, base), where the function f is deﬁned as:

void f(ios_base& str, int base) {

// set basefield
str.setf(base ==

8 ? ios_base::oct :

base == 10 ? ios_base::dec :
base == 16 ? ios_base::hex :
ios_base::fmtflags(0), ios_base::basefield);

The expression out << setbase(base) shall have type basic_ostream<charT, traits>& and value
out. The expression in >> setbase(base) shall have type basic_istream<charT, traits>& and
value in.

unspecified

setfill(char_type c);

Returns: An object of unspeciﬁed type such that if out is an object of type basic_ostream<charT,
traits> and c has type charT then the expression out << setfill(c) behaves as if it called f(out,
c), where the function f is deﬁned as:

template<class charT, class traits>
void f(basic_ios<charT,traits>& str, charT c) {

// set ﬁll character
str.fill(c);

The expression out << setfill(c) shall have type basic_ostream<charT, traits>& and value out.

unspecified

setprecision(int n);

Returns: An object of unspeciﬁed type such that if out is an object of type basic_ostream<charT,
traits> then the expression out << setprecision(n) behaves as if it called f(out, n), or if in
is an object of type basic_istream<charT, traits> then the expression in >> setprecision(n)
behaves as if it called f(in, n), where the function f is deﬁned as:

void f(ios_base& str, int n) {

// set precision
str.precision(n);

}

§ 27.7.4

1065

c(cid:13) ISO/IEC

N4296

The expression out << setprecision(n) shall have type basic_ostream<charT, traits>& and value
out. The expression in >> setprecision(n) shall have type basic_istream<charT, traits>& and
value in.

unspecified

setw(int n);

7

Returns: An object of unspeciﬁed type such that if out is an instance of basic_ostream<charT,
traits> then the expression out << setw(n) behaves as if it called f(out, n), or if in is an object
of type basic_istream<charT, traits> then the expression in >> setw(n) behaves as if it called
f(in, n), where the function f is deﬁned as:

void f(ios_base& str, int n) {

// set width
str.width(n);

}

The expression out << setw(n) shall have type basic_ostream<charT, traits>& and value out.
The expression in >> setw(n) shall have type basic_istream<charT, traits>& and value in.

27.7.5 Extended manipulators

[ext.manip]
1 The header <iomanip> deﬁnes several functions that support extractors and inserters that allow for the

parsing and formatting of sequences and values for money and time.

template <class moneyT> unspecified

get_money(moneyT& mon, bool intl = false);

2

3

4

Requires: The type moneyT shall be either long double or a specialization of the basic_string
template (Clause 21).
Eﬀects: The expression in >>get_money(mon, intl) described below behaves as a formatted input
function (27.7.2.2.1).
Returns: An object of unspeciﬁed type such that if in is an object of type basic_istream<charT,
traits> then the expression in >> get_money(mon, intl) behaves as if it called f(in, mon, intl),
where the function f is deﬁned as:

template <class charT, class traits, class moneyT>
void f(basic_ios<charT, traits>& str, moneyT& mon, bool intl) {

typedef istreambuf_iterator<charT, traits> Iter;
typedef money_get<charT, Iter> MoneyGet;

ios_base::iostate err = ios_base::goodbit;
const MoneyGet &mg = use_facet<MoneyGet>(str.getloc());

mg.get(Iter(str.rdbuf()), Iter(), intl, str, err, mon);

if (ios_base::goodbit != err)

str.setstate(err);

}

The expression in >> get_money(mon, intl) shall have type basic_istream<charT, traits>& and
value in.

template <class moneyT> unspecified

put_money(const moneyT& mon, bool intl = false);

5

Requires: The type moneyT shall be either long double or a specialization of the basic_string
template (Clause 21).

§ 27.7.5

1066

6

7

8

c(cid:13) ISO/IEC

N4296

Returns: An object of unspeciﬁed type such that if out is an object of type basic_ostream<charT,
traits> then the expression out << put_money(mon, intl) behaves as a formatted input function
that calls f(out, mon, intl), where the function f is deﬁned as:

template <class charT, class traits, class moneyT>
void f(basic_ios<charT, traits>& str, const moneyT& mon, bool intl) {

typedef ostreambuf_iterator<charT, traits> Iter;
typedef money_put<charT, Iter> MoneyPut;

const MoneyPut& mp = use_facet<MoneyPut>(str.getloc());
const Iter end = mp.put(Iter(str.rdbuf()), intl, str, str.fill(), mon);

if (end.failed())

str.setstate(ios::badbit);

}

The expression out << put_money(mon, intl) shall have type basic_ostream<charT, traits>&
and value out.

template <class charT> unspecified

get_time(struct tm* tmb, const charT* fmt);

Requires: The argument tmb shall be a valid pointer to an object of type struct tm, and the argument
fmt shall be a valid pointer to an array of objects of type charT with char_traits<charT>::length(fmt)
elements.
Returns: An object of unspeciﬁed type such that if in is an object of type basic_istream<charT,
traits> then the expression in >> get_time(tmb, fmt) behaves as if it called f(in, tmb, fmt),
where the function f is deﬁned as:

template <class charT, class traits>
void f(basic_ios<charT, traits>& str, struct tm* tmb, const charT* fmt) {

typedef istreambuf_iterator<charT, traits> Iter;
typedef time_get<charT, Iter> TimeGet;

ios_base::iostate err = ios_base::goodbit;
const TimeGet& tg = use_facet<TimeGet>(str.getloc());

tg.get(Iter(str.rdbuf()), Iter(), str, err, tmb,

fmt, fmt + traits::length(fmt));

if (err != ios_base::goodbit)

str.setstate(err):

}

The expression in >> get_time(tmb, fmt) shall have type basic_istream<charT, traits>& and
value in.

template <class charT> unspecified

put_time(const struct tm* tmb, const charT* fmt);

9

10

Requires: The argument tmb shall be a valid pointer to an object of type struct tm, and the argument
fmt shall be a valid pointer to an array of objects of type charT with char_traits<charT>::length(
fmt) elements.
Returns: An object of unspeciﬁed type such that if out is an object of type basic_ostream<charT,
traits> then the expression out << put_time(tmb, fmt) behaves as if it called f(out, tmb, fmt),
where the function f is deﬁned as:

§ 27.7.5

1067

c(cid:13) ISO/IEC

N4296

template <class charT, class traits>
void f(basic_ios<charT, traits>& str, const struct tm* tmb, const charT* fmt) {

typedef ostreambuf_iterator<charT, traits> Iter;
typedef time_put<charT, Iter> TimePut;

const TimePut& tp = use_facet<TimePut>(str.getloc());
const Iter end = tp.put(Iter(str.rdbuf()), str, str.fill(), tmb,

fmt, fmt + traits::length(fmt));

if (end.failed())

str.setstate(ios_base::badbit);

}

The expression out << put_time(tmb, fmt) shall have type basic_ostream<charT, traits>& and
value out.

27.7.6 Quoted manipulators
[quoted.manip]
[ Note: Quoted manipulators provide string insertion and extraction of quoted strings (for example, XML
and CSV formats). Quoted manipulators are useful in ensuring that the content of a string with embedded
spaces remains unchanged if inserted and then extracted via stream I/O. — end note ]

template <class charT>

unspecified

quoted(const charT* s, charT delim=charT(’"’), charT escape=charT(’\\’));

template <class charT, class traits, class Allocator>

unspecified

quoted(const basic_string<charT, traits, Allocator>& s,

charT delim=charT(’"’), charT escape=charT(’\\’));

Returns: An object of unspeciﬁed type such that if out is an instance of basic_ostream with member
type char_type the same as charT and with member type traits_type, which in the second form is
the same as traits, then the expression out << quoted(s, delim, escape) behaves as a formatted
output function (27.7.3.6.1) of out. This forms a character sequence seq, initially consisting of the
following elements:
—
—

delim.
Each character in s. If the character to be output is equal to escape or delim, as determined by
traits_type::eq, ﬁrst output escape.
delim.

—
Let x be the number of elements initially in seq. Then padding is determined for seq as described
in 27.7.3.6.1, seq is inserted as if by calling out.rdbuf()->sputn(seq, n), where n is the larger of
out.width() and x, and out.width(0) is called. The expression out << quoted(s, delim, escape)
shall have type basic_ostream<charT, traits>& and value out.

template <class charT, class traits, class Allocator>

unspecified

quoted(basic_string<charT, traits, Allocator>& s,

charT delim=charT(’"’), charT escape=charT(’\\’));

Returns: An object of unspeciﬁed type such that:
—

If in is an instance of basic_istream with member types char_type and traits_type the same
as charT and traits, respectively, then the expression in >> quoted(s, delim, escape) be-
haves as if it extracts the following characters from in using basic_istream::operator>> (27.7.2.2.3)
which may throw ios_base::failure (27.5.3.1.1):
—

If the ﬁrst character extracted is equal to delim, as determined by traits_type::eq, then:

§ 27.7.6

1068

1

2

(2.1)

(2.2)

(2.3)

3

(3.1)

(3.1.1)

c(cid:13) ISO/IEC

—
—
—

(3.1.1.1)
(3.1.1.2)
(3.1.1.3)

(3.1.1.4)
(3.1.1.5)
(3.1.2)

(3.2)

N4296

Turn oﬀ the skipws ﬂag.
s.clear()
Until an unescaped delim character is reached or !in, extract characters from in and
append them to s, except that if an escape is reached, ignore it and append the next
character to s.
Discard the ﬁnal delim character.
Restore the skipws ﬂag to its original value.

—
—
Otherwise, in >> s.

—

—
If out is an instance of basic_ostream with member types char_type and traits_type the
same as charT and traits, respectively, then the expression out << quoted(s, delim, escape)
behaves as speciﬁed for the const basic_string<charT, traits, Allocator>& overload of the
quoted function.

The expression in >> quoted(s, delim, escape) shall have type basic_istream<charT, traits>&
and value in. The expression out << quoted(s, delim, escape) shall have type basic_ostream
<charT, traits>& and value out.

27.8 String-based streams
27.8.1 Overview

[string.streams]
[string.streams.overview]
1 The header <sstream> deﬁnes four class templates and eight types that associate stream buﬀers with objects

of class basic_string, as described in 21.3.
Header <sstream> synopsis

namespace std {

template <class charT, class traits = char_traits<charT>,

class Allocator = allocator<charT> >

class basic_stringbuf;

typedef basic_stringbuf<char>
stringbuf;
typedef basic_stringbuf<wchar_t> wstringbuf;

template <class charT, class traits = char_traits<charT>,

class Allocator = allocator<charT> >

class basic_istringstream;

typedef basic_istringstream<char>
istringstream;
typedef basic_istringstream<wchar_t> wistringstream;

template <class charT, class traits = char_traits<charT>,

class Allocator = allocator<charT> >

class basic_ostringstream;

typedef basic_ostringstream<char>
ostringstream;
typedef basic_ostringstream<wchar_t> wostringstream;

template <class charT, class traits = char_traits<charT>,

class Allocator = allocator<charT> >

class basic_stringstream;

stringstream;
typedef basic_stringstream<char>
typedef basic_stringstream<wchar_t> wstringstream;

}

§ 27.8.1

1069

c(cid:13) ISO/IEC

27.8.2 Class template basic_stringbuf

N4296

[stringbuf]

namespace std {

template <class charT, class traits = char_traits<charT>,

class Allocator = allocator<charT> >

class basic_stringbuf : public basic_streambuf<charT,traits> {
public:

typedef charT
char_type;
typedef typename traits::int_type int_type;
typedef typename traits::pos_type pos_type;
typedef typename traits::off_type off_type;
typedef traits
typedef Allocator

traits_type;
allocator_type;

// 27.8.2.1 Constructors:
explicit basic_stringbuf(ios_base::openmode which

= ios_base::in | ios_base::out);

explicit basic_stringbuf
(const basic_string<charT,traits,Allocator>& str,
ios_base::openmode which = ios_base::in | ios_base::out);
basic_stringbuf(const basic_stringbuf& rhs) = delete;
basic_stringbuf(basic_stringbuf&& rhs);

// 27.8.2.2 Assign and swap:
basic_stringbuf& operator=(const basic_stringbuf& rhs) = delete;
basic_stringbuf& operator=(basic_stringbuf&& rhs);
void swap(basic_stringbuf& rhs);

// 27.8.2.3 Get and set:
basic_string<charT,traits,Allocator> str() const;
void str(const basic_string<charT,traits,Allocator>& s);

protected:

// 27.8.2.4 Overridden virtual functions:
virtual int_type
virtual int_type
virtual int_type
virtual

underflow();
pbackfail(int_type c = traits::eof());
overflow (int_type c = traits::eof());

basic_streambuf<charT,traits>* setbuf(charT*, streamsize);

virtual pos_type seekoff(off_type off, ios_base::seekdir way,

virtual pos_type seekpos(pos_type sp,

ios_base::openmode which

= ios_base::in | ios_base::out);

ios_base::openmode which

= ios_base::in | ios_base::out);

private:

};

ios_base::openmode mode; // exposition only

template <class charT, class traits, class Allocator>
void swap(basic_stringbuf<charT, traits, Allocator>& x,
basic_stringbuf<charT, traits, Allocator>& y);

}

§ 27.8.2

1070

c(cid:13) ISO/IEC

N4296

1 The class basic_stringbuf is derived from basic_streambuf to associate possibly the input sequence and
possibly the output sequence with a sequence of arbitrary characters. The sequence can be initialized from,
or made available as, an object of class basic_string.

2 For the sake of exposition, the maintained data is presented here as:

(2.1)

—

ios_base::openmode mode, has in set if the input sequence can be read, and out set if the output
sequence can be written.

27.8.2.1 basic_stringbuf constructors
explicit basic_stringbuf(ios_base::openmode which =

ios_base::in | ios_base::out);

[stringbuf.cons]

1

2

3

4

5

(5.1)

(5.2)

(5.3)

(5.4)

(5.5)

(5.6)

(5.7)

(5.8)

(5.9)

(5.10)

(5.11)

Eﬀects: Constructs an object of class basic_stringbuf, initializing the base class with basic_-
streambuf() (27.6.3.1), and initializing mode with which.
Postcondition: str() == "".

explicit basic_stringbuf(const basic_string<charT,traits,Allocator>& s,

ios_base::openmode which = ios_base::in | ios_base::out);

Eﬀects: Constructs an object of class basic_stringbuf, initializing the base class with basic_-
streambuf() (27.6.3.1), and initializing mode with which. Then calls str(s).

basic_stringbuf(basic_stringbuf&& rhs);

Eﬀects: Move constructs from the rvalue rhs.
It is implementation-deﬁned whether the sequence
pointers in *this (eback(), gptr(), egptr(), pbase(), pptr(), epptr()) obtain the values which
rhs had. Whether they do or not, *this and rhs reference separate buﬀers (if any at all) after the
construction. The openmode, locale and any other state of rhs is also copied.
Postconditions: Let rhs_p refer to the state of rhs just prior to this construction and let rhs_a refer
to the state of rhs just after this construction.
—
—
—
—
—
—
—
—
—
—
—

str() == rhs_p.str()
gptr() - eback() == rhs_p.gptr() - rhs_p.eback()
egptr() - eback() == rhs_p.egptr() - rhs_p.eback()
pptr() - pbase() == rhs_p.pptr() - rhs_p.pbase()
epptr() - pbase() == rhs_p.epptr() - rhs_p.pbase()
if (eback()) eback() != rhs_a.eback()
if (gptr()) gptr() != rhs_a.gptr()
if (egptr()) egptr() != rhs_a.egptr()
if (pbase()) pbase() != rhs_a.pbase()
if (pptr()) pptr() != rhs_a.pptr()
if (epptr()) epptr() != rhs_a.epptr()

27.8.2.2 Assign and swap
basic_stringbuf& operator=(basic_stringbuf&& rhs);

[stringbuf.assign]

1

2

Eﬀects: After the move assignment *this has the observable state it would have had if it had been
move constructed from rhs (see 27.8.2.1).
Returns: *this.

void swap(basic_stringbuf& rhs);

§ 27.8.2.2

1071

c(cid:13) ISO/IEC

N4296

Eﬀects: Exchanges the state of *this and rhs.

template <class charT, class traits, class Allocator>
void swap(basic_stringbuf<charT, traits, Allocator>& x,
basic_stringbuf<charT, traits, Allocator>& y);

Eﬀects: x.swap(y).

27.8.2.3 Member functions
basic_string<charT,traits,Allocator> str() const;

[stringbuf.members]

Returns: A basic_string object whose content is equal to the basic_stringbuf underlying character
sequence.
If the basic_stringbuf was created only in input mode, the resultant basic_string
contains the character sequence in the range [eback(),egptr()). If the basic_stringbuf was created
with which & ios_base::out being true then the resultant basic_string contains the character
sequence in the range [pbase(),high_mark), where high_mark represents the position one past the
highest initialized character in the buﬀer. Characters can be initialized by writing to the stream,
by constructing the basic_stringbuf with a basic_string, or by calling the str(basic_string)
member function.
In the case of calling the str(basic_string) member function, all characters
initialized prior to the call are now considered uninitialized (except for those characters re-initialized
by the new basic_string). Otherwise the basic_stringbuf has been created in neither input nor
output mode and a zero length basic_string is returned.

void str(const basic_string<charT,traits,Allocator>& s);

Eﬀects: Copies the content of s into the basic_stringbuf underlying character sequence and initializes
the input and output sequences according to mode.
Postconditions: If mode & ios_base::out is true, pbase() points to the ﬁrst underlying character
and epptr() >= pbase() + s.size() holds; in addition, if mode & ios_base::ate is true, pptr()
== pbase() + s.size() holds, otherwise pptr() == pbase() is true. If mode & ios_base::in is
true, eback() points to the ﬁrst underlying character, and both gptr() == eback() and egptr() ==
eback() + s.size() hold.

27.8.2.4 Overridden virtual functions
int_type underflow();

[stringbuf.virtuals]

Returns: If the input sequence has a read position available, returns traits::to_int_type(*gptr()).
Otherwise, returns traits::eof(). Any character in the underlying buﬀer which has been initialized
is considered to be part of the input sequence.

int_type pbackfail(int_type c = traits::eof());

3

4

1

2

3

1

2

(2.1)

(2.2)

—

§ 27.8.2.4

Eﬀects: Puts back the character designated by c to the input sequence, if possible, in one of three
ways:
—

If traits::eq_int_type(c,traits::eof()) returns false and if the input sequence has a put-
back position available, and if traits::eq(to_char_type(c),gptr()[-1]) returns true, assigns
gptr() - 1 to gptr().
Returns: c.
If traits::eq_int_type(c,traits::eof()) returns false and if the input sequence has a put-
back position available, and if mode & ios_base::out is nonzero, assigns c to *--gptr().
Returns: c.

1072

(2.3)

3

4

5

(5.1)

(5.2)

6

7

8

9

c(cid:13) ISO/IEC

N4296

—

If traits::eq_int_type(c,traits::eof()) returns true and if the input sequence has a put-
back position available, assigns gptr() - 1 to gptr().
Returns: traits::not_eof(c).

Returns: traits::eof() to indicate failure.
Remarks: If the function can succeed in more than one of these ways, it is unspeciﬁed which way is
chosen.

int_type overflow(int_type c = traits::eof());

Eﬀects: Appends the character designated by c to the output sequence, if possible, in one of two ways:
If traits::eq_int_type(c,traits::eof()) returns false and if either the output sequence has
—
a write position available or the function makes a write position available (as described below),
the function calls sputc(c ).
Signals success by returning c.
If traits::eq_int_type(c,traits::eof()) returns true, there is no character to append.
Signals success by returning a value other than traits::eof().

—

Remarks: The function can alter the number of write positions available as a result of any call.
Returns: traits::eof() to indicate failure.
The function can make a write position available only if (mode & ios_base::out) != 0. To make a
write position available, the function reallocates (or initially allocates) an array object with a suﬃcient
number of elements to hold the current array object (if any), plus at least one additional write position.
If (mode & ios_base::in) != 0, the function alters the read end pointer egptr() to point just past
the new write position.

pos_type seekoff(off_type off, ios_base::seekdir way,

ios_base::openmode which

= ios_base::in | ios_base::out);

Eﬀects: Alters the stream position within one of the controlled sequences, if possible, as indicated in
Table 130.

Table 130 — seekoff positioning

Conditions

(which & ios_base::in) == ios_-
base::in
(which & ios_base::out) == ios_-
base::out
(which & (ios_base::in |
ios_base::out)) ==
(ios_base::in) |
ios_base::out))
and way == either
ios_base::beg or
ios_base::end
Otherwise

Result
positions the input sequence

positions the output sequence

positions both the input and the output sequences

the positioning operation fails.

10

For a sequence to be positioned, if its next pointer (either gptr() or pptr()) is a null pointer and
the new oﬀset newoff is nonzero, the positioning operation fails. Otherwise, the function determines
newoff as indicated in Table 131.

§ 27.8.2.4

1073

c(cid:13) ISO/IEC

N4296

Table 131 — newoff values

Condition

way == ios_base::beg
way == ios_base::cur

way == ios_base::end

newoff Value

0
the next pointer minus the begin-
ning pointer (xnext - xbeg).
the high mark pointer minus the
beginning pointer (high_mark -
xbeg).

11

12

13

14

15

16

If (newoff + off) < 0, or if newoff + off refers to an uninitialized character (as deﬁned in 27.8.2.3
paragraph 1), the positioning operation fails. Otherwise, the function assigns xbeg + newoff + off
to the next pointer xnext.
Returns: pos_type(newoff), constructed from the resultant oﬀset newoff (of type off_type), that
stores the resultant stream position, if possible. If the positioning operation fails, or if the constructed
object cannot represent the resultant stream position, the return value is pos_type(off_type(-1)).

pos_type seekpos(pos_type sp, ios_base::openmode which

= ios_base::in | ios_base::out);

Eﬀects: Equivalent to seekoff(off_type(sp), ios_base::beg, which).
Returns: sp to indicate success, or pos_type(off_type(-1)) to indicate failure.

basic_streambuf<charT,traits>* setbuf(charT* s, streamsize n);

Eﬀects: implementation-deﬁned, except that setbuf(0,0) has no eﬀect.
Returns: this.

27.8.3 Class template basic_istringstream

[istringstream]

namespace std {

template <class charT, class traits = char_traits<charT>,

class Allocator = allocator<charT> >

class basic_istringstream : public basic_istream<charT,traits> {
public:

char_type;
typedef charT
typedef typename traits::int_type int_type;
typedef typename traits::pos_type pos_type;
typedef typename traits::off_type off_type;
typedef traits
typedef Allocator

traits_type;
allocator_type;

// 27.8.3.1 Constructors:
explicit basic_istringstream(ios_base::openmode which = ios_base::in);
explicit basic_istringstream(

const basic_string<charT,traits,Allocator>& str,
ios_base::openmode which = ios_base::in);

basic_istringstream(const basic_istringstream& rhs) = delete;
basic_istringstream(basic_istringstream&& rhs);

// 27.8.3.2 Assign and swap:
basic_istringstream& operator=(const basic_istringstream& rhs) = delete;
basic_istringstream& operator=(basic_istringstream&& rhs);
void swap(basic_istringstream& rhs);

§ 27.8.3

1074

c(cid:13) ISO/IEC

N4296

// 27.8.3.3 Members:
basic_stringbuf<charT,traits,Allocator>* rdbuf() const;

basic_string<charT,traits,Allocator> str() const;
void str(const basic_string<charT,traits,Allocator>& s);

basic_stringbuf<charT,traits,Allocator> sb; // exposition only

private:

};

template <class charT, class traits, class Allocator>
void swap(basic_istringstream<charT, traits, Allocator>& x,
basic_istringstream<charT, traits, Allocator>& y);

}

1 The class basic_istringstream<charT, traits, Allocator> supports reading objects of class basic_-
It uses a basic_stringbuf<charT, traits, Allocator> object

string<charT, traits, Allocator>.
to control the associated storage. For the sake of exposition, the maintained data is presented here as:

(1.1)

—

sb, the stringbuf object.

27.8.3.1 basic_istringstream constructors
explicit basic_istringstream(ios_base::openmode which = ios_base::in);

[istringstream.cons]

Eﬀects: Constructs an object of class basic_istringstream<charT, traits>, initializing the base
class with basic_istream(&sb) and initializing sb with basic_stringbuf<charT, traits, Alloca-
tor>(which | ios_base::in)) (27.8.2.1).

explicit basic_istringstream(

const basic_string<charT, traits, Allocator>& str,
ios_base::openmode which = ios_base::in);

Eﬀects: Constructs an object of class basic_istringstream<charT, traits>, initializing the base
class with basic_istream(&sb) and initializing sb with basic_stringbuf<charT, traits, Alloca-
tor>(str, which | ios_base::in)) (27.8.2.1).

basic_istringstream(basic_istringstream&& rhs);

Eﬀects: Move constructs from the rvalue rhs. This is accomplished by move constructing the base
class, and the contained basic_stringbuf. Next basic_istream<charT,traits>::set_rdbuf(&sb)
is called to install the contained basic_stringbuf.

27.8.3.2 Assign and swap
basic_istringstream& operator=(basic_istringstream&& rhs);

[istringstream.assign]

Eﬀects: Move assigns the base and members of *this from the base and corresponding members of
rhs.
Returns: *this.

void swap(basic_istringstream& rhs);

Eﬀects: Exchanges the state of *this and rhs by calling basic_istream<charT,traits>::swap(rhs)
and sb.swap(rhs.sb).

1

2

3

1

2

3

template <class charT, class traits, class Allocator>
void swap(basic_istringstream<charT, traits, Allocator>& x,
basic_istringstream<charT, traits, Allocator>& y);

§ 27.8.3.2

1075

c(cid:13) ISO/IEC

Eﬀects: x.swap(y).

N4296

27.8.3.3 Member functions
basic_stringbuf<charT,traits,Allocator>* rdbuf() const;

[istringstream.members]

Returns: const_cast<basic_stringbuf<charT,traits,Allocator>*>(&sb).

basic_string<charT,traits,Allocator> str() const;

Returns: rdbuf()->str().

void str(const basic_string<charT,traits,Allocator>& s);

Eﬀects: Calls rdbuf()->str(s).

27.8.4 Class template basic_ostringstream

[ostringstream]

4

1

2

3

namespace std {

template <class charT, class traits = char_traits<charT>,

class Allocator = allocator<charT> >

class basic_ostringstream : public basic_ostream<charT,traits> {
public:

// types:
typedef charT
char_type;
typedef typename traits::int_type int_type;
typedef typename traits::pos_type pos_type;
typedef typename traits::off_type off_type;
typedef traits
typedef Allocator

traits_type;
allocator_type;

// 27.8.4.1 Constructors/destructor:
explicit basic_ostringstream(ios_base::openmode which = ios_base::out);
explicit basic_ostringstream(

const basic_string<charT,traits,Allocator>& str,
ios_base::openmode which = ios_base::out);

basic_ostringstream(const basic_ostringstream& rhs) = delete;
basic_ostringstream(basic_ostringstream&& rhs);

// 27.8.4.2 Assign/swap:
basic_ostringstream& operator=(const basic_ostringstream& rhs) = delete;
basic_ostringstream& operator=(basic_ostringstream&& rhs);
void swap(basic_ostringstream& rhs);

// 27.8.4.3 Members:
basic_stringbuf<charT,traits,Allocator>* rdbuf() const;

basic_string<charT,traits,Allocator> str() const;
void
private:
basic_stringbuf<charT,traits,Allocator> sb; // exposition only

str(const basic_string<charT,traits,Allocator>& s);

};

template <class charT, class traits, class Allocator>
void swap(basic_ostringstream<charT, traits, Allocator>& x,
basic_ostringstream<charT, traits, Allocator>& y);

}

§ 27.8.4

1076

c(cid:13) ISO/IEC

N4296

1 The class basic_ostringstream<charT, traits, Allocator> supports writing objects of class basic_-
string<charT, traits, Allocator>. It uses a basic_stringbuf object to control the associated storage.
For the sake of exposition, the maintained data is presented here as:

(1.1)

—

sb, the stringbuf object.

27.8.4.1 basic_ostringstream constructors
explicit basic_ostringstream(ios_base::openmode which = ios_base::out);

[ostringstream.cons]

Eﬀects: Constructs an object of class basic_ostringstream, initializing the base class with basic_-
ostream(&sb) and initializing sb with basic_stringbuf<charT, traits, Allocator>(which |
ios_base::out)) (27.8.2.1).

explicit basic_ostringstream(

const basic_string<charT,traits,Allocator>& str,
ios_base::openmode which = ios_base::out);

Eﬀects: Constructs an object of class basic_ostringstream<charT, traits>, initializing the base
class with basic_ostream(&sb) and initializing sb with basic_stringbuf<charT, traits, Alloca-
tor>(str, which | ios_base::out)) (27.8.2.1).

basic_ostringstream(basic_ostringstream&& rhs);

Eﬀects: Move constructs from the rvalue rhs. This is accomplished by move constructing the base
class, and the contained basic_stringbuf. Next basic_ostream<charT,traits>::set_rdbuf(&sb)
is called to install the contained basic_stringbuf.

27.8.4.2 Assign and swap
basic_ostringstream& operator=(basic_ostringstream&& rhs);

[ostringstream.assign]

Eﬀects: Move assigns the base and members of *this from the base and corresponding members of
rhs.
Returns: *this.

void swap(basic_ostringstream& rhs);

Eﬀects: Exchanges the state of *this and rhs by calling basic_ostream<charT,traits>::swap(rhs)
and sb.swap(rhs.sb).

template <class charT, class traits, class Allocator>
void swap(basic_ostringstream<charT, traits, Allocator>& x,
basic_ostringstream<charT, traits, Allocator>& y);

Eﬀects: x.swap(y).

27.8.4.3 Member functions
basic_stringbuf<charT,traits,Allocator>* rdbuf() const;

[ostringstream.members]

Returns: const_cast<basic_stringbuf<charT,traits,Allocator>*>(&sb).

basic_string<charT,traits,Allocator> str() const;

Returns: rdbuf()->str().

void str(const basic_string<charT,traits,Allocator>& s);

Eﬀects: Calls rdbuf()->str(s).

§ 27.8.4.3

1077

1

2

3

1

2

3

4

1

2

3

c(cid:13) ISO/IEC

27.8.5 Class template basic_stringstream

N4296

[stringstream]

namespace std {

template <class charT, class traits = char_traits<charT>,

class Allocator = allocator<charT> >

class basic_stringstream

: public basic_iostream<charT,traits> {

public:

// types:
typedef charT
char_type;
typedef typename traits::int_type int_type;
typedef typename traits::pos_type pos_type;
typedef typename traits::off_type off_type;
typedef traits
typedef Allocator

traits_type;
allocator_type;

// constructors/destructor
explicit basic_stringstream(
ios_base::openmode which = ios_base::out|ios_base::in);
explicit basic_stringstream(
const basic_string<charT,traits,Allocator>& str,
ios_base::openmode which = ios_base::out|ios_base::in);
basic_stringstream(const basic_stringstream& rhs) = delete;
basic_stringstream(basic_stringstream&& rhs);

// 27.8.5.2 Assign/swap:
basic_stringstream& operator=(const basic_stringstream& rhs) = delete;
basic_stringstream& operator=(basic_stringstream&& rhs);
void swap(basic_stringstream& rhs);

// Members:
basic_stringbuf<charT,traits,Allocator>* rdbuf() const;
basic_string<charT,traits,Allocator> str() const;
void str(const basic_string<charT,traits,Allocator>& str);

private:

};

basic_stringbuf<charT, traits> sb; // exposition only

template <class charT, class traits, class Allocator>
void swap(basic_stringstream<charT, traits, Allocator>& x,
basic_stringstream<charT, traits, Allocator>& y);

}

1 The class template basic_stringstream<charT, traits> supports reading and writing from objects of
class basic_string<charT, traits, Allocator>. It uses a basic_stringbuf<charT, traits, Alloca-
tor> object to control the associated sequence. For the sake of exposition, the maintained data is presented
here as

(1.1)

—

sb, the stringbuf object.

27.8.5.1 basic_stringstream constructors
explicit basic_stringstream(

ios_base::openmode which = ios_base::out|ios_base::in);

§ 27.8.5.1

[stringstream.cons]

1078

c(cid:13) ISO/IEC

N4296

Eﬀects: Constructs an object of class basic_stringstream<charT,traits>, initializing the base
class with basic_iostream(&sb) and initializing sb with basic_stringbuf<charT,traits,Alloca-
tor>(which).

explicit basic_stringstream(

const basic_string<charT,traits,Allocator>& str,
ios_base::openmode which = ios_base::out|ios_base::in);
Eﬀects: Constructs an object of class basic_stringstream<charT, traits>, initializing the base
class with basic_iostream(&sb) and initializing sb with basic_stringbuf<charT, traits, Alloca-
tor>(str, which).

basic_stringstream(basic_stringstream&& rhs);

Eﬀects: Move constructs from the rvalue rhs. This is accomplished by move constructing the base
class, and the contained basic_stringbuf. Next basic_istream<charT,traits>::set_rdbuf(&sb)
is called to install the contained basic_stringbuf.

27.8.5.2 Assign and swap
basic_stringstream& operator=(basic_stringstream&& rhs);

[stringstream.assign]

Eﬀects: Move assigns the base and members of *this from the base and corresponding members of
rhs.
Returns: *this.

void swap(basic_stringstream& rhs);

Eﬀects: Exchanges the state of *this and rhs by calling basic_iostream<charT,traits>::swap(rhs)
and sb.swap(rhs.sb).

template <class charT, class traits, class Allocator>
void swap(basic_stringstream<charT, traits, Allocator>& x,
basic_stringstream<charT, traits, Allocator>& y);

Eﬀects: x.swap(y).

27.8.5.3 Member functions
basic_stringbuf<charT,traits,Allocator>* rdbuf() const;

[stringstream.members]

Returns: const_cast<basic_stringbuf<charT,traits,Allocator>*>(&sb)

basic_string<charT,traits,Allocator> str() const;

Returns: rdbuf()->str().

void str(const basic_string<charT,traits,Allocator>& str);

Eﬀects: Calls rdbuf()->str(str).

1

2

3

1

2

3

4

1

2

3

27.9 File-based streams
27.9.1 File streams

[ﬁle.streams]
[fstreams]
1 The header <fstream> deﬁnes four class templates and eight types that associate stream buﬀers with ﬁles

and assist reading and writing ﬁles.
Header <fstream> synopsis

§ 27.9.1

1079

c(cid:13) ISO/IEC

N4296

namespace std {

template <class charT, class traits = char_traits<charT> >

class basic_filebuf;

typedef basic_filebuf<char>
filebuf;
typedef basic_filebuf<wchar_t> wfilebuf;

template <class charT, class traits = char_traits<charT> >

class basic_ifstream;

typedef basic_ifstream<char>
ifstream;
typedef basic_ifstream<wchar_t> wifstream;

template <class charT, class traits = char_traits<charT> >

class basic_ofstream;

typedef basic_ofstream<char>
ofstream;
typedef basic_ofstream<wchar_t> wofstream;

template <class charT, class traits = char_traits<charT> >

class basic_fstream;

fstream;
typedef basic_fstream<char>
typedef basic_fstream<wchar_t> wfstream;

}

2

3

In this subclause, the type name FILE refers to the type FILE declared in <cstdio> (27.9.2).
[ Note: The class template basic_filebuf treats a ﬁle as a source or sink of bytes. In an environment that
uses a large character set, the ﬁle typically holds multibyte character sequences and the basic_filebuf
object converts those multibyte sequences into wide character sequences. — end note ]
27.9.1.1 Class template basic_filebuf

[ﬁlebuf]

namespace std {

template <class charT, class traits = char_traits<charT> >
class basic_filebuf : public basic_streambuf<charT,traits> {
public:

typedef charT
char_type;
typedef typename traits::int_type int_type;
typedef typename traits::pos_type pos_type;
typedef typename traits::off_type off_type;
typedef traits

traits_type;

// 27.9.1.2 Constructors/destructor:
basic_filebuf();
basic_filebuf(const basic_filebuf& rhs) = delete;
basic_filebuf(basic_filebuf&& rhs);
virtual ~basic_filebuf();

// 27.9.1.3 Assign/swap:
basic_filebuf& operator=(const basic_filebuf& rhs) = delete;
basic_filebuf& operator=(basic_filebuf&& rhs);
void swap(basic_filebuf& rhs);

// 27.9.1.4 Members:
bool is_open() const;
basic_filebuf<charT,traits>* open(const char* s,

ios_base::openmode mode);

basic_filebuf<charT,traits>* open(const string& s,

§ 27.9.1.1

1080

c(cid:13) ISO/IEC

N4296

ios_base::openmode mode);

basic_filebuf<charT,traits>* close();

protected:

// 27.9.1.5 Overridden virtual functions:
virtual streamsize showmanyc();
virtual int_type underflow();
virtual int_type uflow();
virtual int_type pbackfail(int_type c = traits::eof());
virtual int_type overflow (int_type c = traits::eof());

virtual basic_streambuf<charT,traits>*
setbuf(char_type* s, streamsize n);

virtual pos_type seekoff(off_type off, ios_base::seekdir way,
ios_base::openmode which = ios_base::in | ios_base::out);

virtual pos_type seekpos(pos_type sp,

ios_base::openmode which = ios_base::in | ios_base::out);

virtual int
virtual void

sync();
imbue(const locale& loc);

};

template <class charT, class traits>
void swap(basic_filebuf<charT, traits>& x,
basic_filebuf<charT, traits>& y);

}

1 The class basic_filebuf<charT,traits> associates both the input sequence and the output sequence with

a ﬁle.

2 The restrictions on reading and writing a sequence controlled by an object of class basic_filebuf<charT,

traits> are the same as for reading and writing with the Standard C library FILEs.
In particular:

—
—
—

If the ﬁle is not open for reading the input sequence cannot be read.
If the ﬁle is not open for writing the output sequence cannot be written.
A joint ﬁle position is maintained for both the input sequence and the output sequence.

3

(3.1)

(3.2)

(3.3)

5

1

2

4 An instance of basic_filebuf behaves as described in 27.9.1.1 provided traits::pos_type is fpos<traits

::state_type>. Otherwise the behavior is undeﬁned.
In order to support ﬁle I/O and multibyte/wide character conversion, conversions are performed using
members of a facet, referred to as a_codecvt in following sections, obtained as if by

const codecvt<charT,char,typename traits::state_type>& a_codecvt =

use_facet<codecvt<charT,char,typename traits::state_type> >(getloc());

27.9.1.2 basic_filebuf constructors
basic_filebuf();

[ﬁlebuf.cons]

Eﬀects: Constructs an object of class basic_filebuf<charT,traits>, initializing the base class with
basic_streambuf<charT,traits>() (27.6.3.1).
Postcondition: is_open() == false.

basic_filebuf(basic_filebuf&& rhs);

§ 27.9.1.2

1081

c(cid:13) ISO/IEC

N4296

It is implementation-deﬁned whether the sequence
Eﬀects: Move constructs from the rvalue rhs.
pointers in *this (eback(), gptr(), egptr(), pbase(), pptr(), epptr()) obtain the values which
rhs had. Whether they do or not, *this and rhs reference separate buﬀers (if any at all) after the
construction. Additionally *this references the ﬁle which rhs did before the construction, and rhs
references no ﬁle after the construction. The openmode, locale and any other state of rhs is also
copied.
Postconditions: Let rhs_p refer to the state of rhs just prior to this construction and let rhs_a refer
to the state of rhs just after this construction.
—
—
—
—
—
—
—
—
—
—
—
—

is_open() == rhs_p.is_open()
rhs_a.is_open() == false
gptr() - eback() == rhs_p.gptr() - rhs_p.eback()
egptr() - eback() == rhs_p.egptr() - rhs_p.eback()
pptr() - pbase() == rhs_p.pptr() - rhs_p.pbase()
epptr() - pbase() == rhs_p.epptr() - rhs_p.pbase()
if (eback()) eback() != rhs_a.eback()
if (gptr()) gptr() != rhs_a.gptr()
if (egptr()) egptr() != rhs_a.egptr()
if (pbase()) pbase() != rhs_a.pbase()
if (pptr()) pptr() != rhs_a.pptr()
if (epptr()) epptr() != rhs_a.epptr()

virtual ~basic_filebuf();

Eﬀects: Destroys an object of class basic_filebuf<charT,traits>. Calls close(). If an exception
occurs during the destruction of the object, including the call to close(), the exception is caught but
not rethrown (see 17.6.5.12).

27.9.1.3 Assign and swap
basic_filebuf& operator=(basic_filebuf&& rhs);

[ﬁlebuf.assign]

Eﬀects: Calls this->close() then move assigns from rhs. After the move assignment *this has the
observable state it would have had if it had been move constructed from rhs (see 27.9.1.2).
Returns: *this.

void swap(basic_filebuf& rhs);

Eﬀects: Exchanges the state of *this and rhs.

template <class charT, class traits>
void swap(basic_filebuf<charT, traits>& x,
basic_filebuf<charT, traits>& y);

Eﬀects: x.swap(y).

3

4

(4.1)

(4.2)

(4.3)

(4.4)

(4.5)

(4.6)

(4.7)

(4.8)

(4.9)

(4.10)

(4.11)

(4.12)

5

1

2

3

4

§ 27.9.1.3

1082

1

2

3

4

5

c(cid:13) ISO/IEC

27.9.1.4 Member functions
bool is_open() const;

N4296

[ﬁlebuf.members]

Returns: true if a previous call to open succeeded (returned a non-null value) and there has been no
intervening call to close.

basic_filebuf<charT,traits>* open(const char* s,

ios_base::openmode mode);
Eﬀects: If is_open() != false, returns a null pointer. Otherwise, initializes the filebuf as required.
It then opens a ﬁle, if possible, whose name is the ntbs s (as if by calling std::fopen(s,modstr)).
The ntbs modstr is determined from mode & ~ios_base::ate as indicated in Table 132. If mode is
not some combination of ﬂags shown in the table then the open fails.

Table 132 — File open modes

ios_base ﬂag combination

stdio equivalent

binary

in

trunc

app

out
+
+

+

+

+

+

+

+
+
+

+
+

+

+
+
+

+
+
+
+
+

+
+
+
+
+

+
+
+
+
+
+
+
+
+

"w"
"a"
"a"
"w"
"r"
"r+"
"w+"
"a+"
"a+"
"wb"
"ab"
"ab"
"wb"
"rb"
"r+b"
"w+b"
"a+b"
"a+b"

+
+

+
+

+
+

+
+

If the open operation succeeds and (mode & ios_base::ate) != 0, positions the ﬁle to the end (as
if by calling std::fseek(file,0,SEEK_END)).334
If the repositioning operation fails, calls close() and returns a null pointer to indicate failure.
Returns: this if successful, a null pointer otherwise.

basic_filebuf<charT,traits>* open(const string& s,

ios_base::openmode mode);
Returns: open(s.c_str(), mode);

basic_filebuf<charT,traits>* close();

334) The macro SEEK_END is deﬁned, and the function signatures fopen(const char*, const char*) and fseek(FILE*, long,
int) are declared, in <cstdio> (27.9.2).

§ 27.9.1.4

1083

6

7

8

1

2

3

4

5

(5.1)

c(cid:13) ISO/IEC

N4296

Eﬀects: If is_open() == false, returns a null pointer. If a put area exists, calls overflow(traits::
eof()) to ﬂush characters. If the last virtual member function called on *this (between underflow,
overflow, seekoff, and seekpos) was overflow then calls a_codecvt.unshift (possibly several
times) to determine a termination sequence, inserts those characters and calls overflow(traits::
eof()) again. Finally, regardless of whether any of the preceding calls fails or throws an exception,
the function closes the ﬁle (as if by calling std::fclose(file)).335 If any of the calls made by the
function, including std::fclose, fails, close fails by returning a null pointer. If one of these calls
throws an exception, the exception is caught and rethrown after closing the ﬁle.
Returns: this on success, a null pointer otherwise.
Postcondition: is_open() == false.
27.9.1.5 Overridden virtual functions
streamsize showmanyc();

[ﬁlebuf.virtuals]

Eﬀects: Behaves the same as basic_streambuf::showmanyc() (27.6.3.4).
Remarks: An implementation might well provide an overriding deﬁnition for this function signature if
it can determine that more characters can be read from the input sequence.

int_type underflow();

Eﬀects: Behaves according to the description of basic_streambuf<charT,traits>::underflow(),
with the specialization that a sequence of characters is read from the input sequence as if by reading
from the associated ﬁle into an internal buﬀer ( extern_buf) and then as if by doing

extern_buf[XSIZE];
extern_end;
intern_buf[ISIZE];

char
char*
charT
charT* intern_end;
codecvt_base::result r =

a_codecvt.in(state, extern_buf, extern_buf+XSIZE, extern_end,

intern_buf, intern_buf+ISIZE, intern_end);

This shall be done in such a way that the class can recover the position (fpos_t) corresponding to
each character between intern_buf and intern_end. If the value of r indicates that a_codecvt.in()
ran out of space in intern_buf, retry with a larger intern_buf.

int_type uflow();

Eﬀects: Behaves according to the description of basic_streambuf<charT,traits>::uflow(), with
the specialization that a sequence of characters is read from the input with the same method as used
by underflow.

int_type pbackfail(int_type c = traits::eof());

Eﬀects: Puts back the character designated by c to the input sequence, if possible, in one of three
ways:
—

If traits::eq_int_type(c,traits::eof()) returns false and if the function makes a putback
position available and if traits::eq(to_char_type(c),gptr()[-1]) returns true, decrements
the next pointer for the input sequence, gptr().
Returns: c.

335) The function signature fclose(FILE*) is declared in <cstdio> (27.9.2).

§ 27.9.1.5

1084

(5.2)

(5.3)

6

7

8

9

10

(10.1)

(10.2)

(10.3)

(10.4)

11

12

13

c(cid:13) ISO/IEC

N4296

—

—

If traits::eq_int_type(c,traits::eof()) returns false and if the function makes a putback
position available and if the function is permitted to assign to the putback position, decrements
the next pointer for the input sequence, and stores c there.
Returns: c.
If traits::eq_int_type(c,traits::eof()) returns true, and if either the input sequence has
a putback position available or the function makes a putback position available, decrements the
next pointer for the input sequence, gptr().
Returns: traits::not_eof(c).

Returns: traits::eof() to indicate failure.
Remarks: If is_open() == false, the function always fails.
The function does not put back a character directly to the input sequence.
If the function can succeed in more than one of these ways, it is unspeciﬁed which way is chosen. The
function can alter the number of putback positions available as a result of any call.

int_type overflow(int_type c = traits::eof());

Eﬀects: Behaves according to the description of basic_streambuf<charT,traits>::overflow(c),
except that the behavior of “consuming characters” is performed by ﬁrst converting as if by:

charT* b = pbase();
charT* p = pptr();
charT* end;
char
char*
codecvt_base::result r =

xbuf[XSIZE];
xbuf_end;

a_codecvt.out(state, b, p, end, xbuf, xbuf+XSIZE, xbuf_end);

and then
—
—
—

—

If r == codecvt_base::error then fail.
If r == codecvt_base::noconv then output characters from b up to (and not including) p.
If r == codecvt_base::partial then output to the ﬁle characters from xbuf up to xbuf_end,
and repeat using characters from end to p. If output fails, fail (without repeating).
Otherwise output from xbuf to xbuf_end, and fail if output fails. At this point if b != p and b
== end (xbuf isn’t large enough) then increase XSIZE and repeat from the beginning.

Returns: traits::not_eof(c) to indicate success, and traits::eof() to indicate failure. If is_-
open() == false, the function always fails.

basic_streambuf* setbuf(char_type* s, streamsize n);

Eﬀects: If setbuf(0,0) is called on a stream before any I/O has occurred on that stream, the stream
becomes unbuﬀered. Otherwise the results are implementation-deﬁned. “Unbuﬀered” means that
pbase() and pptr() always return null and output to the ﬁle should appear as soon as possible.

pos_type seekoff(off_type off, ios_base::seekdir way,

ios_base::openmode which = ios_base::in | ios_base::out);
Eﬀects: Let width denote a_codecvt.encoding(). If is_open() == false, or off != 0 && width
<= 0, then the positioning operation fails. Otherwise, if way != basic_ios::cur or off != 0, and if
the last operation was output, then update the output sequence and write any unshift sequence. Next,

§ 27.9.1.5

1085

c(cid:13) ISO/IEC

N4296

if width > 0, call std::fseek(file, width * off, whence), otherwise

seek to the new position:
call std::fseek(file, 0, whence).
Remarks: “The last operation was output” means either the last virtual operation was overﬂow or
the put buﬀer is non-empty. “Write any unshift sequence” means, if width if less than zero then
call a_codecvt.unshift(state, xbuf, xbuf+XSIZE, xbuf_end) and output the resulting unshift
sequence. The function determines one of three values for the argument whence, of type int, as
indicated in Table 133.

Table 133 — seekoff eﬀects

way Value

basic_ios::beg
basic_ios::cur
basic_ios::end

stdio Equivalent
SEEK_SET
SEEK_CUR
SEEK_END

Returns: A newly constructed pos_type object that stores the resultant stream position, if possible. If
the positioning operation fails, or if the object cannot represent the resultant stream position, returns
pos_type(off_type(-1)).

pos_type seekpos(pos_type sp,

ios_base::openmode which = ios_base::in | ios_base::out);
Alters the ﬁle position, if possible, to correspond to the position stored in sp (as described below).
Altering the ﬁle position performs as follows:

1. if (om & ios_base::out) != 0, then update the output sequence and write any unshift sequence;
2. set the ﬁle position to sp;
3. if (om & ios_base::in) != 0, then update the input sequence;

where om is the open mode passed to the last call to open(). The operation fails if is_open() returns
false.
If sp is an invalid stream position, or if the function positions neither sequence, the positioning opera-
tion fails. If sp has not been obtained by a previous successful call to one of the positioning functions
(seekoff or seekpos) on the same ﬁle the eﬀects are undeﬁned.
Returns: sp on success. Otherwise returns pos_type(off_type(-1)).

int sync();

Eﬀects: If a put area exists, calls filebuf::overflow to write the characters to the ﬁle. If a get area
exists, the eﬀect is implementation-deﬁned.

void imbue(const locale& loc);

If the ﬁle is not positioned at its beginning and the encoding of the current locale as
Requires:
determined by a_codecvt.encoding() is state-dependent (22.4.1.4.2) then that facet is the same as
the corresponding facet of loc.
Eﬀects: Causes characters inserted or extracted after this call to be converted according to loc until
another call of imbue.
Remark: This may require reconversion of previously converted characters. This in turn may require
the implementation to be able to reconstruct the original contents of the ﬁle.

§ 27.9.1.5

1086

14

15

16

17

18

19

20

21

22

c(cid:13) ISO/IEC

27.9.1.6 Class template basic_ifstream

N4296

[ifstream]

namespace std {

template <class charT, class traits = char_traits<charT> >
class basic_ifstream : public basic_istream<charT,traits> {
public:

typedef charT
char_type;
typedef typename traits::int_type int_type;
typedef typename traits::pos_type pos_type;
typedef typename traits::off_type off_type;
typedef traits

traits_type;

// 27.9.1.7 Constructors:
basic_ifstream();
explicit basic_ifstream(const char* s,

ios_base::openmode mode = ios_base::in);

explicit basic_ifstream(const string& s,

ios_base::openmode mode = ios_base::in);

basic_ifstream(const basic_ifstream& rhs) = delete;
basic_ifstream(basic_ifstream&& rhs);

// 27.9.1.8 Assign/swap:
basic_ifstream& operator=(const basic_ifstream& rhs) = delete;
basic_ifstream& operator=(basic_ifstream&& rhs);
void swap(basic_ifstream& rhs);

// 27.9.1.9 Members:
basic_filebuf<charT,traits>* rdbuf() const;

bool is_open() const;
void open(const char* s, ios_base::openmode mode = ios_base::in);
void open(const string& s, ios_base::openmode mode = ios_base::in);
void close();

private:

};

basic_filebuf<charT,traits> sb; // exposition only

template <class charT, class traits>
void swap(basic_ifstream<charT, traits>& x,
basic_ifstream<charT, traits>& y);

}

1 The class basic_ifstream<charT, traits> supports reading from named ﬁles. It uses a basic_filebuf<
charT, traits> object to control the associated sequence. For the sake of exposition, the maintained data
is presented here as:

(1.1)

—

sb, the filebuf object.

27.9.1.7 basic_ifstream constructors
basic_ifstream();

[ifstream.cons]

1

Eﬀects: Constructs an object of class basic_ifstream<charT,traits>, initializing the base class
with basic_istream(&sb) and initializing sb with basic_filebuf<charT,traits>()) (27.7.2.1.1,
27.9.1.2).

explicit basic_ifstream(const char* s,

§ 27.9.1.7

1087

c(cid:13) ISO/IEC

N4296

ios_base::openmode mode = ios_base::in);
Eﬀects: Constructs an object of class basic_ifstream,
initializing the base class with basic_-
istream(&sb) and initializing sb with basic_filebuf<charT, traits>()) (27.7.2.1.1, 27.9.1.2),
then calls rdbuf()->open(s, mode | ios_base::in). If that function returns a null pointer, calls
setstate(failbit).

explicit basic_ifstream(const string& s,

ios_base::openmode mode = ios_base::in);
Eﬀects: the same as basic_ifstream(s.c_str(), mode).

basic_ifstream(basic_ifstream&& rhs);

Eﬀects: Move constructs from the rvalue rhs. This is accomplished by move constructing the base
class, and the contained basic_filebuf. Next basic_istream<charT,traits>::set_rdbuf(&sb) is
called to install the contained basic_filebuf.

27.9.1.8 Assign and swap
basic_ifstream& operator=(basic_ifstream&& rhs);

[ifstream.assign]

Eﬀects: Move assigns the base and members of *this from the base and corresponding members of
rhs.
Returns: *this.

void swap(basic_ifstream& rhs);

Eﬀects: Exchanges the state of *this and rhs by calling basic_istream<charT,traits>::swap(rhs)
and sb.swap(rhs.sb).

template <class charT, class traits>
void swap(basic_ifstream<charT, traits>& x,
basic_ifstream<charT, traits>& y);

Eﬀects: x.swap(y).

27.9.1.9 Member functions
basic_filebuf<charT,traits>* rdbuf() const;

Returns: const_cast<basic_filebuf<charT,traits>*>(&sb).

bool is_open() const;

Returns: rdbuf()->is_open().

[ifstream.members]

void open(const char* s, ios_base::openmode mode = ios_base::in);

Eﬀects: Calls rdbuf()->open(s, mode | ios_base::in).
If that function does not return a null
pointer calls clear(), otherwise calls setstate(failbit) (which may throw ios_base::failure
(27.5.5.4)).

void open(const string& s, ios_base::openmode mode = ios_base::in);

Eﬀects: calls open(s.c_str(), mode).

void close();

Eﬀects: Calls rdbuf()->close() and, if that function returns a null pointer, calls setstate(failbit)
(which may throw ios_base::failure (27.5.5.4)).

§ 27.9.1.9

1088

2

3

4

1

2

3

4

1

2

3

4

5

c(cid:13) ISO/IEC

27.9.1.10 Class template basic_ofstream

N4296

[ofstream]

namespace std {

template <class charT, class traits = char_traits<charT> >
class basic_ofstream : public basic_ostream<charT,traits> {
public:

typedef charT
char_type;
typedef typename traits::int_type int_type;
typedef typename traits::pos_type pos_type;
typedef typename traits::off_type off_type;
typedef traits

traits_type;

// 27.9.1.11 Constructors:
basic_ofstream();
explicit basic_ofstream(const char* s,

ios_base::openmode mode = ios_base::out);

explicit basic_ofstream(const string& s,

ios_base::openmode mode = ios_base::out);

basic_ofstream(const basic_ofstream& rhs) = delete;
basic_ofstream(basic_ofstream&& rhs);

// 27.9.1.12 Assign/swap:
basic_ofstream& operator=(const basic_ofstream& rhs) = delete;
basic_ofstream& operator=(basic_ofstream&& rhs);
void swap(basic_ofstream& rhs);

// 27.9.1.13 Members:
basic_filebuf<charT,traits>* rdbuf() const;

bool is_open() const;
void open(const char* s, ios_base::openmode mode = ios_base::out);
void open(const string& s, ios_base::openmode mode = ios_base::out);
void close();

private:

};

basic_filebuf<charT,traits> sb; // exposition only

template <class charT, class traits>
void swap(basic_ofstream<charT, traits>& x,
basic_ofstream<charT, traits>& y);

}

1 The class basic_ofstream<charT, traits> supports writing to named ﬁles. It uses a basic_filebuf<
charT, traits> object to control the associated sequence. For the sake of exposition, the maintained data
is presented here as:

(1.1)

—

sb, the filebuf object.

27.9.1.11 basic_ofstream constructors
basic_ofstream();

[ofstream.cons]

1

Eﬀects: Constructs an object of class basic_ofstream<charT,traits>, initializing the base class with
basic_ostream(&sb) and initializing sb with basic_filebuf<charT,traits>()) (27.7.3.2, 27.9.1.2).

explicit basic_ofstream(const char* s,

ios_base::openmode mode = ios_base::out);

§ 27.9.1.11

1089

c(cid:13) ISO/IEC

N4296

Eﬀects: Constructs an object of class basic_ofstream<charT,traits>, initializing the base class with
basic_ostream(&sb) and initializing sb with basic_filebuf<charT,traits>()) (27.7.3.2, 27.9.1.2),
then calls rdbuf()->open(s, mode|ios_base::out).
If that function returns a null pointer, calls
setstate(failbit).

explicit basic_ofstream(const string& s,

ios_base::openmode mode = ios_base::out);
Eﬀects: the same as basic_ofstream(s.c_str(), mode);

basic_ofstream(basic_ofstream&& rhs);

Eﬀects: Move constructs from the rvalue rhs. This is accomplished by move constructing the base
class, and the contained basic_filebuf. Next basic_ostream<charT,traits>::set_rdbuf(&sb) is
called to install the contained basic_filebuf.

27.9.1.12 Assign and swap
basic_ofstream& operator=(basic_ofstream&& rhs);

[ofstream.assign]

Eﬀects: Move assigns the base and members of *this from the base and corresponding members of
rhs.
Returns: *this.

void swap(basic_ofstream& rhs);

Eﬀects: Exchanges the state of *this and rhs by calling basic_ostream<charT,traits>::swap(rhs)
and sb.swap(rhs.sb).

template <class charT, class traits>
void swap(basic_ofstream<charT, traits>& x,
basic_ofstream<charT, traits>& y);

Eﬀects: x.swap(y).

27.9.1.13 Member functions
basic_filebuf<charT,traits>* rdbuf() const;

Returns: const_cast<basic_filebuf<charT,traits>*>(&sb).

bool is_open() const;

Returns: rdbuf()->is_open().

[ofstream.members]

void open(const char* s, ios_base::openmode mode = ios_base::out);

Eﬀects: Calls rdbuf()->open(s, mode | ios_base::out). If that function does not return a null
pointer calls clear(), otherwise calls setstate(failbit) (which may throw ios_base::failure
(27.5.5.4)).

void close();

Eﬀects: Calls rdbuf()->close() and, if that function fails (returns a null pointer), calls setstate(
failbit) (which may throw ios_base::failure (27.5.5.4)).

void open(const string& s, ios_base::openmode mode = ios_base::out);

Eﬀects: calls open(s.c_str(), mode);

§ 27.9.1.13

1090

2

3

4

1

2

3

4

1

2

3

4

5

c(cid:13) ISO/IEC

27.9.1.14 Class template basic_fstream

N4296

[fstream]

namespace std {

template <class charT, class traits=char_traits<charT> >
class basic_fstream

: public basic_iostream<charT,traits> {

public:

typedef charT
char_type;
typedef typename traits::int_type int_type;
typedef typename traits::pos_type pos_type;
typedef typename traits::off_type off_type;
typedef traits

traits_type;

// constructors/destructor
basic_fstream();
explicit basic_fstream(const char* s,

ios_base::openmode mode = ios_base::in|ios_base::out);

explicit basic_fstream(const string& s,

ios_base::openmode mode = ios_base::in|ios_base::out);

basic_fstream(const basic_fstream& rhs) = delete;
basic_fstream(basic_fstream&& rhs);

// 27.9.1.16 Assign/swap:
basic_fstream& operator=(const basic_fstream& rhs) = delete;
basic_fstream& operator=(basic_fstream&& rhs);
void swap(basic_fstream& rhs);

// Members:
basic_filebuf<charT,traits>* rdbuf() const;
bool is_open() const;
void open(const char* s,

void close();

ios_base::openmode mode = ios_base::in|ios_base::out);

void open(const string& s,

ios_base::openmode mode = ios_base::in|ios_base::out);

private:

};

basic_filebuf<charT,traits> sb; // exposition only

template <class charT, class traits>
void swap(basic_fstream<charT, traits>& x,
basic_fstream<charT, traits>& y);

}

1 The class template basic_fstream<charT,traits> supports reading and writing from named ﬁles. It uses
a basic_filebuf<charT,traits> object to control the associated sequences. For the sake of exposition,
the maintained data is presented here as:

(1.1)

—

sb, the basic_filebuf object.

27.9.1.15 basic_fstream constructors
basic_fstream();

§ 27.9.1.15

[fstream.cons]

1091

c(cid:13) ISO/IEC

N4296

Eﬀects: Constructs an object of class basic_fstream<charT,traits>, initializing the base class with
basic_iostream(&sb) and initializing sb with basic_filebuf<charT,traits>().

explicit basic_fstream(const char* s,

ios_base::openmode mode = ios_base::in|ios_base::out);
Eﬀects: Constructs an object of class basic_fstream<charT, traits>, initializing the base class
with basic_iostream(&sb) and initializing sb with basic_filebuf<charT, traits>(). Then calls
rdbuf()->open(s, mode). If that function returns a null pointer, calls setstate(failbit).

explicit basic_fstream(const string& s,

ios_base::openmode mode = ios_base::in|ios_base::out);
Eﬀects: the same as basic_fstream(s.c_str(), mode);

basic_fstream(basic_fstream&& rhs);

Eﬀects: Move constructs from the rvalue rhs. This is accomplished by move constructing the base
class, and the contained basic_filebuf. Next basic_istream<charT,traits>::set_rdbuf(&sb) is
called to install the contained basic_filebuf.

27.9.1.16 Assign and swap
basic_fstream& operator=(basic_fstream&& rhs);

[fstream.assign]

Eﬀects: Move assigns the base and members of *this from the base and corresponding members of
rhs.
Returns: *this.

void swap(basic_fstream& rhs);

Eﬀects: Exchanges the state of *this and rhs by calling basic_iostream<charT,traits>::swap(rhs)
and sb.swap(rhs.sb).

template <class charT, class traits>
void swap(basic_fstream<charT, traits>& x,
basic_fstream<charT, traits>& y);

Eﬀects: x.swap(y).

27.9.1.17 Member functions
basic_filebuf<charT,traits>* rdbuf() const;

Returns: const_cast<basic_filebuf<charT,traits>*>(&sb).

bool is_open() const;

Returns: rdbuf()->is_open().

[fstream.members]

void open(const char* s,

ios_base::openmode mode = ios_base::in|ios_base::out);
Eﬀects: Calls rdbuf()->open(s,mode). If that function does not return a null pointer calls clear(),
otherwise calls setstate(failbit), (which may throw ios_base::failure) (27.5.5.4).

void open(const string& s,

ios_base::openmode mode = ios_base::in|ios_base::out);
Eﬀects: calls open(s.c_str(), mode);

§ 27.9.1.17

1092

1

2

3

4

1

2

3

4

1

2

3

4

c(cid:13) ISO/IEC

void close();

N4296

5

Eﬀects: Calls rdbuf()->close() and, if that function returns returns a null pointer, calls setstate(
failbit) (27.5.5.4) (which may throw ios_base::failure).

27.9.2 C library ﬁles

[c.ﬁles]

1 Table 134 describes header <cstdio>. [ Note: C++ does not deﬁne the function gets. — end note ]

Type
Macros:
BUFSIZ
EOF
FILENAME_MAX
Types:
Functions:
clearerr
fclose
feof
ferror
fflush
fgetc
fgetpos
fgets

Table 134 — Header <cstdio> synopsis

Name(s)

FOPEN_MAX
L_tmpnam
NULL <cstdio>
FILE

SEEK_CUR
SEEK_END
SEEK_SET
fpos_t

TMP_MAX
_IOFBF
_IOLBF
size_t <cstdio>

_IONBF
stderr
stdin

stdout

fopen
fprintf
fputc
fputs
fread
freopen
fscanf
fseek

fsetpos
ftell
fwrite
getc
getchar
perror
printf
putc

putchar
puts
remove
rename
rewind
scanf
setbuf
setvbuf

vscanf
vsnprintf
vsprintf
vsscanf

snprintf
sprintf
sscanf
tmpfile
tmpnam
ungetc
vfprintf
vprintf

2 Calls to the function tmpnam with an argument of NULL may introduce a data race (17.6.5.9) with other calls

to tmpnam with an argument of NULL.
See also: ISO C 7.9, Amendment 1 4.6.2.

3 Table 135 describes header <cinttypes>. [ Note: The macros deﬁned by <cinttypes> are provided uncon-
ditionally. In particular, the symbol __STDC_FORMAT_MACROS, mentioned in footnote 182 of the C standard,
plays no role in C++. — end note ]

Table 135 — Header <cinttypes> synopsis
Type
Macros:
PRI{d i o u x X}[FAST LEAST]{8 16 32 64}
PRI{d i o u x X}{MAX PTR}
SCN{d i o u x X}[FAST LEAST]{8 16 32 64}
SCN{d i o u x X}{MAX PTR}
Types:
Functions:
abs
div

strtoimax
strtoumax

wcstoimax
wcstoumax

Name(s)

imaxdiv_t

imaxabs
imaxdiv

4 The contents of header <cinttypes> are the same as the Standard C Library header <inttypes.h>, with

the following changes:

(4.1)

—

the header <cinttypes> includes the header <cstdint> instead of <stdint.h>, and

§ 27.9.2

1093

c(cid:13) ISO/IEC

N4296

(4.2)

—

if and only if the type intmax_t designates an extended integer type (3.9.1), the following function
signatures are added:

intmax_t abs(intmax_t);
imaxdiv_t div(intmax_t, intmax_t);

which shall have the same semantics as the function signatures intmax_t imaxabs(intmax_t) and
imaxdiv_t imaxdiv(intmax_t, intmax_t), respectively.

§ 27.9.2

1094

c(cid:13) ISO/IEC

N4296

28 Regular expressions library
28.1 General

[re]
[re.general]
1 This Clause describes components that C++ programs may use to perform operations involving regular

expression matching and searching.

2 The following subclauses describe a basic regular expression class template and its traits that can handle
char-like template arguments, two specializations of this class template that handle sequences of char and
wchar_t, a class template that holds the result of a regular expression match, a series of algorithms that allow
a character sequence to be operated upon by a regular expression, and two iterator types for enumerating
regular expression matches, as described in Table 136.

Table 136 — Regular expressions library summary
Header(s)

Subclause

Deﬁnitions
Requirements
Constants
Exception type
Traits
Regular expression template
Submatches

28.2
28.3
28.5
28.6
28.7
28.8
28.9
28.10 Match results
28.11 Algorithms
28.12
Iterators
28.13 Grammar

<regex>

28.2 Deﬁnitions

1 The following deﬁnitions shall apply to this Clause:

[re.def]

28.2.1
collating element
a sequence of one or more characters within the current locale that collate as if they were a single character.

[defns.regex.collating.element]

28.2.2
ﬁnite state machine
an unspeciﬁed data structure that is used to represent a regular expression, and which permits eﬃcient
matches against the regular expression to be obtained.

[defns.regex.ﬁnite.state.machine]

28.2.3
format speciﬁer
a sequence of one or more characters that is to be replaced with some part of a regular expression match.

[defns.regex.format.speciﬁer]

28.2.4
matched

§ 28.2

[defns.regex.matched]

1095

c(cid:13) ISO/IEC

N4296

a sequence of zero or more characters is matched by a regular expression when the characters in the sequence
correspond to a sequence of characters deﬁned by the pattern.

28.2.5
primary equivalence class
a set of one or more characters which share the same primary sort key: that is the sort key weighting that
depends only upon character shape, and not accents, case, or locale speciﬁc tailorings.

[defns.regex.primary.equivalence.class]

28.2.6
regular expression
a pattern that selects speciﬁc strings from a set of character strings.

[defns.regex.regular.expression]

28.2.7
sub-expression
a subset of a regular expression that has been marked by parenthesis.
28.3 Requirements

[defns.regex.subexpression]

[re.req]
[ Note: The class

1 This subclause deﬁnes requirements on classes representing regular expression traits.

template regex_traits, deﬁned in Clause 28.7, satisﬁes these requirements. — end note ]

2 The class template basic_regex, deﬁned in Clause 28.8, needs a set of related types and functions to
complete the deﬁnition of its semantics. These types and functions are provided as a set of member typedefs
and functions in the template parameter traits used by the basic_regex class template. This subclause
deﬁnes the semantics of these members.

4

3 To specialize class template basic_regex for a character container CharT and its related regular expression

traits class Traits, use basic_regex<CharT, Traits>.
In Table 137 X denotes a traits class deﬁning types and functions for the character container type charT;
u is an object of type X; v is an object of type const X; p is a value of type const charT*; I1 and I2
are input iterators (24.2.3); F1 and F2 are forward iterators (24.2.5); c is a value of type const charT; s
is an object of type X::string_type; cs is an object of type const X::string_type; b is a value of type
bool; I is a value of type int; cl is an object of type X::char_class_type, and loc is an object of type
X::locale_type.

Table 137 — Regular expression traits class requirements

Expression

Return type

Assertion/note pre-/post-condition

X::char_type

charT

X::string_type

X::locale_type

X::char_class_type

X::length(p)

std::basic_-
string<charT>
A copy
constructible type
A bitmask
type (17.5.2.1.3).
std::size_t

The character container type used in the
implementation of class template
basic_regex.

A type that represents the locale used by the
traits class.
A bitmask type representing a particular
character classiﬁcation.
Yields the smallest i such that p[i] == 0.
Complexity is linear in i .

§ 28.3

1096

c(cid:13) ISO/IEC

N4296

Table 137 — Regular expression traits class requirements (contin-
ued)

Expression

v.translate(c)

Return type

X::char_type

v.translate_nocase(c)

X::char_type

v.transform(F1, F2)

X::string_type

v.transform_primary(F1,
F2)

X::string_type

v.lookup_collatename(F1,
F2)

X::string_type

v.lookup_classname(F1,
F2, b)

X::char_class_-
type

v.isctype(c, cl)

bool

Assertion/note pre-/post-condition

Returns a character such that for any
character d that is to be considered equivalent
to c then v.translate(c) ==
v.translate(d).
For all characters C that are to be considered
equivalent to c when comparisons are to be
performed without regard to case, then
v.translate_nocase(c) ==
v.translate_nocase(C).
Returns a sort key for the character sequence
designated by the iterator range [F1,F2)
such that if the character sequence [G1,G2)
sorts before the character sequence [H1,H2)
then v.transform(G1, G2) <
v.transform(H1, H2).
Returns a sort key for the character sequence
designated by the iterator range [F1,F2)
such that if the character sequence [G1,G2)
sorts before the character sequence [H1,H2)
when character case is not considered then
v.transform_primary(G1, G2) <
v.transform_primary(H1, H2).
Returns a sequence of characters that
represents the collating element consisting of
the character sequence designated by the
iterator range [F1,F2). Returns an empty
string if the character sequence is not a valid
collating element.
Converts the character sequence designated
by the iterator range [F1,F2) into a value of
a bitmask type that can subsequently be
passed to isctype. Values returned from
lookup_classname can be bitwise or’ed
together; the resulting value represents
membership in either of the corresponding
character classes. If b is true, the returned
bitmask is suitable for matching characters
without regard to their case. Returns 0 if the
character sequence is not the name of a
character class recognized by X. The value
returned shall be independent of the case of
the characters in the sequence.
Returns true if character c is a member of
one of the character classes designated by cl,
false otherwise.

§ 28.3

1097

c(cid:13) ISO/IEC

N4296

Table 137 — Regular expression traits class requirements (contin-
ued)

Expression

Return type

v.value(c, I)

int

u.imbue(loc)

v.getloc()

X::locale_type

X::locale_type

Assertion/note pre-/post-condition
Returns the value represented by the digit c
in base I if the character c is a valid digit in
base I ; otherwise returns -1. [ Note: The
value of I will only be 8, 10, or 16. — end
note ]
Imbues u with the locale loc and returns the
previous locale used by u if any.
Returns the current locale used by v, if any.

5

[ Note: Class template regex_traits satisﬁes the requirements for a regular expression traits class when it
is specialized for char or wchar_t. This class template is described in the header <regex>, and is described
in Clause 28.7. — end note ]
28.4 Header <regex> synopsis

[re.syn]

#include <initializer_list>

namespace std {

// 28.5, regex constants:
namespace regex_constants {

enum error_type;

} // namespace regex_constants

// 28.6, class regex_error:
class regex_error;

// 28.7, class template regex_traits:
template <class charT> struct regex_traits;

// 28.8, class template basic_regex:
template <class charT, class traits = regex_traits<charT> > class basic_regex;

typedef basic_regex<char>
regex;
typedef basic_regex<wchar_t> wregex;

// 28.8.6, basic_regex swap:
template <class charT, class traits>

void swap(basic_regex<charT, traits>& e1, basic_regex<charT, traits>& e2);

// 28.9, class template sub_match:
template <class BidirectionalIterator>

class sub_match;

csub_match;
typedef sub_match<const char*>
wcsub_match;
typedef sub_match<const wchar_t*>
typedef sub_match<string::const_iterator>
ssub_match;
typedef sub_match<wstring::const_iterator> wssub_match;

// 28.9.2, sub_match non-member operators:

§ 28.4

1098

c(cid:13) ISO/IEC

N4296

template <class BiIter>

template <class BiIter>

template <class BiIter>

template <class BiIter>

template <class BiIter>

template <class BiIter>

bool operator==(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);

bool operator!=(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);

bool operator<(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);

bool operator<=(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);

bool operator>=(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);

bool operator>(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);

typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,

typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,

typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,

template <class BiIter, class ST, class SA>

bool operator==(

const basic_string<

const sub_match<BiIter>& rhs);

template <class BiIter, class ST, class SA>

bool operator!=(

const basic_string<

const sub_match<BiIter>& rhs);

template <class BiIter, class ST, class SA>

bool operator<(

const basic_string<

const sub_match<BiIter>& rhs);

template <class BiIter, class ST, class SA>

bool operator>(

const basic_string<

const sub_match<BiIter>& rhs);

template <class BiIter, class ST, class SA>

bool operator>=(

const basic_string<

const sub_match<BiIter>& rhs);

template <class BiIter, class ST, class SA>

bool operator<=(

const basic_string<

typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,

typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,

typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,

const sub_match<BiIter>& rhs);

template <class BiIter, class ST, class SA>

bool operator==(

const sub_match<BiIter>& lhs,
const basic_string<

typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);

template <class BiIter, class ST, class SA>

bool operator!=(

const sub_match<BiIter>& lhs,
const basic_string<

typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);

§ 28.4

1099

c(cid:13) ISO/IEC

N4296

template <class BiIter, class ST, class SA>

bool operator<(

const sub_match<BiIter>& lhs,
const basic_string<

typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);

template <class BiIter, class ST, class SA>

typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);

template <class BiIter, class ST, class SA>

typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);

template <class BiIter, class ST, class SA>

bool operator>(

const sub_match<BiIter>& lhs,
const basic_string<

bool operator>=(

const sub_match<BiIter>& lhs,
const basic_string<

bool operator<=(

const sub_match<BiIter>& lhs,
const basic_string<

typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);

template <class BiIter>

template <class BiIter>

template <class BiIter>

template <class BiIter>

template <class BiIter>

template <class BiIter>

bool operator==(typename iterator_traits<BiIter>::value_type const* lhs,

const sub_match<BiIter>& rhs);

bool operator!=(typename iterator_traits<BiIter>::value_type const* lhs,

const sub_match<BiIter>& rhs);

bool operator<(typename iterator_traits<BiIter>::value_type const* lhs,

const sub_match<BiIter>& rhs);

bool operator>(typename iterator_traits<BiIter>::value_type const* lhs,

const sub_match<BiIter>& rhs);

bool operator>=(typename iterator_traits<BiIter>::value_type const* lhs,

const sub_match<BiIter>& rhs);

bool operator<=(typename iterator_traits<BiIter>::value_type const* lhs,

const sub_match<BiIter>& rhs);

typename iterator_traits<BiIter>::value_type const* rhs);

typename iterator_traits<BiIter>::value_type const* rhs);

template <class BiIter>

bool operator==(const sub_match<BiIter>& lhs,

template <class BiIter>

bool operator!=(const sub_match<BiIter>& lhs,

template <class BiIter>

bool operator<(const sub_match<BiIter>& lhs,

template <class BiIter>

bool operator>(const sub_match<BiIter>& lhs,

template <class BiIter>

bool operator>=(const sub_match<BiIter>& lhs,

typename iterator_traits<BiIter>::value_type const* rhs);

typename iterator_traits<BiIter>::value_type const* rhs);

typename iterator_traits<BiIter>::value_type const* rhs);

§ 28.4

1100

c(cid:13) ISO/IEC

N4296

template <class BiIter>

bool operator<=(const sub_match<BiIter>& lhs,

typename iterator_traits<BiIter>::value_type const* rhs);

bool operator==(typename iterator_traits<BiIter>::value_type const& lhs,

const sub_match<BiIter>& rhs);

bool operator!=(typename iterator_traits<BiIter>::value_type const& lhs,

const sub_match<BiIter>& rhs);

bool operator<(typename iterator_traits<BiIter>::value_type const& lhs,

const sub_match<BiIter>& rhs);

bool operator>(typename iterator_traits<BiIter>::value_type const& lhs,

const sub_match<BiIter>& rhs);

template <class BiIter>

template <class BiIter>

template <class BiIter>

template <class BiIter>

template <class BiIter>

template <class BiIter>

bool operator>=(typename iterator_traits<BiIter>::value_type const& lhs,

const sub_match<BiIter>& rhs);

bool operator<=(typename iterator_traits<BiIter>::value_type const& lhs,

const sub_match<BiIter>& rhs);

typename iterator_traits<BiIter>::value_type const& rhs);

typename iterator_traits<BiIter>::value_type const& rhs);

template <class BiIter>

bool operator==(const sub_match<BiIter>& lhs,

template <class BiIter>

bool operator!=(const sub_match<BiIter>& lhs,

template <class BiIter>

bool operator<(const sub_match<BiIter>& lhs,

template <class BiIter>

bool operator>(const sub_match<BiIter>& lhs,

template <class BiIter>

bool operator>=(const sub_match<BiIter>& lhs,

template <class BiIter>

bool operator<=(const sub_match<BiIter>& lhs,

typename iterator_traits<BiIter>::value_type const& rhs);

typename iterator_traits<BiIter>::value_type const& rhs);

typename iterator_traits<BiIter>::value_type const& rhs);

typename iterator_traits<BiIter>::value_type const& rhs);

template <class charT, class ST, class BiIter>

basic_ostream<charT, ST>&
operator<<(basic_ostream<charT, ST>& os, const sub_match<BiIter>& m);

// 28.10, class template match_results:
template <class BidirectionalIterator,

class match_results;

class Allocator = allocator<sub_match<BidirectionalIterator> > >

cmatch;
typedef match_results<const char*>
wcmatch;
typedef match_results<const wchar_t*>
typedef match_results<string::const_iterator>
smatch;
typedef match_results<wstring::const_iterator> wsmatch;

§ 28.4

1101

c(cid:13) ISO/IEC

N4296

// match_results comparisons
template <class BidirectionalIterator, class Allocator>

bool operator== (const match_results<BidirectionalIterator, Allocator>& m1,
const match_results<BidirectionalIterator, Allocator>& m2);

template <class BidirectionalIterator, class Allocator>

bool operator!= (const match_results<BidirectionalIterator, Allocator>& m1,
const match_results<BidirectionalIterator, Allocator>& m2);

// 28.10.7, match_results swap:
template <class BidirectionalIterator, class Allocator>

void swap(match_results<BidirectionalIterator, Allocator>& m1,
match_results<BidirectionalIterator, Allocator>& m2);

// 28.11.2, function template regex_match:
template <class BidirectionalIterator, class Allocator,

class charT, class traits>

bool regex_match(BidirectionalIterator first, BidirectionalIterator last,

match_results<BidirectionalIterator, Allocator>& m,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

template <class BidirectionalIterator, class charT, class traits>
bool regex_match(BidirectionalIterator first, BidirectionalIterator last,

template <class charT, class Allocator, class traits>

bool regex_match(const charT* str, match_results<const charT*, Allocator>& m,

const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

template <class ST, class SA, class Allocator, class charT, class traits>

bool regex_match(const basic_string<charT, ST, SA>& s,

template <class ST, class SA, class Allocator, class charT, class traits>

bool regex_match(const basic_string<charT, ST, SA>&&,

match_results<

typename basic_string<charT, ST, SA>::const_iterator,
Allocator>& m,

const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

match_results<

typename basic_string<charT, ST, SA>::const_iterator,
Allocator>&,

const basic_regex<charT, traits>&,
regex_constants::match_flag_type =

regex_constants::match_default) = delete;

template <class charT, class traits>
bool regex_match(const charT* str,

const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

template <class ST, class SA, class charT, class traits>
bool regex_match(const basic_string<charT, ST, SA>& s,

§ 28.4

1102

c(cid:13) ISO/IEC

N4296

const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

// 28.11.3, function template regex_search:
template <class BidirectionalIterator, class Allocator,

class charT, class traits>

bool regex_search(BidirectionalIterator first, BidirectionalIterator last,

match_results<BidirectionalIterator, Allocator>& m,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

template <class BidirectionalIterator, class charT, class traits>

bool regex_search(BidirectionalIterator first, BidirectionalIterator last,

const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);
template <class charT, class Allocator, class traits>

bool regex_search(const charT* str,

match_results<const charT*, Allocator>& m,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

template <class charT, class traits>
bool regex_search(const charT* str,

const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

template <class ST, class SA, class charT, class traits>
bool regex_search(const basic_string<charT, ST, SA>& s,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

template <class ST, class SA, class Allocator, class charT, class traits>

bool regex_search(const basic_string<charT, ST, SA>& s,

template <class ST, class SA, class Allocator, class charT, class traits>

bool regex_search(const basic_string<charT, ST, SA>&&,

match_results<

typename basic_string<charT, ST, SA>::const_iterator,
Allocator>& m,

const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

match_results<

typename basic_string<charT, ST, SA>::const_iterator,
Allocator>&,

const basic_regex<charT, traits>&,
regex_constants::match_flag_type =

regex_constants::match_default) = delete;

// 28.11.4, function template regex_replace:
template <class OutputIterator, class BidirectionalIterator,

class traits, class charT, class ST, class SA>

OutputIterator
regex_replace(OutputIterator out,

§ 28.4

1103

c(cid:13) ISO/IEC

N4296

BidirectionalIterator first, BidirectionalIterator last,
const basic_regex<charT, traits>& e,
const basic_string<charT, ST, SA>& fmt,
regex_constants::match_flag_type flags =

regex_constants::match_default);

template <class OutputIterator, class BidirectionalIterator,

class traits, class charT>

OutputIterator
regex_replace(OutputIterator out,

BidirectionalIterator first, BidirectionalIterator last,
const basic_regex<charT, traits>& e,
const charT* fmt,
regex_constants::match_flag_type flags =

template <class traits, class charT, class ST, class SA,

regex_constants::match_default);

class FST, class FSA>

basic_string<charT, ST, SA>
regex_replace(const basic_string<charT, ST, SA>& s,
const basic_regex<charT, traits>& e,
const basic_string<charT, FST, FSA>& fmt,
regex_constants::match_flag_type flags =

regex_constants::match_default);

template <class traits, class charT, class ST, class SA>

basic_string<charT, ST, SA>
regex_replace(const basic_string<charT, ST, SA>& s,
const basic_regex<charT, traits>& e,
const charT* fmt,
regex_constants::match_flag_type flags =

template <class traits, class charT, class ST, class SA>

regex_constants::match_default);

basic_string<charT>
regex_replace(const charT* s,

const basic_regex<charT, traits>& e,
const basic_string<charT, ST, SA>& fmt,
regex_constants::match_flag_type flags =

regex_constants::match_default);

template <class traits, class charT>

basic_string<charT>
regex_replace(const charT* s,

const basic_regex<charT, traits>& e,
const charT* fmt,
regex_constants::match_flag_type flags =

regex_constants::match_default);

// 28.12.1, class template regex_iterator:
template <class BidirectionalIterator,

class charT = typename iterator_traits<

BidirectionalIterator>::value_type,
class traits = regex_traits<charT> >

class regex_iterator;

cregex_iterator;
typedef regex_iterator<const char*>
wcregex_iterator;
typedef regex_iterator<const wchar_t*>
typedef regex_iterator<string::const_iterator>
sregex_iterator;
typedef regex_iterator<wstring::const_iterator> wsregex_iterator;

§ 28.4

1104

c(cid:13) ISO/IEC

N4296

// 28.12.2, class template regex_token_iterator:
template <class BidirectionalIterator,

class regex_token_iterator;

class charT = typename iterator_traits<

BidirectionalIterator>::value_type,
class traits = regex_traits<charT> >

cregex_token_iterator;
typedef regex_token_iterator<const char*>
wcregex_token_iterator;
typedef regex_token_iterator<const wchar_t*>
typedef regex_token_iterator<string::const_iterator>
sregex_token_iterator;
typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;

}

28.5 Namespace std::regex_constants

[re.const]
1 The namespace std::regex_constants holds symbolic constants used by the regular expression library.
This namespace provides three types, syntax_option_type, match_flag_type, and error_type, along
with several constants of these types.
28.5.1 Bitmask type syntax_option_type

[re.synopt]

namespace std::regex_constants {
typedef T1 syntax_option_type;
constexpr syntax_option_type icase = unspecified ;
constexpr syntax_option_type nosubs = unspecified ;
constexpr syntax_option_type optimize = unspecified ;
constexpr syntax_option_type collate = unspecified ;
constexpr syntax_option_type ECMAScript = unspecified ;
constexpr syntax_option_type basic = unspecified ;
constexpr syntax_option_type extended = unspecified ;
constexpr syntax_option_type awk = unspecified ;
constexpr syntax_option_type grep = unspecified ;
constexpr syntax_option_type egrep = unspecified ;

}

1 The type syntax_option_type is an implementation-deﬁned bitmask type (17.5.2.1.3). Setting its elements
has the eﬀects listed in table 138. A valid value of type syntax_option_type shall have at most one of the
grammar elements ECMAScript, basic, extended, awk, grep, egrep, set. If no grammar element is set, the
default grammar is ECMAScript.
28.5.2 Bitmask type regex_constants::match_flag_type

[re.matchﬂag]

namespace std::regex_constants {

typedef T2 match_flag_type;
constexpr match_flag_type match_default = {};
constexpr match_flag_type match_not_bol = unspecified ;
constexpr match_flag_type match_not_eol = unspecified ;
constexpr match_flag_type match_not_bow = unspecified ;
constexpr match_flag_type match_not_eow = unspecified ;
constexpr match_flag_type match_any = unspecified ;
constexpr match_flag_type match_not_null = unspecified ;
constexpr match_flag_type match_continuous = unspecified ;
constexpr match_flag_type match_prev_avail = unspecified ;
constexpr match_flag_type format_default = {};
constexpr match_flag_type format_sed = unspecified ;
constexpr match_flag_type format_no_copy = unspecified ;

§ 28.5.2

1105

c(cid:13) ISO/IEC

N4296

Element
icase

nosubs

optimize

collate

ECMAScript

basic

extended

awk

grep

egrep

Table 138 — syntax_option_type eﬀects

Eﬀect(s) if set

Speciﬁes that matching of regular expressions against a character container
sequence shall be performed without regard to case.
Speciﬁes that no sub-expressions shall be considered to be marked, so that
when a regular expression is matched against a character container se-
quence, no sub-expression matches shall be stored in the supplied match_-
results structure.
Speciﬁes that the regular expression engine should pay more attention to
the speed with which regular expressions are matched, and less to the speed
with which regular expression objects are constructed. Otherwise it has no
detectable eﬀect on the program output.
Speciﬁes that character ranges of the form "[a-b]" shall be locale sensitive.

Speciﬁes that the grammar recognized by the regular expression engine
shall be that used by ECMAScript in ECMA-262, as modiﬁed in 28.13.
Speciﬁes that the grammar recognized by the regular expression engine
shall be that used by basic regular expressions in POSIX, Base Deﬁnitions
and Headers, Section 9, Regular Expressions.
Speciﬁes that the grammar recognized by the regular expression engine shall
be that used by extended regular expressions in POSIX, Base Deﬁnitions
and Headers, Section 9, Regular Expressions.
Speciﬁes that the grammar recognized by the regular expression engine
shall be that used by the utility awk in POSIX.
Speciﬁes that the grammar recognized by the regular expression engine
shall be that used by the utility grep in POSIX.
Speciﬁes that the grammar recognized by the regular expression engine
shall be that used by the utility grep when given the -E option in POSIX.

constexpr match_flag_type format_first_only = unspecified ;

}

1 The type regex_constants::match_flag_type is an implementation-deﬁned bitmask type (17.5.2.1.3).
The constants of that type, except for match_default and format_default, are bitmask elements. The
match_default and format_default constants are empty bitmasks. Matching a regular expression against
a sequence of characters [first,last) proceeds according to the rules of the grammar speciﬁed for the
regular expression object, modiﬁed according to the eﬀects listed in Table 139 for any bitmask elements set.

Table 139 — regex_constants::match_flag_type eﬀects when
obtaining a match against a character container sequence [first,
last).

Element
match_not_bol

match_not_eol

Eﬀect(s) if set

The ﬁrst character in the sequence [first,last) shall be treated as though
it is not at the beginning of a line, so the character ^ in the regular expres-
sion shall not match [first,first).
The last character in the sequence [first,last) shall be treated as though
it is not at the end of a line, so the character "$" in the regular expression
shall not match [last,last).

§ 28.5.2

1106

c(cid:13) ISO/IEC

N4296

Table 139 — regex_constants::match_flag_type eﬀects when
obtaining a match against a character container sequence [first,
last). (continued)

Element
match_not_bow
match_not_eow
match_any
match_not_null
match_continuous
match_prev_avail

format_default

format_sed

format_no_copy

Eﬀect(s) if set

The expression "\\b" shall not match the sub-sequence [first,first).
The expression "\\b" shall not match the sub-sequence [last,last).
If more than one match is possible then any match is an acceptable result.
The expression shall not match an empty sequence.
The expression shall only match a sub-sequence that begins at first.
--first is a valid iterator position. When this ﬂag is set the ﬂags match_-
not_bol and match_not_bow shall be ignored by the regular expression
algorithms 28.11 and iterators 28.12.
When a regular expression match is to be replaced by a new string, the
new string shall be constructed using the rules used by the ECMAScript
replace function in ECMA-262, part 15.5.4.11 String.prototype.replace. In
addition, during search and replace operations all non-overlapping occur-
rences of the regular expression shall be located and replaced, and sections
of the input that did not match the expression shall be copied unchanged
to the output string.
When a regular expression match is to be replaced by a new string, the
new string shall be constructed using the rules used by the sed utility in
POSIX.
During a search and replace operation, sections of the character container
sequence being searched that do not match the regular expression shall not
be copied to the output string.

format_first_only When speciﬁed during a search and replace operation, only the ﬁrst occur-

rence of the regular expression shall be replaced.

28.5.3

Implementation-deﬁned error_type

[re.err]

namespace std::regex_constants {

typedef T3 error_type;
constexpr error_type error_collate = unspecified ;
constexpr error_type error_ctype = unspecified ;
constexpr error_type error_escape = unspecified ;
constexpr error_type error_backref = unspecified ;
constexpr error_type error_brack = unspecified ;
constexpr error_type error_paren = unspecified ;
constexpr error_type error_brace = unspecified ;
constexpr error_type error_badbrace = unspecified ;
constexpr error_type error_range = unspecified ;
constexpr error_type error_space = unspecified ;
constexpr error_type error_badrepeat = unspecified ;
constexpr error_type error_complexity = unspecified ;
constexpr error_type error_stack = unspecified ;

}

1 The type error_type is an implementation-deﬁned enumerated type (17.5.2.1.2). Values of type error_type

represent the error conditions described in Table 140:

§ 28.5.3

1107

c(cid:13) ISO/IEC

N4296

Table 140 — error_type values in the C locale

Error condition

The expression contained an invalid collating element name.
The expression contained an invalid character class name.
The expression contained an invalid escaped character, or a trailing escape.
The expression contained an invalid back reference.
The expression contained mismatched [ and ].
The expression contained mismatched ( and ).
The expression contained mismatched { and }
The expression contained an invalid range in a {} expression.
The expression contained an invalid character range, such as [b-a] in most
encodings.
There was insuﬃcient memory to convert the expression into a ﬁnite state
machine.
One of *?+{ was not preceded by a valid regular expression.

Value

error_collate
error_ctype
error_escape
error_backref
error_brack
error_paren
error_brace
error_badbrace
error_range

error_space

error_stack

error_badrepeat
error_complexity The complexity of an attempted match against a regular expression ex-

ceeded a pre-set level.
There was insuﬃcient memory to determine whether the regular expression
could match the speciﬁed character sequence.

28.6 Class regex_error

[re.badexp]

class regex_error : public std::runtime_error {

explicit regex_error(regex_constants::error_type ecode);
regex_constants::error_type code() const;

public:

};

1 The class regex_error deﬁnes the type of objects thrown as exceptions to report errors from the regular

expression library.

2

3

4

regex_error(regex_constants::error_type ecode);

Eﬀects: Constructs an object of class regex_error.
Postcondition:: ecode == code()

regex_constants::error_type code() const;

Returns: The error code that was passed to the constructor.

28.7 Class template regex_traits

[re.traits]

namespace std {

template <class charT>
struct regex_traits {
public:

typedef charT
typedef std::basic_string<char_type> string_type;
typedef std::locale
locale_type;
char_class_type;
typedef bitmask_type

char_type;

regex_traits();
static std::size_t length(const char_type* p);

§ 28.7

1108

c(cid:13) ISO/IEC

N4296

charT translate(charT c) const;
charT translate_nocase(charT c) const;
template <class ForwardIterator>

string_type transform(ForwardIterator first, ForwardIterator last) const;

template <class ForwardIterator>
string_type transform_primary(

template <class ForwardIterator>
string_type lookup_collatename(

ForwardIterator first, ForwardIterator last) const;

ForwardIterator first, ForwardIterator last) const;

template <class ForwardIterator>

char_class_type lookup_classname(

ForwardIterator first, ForwardIterator last, bool icase = false) const;

bool isctype(charT c, char_class_type f) const;
int value(charT ch, int radix) const;
locale_type imbue(locale_type l);
locale_type getloc() const;

};

}

1 The specializations regex_traits<char> and regex_traits<wchar_t> shall be valid and shall satisfy the

requirements for a regular expression traits class (28.3).

2

3

4

5

6

7

typedef bitmask_type

char_class_type;

The type char_class_type is used to represent a character classiﬁcation and is capable of holding an
implementation speciﬁc set returned by lookup_classname.

static std::size_t length(const char_type* p);
Returns: char_traits<charT>::length(p);

charT translate(charT c) const;

Returns: (c).

charT translate_nocase(charT c) const;

Returns: use_facet<ctype<charT> >(getloc()).tolower(c).

template <class ForwardIterator>

string_type transform(ForwardIterator first, ForwardIterator last) const;

Eﬀects:

string_type str(first, last);
return use_facet<collate<charT> >(

getloc()).transform(&*str.begin(), &*str.begin() + str.length());

template <class ForwardIterator>

string_type transform_primary(ForwardIterator first, ForwardIterator last) const;

if typeid(use_facet<collate<charT> >) == typeid(collate_byname<charT>) and the
Eﬀects:
form of the sort key returned by collate_byname<charT> ::transform(first, last) is known and
can be converted into a primary sort key then returns that key, otherwise returns an empty string.

template <class ForwardIterator>

string_type lookup_collatename(ForwardIterator first, ForwardIterator last) const;

§ 28.7

1109

8

9

10

11

12

c(cid:13) ISO/IEC

N4296

Returns: a sequence of one or more characters that represents the collating element consisting of the
character sequence designated by the iterator range [first,last). Returns an empty string if the
character sequence is not a valid collating element.

template <class ForwardIterator>

char_class_type lookup_classname(

ForwardIterator first, ForwardIterator last, bool icase = false) const;
Returns: an unspeciﬁed value that represents the character classiﬁcation named by the character
sequence designated by the iterator range [first,last).
If the parameter icase is true then the
returned mask identiﬁes the character classiﬁcation without regard to the case of the characters being
matched, otherwise it does honor the case of the characters being matched.336 The value returned shall
be independent of the case of the characters in the character sequence. If the name is not recognized
then returns char_class_type().
Remarks: For regex_traits<char>, at least the narrow character names in Table 141 shall be recog-
nized. For regex_traits<wchar_t>, at least the wide character names in Table 141 shall be recognized.

bool isctype(charT c, char_class_type f) const;

Eﬀects: Determines if the character c is a member of the character classiﬁcation represented by f.
Returns: Given the following function declaration:

// for exposition only
template<class C>

ctype_base::mask convert(typename regex_traits<C>::char_class_type f);

that returns a value in which each ctype_base::mask value corresponding to a value in f named in
Table 141 is set, then the result is determined as if by:

ctype_base::mask m = convert<charT>(f);
const ctype<charT>& ct = use_facet<ctype<charT>>(getloc());
if (ct.is(m, c)) {

return true;

} else if (c == ct.widen(’_’)) {
charT w[1] = { ct.widen(’w’) };
char_class_type x = lookup_classname(w, w+1);

return (f&x) == x;

} else {

return false;

}

[ Example:

regex_traits<char> t;
string d("d");
string u("upper");
regex_traits<char>::char_class_type f;
f = t.lookup_classname(d.begin(), d.end());
f |= t.lookup_classname(u.begin(), u.end());
ctype_base::mask m = convert<char>(f); // m == ctype_base::digit|ctype_base::upper

— end example ] [ Example:

336) For example, if the parameter icase is true then [[:lower:]] is the same as [[:alpha:]].

§ 28.7

1110

c(cid:13) ISO/IEC

N4296

regex_traits<char> t;
string w("w");
regex_traits<char>::char_class_type f;
f = t.lookup_classname(w.begin(), w.end());
t.isctype(’A’, f); // returns true
t.isctype(’_’, f); // returns true
t.isctype(’ ’, f); // returns false

— end example ]

int value(charT ch, int radix) const;

13

14

15

16

17

18

Requires: The value of radix shall be 8, 10, or 16.
Returns: the value represented by the digit ch in base radix if the character ch is a valid digit in base
radix; otherwise returns -1.

locale_type imbue(locale_type loc);

Eﬀects: Imbues this with a copy of the locale loc. [ Note: Calling imbue with a diﬀerent locale than
the one currently in use invalidates all cached data held by *this. — end note ]
Returns: if no locale has been previously imbued then a copy of the global locale in eﬀect at the time
of construction of *this, otherwise a copy of the last argument passed to imbue.
Postcondition: getloc() == loc.

locale_type getloc() const;

Returns: if no locale has been imbued then a copy of the global locale in eﬀect at the time of construc-
tion of *this, otherwise a copy of the last argument passed to imbue.

Table 141 — Character class names and corresponding ctype masks

Narrow character name Wide character name Corresponding ctype_base::mask value
"alnum"
"alpha"
"blank"
"cntrl"
"digit"
"d"
"graph"
"lower"
"print"
"punct"
"space"
"s"
"upper"
"w"
"xdigit"

ctype_base::alnum
ctype_base::alpha
ctype_base::blank
ctype_base::cntrl
ctype_base::digit
ctype_base::digit
ctype_base::graph
ctype_base::lower
ctype_base::print
ctype_base::punct
ctype_base::space
ctype_base::space
ctype_base::upper
ctype_base::alnum
ctype_base::xdigit

L"alnum"
L"alpha"
L"blank"
L"cntrl"
L"digit"
L"d"
L"graph"
L"lower"
L"print"
L"punct"
L"space"
L"s"
L"upper"
L"w"
L"xdigit"

§ 28.7

1111

c(cid:13) ISO/IEC

N4296

28.8 Class template basic_regex

[re.regex]
1 For a char-like type charT, specializations of class template basic_regex represent regular expressions
constructed from character sequences of charT characters. In the rest of 28.8, charT denotes a given char-
like type. Storage for a regular expression is allocated and freed as necessary by the member functions of
class basic_regex.

2 Objects of type specialization of basic_regex are responsible for converting the sequence of charT objects
to an internal representation. It is not speciﬁed what form this representation takes, nor how it is accessed by
algorithms that operate on regular expressions. [ Note: Implementations will typically declare some function
templates as friends of basic_regex to achieve this — end note ]

3 The functions described in this Clause report errors by throwing exceptions of type regex_error.

namespace std {

template <class charT,

class basic_regex {
public:

class traits = regex_traits<charT> >

// types:
typedef
typedef
typedef typename traits::string_type
typedef
typedef typename traits::locale_type

charT
traits

regex_constants::syntax_option_type

value_type;
traits_type;
string_type;
flag_type;
locale_type;

// 28.8.1, constants:
static constexpr regex_constants::syntax_option_type

icase = regex_constants::icase;

static constexpr regex_constants::syntax_option_type

nosubs = regex_constants::nosubs;

static constexpr regex_constants::syntax_option_type

optimize = regex_constants::optimize;

static constexpr regex_constants::syntax_option_type

collate = regex_constants::collate;

static constexpr regex_constants::syntax_option_type

ECMAScript = regex_constants::ECMAScript;

static constexpr regex_constants::syntax_option_type

basic = regex_constants::basic;

static constexpr regex_constants::syntax_option_type

extended = regex_constants::extended;

static constexpr regex_constants::syntax_option_type

awk = regex_constants::awk;

static constexpr regex_constants::syntax_option_type

grep = regex_constants::grep;

static constexpr regex_constants::syntax_option_type

egrep = regex_constants::egrep;

// 28.8.2, construct/copy/destroy:
basic_regex();
explicit basic_regex(const charT* p,

flag_type f = regex_constants::ECMAScript);

basic_regex(const charT* p, size_t len, flag_type f = regex_constants::ECMAScript);
basic_regex(const basic_regex&);
basic_regex(basic_regex&&) noexcept;
template <class ST, class SA>

explicit basic_regex(const basic_string<charT, ST, SA>& p,

§ 28.8

1112

c(cid:13) ISO/IEC

N4296

flag_type f = regex_constants::ECMAScript);

template <class ForwardIterator>

basic_regex(ForwardIterator first, ForwardIterator last,
flag_type f = regex_constants::ECMAScript);

basic_regex(initializer_list<charT>,

flag_type = regex_constants::ECMAScript);

~basic_regex();

basic_regex& operator=(const basic_regex&);
basic_regex& operator=(basic_regex&&) noexcept;
basic_regex& operator=(const charT* ptr);
basic_regex& operator=(initializer_list<charT> il);
template <class ST, class SA>

basic_regex& operator=(const basic_string<charT, ST, SA>& p);

// 28.8.3, assign:
basic_regex& assign(const basic_regex& that);
basic_regex& assign(basic_regex&& that) noexcept;
basic_regex& assign(const charT* ptr,

flag_type f = regex_constants::ECMAScript);

basic_regex& assign(const charT* p, size_t len, flag_type f);
template <class string_traits, class A>

basic_regex& assign(const basic_string<charT, string_traits, A>& s,

flag_type f = regex_constants::ECMAScript);

template <class InputIterator>

basic_regex& assign(InputIterator first, InputIterator last,

flag_type f = regex_constants::ECMAScript);

basic_regex& assign(initializer_list<charT>,

flag_type = regex_constants::ECMAScript);

// 28.8.4, const operations:
unsigned mark_count() const;
flag_type flags() const;

// 28.8.5, locale:
locale_type imbue(locale_type loc);
locale_type getloc() const;

// 28.8.6, swap:
void swap(basic_regex&);

};

}

28.8.1 basic_regex constants

[re.regex.const]

static constexpr regex_constants::syntax_option_type

icase = regex_constants::icase;

static constexpr regex_constants::syntax_option_type

nosubs = regex_constants::nosubs;

static constexpr regex_constants::syntax_option_type

optimize = regex_constants::optimize;

static constexpr regex_constants::syntax_option_type

collate = regex_constants::collate;

static constexpr regex_constants::syntax_option_type

§ 28.8.1

1113

c(cid:13) ISO/IEC

N4296

ECMAScript = regex_constants::ECMAScript;

static constexpr regex_constants::syntax_option_type

basic = regex_constants::basic;

static constexpr regex_constants::syntax_option_type

extended = regex_constants::extended;

static constexpr regex_constants::syntax_option_type

awk = regex_constants::awk;

static constexpr regex_constants::syntax_option_type

grep = regex_constants::grep;

static constexpr regex_constants::syntax_option_type

egrep = regex_constants::egrep;

1 The static constant members are provided as synonyms for the constants declared in namespace regex_-

[re.regex.construct]

constants.
28.8.2 basic_regex constructors
basic_regex();

1

2

3

4

5

6

7

8

9

10

11

12

13

Eﬀects: Constructs an object of class basic_regex that does not match any character sequence.

explicit basic_regex(const charT* p, flag_type f = regex_constants::ECMAScript);

Requires: p shall not be a null pointer.
Throws: regex_error if p is not a valid regular expression.
Eﬀects: Constructs an object of class basic_regex; the object’s internal ﬁnite state machine is con-
structed from the regular expression contained in the array of charT of length char_traits<charT>::
length(p) whose ﬁrst element is designated by p, and interpreted according to the ﬂags f.
Postconditions: flags() returns f. mark_count() returns the number of marked sub-expressions
within the expression.

basic_regex(const charT* p, size_t len, flag_type f);

Requires: p shall not be a null pointer.
Throws: regex_error if p is not a valid regular expression.
Eﬀects: Constructs an object of class basic_regex; the object’s internal ﬁnite state machine is con-
structed from the regular expression contained in the sequence of characters [p,p+len), and interpreted
according the ﬂags speciﬁed in f.
Postconditions: flags() returns f. mark_count() returns the number of marked sub-expressions
within the expression.

basic_regex(const basic_regex& e);

Eﬀects: Constructs an object of class basic_regex as a copy of the object e.
Postconditions: flags() and mark_count() return e.flags() and e.mark_count(), respectively.

basic_regex(basic_regex&& e) noexcept;

Eﬀects: Move constructs an object of class basic_regex from e.
Postconditions: flags() and mark_count() return the values that e.flags() and e.mark_count(),
respectively, had before construction. e is in a valid state with unspeciﬁed value.

template <class ST, class SA>

explicit basic_regex(const basic_string<charT, ST, SA>& s,

flag_type f = regex_constants::ECMAScript);

§ 28.8.2

1114

14

15

16

17

18

19

20

1

2

3

4

5

6

7

8

c(cid:13) ISO/IEC

N4296

Throws: regex_error if s is not a valid regular expression.
Eﬀects: Constructs an object of class basic_regex; the object’s internal ﬁnite state machine is con-
structed from the regular expression contained in the string s, and interpreted according to the ﬂags
speciﬁed in f.
Postconditions: flags() returns f. mark_count() returns the number of marked sub-expressions
within the expression.

template <class ForwardIterator>

basic_regex(ForwardIterator first, ForwardIterator last,
flag_type f = regex_constants::ECMAScript);

Throws: regex_error if the sequence [first,last) is not a valid regular expression.
Eﬀects: Constructs an object of class basic_regex; the object’s internal ﬁnite state machine is con-
structed from the regular expression contained in the sequence of characters [first,last), and in-
terpreted according to the ﬂags speciﬁed in f.
Postconditions: flags() returns f. mark_count() returns the number of marked sub-expressions
within the expression.

[re.regex.assign]

basic_regex(initializer_list<charT> il,

flag_type f = regex_constants::ECMAScript);

Eﬀects: Same as basic_regex(il.begin(), il.end(), f).

28.8.3 basic_regex assign
basic_regex& operator=(const basic_regex& e);

Eﬀects: returns assign(e).

basic_regex& operator=(basic_regex&& e) noexcept;

Eﬀects: returns assign(std::move(e)).

basic_regex& operator=(const charT* ptr);

Requires: ptr shall not be a null pointer.
Eﬀects: returns assign(ptr).

basic_regex& operator=(initializer_list<charT> il);
Eﬀects: returns assign(il.begin(), il.end()).

template <class ST, class SA>

basic_regex& operator=(const basic_string<charT, ST, SA>& p);

Eﬀects: returns assign(p).

basic_regex& assign(const basic_regex& that);

Eﬀects: copies that into *this and returns *this.
Postconditions: flags() and mark_count() return that.flags() and that.mark_count(), respec-
tively.

basic_regex& assign(basic_regex&& that) noexcept;

§ 28.8.3

1115

9

10

11

12

13

14

15

16

17

18

19

20

1

2

1

2

c(cid:13) ISO/IEC

N4296

Eﬀects: move assigns from that into *this and returns *this.
Postconditions: flags() and mark_count() return the values that that.flags() and that.mark_-
count(), respectively, had before assignment. that is in a valid state with unspeciﬁed value.

basic_regex& assign(const charT* ptr, flag_type f = regex_constants::ECMAScript);

Returns: assign(string_type(ptr), f).

basic_regex& assign(const charT* ptr, size_t len,

flag_type f = regex_constants::ECMAScript);

Returns: assign(string_type(ptr, len), f).

template <class string_traits, class A>

basic_regex& assign(const basic_string<charT, string_traits, A>& s,

flag_type f = regex_constants::ECMAScript);

Throws: regex_error if s is not a valid regular expression.
Returns: *this.
Eﬀects: Assigns the regular expression contained in the string s, interpreted according the ﬂags spec-
iﬁed in f. If an exception is thrown, *this is unchanged.
Postconditions: If no exception is thrown, flags() returns f and mark_count() returns the number
of marked sub-expressions within the expression.

template <class InputIterator>

basic_regex& assign(InputIterator first, InputIterator last,

flag_type f = regex_constants::ECMAScript);

Requires: The type InputIterator shall satisfy the requirements for an Input Iterator (24.2.3).
Returns: assign(string_type(first, last), f).

basic_regex& assign(initializer_list<charT> il,

flag_type f = regex_constants::ECMAScript);

Eﬀects: Same as assign(il.begin(), il.end(), f).
Returns: *this.

28.8.4 basic_regex constant operations
unsigned mark_count() const;

[re.regex.operations]

Eﬀects: Returns the number of marked sub-expressions within the regular expression.

flag_type flags() const;

Eﬀects: Returns a copy of the regular expression syntax ﬂags that were passed to the object’s con-
structor or to the last call to assign.

28.8.5 basic_regex locale
locale_type imbue(locale_type loc);

[re.regex.locale]

Eﬀects: Returns the result of traits_inst.imbue(loc) where traits_inst is a (default initialized)
instance of the template type argument traits stored within the object. After a call to imbue the
basic_regex object does not match any character sequence.

locale_type getloc() const;

Eﬀects: Returns the result of traits_inst.getloc() where traits_inst is a (default initialized)
instance of the template parameter traits stored within the object.

§ 28.8.5

1116

1

2

3

1

c(cid:13) ISO/IEC

28.8.6 basic_regex swap
void swap(basic_regex& e);

N4296

[re.regex.swap]

Eﬀects: Swaps the contents of the two regular expressions.
Postcondition: *this contains the regular expression that was in e, e contains the regular expression
that was in *this.
Complexity: Constant time.

28.8.7 basic_regex non-member functions
28.8.7.1 basic_regex non-member swap
template <class charT, class traits>

[re.regex.nonmemb]
[re.regex.nmswap]

void swap(basic_regex<charT, traits>& lhs, basic_regex<charT, traits>& rhs);

Eﬀects: Calls lhs.swap(rhs).

28.9 Class template sub_match

[re.submatch]
1 Class template sub_match denotes the sequence of characters matched by a particular marked sub-expression.

namespace std {

template <class BidirectionalIterator>
class sub_match : public std::pair<BidirectionalIterator, BidirectionalIterator> {
public:

typedef typename iterator_traits<BidirectionalIterator>::

value_type

typedef typename iterator_traits<BidirectionalIterator>::

difference_type

typedef BidirectionalIterator
typedef basic_string<value_type>

bool matched;

constexpr sub_match();

difference_type length() const;
operator string_type() const;
string_type str() const;

int compare(const sub_match& s) const;
int compare(const string_type& s) const;
int compare(const value_type* s) const;

};

}

28.9.1 sub_match members
constexpr sub_match();

value_type;

difference_type;
iterator;
string_type;

[re.submatch.members]

1

2

Eﬀects: Value-initializes the pair base class subobject and the member matched.

difference_type length() const;

Returns: (matched ? distance(first, second) :

0).

operator string_type() const;

§ 28.9.1

1117

c(cid:13) ISO/IEC

N4296

Returns: matched ?

string_type(first, second) :

string_type().

string_type str() const;
Returns: matched ?

string_type(first, second) :

string_type().

int compare(const sub_match& s) const;
Returns: str().compare(s.str()).

int compare(const string_type& s) const;

Returns: str().compare(s).

int compare(const value_type* s) const;

Returns: str().compare(s).

28.9.2 sub_match non-member operators
template <class BiIter>

bool operator==(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);

[re.submatch.op]

Returns: lhs.compare(rhs) == 0.

template <class BiIter>

bool operator!=(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);

Returns: lhs.compare(rhs) != 0.

template <class BiIter>

bool operator<(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);

Returns: lhs.compare(rhs) < 0.

template <class BiIter>

bool operator<=(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);

Returns: lhs.compare(rhs) <= 0.

template <class BiIter>

bool operator>=(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);

Returns: lhs.compare(rhs) >= 0.

template <class BiIter>

bool operator>(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);

Returns: lhs.compare(rhs) > 0.

template <class BiIter, class ST, class SA>

bool operator==(

const basic_string<

typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,

const sub_match<BiIter>& rhs);
Returns: rhs.compare(typename sub_match<BiIter>::string_type(lhs.data(), lhs.size()))
== 0.

3

4

5

6

7

1

2

3

4

5

6

7

§ 28.9.2

1118

c(cid:13) ISO/IEC

N4296

template <class BiIter, class ST, class SA>

bool operator!=(

const basic_string<

typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,

const sub_match<BiIter>& rhs);
Returns: !(lhs == rhs).

template <class BiIter, class ST, class SA>

bool operator<(

const basic_string<

typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,

const sub_match<BiIter>& rhs);
Returns: rhs.compare(typename sub_match<BiIter>::string_type(lhs.data(), lhs.size()))
> 0.

template <class BiIter, class ST, class SA>

bool operator>(

const basic_string<

typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,

typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,

const sub_match<BiIter>& rhs);
Returns: rhs < lhs.

template <class BiIter, class ST, class SA>

bool operator>=(

const basic_string<

const sub_match<BiIter>& rhs);
Returns: !(lhs < rhs).

template <class BiIter, class ST, class SA>

bool operator<=(

const basic_string<

const sub_match<BiIter>& rhs);
Returns: !(rhs < lhs).

typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,

8

9

10

11

12

13

template <class BiIter, class ST, class SA>

bool operator==(const sub_match<BiIter>& lhs,

const basic_string<

typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);

Returns: lhs.compare(typename sub_match<BiIter>::string_type(rhs.data(), rhs.size()))
== 0.

template <class BiIter, class ST, class SA>

bool operator!=(const sub_match<BiIter>& lhs,

const basic_string<

typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);

14

Returns: !(lhs == rhs).

template <class BiIter, class ST, class SA>

bool operator<(const sub_match<BiIter>& lhs,

const basic_string<

typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);

§ 28.9.2

1119

c(cid:13) ISO/IEC

N4296

Returns: lhs.compare(typename sub_match<BiIter>::string_type(rhs.data(), rhs.size()))
< 0.

template <class BiIter, class ST, class SA>

bool operator>(const sub_match<BiIter>& lhs,

const basic_string<

typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);

Returns: rhs < lhs.

template <class BiIter, class ST, class SA>

bool operator>=(const sub_match<BiIter>& lhs,

const basic_string<

typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);

Returns: !(lhs < rhs).

template <class BiIter, class ST, class SA>

bool operator<=(const sub_match<BiIter>& lhs,

const basic_string<

typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);

Returns: !(rhs < lhs).

template <class BiIter>

bool operator==(typename iterator_traits<BiIter>::value_type const* lhs,

const sub_match<BiIter>& rhs);

Returns: rhs.compare(lhs) == 0.

template <class BiIter>

bool operator!=(typename iterator_traits<BiIter>::value_type const* lhs,

const sub_match<BiIter>& rhs);

Returns: !(lhs == rhs).

template <class BiIter>

bool operator<(typename iterator_traits<BiIter>::value_type const* lhs,

const sub_match<BiIter>& rhs);

Returns: rhs.compare(lhs) > 0.

template <class BiIter>

bool operator>(typename iterator_traits<BiIter>::value_type const* lhs,

const sub_match<BiIter>& rhs);

Returns: rhs < lhs.

template <class BiIter>

bool operator>=(typename iterator_traits<BiIter>::value_type const* lhs,

const sub_match<BiIter>& rhs);

Returns: !(lhs < rhs).

template <class BiIter>

bool operator<=(typename iterator_traits<BiIter>::value_type const* lhs,

const sub_match<BiIter>& rhs);

Returns: !(rhs < lhs).

§ 28.9.2

1120

15

16

17

18

19

20

21

22

23

24

c(cid:13) ISO/IEC

N4296

template <class BiIter>

bool operator==(const sub_match<BiIter>& lhs,

typename iterator_traits<BiIter>::value_type const* rhs);

Returns: lhs.compare(rhs) == 0.

template <class BiIter>

bool operator!=(const sub_match<BiIter>& lhs,

typename iterator_traits<BiIter>::value_type const* rhs);

Returns: !(lhs == rhs).

template <class BiIter>

bool operator<(const sub_match<BiIter>& lhs,

typename iterator_traits<BiIter>::value_type const* rhs);

Returns: lhs.compare(rhs) < 0.

template <class BiIter>

bool operator>(const sub_match<BiIter>& lhs,

typename iterator_traits<BiIter>::value_type const* rhs);

Returns: rhs < lhs.

template <class BiIter>

bool operator>=(const sub_match<BiIter>& lhs,

typename iterator_traits<BiIter>::value_type const* rhs);

Returns: !(lhs < rhs).

template <class BiIter>

bool operator<=(const sub_match<BiIter>& lhs,

typename iterator_traits<BiIter>::value_type const* rhs);

Returns: !(rhs < lhs).

template <class BiIter>

bool operator==(typename iterator_traits<BiIter>::value_type const& lhs,

const sub_match<BiIter>& rhs);

Returns: rhs.compare(typename sub_match<BiIter>::string_type(1, lhs)) == 0.

template <class BiIter>

bool operator!=(typename iterator_traits<BiIter>::value_type const& lhs,

const sub_match<BiIter>& rhs);

Returns: !(lhs == rhs).

template <class BiIter>

bool operator<(typename iterator_traits<BiIter>::value_type const& lhs,

const sub_match<BiIter>& rhs);

Returns: rhs.compare(typename sub_match<BiIter>::string_type(1, lhs)) > 0.

template <class BiIter>

bool operator>(typename iterator_traits<BiIter>::value_type const& lhs,

const sub_match<BiIter>& rhs);

Returns: rhs < lhs.

§ 28.9.2

1121

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

c(cid:13) ISO/IEC

N4296

template <class BiIter>

bool operator>=(typename iterator_traits<BiIter>::value_type const& lhs,

const sub_match<BiIter>& rhs);

Returns: !(lhs < rhs).

template <class BiIter>

bool operator<=(typename iterator_traits<BiIter>::value_type const& lhs,

const sub_match<BiIter>& rhs);

Returns: !(rhs < lhs).

template <class BiIter>

bool operator==(const sub_match<BiIter>& lhs,

typename iterator_traits<BiIter>::value_type const& rhs);

Returns: lhs.compare(typename sub_match<BiIter>::string_type(1, rhs)) == 0.

template <class BiIter>

bool operator!=(const sub_match<BiIter>& lhs,

typename iterator_traits<BiIter>::value_type const& rhs);

Returns: !(lhs == rhs).

template <class BiIter>

bool operator<(const sub_match<BiIter>& lhs,

typename iterator_traits<BiIter>::value_type const& rhs);

Returns: lhs.compare(typename sub_match<BiIter>::string_type(1, rhs)) < 0.

template <class BiIter>

bool operator>(const sub_match<BiIter>& lhs,

typename iterator_traits<BiIter>::value_type const& rhs);

Returns: rhs < lhs.

template <class BiIter>

bool operator>=(const sub_match<BiIter>& lhs,

typename iterator_traits<BiIter>::value_type const& rhs);

Returns: !(lhs < rhs).

template <class BiIter>

bool operator<=(const sub_match<BiIter>& lhs,

typename iterator_traits<BiIter>::value_type const& rhs);

Returns: !(rhs < lhs).

template <class charT, class ST, class BiIter>

basic_ostream<charT, ST>&
operator<<(basic_ostream<charT, ST>& os, const sub_match<BiIter>& m);

Returns: (os << m.str()).

§ 28.9.2

1122

c(cid:13) ISO/IEC

N4296

28.10 Class template match_results

[re.results]
1 Class template match_results denotes a collection of character sequences representing the result of a regular
expression match. Storage for the collection is allocated and freed as necessary by the member functions of
class template match_results.

2 The class template match_results shall satisfy the requirements of an allocator-aware container and of a
sequence container, as speciﬁed in 23.2.3, except that only operations deﬁned for const-qualiﬁed sequence
containers are supported.

3 A default-constructed match_results object has no fully established result state. A match result is ready
when, as a consequence of a completed regular expression match modifying such an object, its result state
becomes fully established. The eﬀects of calling most member functions from a match_results object that
is not ready are undeﬁned.

4 The sub_match object stored at index 0 represents sub-expression 0, i.e., the whole match. In this case the
sub_match member matched is always true. The sub_match object stored at index n denotes what matched
the marked sub-expression n within the matched expression. If the sub-expression n participated in a regular
expression match then the sub_match member matched evaluates to true, and members first and second
denote the range of characters [first,second) which formed that match. Otherwise matched is false, and
members first and second point to the end of the sequence that was searched.
[ Note: The sub_match
objects representing diﬀerent sub-expressions that did not participate in a regular expression match need
not be distinct. — end note ]

namespace std {

template <class BidirectionalIterator,

class match_results {
public:

class Allocator = allocator<sub_match<BidirectionalIterator>>>

typedef sub_match<BidirectionalIterator>
typedef const value_type&
typedef value_type&
typedef implementation-defined
typedef const_iterator
typedef typename
iterator_traits<BidirectionalIterator>::difference_type
typedef typename allocator_traits<Allocator>::size_type
typedef Allocator
typedef typename iterator_traits<BidirectionalIterator>::

value_type

typedef basic_string<char_type>

value_type;
const_reference;
reference;
const_iterator;
iterator;

difference_type;
size_type;
allocator_type;

char_type;
string_type;

// 28.10.1, construct/copy/destroy:
explicit match_results(const Allocator& a = Allocator());
match_results(const match_results& m);
match_results(match_results&& m) noexcept;
match_results& operator=(const match_results& m);
match_results& operator=(match_results&& m);
~match_results();

// 28.10.2, state:
bool ready() const;

// 28.10.3, size:
size_type size() const;
size_type max_size() const;
bool empty() const;

§ 28.10

1123

c(cid:13) ISO/IEC

N4296

// 28.10.4, element access:
difference_type length(size_type sub = 0) const;
difference_type position(size_type sub = 0) const;
string_type str(size_type sub = 0) const;
const_reference operator[](size_type n) const;

const_reference prefix() const;
const_reference suffix() const;
const_iterator begin() const;
const_iterator end() const;
const_iterator cbegin() const;
const_iterator cend() const;

// 28.10.5, format:
template <class OutputIter>
OutputIter
format(OutputIter out,

const char_type* fmt_first, const char_type* fmt_last,
regex_constants::match_flag_type flags =
regex_constants::format_default) const;
template <class OutputIter, class ST, class SA>

OutputIter
format(OutputIter out,

const basic_string<char_type, ST, SA>& fmt,
regex_constants::match_flag_type flags =
regex_constants::format_default) const;

template <class ST, class SA>
basic_string<char_type, ST, SA>
format(const basic_string<char_type, ST, SA>& fmt,

regex_constants::match_flag_type flags =
regex_constants::format_default) const;

string_type
format(const char_type* fmt,

regex_constants::match_flag_type flags =
regex_constants::format_default) const;

// 28.10.6, allocator:
allocator_type get_allocator() const;

// 28.10.7, swap:
void swap(match_results& that);

};

}

1

2

3

[re.results.const]
28.10.1 match_results constructors
In all match_results constructors, a copy of the Allocator argument shall be used for any memory allo-
cation performed by the constructor or member functions during the lifetime of the object.

match_results(const Allocator& a = Allocator());

Eﬀects: Constructs an object of class match_results.
Postconditions: ready() returns false. size() returns 0.

match_results(const match_results& m);

§ 28.10.1

1124

c(cid:13) ISO/IEC

N4296

Eﬀects: Constructs an object of class match_results, as a copy of m.

match_results(match_results&& m) noexcept;

Eﬀects: Move-constructs an object of class match_results from m satisfying the same postconditions
as Table 142. Additionally, the stored Allocator value is move constructed from m.get_allocator().
Throws: Nothing.

match_results& operator=(const match_results& m);

Eﬀects: Assigns m to *this. The postconditions of this function are indicated in Table 142.

match_results& operator=(match_results&& m);

Eﬀects: Move-assigns m to *this. The postconditions of this function are indicated in Table 142.

Table 142 — match_results assignment operator eﬀects

Element

ready()
size()
str(n)
prefix()
suffix()
(*this)[n]
length(n)
position(n)

Value

m.ready()
m.size()
m.str(n) for all integers n < m.size()
m.prefix()
m.suffix()
m[n] for all integers n < m.size()
m.length(n) for all integers n < m.size()
m.position(n) for all integers n < m.size()

28.10.2 match_results state
bool ready() const;

Returns: true if *this has a fully established result state, otherwise false.

28.10.3 match_results size
size_type size() const;

[re.results.state]

[re.results.size]

Returns: One plus the number of marked sub-expressions in the regular expression that was matched
if *this represents the result of a successful match. Otherwise returns 0.
[ Note: The state of a
match_results object can be modiﬁed only by passing that object to regex_match or regex_search.
Sections 28.11.2 and 28.11.3 specify the eﬀects of those algorithms on their match_results arguments.
— end note ]

size_type max_size() const;

Returns: The maximum number of sub_match elements that can be stored in *this.

bool empty() const;

Returns: size() == 0.

4

5

6

7

8

1

1

2

3

§ 28.10.3

1125

c(cid:13) ISO/IEC

28.10.4 match_results element access
difference_type length(size_type sub = 0) const;

Requires: ready() == true.
Returns: (*this)[sub].length().

difference_type position(size_type sub = 0) const;

N4296

[re.results.acc]

Requires: ready() == true.
Returns: The distance from the start of the target sequence to (*this)[sub].first.

string_type str(size_type sub = 0) const;

Requires: ready() == true.
Returns: string_type((*this)[sub]).

const_reference operator[](size_type n) const;

Requires: ready() == true.
Returns: A reference to the sub_match object representing the character sequence that matched marked
sub-expression n. If n == 0 then returns a reference to a sub_match object representing the character
sequence that matched the whole regular expression. If n >= size() then returns a sub_match object
representing an unmatched sub-expression.

const_reference prefix() const;
Requires: ready() == true.
Returns: A reference to the sub_match object representing the character sequence from the start of
the string being matched/searched to the start of the match found.

const_reference suffix() const;
Requires: ready() == true.
Returns: A reference to the sub_match object representing the character sequence from the end of the
match found to the end of the string being matched/searched.

const_iterator begin() const;
const_iterator cbegin() const;

Returns: A starting iterator that enumerates over all the sub-expressions stored in *this.

const_iterator end() const;
const_iterator cend() const;

Returns: A terminating iterator that enumerates over all the sub-expressions stored in *this.

1

2

3

4

5

6

7

8

9

10

11

12

13

14

28.10.5 match_results formatting
template <class OutputIter>

OutputIter format(OutputIter out,

const char_type* fmt_first, const char_type* fmt_last,
regex_constants::match_flag_type flags =
regex_constants::format_default) const;

[re.results.form]

§ 28.10.5

1126

c(cid:13) ISO/IEC

N4296

Requires: ready() == true and OutputIter shall satisfy the requirements for an Output Iterator (24.2.4).
Eﬀects: Copies the character sequence [fmt_first,fmt_last) to OutputIter out. Replaces each
format speciﬁer or escape sequence in the copied range with either the character(s) it represents or
the sequence of characters within *this to which it refers. The bitmasks speciﬁed in flags determine
which format speciﬁers and escape sequences are recognized.
Returns: out.

template <class OutputIter, class ST, class SA>

OutputIter format(OutputIter out,

const basic_string<char_type, ST, SA>& fmt,
regex_constants::match_flag_type flags =
regex_constants::format_default) const;

Eﬀects: Equivalent to return format(out, fmt.data(), fmt.data() + fmt.size(), flags).

template <class ST, class SA>

basic_string<char_type, ST, SA>
format(const basic_string<char_type, ST, SA>& fmt,

regex_constants::match_flag_type flags =
regex_constants::format_default) const;

Requires: ready() == true.
Eﬀects: Constructs an empty string result of type basic_string<char_type, ST, SA> and calls
format(back_inserter(result), fmt, flags).
Returns: result.

string_type

format(const char_type* fmt,

regex_constants::match_flag_type flags =
regex_constants::format_default) const;

Requires: ready() == true.
calls
an
Eﬀects:
format(back_inserter(result), fmt, fmt + char_traits<char_type>::length(fmt), flags).
Returns: result.

string_type

Constructs

empty

string

and

result

of

type

28.10.6 match_results allocator
allocator_type get_allocator() const;

[re.results.all]

Returns: A copy of the Allocator that was passed to the object’s constructor or, if that allocator has
been replaced, a copy of the most recent replacement.

28.10.7 match_results swap
void swap(match_results& that);

[re.results.swap]

Eﬀects: Swaps the contents of the two sequences.
Postcondition: *this contains the sequence of matched sub-expressions that were in that, that con-
tains the sequence of matched sub-expressions that were in *this.
Complexity: Constant time.

1

2

3

4

5

6

7

8

9

10

1

1

2

3

template <class BidirectionalIterator, class Allocator>

void swap(match_results<BidirectionalIterator, Allocator>& m1,
match_results<BidirectionalIterator, Allocator>& m2);

4 Eﬀects: m1.swap(m2).

§ 28.10.7

1127

c(cid:13) ISO/IEC

N4296

28.10.8 match_results non-member functions
template <class BidirectionalIterator, class Allocator>
bool operator==(const match_results<BidirectionalIterator, Allocator>& m1,
const match_results<BidirectionalIterator, Allocator>& m2);

[re.results.nonmember]

1

(1.1)

(1.2)

(1.2.1)
(1.2.2)
(1.2.3)

Returns: true if neither match result is ready, false if one match result is ready and the other is not.
If both match results are ready, returns true only if:
—
—

m1.empty() && m2.empty(), or
!m1.empty() && !m2.empty(), and the following conditions are satisﬁed:
—
—
—

m1.prefix() == m2.prefix(),
m1.size() == m2.size() && equal(m1.begin(), m1.end(), m2.begin()), and
m1.suffix() == m2.suffix().

[ Note: The algorithm equal is deﬁned in Clause 25. — end note ]

template <class BidirectionalIterator, class Allocator>
bool operator!=(const match_results<BidirectionalIterator, Allocator>& m1,
const match_results<BidirectionalIterator, Allocator>& m2);

2

Returns: !(m1 == m2).

1 The algorithms described in this subclause may throw an exception of type regex_error.

28.11 Regular expression algorithms
28.11.1 exceptions

[re.alg]
[re.except]
If such an
exception e is thrown, e.code() shall return either regex_constants::error_complexity or regex_-
constants::error_stack.
28.11.2 regex_match
template <class BidirectionalIterator, class Allocator, class charT, class traits>

[re.alg.match]

bool regex_match(BidirectionalIterator first, BidirectionalIterator last,

match_results<BidirectionalIterator, Allocator>& m,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

1

2

3

Requires: The type BidirectionalIterator shall satisfy the requirements of a Bidirectional Iterator
(24.2.6).
Eﬀects: Determines whether there is a match between the regular expression e, and all of the character
sequence [first,last). The parameter flags is used to control how the expression is matched against
the character sequence. Returns true if such a match exists, false otherwise.
Postconditions: m.ready() == true in all cases.
If the function returns false, then the eﬀect on
parameter m is unspeciﬁed except that m.size() returns 0 and m.empty() returns true. Otherwise
the eﬀects on parameter m are given in Table 143.

Table 143 — Eﬀects of regex_match algorithm

Element

m.size()
m.empty()
m.prefix().first

1 + e.mark_count()
false
ﬁrst

Value

§ 28.11.2

1128

c(cid:13) ISO/IEC

N4296

Table 143 — Eﬀects of regex_match algorithm (continued)

Element

m.prefix().second
m.prefix().matched
m.suffix().first
m.suffix().second
m.suffix().matched
m[0].first
m[0].second
m[0].matched
m[n].first

m[n].second

m[n].matched

Value

ﬁrst
false
last
last
false
ﬁrst
last
true
For all integers 0 < n < m.size(), the start of the se-
quence that matched sub-expression n. Alternatively, if
sub-expression n did not participate in the match, then
last.
For all integers 0 < n < m.size(), the end of the se-
quence that matched sub-expression n. Alternatively, if
sub-expression n did not participate in the match, then
last.
For all integers 0 < n < m.size(), true if sub-expression
n participated in the match, false otherwise.

template <class BidirectionalIterator, class charT, class traits>

bool regex_match(BidirectionalIterator first, BidirectionalIterator last,

const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

Eﬀects: Behaves “as if” by constructing an instance of match_results<BidirectionalIterator>
what, and then returning the result of regex_match(first, last, what, e, flags).

template <class charT, class Allocator, class traits>

bool regex_match(const charT* str,

match_results<const charT*, Allocator>& m,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

Returns: regex_match(str, str + char_traits<charT>::length(str), m, e, flags).

template <class ST, class SA, class Allocator, class charT, class traits>

bool regex_match(const basic_string<charT, ST, SA>& s,

match_results<

typename basic_string<charT, ST, SA>::const_iterator,
Allocator>& m,

const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

Returns: regex_match(s.begin(), s.end(), m, e, flags).

template <class charT, class traits>
bool regex_match(const charT* str,

§ 28.11.2

1129

4

5

6

7

8

1

2

3

c(cid:13) ISO/IEC

N4296

const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

Returns: regex_match(str, str + char_traits<charT>::length(str), e, flags)

template <class ST, class SA, class charT, class traits>
bool regex_match(const basic_string<charT, ST, SA>& s,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

Returns: regex_match(s.begin(), s.end(), e, flags).

28.11.3 regex_search
template <class BidirectionalIterator, class Allocator, class charT, class traits>

bool regex_search(BidirectionalIterator first, BidirectionalIterator last,

match_results<BidirectionalIterator, Allocator>& m,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

[re.alg.search]

Requires: Type BidirectionalIterator shall satisfy the requirements of a Bidirectional Iterator
(24.2.6).
Eﬀects: Determines whether there is some sub-sequence within [first,last) that matches the regular
expression e. The parameter flags is used to control how the expression is matched against the
character sequence. Returns true if such a sequence exists, false otherwise.
Postconditions: m.ready() == true in all cases.
If the function returns false, then the eﬀect on
parameter m is unspeciﬁed except that m.size() returns 0 and m.empty() returns true. Otherwise
the eﬀects on parameter m are given in Table 144.

Table 144 — Eﬀects of regex_search algorithm

Element

m.size()
m.empty()
m.prefix().first
m.prefix().second
m.prefix().matched
m.suffix().first
m.suffix().second
m.suffix().matched
m[0].first

m[0].second

m[0].matched
m[n].first

Value

1 + e.mark_count()
false
first
m[0].first
m.prefix().first != m.prefix().second
m[0].second
last
m.suffix().first != m.suffix().second
The start of the sequence of characters that matched the
regular expression
The end of the sequence of characters that matched the
regular expression
true
For all integers 0 < n < m.size(), the start of the se-
quence that matched sub-expression n. Alternatively, if
sub-expression n did not participate in the match, then
last.

§ 28.11.3

1130

c(cid:13) ISO/IEC

N4296

Table 144 — Eﬀects of regex_search algorithm (continued)

Element

m[n].second

m[n].matched

Value

For all integers 0 < n < m.size(), the end of the se-
quence that matched sub-expression n. Alternatively, if
sub-expression n did not participate in the match, then
last .
For all integers 0 < n < m.size(), true if sub-expression
n participated in the match, false otherwise.

template <class charT, class Allocator, class traits>
bool regex_search(const charT* str, match_results<const charT*, Allocator>& m,

const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

Returns: The result of regex_search(str, str + char_traits<charT>::length(str), m, e, flags).

template <class ST, class SA, class Allocator, class charT, class traits>

bool regex_search(const basic_string<charT, ST, SA>& s,

match_results<

typename basic_string<charT, ST, SA>::const_iterator,
Allocator>& m,

const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

Returns: The result of regex_search(s.begin(), s.end(), m, e, flags).

template <class BidirectionalIterator, class charT, class traits>

bool regex_search(BidirectionalIterator first, BidirectionalIterator last,

const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

Eﬀects: Behaves “as if” by constructing an object what of type match_results<BidirectionalIterator>
and then returning the result of regex_search(first, last, what, e, flags).

template <class charT, class traits>
bool regex_search(const charT* str,

const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

Returns: regex_search(str, str + char_traits<charT>::length(str), e, flags)

template <class ST, class SA, class charT, class traits>
bool regex_search(const basic_string<charT, ST, SA>& s,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags =

regex_constants::match_default);

Returns: regex_search(s.begin(), s.end(), e, flags).

§ 28.11.3

1131

4

5

6

7

8

N4296

[re.alg.replace]

c(cid:13) ISO/IEC

28.11.4 regex_replace
template <class OutputIterator, class BidirectionalIterator,

class traits, class charT, class ST, class SA>

OutputIterator
regex_replace(OutputIterator out,

BidirectionalIterator first, BidirectionalIterator last,
const basic_regex<charT, traits>& e,
const basic_string<charT, ST, SA>& fmt,
regex_constants::match_flag_type flags =

regex_constants::match_default);

template <class OutputIterator, class BidirectionalIterator,

class traits, class charT>

OutputIterator
regex_replace(OutputIterator out,

BidirectionalIterator first, BidirectionalIterator last,
const basic_regex<charT, traits>& e,
const charT* fmt,
regex_constants::match_flag_type flags =

regex_constants::match_default);

1

Eﬀects: Constructs a regex_iterator object i as if by

regex_iterator<BidirectionalIterator, charT, traits> i(first, last, e, flags)

and uses i to enumerate through all of the matches m of type match_results<BidirectionalIterator>
that occur within the sequence [first,last). If no such matches are found and !(flags & regex_-
constants::format_no_copy) then calls

(1.1)

(1.2)

out = std::copy(first, last, out)

If any matches are found then, for each such match:
—

If !(flags & regex_constants::format_no_copy), calls

out = std::copy(m.prefix().first, m.prefix().second, out)

—

Then calls

out = m.format(out, fmt, flags)
for the ﬁrst form of the function and

out = m.format(out, fmt, fmt + char_traits<charT>::length(fmt), flags)

for the second.

Finally, if such a match is found and !(flags & regex_constants::format_no_copy), calls

out = std::copy(last_m.suffix().first, last_m.suffix().second, out)

where last_m is a copy of the last match found. If flags & regex_constants::format_first_only
is non-zero then only the ﬁrst match found is replaced.
Returns: out.

2

template <class traits, class charT, class ST, class SA, class FST, class FSA>

basic_string<charT, ST, SA>
regex_replace(const basic_string<charT, ST, SA>& s,
const basic_regex<charT, traits>& e,

§ 28.11.4

1132

c(cid:13) ISO/IEC

N4296

const basic_string<charT, FST, FSA>& fmt,
regex_constants::match_flag_type flags =

regex_constants::match_default);

template <class traits, class charT, class ST, class SA>

basic_string<charT, ST, SA>
regex_replace(const basic_string<charT, ST, SA>& s,
const basic_regex<charT, traits>& e,
const charT* fmt,
regex_constants::match_flag_type flags =

regex_constants::match_default);

Eﬀects: Constructs an empty string result of type basic_string<charT, ST, SA> and calls regex_-
replace(back_inserter(result), s.begin(), s.end(), e, fmt, flags).
Returns: result.

template <class traits, class charT, class ST, class SA>

basic_string<charT>
regex_replace(const charT* s,

const basic_regex<charT, traits>& e,
const basic_string<charT, ST, SA>& fmt,
regex_constants::match_flag_type flags =

regex_constants::match_default);

template <class traits, class charT>

basic_string<charT>
regex_replace(const charT* s,

const basic_regex<charT, traits>& e,
const charT* fmt,
regex_constants::match_flag_type flags =

regex_constants::match_default);

3

4

5

6

Eﬀects: Constructs an empty string result of type basic_string<charT> and calls regex_replace(
back_inserter(result), s, s + char_traits<charT>::length(s), e, fmt, flags).
Returns: result.

28.12 Regular expression iterators
28.12.1 Class template regex_iterator

[re.iter]
[re.regiter]
1 The class template regex_iterator is an iterator adaptor. It represents a new view of an existing iterator
sequence, by enumerating all the occurrences of a regular expression within that sequence. A regex_-
iterator uses regex_search to ﬁnd successive regular expression matches within the sequence from which
it was constructed. After the iterator is constructed, and every time operator++ is used, the iterator ﬁnds
and stores a value of match_results<BidirectionalIterator>.
If the end of the sequence is reached
(regex_search returns false), the iterator becomes equal to the end-of-sequence iterator value. The de-
fault constructor constructs an end-of-sequence iterator object, which is the only legitimate iterator to be
used for the end condition. The result of operator* on an end-of-sequence iterator is not deﬁned. For
any other iterator value a const match_results<BidirectionalIterator>& is returned. The result of
operator-> on an end-of-sequence iterator is not deﬁned. For any other iterator value a const match_-
results<BidirectionalIterator>* is returned.
It is impossible to store things into regex_iterators.
Two end-of-sequence iterators are always equal. An end-of-sequence iterator is not equal to a non-end-of-
sequence iterator. Two non-end-of-sequence iterators are equal when they are constructed from the same
arguments.

namespace std {

template <class BidirectionalIterator,

§ 28.12.1

1133

c(cid:13) ISO/IEC

N4296

class charT = typename iterator_traits<

BidirectionalIterator>::value_type,
class traits = regex_traits<charT> >

class regex_iterator {
public:

typedef basic_regex<charT, traits>
regex_type;
typedef match_results<BidirectionalIterator> value_type;
typedef std::ptrdiff_t
typedef const value_type*
typedef const value_type&
typedef std::forward_iterator_tag

difference_type;
pointer;
reference;
iterator_category;

regex_iterator();
regex_iterator(BidirectionalIterator a, BidirectionalIterator b,

const regex_type& re,
regex_constants::match_flag_type m =

regex_constants::match_default);

regex_iterator(BidirectionalIterator a, BidirectionalIterator b,

const regex_type&& re,
regex_constants::match_flag_type m =

regex_constants::match_default) = delete;

regex_iterator(const regex_iterator&);
regex_iterator& operator=(const regex_iterator&);
bool operator==(const regex_iterator&) const;
bool operator!=(const regex_iterator&) const;
const value_type& operator*() const;
const value_type* operator->() const;
regex_iterator& operator++();
regex_iterator operator++(int);

begin; // exposition only
BidirectionalIterator
// exposition only
end;
BidirectionalIterator
pregex; // exposition only
const regex_type*
flags; // exposition only
regex_constants::match_flag_type
match_results<BidirectionalIterator> match; // exposition only

private:

};

}

2 An object of type regex_iterator that is not an end-of-sequence iterator holds a zero-length match if
match[0].matched == true and match[0].first == match[0].second.
[ Note: For example, this can
occur when the part of the regular expression that matched consists only of an assertion (such as ’^’, ’$’,
’\b’, ’\B’). — end note ]
28.12.1.1 regex_iterator constructors
regex_iterator();

[re.regiter.cnstr]

1

2

Eﬀects: Constructs an end-of-sequence iterator.

regex_iterator(BidirectionalIterator a, BidirectionalIterator b,

const regex_type& re,
regex_constants::match_flag_type m = regex_constants::match_default);

Eﬀects: Initializes begin and end to a and b, respectively, sets pregex to &re, sets flags to m, then calls
regex_search(begin, end, match, *pregex, flags).
If this call returns false the constructor
sets *this to the end-of-sequence iterator.

§ 28.12.1.1

1134

c(cid:13) ISO/IEC

28.12.1.2 regex_iterator comparisons
bool operator==(const regex_iterator& right) const;

N4296

[re.regiter.comp]

1

(1.1)
(1.2)
(1.3)
(1.4)
(1.5)

Returns: true if *this and right are both end-of-sequence iterators or if the following conditions all
hold:
—
—
—
—
—
otherwise false.

begin == right.begin,
end == right.end,
pregex == right.pregex,
flags == right.flags, and
match[0] == right.match[0];

bool operator!=(const regex_iterator& right) const;

2

1

2

1

2

3

4

5

6

7

8

Returns: !(*this == right).

28.12.1.3 regex_iterator indirection
const value_type& operator*() const;

Returns: match.

const value_type* operator->() const;

Returns: &match.

28.12.1.4 regex_iterator increment
regex_iterator& operator++();

[re.regiter.deref]

[re.regiter.incr]

Eﬀects: Constructs a local variable start of type BidirectionalIterator and initializes it with the
value of match[0].second.
If the iterator holds a zero-length match and start == end the operator sets *this to the end-of-
sequence iterator and returns *this.
Otherwise, if the iterator holds a zero-length match the operator calls regex_search(start, end,
match, *pregex, flags | regex_constants::match_not_null | regex_constants::match_
continuous). If the call returns true the operator returns *this. Otherwise the operator increments
start and continues as if the most recent match was not a zero-length match.
If the most recent match was not a zero-length match, the operator sets flags to flags | regex_-
constants ::match_prev_avail and calls regex_search(start, end, match, *pregex, flags).
If the call returns false the iterator sets *this to the end-of-sequence iterator. The iterator then
returns *this.
In all cases in which the call to regex_search returns true, match.prefix().first shall be equal to
the previous value of match[0].second, and for each index i in the half-open range [0, match.size())
for which match[i].matched is true, match[i].position() shall return distance(begin, match[i].
first).
[ Note: This means that match[i].position() gives the oﬀset from the beginning of the target se-
quence, which is often not the same as the oﬀset from the sequence passed in the call to regex_search.
— end note ]
It is unspeciﬁed how the implementation makes these adjustments.
[ Note: This means that a compiler may call an implementation-speciﬁc search function, in which case
a user-deﬁned specialization of regex_search will not be called. — end note ]

§ 28.12.1.4

1135

c(cid:13) ISO/IEC

regex_iterator operator++(int);

9

Eﬀects:

regex_iterator tmp = *this;
++(*this);
return tmp;

N4296

28.12.2 Class template regex_token_iterator

[re.tokiter]
1 The class template regex_token_iterator is an iterator adaptor; that is to say it represents a new view
of an existing iterator sequence, by enumerating all the occurrences of a regular expression within that
sequence, and presenting one or more sub-expressions for each match found. Each position enumerated by
the iterator is a sub_match class template instance that represents what matched a particular sub-expression
within the regular expression.

2 When class regex_token_iterator is used to enumerate a single sub-expression with index -1 the iterator
performs ﬁeld splitting: that is to say it enumerates one sub-expression for each section of the character
container sequence that does not match the regular expression speciﬁed.

3 After it is constructed, the iterator ﬁnds and stores a value regex_iterator<BidirectionalIterator>
position and sets the internal count N to zero. It also maintains a sequence subs which contains a list of
the sub-expressions which will be enumerated. Every time operator++ is used the count N is incremented; if
N exceeds or equals subs.size(), then the iterator increments member position and sets count N to zero.
If the end of sequence is reached (position is equal to the end of sequence iterator), the iterator becomes
equal to the end-of-sequence iterator value, unless the sub-expression being enumerated has index -1, in
which case the iterator enumerates one last sub-expression that contains all the characters from the end of
the last regular expression match to the end of the input sequence being enumerated, provided that this
would not be an empty sub-expression.

4

5 The default constructor constructs an end-of-sequence iterator object, which is the only legitimate iterator
to be used for the end condition. The result of operator* on an end-of-sequence iterator is not deﬁned.
For any other iterator value a const sub_match<BidirectionalIterator>& is returned. The result of
operator-> on an end-of-sequence iterator is not deﬁned. For any other iterator value a const sub_-
match<BidirectionalIterator>* is returned.
It is impossible to store things into regex_token_iterators. Two end-of-sequence iterators are always
equal. An end-of-sequence iterator is not equal to a non-end-of-sequence iterator. Two non-end-of-sequence
iterators are equal when they are constructed from the same arguments.

6

namespace std {

template <class BidirectionalIterator,

class charT = typename iterator_traits<

BidirectionalIterator>::value_type,
class traits = regex_traits<charT> >

class regex_token_iterator
public:

{

regex_type;
typedef basic_regex<charT, traits>
typedef sub_match<BidirectionalIterator> value_type;
typedef std::ptrdiff_t
typedef const value_type*
typedef const value_type&
typedef std::forward_iterator_tag

difference_type;
pointer;
reference;
iterator_category;

regex_token_iterator();
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,

const regex_type& re,

§ 28.12.2

1136

c(cid:13) ISO/IEC

N4296

regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,

regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,

template <std::size_t N>

regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,

int submatch = 0,
regex_constants::match_flag_type m =

regex_constants::match_default);

const regex_type& re,
const std::vector<int>& submatches,
regex_constants::match_flag_type m =

regex_constants::match_default);

const regex_type& re,
initializer_list<int> submatches,
regex_constants::match_flag_type m =

regex_constants::match_default);

const regex_type& re,
const int (&submatches)[N],
regex_constants::match_flag_type m =

regex_constants::match_default);

const regex_type&& re,
int submatch = 0,
regex_constants::match_flag_type m =

regex_constants::match_default) = delete;

const regex_type&& re,
const std::vector<int>& submatches,
regex_constants::match_flag_type m =

regex_constants::match_default) = delete;

const regex_type&& re,
initializer_list<int> submatches,
regex_constants::match_flag_type m =

regex_constants::match_default) = delete;

const regex_type&& re,
const int (&submatches)[N],
regex_constants::match_flag_type m =

regex_constants::match_default) = delete;

regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,

regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,

regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,

template <std::size_t N>
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,

regex_token_iterator(const regex_token_iterator&);
regex_token_iterator& operator=(const regex_token_iterator&);
bool operator==(const regex_token_iterator&) const;
bool operator!=(const regex_token_iterator&) const;
const value_type& operator*() const;
const value_type* operator->() const;
regex_token_iterator& operator++();
regex_token_iterator operator++(int);

private:
typedef

regex_iterator<BidirectionalIterator, charT, traits> position_iterator; // exposition only
// exposition only
// exposition only
// exposition only
// exposition only

position_iterator position;
const value_type* result;
value_type suffix;
std::size_t N;

§ 28.12.2

1137

c(cid:13) ISO/IEC

std::vector<int> subs;

};

}

N4296

// exposition only

7 A suﬃx iterator is a regex_token_iterator object that points to a ﬁnal sequence of characters at the end
of the target sequence. In a suﬃx iterator the member result holds a pointer to the data member suffix,
the value of the member suffix.match is true, suffix.first points to the beginning of the ﬁnal sequence,
and suffix.second points to the end of the ﬁnal sequence.
[ Note: For a suﬃx iterator, data member suffix.first is the same as the end of the last match found,
and suffix.second is the same as the end of the target sequence — end note ]

8

9 The current match is (*position).prefix() if subs[N] == -1, or (*position)[subs[N]] for any other

value of subs[N].
28.12.2.1 regex_token_iterator constructors
regex_token_iterator();

[re.tokiter.cnstr]

1

Eﬀects: Constructs the end-of-sequence iterator.

regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,

const regex_type& re,
int submatch = 0,
regex_constants::match_flag_type m =
regex_constants::match_default);

regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,

const regex_type& re,
const std::vector<int>& submatches,
regex_constants::match_flag_type m =
regex_constants::match_default);

regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,

const regex_type& re,
initializer_list<int> submatches,
regex_constants::match_flag_type m =

regex_constants::match_default);

template <std::size_t N>

regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,

const regex_type& re,
const int (&submatches)[N],
regex_constants::match_flag_type m =
regex_constants::match_default);

2

3

4

Requires: Each of the initialization values of submatches shall be >= -1.
Eﬀects: The ﬁrst constructor initializes the member subs to hold the single value submatch. The second
constructor initializes the member subs to hold a copy of the argument submatches. The third and
fourth constructors initialize the member subs to hold a copy of the sequence of integer values pointed
to by the iterator range [submatches.begin(),submatches.end()) and [&submatches,&submatches
+ N), respectively.
Each constructor then sets N to 0, and position to position_iterator(a, b, re, m). If position
is not an end-of-sequence iterator the constructor sets result to the address of the current match.
Otherwise if any of the values stored in subs is equal to -1 the constructor sets *this to a suﬃx

§ 28.12.2.1

1138

c(cid:13) ISO/IEC

N4296

iterator that points to the range [a,b), otherwise the constructor sets *this to an end-of-sequence
iterator.

28.12.2.2 regex_token_iterator comparisons
bool operator==(const regex_token_iterator& right) const;

[re.tokiter.comp]

Returns: true if *this and right are both end-of-sequence iterators, or if *this and right are both
suﬃx iterators and suffix == right.suffix; otherwise returns false if *this or right is an end-
of-sequence iterator or a suﬃx iterator. Otherwise returns true if position == right.position, N
== right.N, and subs == right.subs. Otherwise returns false.

bool operator!=(const regex_token_iterator& right) const;

Returns: !(*this == right).

28.12.2.3 regex_token_iterator indirection
const value_type& operator*() const;

Returns: *result.

const value_type* operator->() const;

Returns: result.

28.12.2.4 regex_token_iterator increment
regex_token_iterator& operator++();

[re.tokiter.deref]

[re.tokiter.incr]

Eﬀects: Constructs a local variable prev of type position_iterator, initialized with the value of
position.
If *this is a suﬃx iterator, sets *this to an end-of-sequence iterator.
Otherwise, if N + 1 < subs.size(), increments N and sets result to the address of the current match.
Otherwise, sets N to 0 and increments position. If position is not an end-of-sequence iterator the
operator sets result to the address of the current match.
Otherwise, if any of the values stored in subs is equal to -1 and prev->suffix().length() is not
0 the operator sets *this to a suﬃx iterator that points to the range [prev->suffix().first,
prev->suffix().second).
Otherwise, sets *this to an end-of-sequence iterator.
Returns: *this

regex_token_iterator& operator++(int);

Eﬀects: Constructs a copy tmp of *this, then calls ++(*this).
Returns: tmp.

1

2

1

2

1

2

3

4

5

6

7

8

28.13 Modiﬁed ECMAScript regular expression grammar

[re.grammar]
1 The regular expression grammar recognized by basic_regex objects constructed with the ECMAScript ﬂag

is that speciﬁed by ECMA-262, except as speciﬁed below.

2 Objects of type specialization of basic_regex store within themselves a default-constructed instance of
their traits template parameter, henceforth referred to as traits_inst. This traits_inst object is used
to support localization of the regular expression; basic_regex member functions shall not call any locale
dependent C or C++ API, including the formatted string input functions.
Instead they shall call the
appropriate traits member function to achieve the required eﬀect.

§ 28.13

1139

c(cid:13) ISO/IEC

N4296

3 The following productions within the ECMAScript grammar are modiﬁed as follows:

ClassAtom ::

-
ClassAtomNoDash
ClassAtomExClass
ClassAtomCollatingElement
ClassAtomEquivalence

4 The following new productions are then added:

ClassAtomExClass ::

[: ClassName :]

ClassAtomCollatingElement ::

[. ClassName .]

ClassAtomEquivalence ::

[= ClassName =]

ClassName ::

ClassNameCharacter
ClassNameCharacter ClassName

ClassNameCharacter ::

SourceCharacter but not one of "." "=" ":"

5 The productions ClassAtomExClass, ClassAtomCollatingElement and ClassAtomEquivalence provide

functionality equivalent to that of the same features in regular expressions in POSIX.

6 The regular expression grammar may be modiﬁed by any regex_constants::syntax_option_type ﬂags
speciﬁed when constructing an object of type specialization of basic_regex according to the rules in Table
138.

7 A ClassName production, when used in ClassAtomExClass, is not valid if traits_inst.lookup_classname
returns zero for that name. The names recognized as valid ClassNames are determined by the type of
the traits class, but at least the following names shall be recognized: alnum, alpha, blank, cntrl, digit,
graph, lower, print, punct, space, upper, xdigit, d, s, w. In addition the following expressions shall be
equivalent:

\d and [[:digit:]]

\D and [^[:digit:]]

\s and [[:space:]]

\S and [^[:space:]]

\w and [_[:alnum:]]

\W and [^_[:alnum:]]

8 A ClassName production when used in a ClassAtomCollatingElement production is not valid if the value

returned by traits_inst.lookup_collatename for that name is an empty string.

9 The results from multiple calls to traits_inst.lookup_classname can be bitwise OR’ed together and

subsequently passed to traits_inst.isctype.

§ 28.13

1140

c(cid:13) ISO/IEC

N4296

10 A ClassName production when used in a ClassAtomEquivalence production is not valid if the value returned
by traits_inst.lookup_collatename for that name is an empty string or if the value returned by traits_-
inst.transform_primary for the result of the call to traits_inst.lookup_collatename is an empty string.
11 When the sequence of characters being transformed to a ﬁnite state machine contains an invalid class name

the translator shall throw an exception object of type regex_error.
If the CV of a UnicodeEscapeSequence is greater than the largest value that can be held in an object of type
charT the translator shall throw an exception object of type regex_error. [ Note: This means that values
of the form "uxxxx" that do not ﬁt in a character are invalid. — end note ]

12

13 Where the regular expression grammar requires the conversion of a sequence of characters to an integral

value, this is accomplished by calling traits_inst.value.

14 The behavior of the internal ﬁnite state machine representation when used to match a sequence of characters
is as described in ECMA-262. The behavior is modiﬁed according to any match_ﬂag_type ﬂags 28.5.2
speciﬁed when using the regular expression object in one of the regular expression algorithms 28.11. The
behavior is also localized by interaction with the traits class template parameter as follows:

(14.1)

—

During matching of a regular expression ﬁnite state machine against a sequence of characters, two
characters c and d are compared using the following rules:

1. if (flags() & regex_constants::icase) the two characters are equal if traits_inst.trans-

late_nocase(c) == traits_inst.translate_nocase(d);

2. otherwise, if flags() & regex_constants::collate the two characters are equal if traits_-

inst.translate(c) == traits_inst.translate(d);

3. otherwise, the two characters are equal if c == d.

(14.2)

—

During matching of a regular expression ﬁnite state machine against a sequence of characters, com-
parison of a collating element range c1-c2 against a character c is conducted as follows: if flags() &
regex_constants ::collate is false then the character c is matched if c1 <= c && c <= c2, other-
wise c is matched in accordance with the following algorithm:

string_type str1 = string_type(1,

flags() & icase ?

string_type str2 = string_type(1,

flags() & icase ?

traits_inst.translate_nocase(c1) : traits_inst.translate(c1);

traits_inst.translate_nocase(c2) : traits_inst.translate(c2);

string_type str = string_type(1,

flags() & icase ?

traits_inst.translate_nocase(c) : traits_inst.translate(c);

return traits_inst.transform(str1.begin(), str1.end())
<= traits_inst.transform(str.begin(), str.end())

&& traits_inst.transform(str.begin(), str.end())

<= traits_inst.transform(str2.begin(), str2.end());

(14.3)

—

(14.4)

—

During matching of a regular expression ﬁnite state machine against a sequence of characters, testing
whether a collating element is a member of a primary equivalence class is conducted by ﬁrst converting
the collating element and the equivalence class to sort keys using traits::transform_primary, and
then comparing the sort keys for equality.
During matching of a regular expression ﬁnite state machine against a sequence of characters, a char-
acter c is a member of a character class designated by an iterator range [first,last) if traits_-
inst.isctype(c, traits_inst.lookup_classname(first, last, flags() & icase)) is true.

§ 28.13

1141

c(cid:13) ISO/IEC

N4296

29 Atomic operations library
29.1 General

[atomics]
[atomics.general]
1 This Clause describes components for ﬁne-grained atomic access. This access is provided via operations on

atomic objects.

2 The following subclauses describe atomics requirements and components for types and operations, as sum-

marized below.

Table 145 — Atomics library summary

Subclause

Header(s)

29.3 Order and Consistency
29.4 Lock-free Property
29.5 Atomic Types
29.6 Operations on Atomic Types
29.7 Flag Type and Operations
29.8 Fences

<atomic>

29.2 Header <atomic> synopsis

[atomics.syn]

namespace std {

// 29.3, order and consistency
enum memory_order;
template <class T>

T kill_dependency(T y) noexcept;

// 29.4, lock-free property
#define ATOMIC_BOOL_LOCK_FREE unspecified
#define ATOMIC_CHAR_LOCK_FREE unspecified
#define ATOMIC_CHAR16_T_LOCK_FREE unspecified
#define ATOMIC_CHAR32_T_LOCK_FREE unspecified
#define ATOMIC_WCHAR_T_LOCK_FREE unspecified
#define ATOMIC_SHORT_LOCK_FREE unspecified
#define ATOMIC_INT_LOCK_FREE unspecified
#define ATOMIC_LONG_LOCK_FREE unspecified
#define ATOMIC_LLONG_LOCK_FREE unspecified
#define ATOMIC_POINTER_LOCK_FREE unspecified

// 29.5, generic types
template<class T> struct atomic;
template<> struct atomic<integral >;
template<class T> struct atomic<T*>;

// 29.6.1, general operations on atomic types
// In the following declarations, atomic-type is either
// atomic<T> or a named base class for T from
// Table 146 or inferred from Table 147 or from bool.
// If it is atomic<T>, then the declaration is a template
// declaration preﬁxed with template <class T>.

§ 29.2

1142

c(cid:13) ISO/IEC

N4296

bool atomic_is_lock_free(const volatile atomic-type *) noexcept;
bool atomic_is_lock_free(const atomic-type *) noexcept;
void atomic_init(volatile atomic-type *, T) noexcept;
void atomic_init(atomic-type *, T) noexcept;
void atomic_store(volatile atomic-type *, T) noexcept;
void atomic_store(atomic-type *, T) noexcept;
void atomic_store_explicit(volatile atomic-type *, T, memory_order) noexcept;
void atomic_store_explicit(atomic-type *, T, memory_order) noexcept;
T atomic_load(const volatile atomic-type *) noexcept;
T atomic_load(const atomic-type *) noexcept;
T atomic_load_explicit(const volatile atomic-type *, memory_order) noexcept;
T atomic_load_explicit(const atomic-type *, memory_order) noexcept;
T atomic_exchange(volatile atomic-type *, T) noexcept;
T atomic_exchange(atomic-type *, T) noexcept;
T atomic_exchange_explicit(volatile atomic-type *, T, memory_order) noexcept;
T atomic_exchange_explicit(atomic-type *, T, memory_order) noexcept;
bool atomic_compare_exchange_weak(volatile atomic-type *, T*, T) noexcept;
bool atomic_compare_exchange_weak(atomic-type *, T*, T) noexcept;
bool atomic_compare_exchange_strong(volatile atomic-type *, T*, T) noexcept;
bool atomic_compare_exchange_strong(atomic-type *, T*, T) noexcept;
bool atomic_compare_exchange_weak_explicit(volatile atomic-type *, T*, T,

memory_order, memory_order) noexcept;

bool atomic_compare_exchange_weak_explicit(atomic-type *, T*, T,

memory_order, memory_order) noexcept;

bool atomic_compare_exchange_strong_explicit(volatile atomic-type *, T*, T,

memory_order, memory_order) noexcept;

bool atomic_compare_exchange_strong_explicit(atomic-type *, T*, T,

memory_order, memory_order) noexcept;

// 29.6.2, templated operations on atomic types
template <class T>

T atomic_fetch_add(volatile atomic<T>*, T) noexcept;

T atomic_fetch_add(atomic<T>*, T) noexcept;

T atomic_fetch_add_explicit(volatile atomic<T>*, T, memory_order) noexcept;

T atomic_fetch_add_explicit(atomic<T>*, T, memory_order) noexcept;

T atomic_fetch_sub(volatile atomic<T>*, T) noexcept;

T atomic_fetch_sub(atomic<T>*, T) noexcept;

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

T atomic_fetch_sub_explicit(volatile atomic<T>*, T, memory_order) noexcept;

T atomic_fetch_sub_explicit(atomic<T>*, T, memory_order) noexcept;

T atomic_fetch_and(volatile atomic<T>*, T) noexcept;

T atomic_fetch_and(atomic<T>*, T) noexcept;

T atomic_fetch_and_explicit(volatile atomic<T>*, T, memory_order) noexcept;

T atomic_fetch_and_explicit(atomic<T>*, T, memory_order) noexcept;

§ 29.2

1143

c(cid:13) ISO/IEC

N4296

T atomic_fetch_or(volatile atomic<T>*, T) noexcept;

T atomic_fetch_or(atomic<T>*, T) noexcept;

T atomic_fetch_or_explicit(volatile atomic<T>*, T, memory_order) noexcept;

T atomic_fetch_or_explicit(atomic<T>*, T, memory_order) noexcept;

T atomic_fetch_xor(volatile atomic<T>*, T) noexcept;

T atomic_fetch_xor(atomic<T>*, T) noexcept;

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

T atomic_fetch_xor_explicit(volatile atomic<T>*, T, memory_order) noexcept;

T atomic_fetch_xor_explicit(atomic<T>*, T, memory_order) noexcept;

// 29.6.3, arithmetic operations on atomic types
// In the following declarations, atomic-integral is either
// atomic<T> or a named base class for T from
// Table 146 or inferred from Table 147.
// If it is atomic<T>, then the declaration is a template
// specialization declaration preﬁxed with template <>.

integral atomic_fetch_add(volatile atomic-integral *, integral ) noexcept;
integral atomic_fetch_add(atomic-integral *, integral ) noexcept;
integral atomic_fetch_add_explicit(volatile atomic-integral *, integral , memory_order) noexcept;
integral atomic_fetch_add_explicit(atomic-integral *, integral , memory_order) noexcept;
integral atomic_fetch_sub(volatile atomic-integral *, integral ) noexcept;
integral atomic_fetch_sub(atomic-integral *, integral ) noexcept;
integral atomic_fetch_sub_explicit(volatile atomic-integral *, integral , memory_order) noexcept;
integral atomic_fetch_sub_explicit(atomic-integral *, integral , memory_order) noexcept;
integral atomic_fetch_and(volatile atomic-integral *, integral ) noexcept;
integral atomic_fetch_and(atomic-integral *, integral ) noexcept;
integral atomic_fetch_and_explicit(volatile atomic-integral *, integral , memory_order) noexcept;
integral atomic_fetch_and_explicit(atomic-integral *, integral , memory_order) noexcept;
integral atomic_fetch_or(volatile atomic-integral *, integral ) noexcept;
integral atomic_fetch_or(atomic-integral *, integral ) noexcept;
integral atomic_fetch_or_explicit(volatile atomic-integral *, integral , memory_order) noexcept;
integral atomic_fetch_or_explicit(atomic-integral *, integral , memory_order) noexcept;
integral atomic_fetch_xor(volatile atomic-integral *, integral ) noexcept;
integral atomic_fetch_xor(atomic-integral *, integral ) noexcept;
integral atomic_fetch_xor_explicit(volatile atomic-integral *, integral , memory_order) noexcept;
integral atomic_fetch_xor_explicit(atomic-integral *, integral , memory_order) noexcept;

// 29.6.4, partial specializations for pointers

template <class T>

template <class T>

template <class T>

template <class T>

template <class T>

T* atomic_fetch_add(volatile atomic<T*>*, ptrdiff_t) noexcept;

T* atomic_fetch_add(atomic<T*>*, ptrdiff_t) noexcept;

T* atomic_fetch_add_explicit(volatile atomic<T*>*, ptrdiff_t, memory_order) noexcept;

T* atomic_fetch_add_explicit(atomic<T*>*, ptrdiff_t, memory_order) noexcept;

§ 29.2

1144

c(cid:13) ISO/IEC

N4296

T* atomic_fetch_sub(volatile atomic<T*>*, ptrdiff_t) noexcept;

T* atomic_fetch_sub(atomic<T*>*, ptrdiff_t) noexcept;

template <class T>

template <class T>

template <class T>

T* atomic_fetch_sub_explicit(volatile atomic<T*>*, ptrdiff_t, memory_order) noexcept;

T* atomic_fetch_sub_explicit(atomic<T*>*, ptrdiff_t, memory_order) noexcept;

// 29.6.5, initialization
#define ATOMIC_VAR_INIT(value) see below

// 29.7, ﬂag type and operations
struct atomic_flag;
bool atomic_flag_test_and_set(volatile atomic_flag*) noexcept;
bool atomic_flag_test_and_set(atomic_flag*) noexcept;
bool atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order) noexcept;
bool atomic_flag_test_and_set_explicit(atomic_flag*, memory_order) noexcept;
void atomic_flag_clear(volatile atomic_flag*) noexcept;
void atomic_flag_clear(atomic_flag*) noexcept;
void atomic_flag_clear_explicit(volatile atomic_flag*, memory_order) noexcept;
void atomic_flag_clear_explicit(atomic_flag*, memory_order) noexcept;
#define ATOMIC_FLAG_INIT see below

// 29.8, fences
extern "C" void atomic_thread_fence(memory_order) noexcept;
extern "C" void atomic_signal_fence(memory_order) noexcept;

}

29.3 Order and consistency

[atomics.order]

namespace std {

typedef enum memory_order {

} memory_order;

}

memory_order_relaxed, memory_order_consume, memory_order_acquire,
memory_order_release, memory_order_acq_rel, memory_order_seq_cst

1 The enumeration memory_order speciﬁes the detailed regular (non-atomic) memory synchronization order
as deﬁned in 1.10 and may provide for operation ordering. Its enumerated values and their meanings are as
follows:

(1.1)

(1.2)

(1.3)

(1.4)

—
—

—

—

memory_order_relaxed: no operation orders memory.
memory_order_release, memory_order_acq_rel, and memory_order_seq_cst: a store operation per-
forms a release operation on the aﬀected memory location.
memory_order_consume: a load operation performs a consume operation on the aﬀected memory
location.
memory_order_acquire, memory_order_acq_rel, and memory_order_seq_cst: a load operation per-
forms an acquire operation on the aﬀected memory location.

[ Note: Atomic operations specifying memory_order_relaxed are relaxed with respect to memory ordering.
Implementations must still guarantee that any given atomic access to a particular atomic object be indivisible
with respect to all other atomic accesses to that object. — end note ]

§ 29.3

1145

c(cid:13) ISO/IEC

N4296

2 An atomic operation A that performs a release operation on an atomic object M synchronizes with an atomic
operation B that performs an acquire operation on M and takes its value from any side eﬀect in the release
sequence headed by A.

3 There shall be a single total order S on all memory_order_seq_cst operations, consistent with the “happens
before” order and modiﬁcation orders for all aﬀected locations, such that each memory_order_seq_cst
operation B that loads a value from an atomic object M observes one of the following values:

(3.1)

(3.2)

(3.3)

—
—

—

the result of the last modiﬁcation A of M that precedes B in S, if it exists, or
if A exists, the result of some modiﬁcation of M that is not memory_order_seq_cst and that does not
happen before A, or
if A does not exist, the result of some modiﬁcation of M that is not memory_order_seq_cst.

[ Note: Although it is not explicitly required that S include locks, it can always be extended to an order
that does include lock and unlock operations, since the ordering between those is already included in the
“happens before” ordering. — end note ]

4 For an atomic operation B that reads the value of an atomic object M, if there is a memory_order_seq_-
cst fence X sequenced before B, then B observes either the last memory_order_seq_cst modiﬁcation of M
preceding X in the total order S or a later modiﬁcation of M in its modiﬁcation order.

5 For atomic operations A and B on an atomic object M, where A modiﬁes M and B takes its value, if there is
a memory_order_seq_cst fence X such that A is sequenced before X and B follows X in S, then B observes
either the eﬀects of A or a later modiﬁcation of M in its modiﬁcation order.

6 For atomic operations A and B on an atomic object M, where A modiﬁes M and B takes its value, if there
are memory_order_seq_cst fences X and Y such that A is sequenced before X, Y is sequenced before B,
and X precedes Y in S, then B observes either the eﬀects of A or a later modiﬁcation of M in its modiﬁcation
order.

7 For atomic modiﬁcations A and B of an atomic object M, B occurs later than A in the modiﬁcation order

of M if:

(7.1)

(7.2)

(7.3)

—

—

—

there is a memory_order_seq_cst fence X such that A is sequenced before X, and X precedes B in S,
or
there is a memory_order_seq_cst fence Y such that Y is sequenced before B, and A precedes Y in
S, or
there are memory_order_seq_cst fences X and Y such that A is sequenced before X, Y is sequenced
before B, and X precedes Y in S.

8

9

[ Note: memory_order_seq_cst ensures sequential consistency only for a program that is free of data races
and uses exclusively memory_order_seq_cst operations. Any use of weaker ordering will invalidate this
guarantee unless extreme care is used. In particular, memory_order_seq_cst fences ensure a total order
only for the fences themselves. Fences cannot, in general, be used to restore sequential consistency for atomic
operations with weaker ordering speciﬁcations. — end note ]
Implementations should ensure that no “out-of-thin-air” values are computed that circularly depend on their
own computation.
[ Note: For example, with x and y initially zero,

// Thread 1:
r1 = y.load(memory_order_relaxed);
x.store(r1, memory_order_relaxed);

§ 29.3

1146

c(cid:13) ISO/IEC

// Thread 2:
r2 = x.load(memory_order_relaxed);
y.store(r2, memory_order_relaxed);

N4296

should not produce r1 == r2 == 42, since the store of 42 to y is only possible if the store to x stores 42,
which circularly depends on the store to y storing 42. Note that without this restriction, such an execution
is possible. — end note ]
[ Note: The recommendation similarly disallows r1 == r2 == 42 in the following example, with x and y
again initially zero:

10

// Thread 1:
r1 = x.load(memory_order_relaxed);
if (r1 == 42) y.store(42, memory_order_relaxed);

// Thread 2:
r2 = y.load(memory_order_relaxed);
if (r2 == 42) x.store(42, memory_order_relaxed);

— end note ]

11 Atomic read-modify-write operations shall always read the last value (in the modiﬁcation order) written

before the write associated with the read-modify-write operation.
Implementations should make atomic stores visible to atomic loads within a reasonable amount of time.

12

13

14

template <class T>

T kill_dependency(T y) noexcept;

Eﬀects: The argument does not carry a dependency to the return value (1.10).
Returns: y.

29.4 Lock-free property

#define ATOMIC_BOOL_LOCK_FREE unspecified
#define ATOMIC_CHAR_LOCK_FREE unspecified
#define ATOMIC_CHAR16_T_LOCK_FREE unspecified
#define ATOMIC_CHAR32_T_LOCK_FREE unspecified
#define ATOMIC_WCHAR_T_LOCK_FREE unspecified
#define ATOMIC_SHORT_LOCK_FREE unspecified
#define ATOMIC_INT_LOCK_FREE unspecified
#define ATOMIC_LONG_LOCK_FREE unspecified
#define ATOMIC_LLONG_LOCK_FREE unspecified
#define ATOMIC_POINTER_LOCK_FREE unspecified

[atomics.lockfree]

1 The ATOMIC_..._LOCK_FREE macros indicate the lock-free property of the corresponding atomic types, with
the signed and unsigned variants grouped together. The properties also apply to the corresponding (partial)
specializations of the atomic template. A value of 0 indicates that the types are never lock-free. A value of
1 indicates that the types are sometimes lock-free. A value of 2 indicates that the types are always lock-free.
2 The function atomic_is_lock_free (29.6) indicates whether the object is lock-free. In any given program

execution, the result of the lock-free query shall be consistent for all pointers of the same type.
[ Note: Operations that are lock-free should also be address-free. That is, atomic operations on the same
memory location via two diﬀerent addresses will communicate atomically. The implementation should not
depend on any per-process state. This restriction enables communication by memory that is mapped into a
process more than once and by memory that is shared between two processes. — end note ]
29.5 Atomic types

[atomics.types.generic]

3

§ 29.5

1147

c(cid:13) ISO/IEC

N4296

namespace std {

template <class T> struct atomic {

bool is_lock_free() const volatile noexcept;
bool is_lock_free() const noexcept;
void store(T, memory_order = memory_order_seq_cst) volatile noexcept;
void store(T, memory_order = memory_order_seq_cst) noexcept;
T load(memory_order = memory_order_seq_cst) const volatile noexcept;
T load(memory_order = memory_order_seq_cst) const noexcept;
operator T() const volatile noexcept;
operator T() const noexcept;
T exchange(T, memory_order = memory_order_seq_cst) volatile noexcept;
T exchange(T, memory_order = memory_order_seq_cst) noexcept;
bool compare_exchange_weak(T&, T, memory_order, memory_order) volatile noexcept;
bool compare_exchange_weak(T&, T, memory_order, memory_order) noexcept;
bool compare_exchange_strong(T&, T, memory_order, memory_order) volatile noexcept;
bool compare_exchange_strong(T&, T, memory_order, memory_order) noexcept;
bool compare_exchange_weak(T&, T, memory_order = memory_order_seq_cst) volatile noexcept;
bool compare_exchange_weak(T&, T, memory_order = memory_order_seq_cst) noexcept;
bool compare_exchange_strong(T&, T, memory_order = memory_order_seq_cst) volatile noexcept;
bool compare_exchange_strong(T&, T, memory_order = memory_order_seq_cst) noexcept;

atomic() noexcept = default;
constexpr atomic(T) noexcept;
atomic(const atomic&) = delete;
atomic& operator=(const atomic&) = delete;
atomic& operator=(const atomic&) volatile = delete;
T operator=(T) volatile noexcept;
T operator=(T) noexcept;

};

template <> struct atomic<integral > {

bool is_lock_free() const volatile noexcept;
bool is_lock_free() const noexcept;
void store(integral , memory_order = memory_order_seq_cst) volatile noexcept;
void store(integral , memory_order = memory_order_seq_cst) noexcept;
integral load(memory_order = memory_order_seq_cst) const volatile noexcept;
integral load(memory_order = memory_order_seq_cst) const noexcept;
operator integral() const volatile noexcept;
operator integral() const noexcept;
integral exchange(integral , memory_order = memory_order_seq_cst) volatile noexcept;
integral exchange(integral , memory_order = memory_order_seq_cst) noexcept;
bool compare_exchange_weak(integral &, integral , memory_order, memory_order) volatile noexcept;
bool compare_exchange_weak(integral &, integral , memory_order, memory_order) noexcept;
bool compare_exchange_strong(integral &, integral , memory_order, memory_order) volatile noexcept;
bool compare_exchange_strong(integral &, integral , memory_order, memory_order) noexcept;
bool compare_exchange_weak(integral &, integral , memory_order = memory_order_seq_cst) volatile noexcept;
bool compare_exchange_weak(integral &, integral , memory_order = memory_order_seq_cst) noexcept;
bool compare_exchange_strong(integral &, integral , memory_order = memory_order_seq_cst) volatile noexcept;
bool compare_exchange_strong(integral &, integral , memory_order = memory_order_seq_cst) noexcept;
integral fetch_add(integral , memory_order = memory_order_seq_cst) volatile noexcept;
integral fetch_add(integral , memory_order = memory_order_seq_cst) noexcept;
integral fetch_sub(integral , memory_order = memory_order_seq_cst) volatile noexcept;
integral fetch_sub(integral , memory_order = memory_order_seq_cst) noexcept;
integral fetch_and(integral , memory_order = memory_order_seq_cst) volatile noexcept;
integral fetch_and(integral , memory_order = memory_order_seq_cst) noexcept;

§ 29.5

1148

c(cid:13) ISO/IEC

N4296

integral fetch_or(integral , memory_order = memory_order_seq_cst) volatile noexcept;
integral fetch_or(integral , memory_order = memory_order_seq_cst) noexcept;
integral fetch_xor(integral , memory_order = memory_order_seq_cst) volatile noexcept;
integral fetch_xor(integral , memory_order = memory_order_seq_cst) noexcept;

atomic() noexcept = default;
constexpr atomic(integral ) noexcept;
atomic(const atomic&) = delete;
atomic& operator=(const atomic&) = delete;
atomic& operator=(const atomic&) volatile = delete;
integral operator=(integral ) volatile noexcept;
integral operator=(integral ) noexcept;

integral operator++(int) volatile noexcept;
integral operator++(int) noexcept;
integral operator--(int) volatile noexcept;
integral operator--(int) noexcept;
integral operator++() volatile noexcept;
integral operator++() noexcept;
integral operator--() volatile noexcept;
integral operator--() noexcept;
integral operator+=(integral ) volatile noexcept;
integral operator+=(integral ) noexcept;
integral operator-=(integral ) volatile noexcept;
integral operator-=(integral ) noexcept;
integral operator&=(integral ) volatile noexcept;
integral operator&=(integral ) noexcept;
integral operator|=(integral ) volatile noexcept;
integral operator|=(integral ) noexcept;
integral operator^=(integral ) volatile noexcept;
integral operator^=(integral ) noexcept;

};

template <class T> struct atomic<T*> {

bool is_lock_free() const volatile noexcept;
bool is_lock_free() const noexcept;
void store(T*, memory_order = memory_order_seq_cst) volatile noexcept;
void store(T*, memory_order = memory_order_seq_cst) noexcept;
T* load(memory_order = memory_order_seq_cst) const volatile noexcept;
T* load(memory_order = memory_order_seq_cst) const noexcept;
operator T*() const volatile noexcept;
operator T*() const noexcept;
T* exchange(T*, memory_order = memory_order_seq_cst) volatile noexcept;
T* exchange(T*, memory_order = memory_order_seq_cst) noexcept;
bool compare_exchange_weak(T*&, T*, memory_order, memory_order) volatile noexcept;
bool compare_exchange_weak(T*&, T*, memory_order, memory_order) noexcept;
bool compare_exchange_strong(T*&, T*, memory_order, memory_order) volatile noexcept;
bool compare_exchange_strong(T*&, T*, memory_order, memory_order) noexcept;
bool compare_exchange_weak(T*&, T*, memory_order = memory_order_seq_cst) volatile noexcept;
bool compare_exchange_weak(T*&, T*, memory_order = memory_order_seq_cst) noexcept;
bool compare_exchange_strong(T*&, T*, memory_order = memory_order_seq_cst) volatile noexcept;
bool compare_exchange_strong(T*&, T*, memory_order = memory_order_seq_cst) noexcept;
T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) volatile noexcept;
T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) noexcept;
T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) volatile noexcept;

§ 29.5

1149

c(cid:13) ISO/IEC

N4296

T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) noexcept;

atomic() noexcept = default;
constexpr atomic(T*) noexcept;
atomic(const atomic&) = delete;
atomic& operator=(const atomic&) = delete;
atomic& operator=(const atomic&) volatile = delete;
T* operator=(T*) volatile noexcept;
T* operator=(T*) noexcept;

T* operator++(int) volatile noexcept;
T* operator++(int) noexcept;
T* operator--(int) volatile noexcept;
T* operator--(int) noexcept;
T* operator++() volatile noexcept;
T* operator++() noexcept;
T* operator--() volatile noexcept;
T* operator--() noexcept;
T* operator+=(ptrdiff_t) volatile noexcept;
T* operator+=(ptrdiff_t) noexcept;
T* operator-=(ptrdiff_t) volatile noexcept;
T* operator-=(ptrdiff_t) noexcept;

};

}

1 There is a generic class template atomic<T>. The type of the template argument T shall be trivially
[ Note: Type arguments that are not also statically initializable may be diﬃcult to use.

copyable (3.9).
— end note ]

2 The semantics of the operations on specializations of atomic are deﬁned in 29.6.
3 Specializations and instantiations of the atomic template shall have a deleted copy constructor, a deleted

copy assignment operator, and a constexpr value constructor.

4 There shall be explicit specializations of the atomic template for the integral types char, signed char,
unsigned char, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned
long long, char16_t, char32_t, wchar_t, and any other types needed by the typedefs in the header
<cstdint>. For each integral type integral, the specialization atomic<integral> provides additional atomic
operations appropriate to integral types. There shall be a specialization atomic<bool> which provides the
general atomic operations as speciﬁed in 29.6.1.

5 The atomic integral specializations and the specialization atomic<bool> shall have standard layout. They
shall each have a trivial default constructor and a trivial destructor. They shall each support aggregate
initialization syntax.

6 There shall be pointer partial specializations of the atomic class template. These specializations shall have
standard layout, trivial default constructors, and trivial destructors. They shall each support aggregate
initialization syntax.

7 There shall be named types corresponding to the integral specializations of atomic, as speciﬁed in Table 146,
and a named type atomic_bool corresponding to the speciﬁed atomic<bool>. Each named type is either a
typedef to the corresponding specialization or a base class of the corresponding specialization. If it is a base
class, it shall support the same member functions as the corresponding specialization.

8 There shall be atomic typedefs corresponding to the typedefs in the header <inttypes.h> as speciﬁed in

Table 147.
[ Note: The representation of an atomic specialization need not have the same size as its corresponding

9

§ 29.5

1150

c(cid:13) ISO/IEC

N4296

Table 146 — atomic integral typedefs

Named type
atomic_char
atomic_schar
atomic_uchar
atomic_short
atomic_ushort
atomic_int
atomic_uint
atomic_long
atomic_ulong
atomic_llong
atomic_ullong
atomic_char16_t
atomic_char32_t
atomic_wchar_t

Integral argument type
char
signed char
unsigned char
short
unsigned short
int
unsigned int
long
unsigned long
long long
unsigned long long
char16_t
char32_t
wchar_t

argument type. Specializations should have the same size whenever possible, as this reduces the eﬀort
required to port existing code. — end note ]
29.6 Operations on atomic types
29.6.1 General operations on atomic types

[atomics.types.operations]
[atomics.types.operations.general]
1 The implementation shall provide the functions and function templates identiﬁed as “general operations on

atomic types” in 29.2.
In the declarations of these functions and function templates, the name atomic-type refers to either atomic<T>
or to a named base class for T from Table 146 or inferred from Table 147.
29.6.2 Templated operations on atomic types

[atomics.types.operations.templ]
1 The implementation shall declare but not deﬁne the function templates identiﬁed as “templated operations

2

on atomic types” in 29.2.
29.6.3 Arithmetic operations on atomic types

[atomics.types.operations.arith]
1 The implementation shall provide the functions and function template specializations identiﬁed as “arith-

metic operations on atomic types” in 29.2.
In the declarations of these functions and function template specializations, the name integral refers to an
integral type and the name atomic-integral refers to either atomic<integral > or to a named base class for
integral from Table 146 or inferred from Table 147.
29.6.4 Operations on atomic pointer types

[atomics.types.operations.pointer]
1 The implementation shall provide the function template specializations identiﬁed as “partial specializations

for pointers” in 29.2.
29.6.5 Requirements for operations on atomic types

[atomics.types.operations.req]
1 There are only a few kinds of operations on atomic types, though there are many instances on those kinds.
This section speciﬁes each general kind. The speciﬁc instances are deﬁned in 29.5, 29.6.1, 29.6.3, and 29.6.4.
In the following operation deﬁnitions:

2

2

(2.1)

—

an A refers to one of the atomic types.

§ 29.6.5

1151

c(cid:13) ISO/IEC

N4296

Table 147 — atomic <inttypes.h> typedefs

Atomic typedef
atomic_int_least8_t
atomic_uint_least8_t
atomic_int_least16_t
atomic_uint_least16_t
atomic_int_least32_t
atomic_uint_least32_t
atomic_int_least64_t
atomic_uint_least64_t
atomic_int_fast8_t
atomic_uint_fast8_t
atomic_int_fast16_t
atomic_uint_fast16_t
atomic_int_fast32_t
atomic_uint_fast32_t
atomic_int_fast64_t
atomic_uint_fast64_t
atomic_intptr_t
atomic_uintptr_t
atomic_size_t
atomic_ptrdiff_t
atomic_intmax_t
atomic_uintmax_t

<inttypes.h> type
int_least8_t
uint_least8_t
int_least16_t
uint_least16_t
int_least32_t
uint_least32_t
int_least64_t
uint_least64_t
int_fast8_t
uint_fast8_t
int_fast16_t
uint_fast16_t
int_fast32_t
uint_fast32_t
int_fast64_t
uint_fast64_t
intptr_t
uintptr_t
size_t
ptrdiff_t
intmax_t
uintmax_t

(2.2)

(2.3)

(2.4)

—
—

—

a C refers to its corresponding non-atomic type.
an M refers to type of the other argument for arithmetic operations. For integral atomic types, M is
C. For atomic address types, M is std::ptrdiff_t.
the non-member functions not ending in _explicit have the semantics of their corresponding _-
explicit functions with memory_order arguments of memory_order_seq_cst.

3

4

5

[ Note: Many operations are volatile-qualiﬁed. The “volatile as device register” semantics have not changed
in the standard. This qualiﬁcation means that volatility is preserved when applying these operations to
volatile objects. It does not mean that operations on non-volatile objects become volatile. Thus, volatile
qualiﬁed operations on non-volatile objects may be merged under some conditions. — end note ]

A ::A () noexcept = default;

Eﬀects: leaves the atomic object in an uninitialized state. [ Note: These semantics ensure compatibility
with C. — end note ]

constexpr A ::A (C desired) noexcept;

Eﬀects: Initializes the object with the value desired. Initialization is not an atomic operation (1.10).
[ Note: it is possible to have an access to an atomic object A race with its construction, for example
by communicating the address of the just-constructed object A to another thread via memory_order_-
relaxed operations on a suitable atomic pointer variable, and then immediately accessing A in the
receiving thread. This results in undeﬁned behavior. — end note ]

#define ATOMIC_VAR_INIT(value) see below

§ 29.6.5

1152

6

7

8

9

10

11

12

13

14

15

c(cid:13) ISO/IEC

N4296

The macro expands to a token sequence suitable for constant initialization of an atomic variable of
static storage duration of a type that is initialization-compatible with value.
[ Note: This operation
may need to initialize locks. — end note ] Concurrent access to the variable being initialized, even via
an atomic operation, constitutes a data race. [ Example:

atomic<int> v = ATOMIC_VAR_INIT(5);

— end example ]

bool atomic_is_lock_free(const volatile A * object) noexcept;
bool atomic_is_lock_free(const A * object) noexcept;
bool A ::is_lock_free() const volatile noexcept;
bool A ::is_lock_free() const noexcept;

Returns: True if the object’s operations are lock-free, false otherwise.

void atomic_init(volatile A * object, C desired) noexcept;
void atomic_init(A * object, C desired) noexcept;

Eﬀects: Non-atomically initializes *object with value desired. This function shall only be applied
to objects that have been default constructed, and then only once.
[ Note: These semantics ensure
compatibility with C. — end note ] [ Note: Concurrent access from another thread, even via an atomic
operation, constitutes a data race. — end note ]

void atomic_store(volatile A * object, C desired) noexcept;
void atomic_store(A * object, C desired) noexcept;
void atomic_store_explicit(volatile A * object, C desired, memory_order order) noexcept;
void atomic_store_explicit(A * object, C desired, memory_order order) noexcept;
void A ::store(C desired, memory_order order = memory_order_seq_cst) volatile noexcept;
void A ::store(C desired, memory_order order = memory_order_seq_cst) noexcept;

Requires: The order argument shall not be memory_order_consume, memory_order_acquire, nor
memory_order_acq_rel.
Eﬀects: Atomically replaces the value pointed to by object or by this with the value of desired.
Memory is aﬀected according to the value of order.

C A ::operator=(C desired) volatile noexcept;
C A ::operator=(C desired) noexcept;

Eﬀects: store(desired)
Returns: desired

C atomic_load(const volatile A * object) noexcept;
C atomic_load(const A * object) noexcept;
C atomic_load_explicit(const volatile A * object, memory_order) noexcept;
C atomic_load_explicit(const A * object, memory_order) noexcept;
C A ::load(memory_order order = memory_order_seq_cst) const volatile noexcept;
C A ::load(memory_order order = memory_order_seq_cst) const noexcept;

Requires: The order argument shall not be memory_order_release nor memory_order_acq_rel.
Eﬀects: Memory is aﬀected according to the value of order.
Returns: Atomically returns the value pointed to by object or by this.

A ::operator C () const volatile noexcept;
A ::operator C () const noexcept;

§ 29.6.5

1153

16

17

18

19

20

21

c(cid:13) ISO/IEC

Eﬀects: load()
Returns: The result of load().

N4296

C atomic_exchange(volatile A * object, C desired) noexcept;
C atomic_exchange(A * object, C desired) noexcept;
C atomic_exchange_explicit(volatile A * object, C desired, memory_order) noexcept;
C atomic_exchange_explicit(A * object, C desired, memory_order) noexcept;
C A ::exchange(C desired, memory_order order = memory_order_seq_cst) volatile noexcept;
C A ::exchange(C desired, memory_order order = memory_order_seq_cst) noexcept;

Eﬀects: Atomically replaces the value pointed to by object or by this with desired. Memory
is aﬀected according to the value of order. These operations are atomic read-modify-write opera-
tions (1.10).
Returns: Atomically returns the value pointed to by object or by this immediately before the eﬀects.

bool atomic_compare_exchange_weak(volatile A * object, C * expected, C desired) noexcept;
bool atomic_compare_exchange_weak(A * object, C * expected, C desired) noexcept;
bool atomic_compare_exchange_strong(volatile A * object, C * expected, C desired) noexcept;
bool atomic_compare_exchange_strong(A * object, C * expected, C desired) noexcept;
bool atomic_compare_exchange_weak_explicit(volatile A * object, C * expected, C desired,

memory_order success, memory_order failure) noexcept;

bool atomic_compare_exchange_weak_explicit(A * object, C * expected, C desired,

memory_order success, memory_order failure) noexcept;

bool atomic_compare_exchange_strong_explicit(volatile A * object, C * expected, C desired,

memory_order success, memory_order failure) noexcept;

bool atomic_compare_exchange_strong_explicit(A * object, C * expected, C desired,

memory_order success, memory_order failure) noexcept;

bool A ::compare_exchange_weak(C & expected, C desired,

memory_order success, memory_order failure) volatile noexcept;

bool A ::compare_exchange_weak(C & expected, C desired,

memory_order success, memory_order failure) noexcept;
bool A ::compare_exchange_strong(C & expected, C desired,

memory_order success, memory_order failure) volatile noexcept;

bool A ::compare_exchange_strong(C & expected, C desired,
memory_order success, memory_order failure) noexcept;

bool A ::compare_exchange_weak(C & expected, C desired,

memory_order order = memory_order_seq_cst) volatile noexcept;

bool A ::compare_exchange_weak(C & expected, C desired,

memory_order order = memory_order_seq_cst) noexcept;
bool A ::compare_exchange_strong(C & expected, C desired,

memory_order order = memory_order_seq_cst) volatile noexcept;

bool A ::compare_exchange_strong(C & expected, C desired,
memory_order order = memory_order_seq_cst) noexcept;
Requires: The failure argument shall not be memory_order_release nor memory_order_acq_rel.
The failure argument shall be no stronger than the success argument.
Eﬀects: Atomically, compares the contents of the memory pointed to by object or by this for equality
with that in expected, and if true, replaces the contents of the memory pointed to by object or by
this with that in desired, and if false, updates the contents of the memory in expected with the
contents of the memory pointed to by object or by this. Further, if the comparison is true, memory
is aﬀected according to the value of success, and if the comparison is false, memory is aﬀected
according to the value of failure. When only one memory_order argument is supplied, the value of
success is order, and the value of failure is order except that a value of memory_order_acq_rel
shall be replaced by the value memory_order_acquire and a value of memory_order_release shall

§ 29.6.5

1154

c(cid:13) ISO/IEC

N4296

be replaced by the value memory_order_relaxed. If the operation returns true, these operations are
atomic read-modify-write operations (1.10). Otherwise, these operations are atomic load operations.
Returns: The result of the comparison.
[ Note: For example, the eﬀect of atomic_compare_exchange_strong is

if (memcmp(object, expected, sizeof(*object)) == 0)

memcpy(object, &desired, sizeof(*object));

else

memcpy(expected, object, sizeof(*object));

— end note ] [ Example:
the expected use of the compare-and-exchange operations is as follows.
The compare-and-exchange operations will update expected when another iteration of the loop is
needed.

expected = current.load();
do {

desired = function(expected);

} while (!current.compare_exchange_weak(expected, desired));

— end example ]
Implementations should ensure that weak compare-and-exchange operations do not consistently return
false unless either the atomic object has value diﬀerent from expected or there are concurrent
modiﬁcations to the atomic object.
Remark: A weak compare-and-exchange operation may fail spuriously. That is, even when the con-
tents of memory referred to by expected and object are equal, it may return false and store back
to expected the same memory contents that were originally there.
[ Note: This spurious failure
enables implementation of compare-and-exchange on a broader class of machines, e.g., load-locked
store-conditional machines. A consequence of spurious failure is that nearly all uses of weak compare-
and-exchange will be in a loop.
When a compare-and-exchange is in a loop, the weak version will yield better performance on some
platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the
strong one is preferable. — end note ]
[ Note: The memcpy and memcmp semantics of the compare-and-exchange operations may result in failed
comparisons for values that compare equal with operator== if the underlying type has padding bits,
trap bits, or alternate representations of the same value. Thus, compare_exchange_strong should be
used with extreme care. On the other hand, compare_exchange_weak should converge rapidly. — end
note ]

22

23

24

25

26

27 The following operations perform arithmetic computations. The key, operator, and computation correspon-

dence is:

Table 148 — Atomic arithmetic computations

Key Op Computation
add
or
and

addition
bitwise inclusive or
bitwise and

+
|
&

Key Op Computation
sub
xor

subtraction
bitwise exclusive or

-
ˆ

C atomic_fetch_key (volatile A * object, M operand) noexcept;
C atomic_fetch_key (A * object, M operand) noexcept;
C atomic_fetch_key _explicit(volatile A * object, M operand, memory_order order) noexcept;
C atomic_fetch_key _explicit(A * object, M operand, memory_order order) noexcept;

§ 29.6.5

1155

c(cid:13) ISO/IEC

N4296

C A ::fetch_key (M operand, memory_order order = memory_order_seq_cst) volatile noexcept;
C A ::fetch_key (M operand, memory_order order = memory_order_seq_cst) noexcept;

Eﬀects: Atomically replaces the value pointed to by object or by this with the result of the computa-
tion applied to the value pointed to by object or by this and the given operand. Memory is aﬀected
according to the value of order. These operations are atomic read-modify-write operations (1.10).
Returns: Atomically, the value pointed to by object or by this immediately before the eﬀects.
Remark: For signed integer types, arithmetic is deﬁned to use two’s complement representation. There
are no undeﬁned results. For address types, the result may be an undeﬁned address, but the operations
otherwise have no undeﬁned behavior.

C A ::operator op =(M operand) volatile noexcept;
C A ::operator op =(M operand) noexcept;

Eﬀects: fetch_key (operand)
Returns: fetch_key (operand) op operand

C A ::operator++(int) volatile noexcept;
C A ::operator++(int) noexcept;

Returns: fetch_add(1)

C A ::operator--(int) volatile noexcept;
C A ::operator--(int) noexcept;

Returns: fetch_sub(1)

C A ::operator++() volatile noexcept;
C A ::operator++() noexcept;
Eﬀects: fetch_add(1)
Returns: fetch_add(1) + 1

C A ::operator--() volatile noexcept;
C A ::operator--() noexcept;
Eﬀects: fetch_sub(1)
Returns: fetch_sub(1) - 1

29.7 Flag type and operations

[atomics.ﬂag]

28

29

30

31

32

33

34

35

36

37

38

namespace std {

typedef struct atomic_flag {

bool test_and_set(memory_order = memory_order_seq_cst) volatile noexcept;
bool test_and_set(memory_order = memory_order_seq_cst) noexcept;
void clear(memory_order = memory_order_seq_cst) volatile noexcept;
void clear(memory_order = memory_order_seq_cst) noexcept;

atomic_flag() noexcept = default;
atomic_flag(const atomic_flag&) = delete;
atomic_flag& operator=(const atomic_flag&) = delete;
atomic_flag& operator=(const atomic_flag&) volatile = delete;

} atomic_flag;

bool atomic_flag_test_and_set(volatile atomic_flag*) noexcept;
bool atomic_flag_test_and_set(atomic_flag*) noexcept;

§ 29.7

1156

c(cid:13) ISO/IEC

N4296

bool atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order) noexcept;
bool atomic_flag_test_and_set_explicit(atomic_flag*, memory_order) noexcept;
void atomic_flag_clear(volatile atomic_flag*) noexcept;
void atomic_flag_clear(atomic_flag*) noexcept;
void atomic_flag_clear_explicit(volatile atomic_flag*, memory_order) noexcept;
void atomic_flag_clear_explicit(atomic_flag*, memory_order) noexcept;

#define ATOMIC_FLAG_INIT see below

}

1 The atomic_flag type provides the classic test-and-set functionality. It has two states, set and clear.
2 Operations on an object of type atomic_flag shall be lock-free.

[ Note: Hence the operations should also
be address-free. No other type requires lock-free operations, so the atomic_flag type is the minimum
hardware-implemented type needed to conform to this International standard. The remaining types can be
emulated with atomic_flag, though with less than ideal properties. — end note ]

3 The atomic_flag type shall have standard layout. It shall have a trivial default constructor, a deleted copy

constructor, a deleted copy assignment operator, and a trivial destructor.

4 The macro ATOMIC_FLAG_INIT shall be deﬁned in such a way that it can be used to initialize an object of

type atomic_flag to the clear state. The macro can be used in the form:

atomic_flag guard = ATOMIC_FLAG_INIT;

It is unspeciﬁed whether the macro can be used in other initialization contexts. For a complete static-duration
object, that initialization shall be static. Unless initialized with ATOMIC_FLAG_INIT, it is unspeciﬁed whether
an atomic_flag object has an initial state of set or clear.

bool atomic_flag_test_and_set(volatile atomic_flag* object) noexcept;
bool atomic_flag_test_and_set(atomic_flag* object) noexcept;
bool atomic_flag_test_and_set_explicit(volatile atomic_flag* object, memory_order order) noexcept;
bool atomic_flag_test_and_set_explicit(atomic_flag* object, memory_order order) noexcept;
bool atomic_flag::test_and_set(memory_order order = memory_order_seq_cst) volatile noexcept;
bool atomic_flag::test_and_set(memory_order order = memory_order_seq_cst) noexcept;

Eﬀects: Atomically sets the value pointed to by object or by this to true. Memory is aﬀected
according to the value of order. These operations are atomic read-modify-write operations (1.10).
Returns: Atomically, the value of the object immediately before the eﬀects.

void atomic_flag_clear(volatile atomic_flag* object) noexcept;
void atomic_flag_clear(atomic_flag* object) noexcept;
void atomic_flag_clear_explicit(volatile atomic_flag* object, memory_order order) noexcept;
void atomic_flag_clear_explicit(atomic_flag* object, memory_order order) noexcept;
void atomic_flag::clear(memory_order order = memory_order_seq_cst) volatile noexcept;
void atomic_flag::clear(memory_order order = memory_order_seq_cst) noexcept;

Requires: The order argument shall not be memory_order_consume, memory_order_acquire, nor
memory_order_acq_rel.
Eﬀects: Atomically sets the value pointed to by object or by this to false. Memory is aﬀected
according to the value of order.

5

6

7

8

29.8 Fences

[atomics.fences]
1 This section introduces synchronization primitives called fences. Fences can have acquire semantics, release
semantics, or both. A fence with acquire semantics is called an acquire fence. A fence with release semantics
is called a release fence.

§ 29.8

1157

c(cid:13) ISO/IEC

N4296

2 A release fence A synchronizes with an acquire fence B if there exist atomic operations X and Y, both
operating on some atomic object M, such that A is sequenced before X, X modiﬁes M, Y is sequenced before
B, and Y reads the value written by X or a value written by any side eﬀect in the hypothetical release
sequence X would head if it were a release operation.

3 A release fence A synchronizes with an atomic operation B that performs an acquire operation on an atomic
object M if there exists an atomic operation X such that A is sequenced before X, X modiﬁes M, and B
reads the value written by X or a value written by any side eﬀect in the hypothetical release sequence X
would head if it were a release operation.

4 An atomic operation A that is a release operation on an atomic object M synchronizes with an acquire fence
B if there exists some atomic operation X on M such that X is sequenced before B and reads the value
written by A or a value written by any side eﬀect in the release sequence headed by A.

extern "C" void atomic_thread_fence(memory_order order) noexcept;

5
(5.1)

(5.2)

(5.3)

(5.4)

(5.5)

6

7

8

Eﬀects: depending on the value of order, this operation:
has no eﬀects, if order == memory_order_relaxed;
—
—
is an acquire fence, if order == memory_order_acquire || order == memory_order_consume;
is a release fence, if order == memory_order_release;
—
is both an acquire fence and a release fence, if order == memory_order_acq_rel;
—
—
is a sequentially consistent acquire and release fence, if order == memory_order_seq_cst.

extern "C" void atomic_signal_fence(memory_order order) noexcept;

Eﬀects: Equivalent to atomic_thread_fence(order), except that the resulting ordering constraints
are established only between a thread and a signal handler executed in the same thread.
Note: atomic_signal_fence can be used to specify the order in which actions performed by the thread
become visible to the signal handler.
Note: compiler optimizations and reorderings of loads and stores are inhibited in the same way as with
atomic_thread_fence, but the hardware fence instructions that atomic_thread_fence would have
inserted are not emitted.

§ 29.8

1158

c(cid:13) ISO/IEC

N4296

30 Thread support library
30.1 General

[thread]
[thread.general]
1 The following subclauses describe components to create and manage threads (1.10), perform mutual exclu-

sion, and communicate conditions and values between threads, as summarized in Table 149.

Table 149 — Thread support library summary

Subclause

Header(s)

30.2 Requirements
30.3 Threads
30.4 Mutual exclusion

30.5 Condition variables
30.6 Futures

<thread>
<mutex>
<shared_mutex>
<condition_variable>
<future>

1 Throughout this Clause, the names of template parameters are used to express type requirements.

30.2 Requirements
30.2.1 Template parameter names

[thread.req]
[thread.req.paramname]
If a
template parameter is named Predicate, operator() applied to the template argument shall return a value
that is convertible to bool.
30.2.2 Exceptions

[thread.req.exception]
1 Some functions described in this Clause are speciﬁed to throw exceptions of type system_error (19.5.6).
Such exceptions shall be thrown if any of the function’s error conditions is detected or a call to an operating
system or other underlying API results in an error that prevents the library function from meeting its
speciﬁcations. Failure to allocate storage shall be reported as described in 17.6.5.12.
[ Example: Consider a function in this clause that is speciﬁed to throw exceptions of type system_error
and speciﬁes error conditions that include operation_not_permitted for a thread that does not have the
privilege to perform the operation. Assume that, during the execution of this function, an errno of EPERM is
reported by a POSIX API call used by the implementation. Since POSIX speciﬁes an errno of EPERM when
“the caller does not have the privilege to perform the operation”, the implementation maps EPERM to an
error_condition of operation_not_permitted (19.5) and an exception of type system_error is thrown.
— end example ]

2 The error_code reported by such an exception’s code() member function shall compare equal to one of

the conditions speciﬁed in the function’s error condition element.
30.2.3 Native handles

[thread.req.native]
1 Several classes described in this Clause have members native_handle_type and native_handle. The
presence of these members and their semantics is implementation-deﬁned.
[ Note: These members allow
implementations to provide access to implementation details. Their names are speciﬁed to facilitate portable
compile-time detection. Actual use of these members is inherently non-portable. — end note ]

§ 30.2.3

1159

c(cid:13) ISO/IEC

N4296

2

30.2.4 Timing speciﬁcations

[thread.req.timing]
1 Several functions described in this Clause take an argument to specify a timeout. These timeouts are

speciﬁed as either a duration or a time_point type as speciﬁed in 20.12.
Implementations necessarily have some delay in returning from a timeout. Any overhead in interrupt re-
sponse, function return, and scheduling induces a “quality of implementation” delay, expressed as duration
Di. Ideally, this delay would be zero. Further, any contention for processor and memory resources induces
a “quality of management” delay, expressed as duration Dm. The delay durations may vary from timeout
to timeout, but in all cases shorter is better.

3 The member functions whose names end in _for take an argument that speciﬁes a duration. These functions
produce relative timeouts. Implementations should use a steady clock to measure time for these functions.337
Given a duration argument Dt, the real-time duration of the timeout is Dt + Di + Dm.

4 The member functions whose names end in _until take an argument that speciﬁes a time point. These
functions produce absolute timeouts. Implementations should use the clock speciﬁed in the time point to
measure time for these functions. Given a clock time point argument Ct, the clock time point of the return
from timeout should be Ct + Di + Dm when the clock is not adjusted during the timeout. If the clock is
adjusted to the time Ca during the timeout, the behavior should be as follows:

(4.1)

(4.2)

—

—

if Ca > Ct, the waiting function should wake as soon as possible, i.e. Ca + Di + Dm, since the timeout
is already satisﬁed. [ Note: This speciﬁcation may result in the total duration of the wait decreasing
when measured against a steady clock. — end note ]
if Ca <= Ct, the waiting function should not time out until Clock::now() returns a time Cn >= Ct,
i.e. waking at Ct + Di + Dm.
[ Note: When the clock is adjusted backwards, this speciﬁcation may
result in the total duration of the wait increasing when measured against a steady clock. When the
clock is adjusted forwards, this speciﬁcation may result in the total duration of the wait decreasing
when measured against a steady clock. — end note ]

An implementation shall return from such a timeout at any point from the time speciﬁed above to the time
it would return from a steady-clock relative timeout on the diﬀerence between Ct and the time point of the
call to the _until function.
[ Note: Implementations should decrease the duration of the wait when the
clock is adjusted forwards. — end note ]
[ Note: If the clock is not synchronized with a steady clock, e.g., a CPU time clock, these timeouts might
not provide useful functionality. — end note ]

5

6 The resolution of timing provided by an implementation depends on both operating system and hardware.

The ﬁnest resolution provided by an implementation is called the native resolution.
Implementation-provided clocks that are used for these functions shall meet the TrivialClock requirements
(20.12.3).

7

8 A function that takes an argument which speciﬁes a timeout will throw if, during its execution, a clock, time
point, or time duration throws an exception. Such exceptions are referred to as timeout-related exceptions.
[ Note: instantiations of clock, time point and duration types supplied by the implementation as speciﬁed
in 20.12.7 do not throw exceptions. — end note ]
30.2.5 Requirements for Lockable types
30.2.5.1

[thread.req.lockable]
[thread.req.lockable.general]
1 An execution agent is an entity such as a thread that may perform work in parallel with other execution
agents. [ Note: Implementations or users may introduce other kinds of agents such as processes or thread-
337) All implementations for which standard time units are meaningful must necessarily have a steady clock within their
hardware implementation.

In general

§ 30.2.5.1

1160

c(cid:13) ISO/IEC

N4296

pool tasks. — end note ] The calling agent is determined by context, e.g. the calling thread that contains
the call, and so on.
[ Note: Some lockable objects are “agent oblivious” in that they work for any execution agent model because
they do not determine or store the agent’s ID (e.g., an ordinary spin lock). — end note ]

2

3 The standard library templates unique_lock (30.4.2.2), lock_guard (30.4.2.1), lock, try_lock (30.4.3),
and condition_variable_any (30.5.2) all operate on user-supplied lockable objects. The BasicLockable
requirements, the Lockable requirements, and the TimedLockable requirements list the requirements im-
posed by these library types in order to acquire or release ownership of a lock by a given execution agent.
[ Note: The nature of any lock ownership and any synchronization it may entail are not part of these
requirements. — end note ]
30.2.5.2 BasicLockable requirements

[thread.req.lockable.basic]
1 A type L meets the BasicLockable requirements if the following expressions are well-formed and have the

speciﬁed semantics (m denotes a value of type L).

m.lock()

Eﬀects: Blocks until a lock can be acquired for the current execution agent. If an exception is thrown
then a lock shall not have been acquired for the current execution agent.

m.unlock()

Requires: The current execution agent shall hold a lock on m.
Eﬀects: Releases a lock on m held by the current execution agent.
Throws: Nothing.

2

3

4

5

30.2.5.3 Lockable requirements

[thread.req.lockable.req]
1 A type L meets the Lockable requirements if it meets the BasicLockable requirements and the following

expressions are well-formed and have the speciﬁed semantics (m denotes a value of type L).

m.try_lock()

2

3

4

Eﬀects: attempts to acquire a lock for the current execution agent without blocking. If an exception
is thrown then a lock shall not have been acquired for the current execution agent.
Return type: bool.
Returns: true if the lock was acquired, false otherwise.

30.2.5.4 TimedLockable requirements

[thread.req.lockable.timed]
1 A type L meets the TimedLockable requirements if it meets the Lockable requirements and the following
expressions are well-formed and have the speciﬁed semantics (m denotes a value of type L, rel_time denotes
a value of an instantiation of duration (20.12.5), and abs_time denotes a value of an instantiation of
time_point (20.12.6)).

m.try_lock_for(rel_time)

2

3

4

Eﬀects: attempts to acquire a lock for the current execution agent within the relative timeout (30.2.4)
speciﬁed by rel_time. The function shall not return within the timeout speciﬁed by rel_time unless
it has obtained a lock on m for the current execution agent. If an exception is thrown then a lock shall
not have been acquired for the current execution agent.
Return type: bool.
Returns: true if the lock was acquired, false otherwise.

§ 30.2.5.4

1161

c(cid:13) ISO/IEC

m.try_lock_until(abs_time)

N4296

5

6

7

1

Eﬀects: attempts to acquire a lock for the current execution agent before the absolute timeout (30.2.4)
speciﬁed by abs_time. The function shall not return before the timeout speciﬁed by abs_time unless
it has obtained a lock on m for the current execution agent. If an exception is thrown then a lock shall
not have been acquired for the current execution agent.
Return type: bool.
Returns: true if the lock was acquired, false otherwise.

30.2.6 decay_copy
[thread.decaycopy]
In several places in this Clause the operation DECAY_COPY(x) is used. All such uses mean call the function
decay_copy(x) and use the result, where decay_copy is deﬁned as follows:

template <class T> decay_t<T> decay_copy(T&& v)

{ return std::forward<T>(v); }

30.3 Threads

1 30.3 describes components that can be used to create and manage threads.

intended to map one-to-one with operating system threads. — end note ]
Header <thread> synopsis

[thread.threads]
[ Note: These threads are

namespace std {
class thread;

void swap(thread& x, thread& y) noexcept;

namespace this_thread {

thread::id get_id() noexcept;

void yield() noexcept;
template <class Clock, class Duration>

void sleep_until(const chrono::time_point<Clock, Duration>& abs_time);

template <class Rep, class Period>

void sleep_for(const chrono::duration<Rep, Period>& rel_time);

}

}

30.3.1 Class thread

[thread.thread.class]
1 The class thread provides a mechanism to create a new thread of execution, to join with a thread (i.e., wait
for a thread to complete), and to perform other operations that manage and query the state of a thread. A
thread object uniquely represents a particular thread of execution. That representation may be transferred
to other thread objects in such a way that no two thread objects simultaneously represent the same thread
of execution. A thread of execution is detached when no thread object represents that thread. Objects of
class thread can be in a state that does not represent a thread of execution. [ Note: A thread object does
not represent a thread of execution after default construction, after being moved from, or after a successful
call to detach or join. — end note ]

namespace std {
class thread {
public:

// types:
class id;

§ 30.3.1

1162

c(cid:13) ISO/IEC

N4296

typedef implementation-defined native_handle_type; // See 30.2.3

// construct/copy/destroy:
thread() noexcept;
template <class F, class ...Args> explicit thread(F&& f, Args&&... args);
~thread();
thread(const thread&) = delete;
thread(thread&&) noexcept;
thread& operator=(const thread&) = delete;
thread& operator=(thread&&) noexcept;

// members:
void swap(thread&) noexcept;
bool joinable() const noexcept;
void join();
void detach();
id get_id() const noexcept;
native_handle_type native_handle(); // See 30.2.3

// static members:
static unsigned hardware_concurrency() noexcept;

};

}

30.3.1.1 Class thread::id

[thread.thread.id]

namespace std {

class thread::id {
public:

id() noexcept;

};

bool operator==(thread::id x, thread::id y) noexcept;
bool operator!=(thread::id x, thread::id y) noexcept;
bool operator<(thread::id x, thread::id y) noexcept;
bool operator<=(thread::id x, thread::id y) noexcept;
bool operator>(thread::id x, thread::id y) noexcept;
bool operator>=(thread::id x, thread::id y) noexcept;

template<class charT, class traits>

basic_ostream<charT, traits>&

operator<< (basic_ostream<charT, traits>& out, thread::id id);

// Hash support
template <class T> struct hash;
template <> struct hash<thread::id>;

}

1 An object of type thread::id provides a unique identiﬁer for each thread of execution and a single distinct
value for all thread objects that do not represent a thread of execution (30.3.1). Each thread of execution has
an associated thread::id object that is not equal to the thread::id object of any other thread of execution
and that is not equal to the thread::id object of any std::thread object that does not represent threads
of execution.

2 thread::id shall be a trivially copyable class (Clause 9). The library may reuse the value of a thread::id

of a terminated thread that can no longer be joined.

§ 30.3.1.1

1163

3

4

5

6

7

8

9

10

11

12

13

14

1

2

c(cid:13) ISO/IEC

N4296

[ Note: Relational operators allow thread::id objects to be used as keys in associative containers. — end
note ]

id() noexcept;

Eﬀects: Constructs an object of type id.
Postconditions: The constructed object does not represent a thread of execution.

bool operator==(thread::id x, thread::id y) noexcept;

Returns: true only if x and y represent the same thread of execution or neither x nor y represents a
thread of execution.

bool operator!=(thread::id x, thread::id y) noexcept;

Returns: !(x == y)

bool operator<(thread::id x, thread::id y) noexcept;

Returns: A value such that operator< is a total ordering as described in 25.4.

bool operator<=(thread::id x, thread::id y) noexcept;

Returns: !(y < x)

bool operator>(thread::id x, thread::id y) noexcept;

Returns: y < x

bool operator>=(thread::id x, thread::id y) noexcept;

Returns: !(x < y)

template<class charT, class traits>

basic_ostream<charT, traits>&

operator<< (basic_ostream<charT, traits>&& out, thread::id id);
Eﬀects: Inserts an unspeciﬁed text representation of id into out. For two objects of type thread::id
x and y, if x == y the thread::id objects shall have the same text representation and if x != y the
thread::id objects shall have distinct text representations.
Returns: out

template <> struct hash<thread::id>;

The template specialization shall meet the requirements of class template hash (20.9.13).

30.3.1.2 thread constructors
thread() noexcept;

[thread.thread.constr]

Eﬀects: Constructs a thread object that does not represent a thread of execution.
Postcondition: get_id() == id()

template <class F, class ...Args> explicit thread(F&& f, Args&&... args);

§ 30.3.1.2

1164

c(cid:13) ISO/IEC

N4296

3

4

5

6

7

8

9

(9.1)

10

11

1

1

2

3

1

Requires: F and each Ti in Args shall satisfy the MoveConstructible requirements. INVOKE (DECAY_-
COPY ( std::forward<F>(f)), DECAY_COPY (std::forward<Args>(args))...) (20.9.2) shall be a
valid expression.
Remarks: This constructor shall not participate in overload resolution if decay_t<F> is the same type
as std::thread.
Eﬀects: Constructs an object of type thread. The new thread of execution executes INVOKE (DECAY_-
COPY ( std::forward<F>(f)), DECAY_COPY (std::forward<Args>(args))...) with the calls to
DECAY_COPY being evaluated in the constructing thread. Any return value from this invocation is
ignored.
[ Note: This implies that any exceptions not thrown from the invocation of the copy of f
will be thrown in the constructing thread, not the new thread. — end note ] If the invocation of
INVOKE (DECAY_COPY ( std::forward<F>(f)), DECAY_COPY (std::forward<Args>(args))...) ter-
minates with an uncaught exception, std::terminate shall be called.
Synchronization: The completion of the invocation of the constructor synchronizes with the beginning
of the invocation of the copy of f.
Postconditions: get_id() != id(). *this represents the newly started thread.
Throws: system_error if unable to start the new thread.
Error conditions:
—

resource_unavailable_try_again — the system lacked the necessary resources to create an-
other thread, or the system-imposed limit on the number of threads in a process would be ex-
ceeded.

thread(thread&& x) noexcept;

Eﬀects: Constructs an object of type thread from x, and sets x to a default constructed state.
Postconditions: x.get_id() == id() and get_id() returns the value of x.get_id() prior to the
start of construction.

30.3.1.3 thread destructor
~thread();

[thread.thread.destr]

If joinable(), calls std::terminate(). Otherwise, has no eﬀects. [ Note: Either implicitly detach-
ing or joining a joinable() thread in its destructor could result in diﬃcult to debug correctness (for
detach) or performance (for join) bugs encountered only when an exception is raised. Thus the pro-
grammer must ensure that the destructor is never executed while the thread is still joinable. — end
note ]

30.3.1.4 thread assignment
thread& operator=(thread&& x) noexcept;

[thread.thread.assign]

Eﬀects: If joinable(), calls std::terminate(). Otherwise, assigns the state of x to *this and sets
x to a default constructed state.
Postconditions: x.get_id() == id() and get_id() returns the value of x.get_id() prior to the
assignment.
Returns: *this

30.3.1.5 thread members
void swap(thread& x) noexcept;

Eﬀects: Swaps the state of *this and x.

§ 30.3.1.5

[thread.thread.member]

1165

c(cid:13) ISO/IEC

bool joinable() const noexcept;
Returns: get_id() != id()

void join();

N4296

Requires: joinable() is true.
Eﬀects: Blocks until the thread represented by *this has completed.
Synchronization: The completion of the thread represented by *this synchronizes with (1.10) the
corresponding successful join() return.
[ Note: Operations on *this are not synchronized. — end
note ]
Postconditions: The thread represented by *this has completed. get_id() == id().
Throws: system_error when an exception is required (30.2.2).
Error conditions:
—

resource_deadlock_would_occur — if deadlock is detected or this->get_id() == std::this_-
thread::get_id().
no_such_process — if the thread is not valid.
invalid_argument — if the thread is not joinable.

—
—

void detach();

Requires: joinable() is true.
Eﬀects: The thread represented by *this continues execution without the calling thread blocking.
When detach() returns, *this no longer represents the possibly continuing thread of execution.
When the thread previously represented by *this ends execution, the implementation shall release
any owned resources.
Postcondition: get_id() == id().
Throws: system_error when an exception is required (30.2.2).
Error conditions:
—
—

no_such_process — if the thread is not valid.
invalid_argument — if the thread is not joinable.

id get_id() const noexcept;

Returns: A default constructed id object if *this does not represent a thread, otherwise this_-
thread::get_id() for the thread of execution represented by *this.

30.3.1.6 thread static members
unsigned hardware_concurrency() noexcept;

[thread.thread.static]

Returns: The number of hardware thread contexts. [ Note: This value should only be considered to be
a hint. — end note ] If this value is not computable or well deﬁned an implementation should return
0.

30.3.1.7 thread specialized algorithms
void swap(thread& x, thread& y) noexcept;

Eﬀects: x.swap(y)

[thread.thread.algorithm]

§ 30.3.1.7

1166

2

3

4

5

6

7

8

(8.1)

(8.2)

(8.3)

9

10

11

12

13

(13.1)

(13.2)

14

1

1

c(cid:13) ISO/IEC

30.3.2 Namespace this_thread

namespace std::this_thread {

thread::id get_id() noexcept;

N4296

[thread.thread.this]

void yield() noexcept;
template <class Clock, class Duration>

void sleep_until(const chrono::time_point<Clock, Duration>& abs_time);

template <class Rep, class Period>

void sleep_for(const chrono::duration<Rep, Period>& rel_time);

}

thread::id this_thread::get_id() noexcept;

Returns: An object of type thread::id that uniquely identiﬁes the current thread of execution. No
other thread of execution shall have this id and this thread of execution shall always have this id. The
object returned shall not compare equal to a default constructed thread::id.

void this_thread::yield() noexcept;

Eﬀects: Oﬀers the implementation the opportunity to reschedule.
Synchronization: None.

template <class Clock, class Duration>

void sleep_until(const chrono::time_point<Clock, Duration>& abs_time);

Eﬀects: Blocks the calling thread for the absolute timeout (30.2.4) speciﬁed by abs_time.
Synchronization: None.
Throws: Timeout-related exceptions (30.2.4).

template <class Rep, class Period>

void sleep_for(const chrono::duration<Rep, Period>& rel_time);

Eﬀects: Blocks the calling thread for the relative timeout (30.2.4) speciﬁed by rel_time.
Synchronization: None.
Throws: Timeout-related exceptions (30.2.4).

1

2

3

4

5

6

7

8

9

30.4 Mutual exclusion

[thread.mutex]
1 This section provides mechanisms for mutual exclusion: mutexes, locks, and call once. These mechanisms

ease the production of race-free programs (1.10).
Header <mutex> synopsis

namespace std {
class mutex;
class recursive_mutex;
class timed_mutex;
class recursive_timed_mutex;

struct defer_lock_t { };
struct try_to_lock_t { };
struct adopt_lock_t { };

constexpr defer_lock_t
defer_lock { };
constexpr try_to_lock_t try_to_lock { };
constexpr adopt_lock_t
adopt_lock { };

§ 30.4

1167

c(cid:13) ISO/IEC

N4296

template <class Mutex> class lock_guard;
template <class Mutex> class unique_lock;

template <class Mutex>

void swap(unique_lock<Mutex>& x, unique_lock<Mutex>& y) noexcept;

template <class L1, class L2, class... L3> int try_lock(L1&, L2&, L3&...);
template <class L1, class L2, class... L3> void lock(L1&, L2&, L3&...);

struct once_flag {

constexpr once_flag() noexcept;

once_flag(const once_flag&) = delete;
once_flag& operator=(const once_flag&) = delete;

};

template<class Callable, class ...Args>

void call_once(once_flag& flag, Callable&& func, Args&&... args);

}

Header <shared_mutex> synopsis

namespace std {

class shared_timed_mutex;
template <class Mutex> class shared_lock;
template <class Mutex>

void swap(shared_lock<Mutex>& x, shared_lock<Mutex>& y) noexcept;

}

30.4.1 Mutex requirements
30.4.1.1

In general

[thread.mutex.requirements]
[thread.mutex.requirements.general]
1 A mutex object facilitates protection against data races and allows safe synchronization of data between
execution agents (30.2.5). An execution agent owns a mutex from the time it successfully calls one of
the lock functions until it calls unlock. Mutexes can be either recursive or non-recursive, and can grant
simultaneous ownership to one or many execution agents. Both recursive and non-recursive mutexes are
supplied.
30.4.1.2 Mutex types

[thread.mutex.requirements.mutex]
1 The mutex types are the standard library types std::mutex, std::recursive_mutex, std::timed_mutex,
std::recursive_timed_mutex, and std::shared_timed_mutex. They shall meet the requirements set out
in this section. In this description, m denotes an object of a mutex type.

2 The mutex types shall meet the Lockable requirements (30.2.5.3).
3 The mutex types shall be DefaultConstructible and Destructible. If initialization of an object of a mutex
type fails, an exception of type system_error shall be thrown. The mutex types shall not be copyable or
movable.

4 The error conditions for error codes, if any, reported by member functions of the mutex types shall be:

(4.1)

(4.2)

(4.3)

—
—
—

resource_unavailable_try_again — if any native handle type manipulated is not available.
operation_not_permitted — if the thread does not have the privilege to perform the operation.
device_or_resource_busy — if any native handle type manipulated is already locked.

§ 30.4.1.2

1168

c(cid:13) ISO/IEC

N4296

(4.4)

—

invalid_argument — if any native handle type manipulated as part of mutex construction is incorrect.

5 The implementation shall provide lock and unlock operations, as described below. For purposes of determin-
ing the existence of a data race, these behave as atomic operations (1.10). The lock and unlock operations
on a single mutex shall appear to occur in a single total order. [ Note: this can be viewed as the modiﬁcation
order (1.10) of the mutex. — end note ] [ Note: Construction and destruction of an object of a mutex type
need not be thread-safe; other synchronization should be used to ensure that mutex objects are initialized
and visible to other threads. — end note ]

6 The expression m.lock() shall be well-formed and have the following semantics:
7

Requires: If m is of type std::mutex, std::timed_mutex, or std::shared_timed_mutex, the calling
thread does not own the mutex.
Eﬀects: Blocks the calling thread until ownership of the mutex can be obtained for the calling thread.
Postcondition: The calling thread owns the mutex.
Return type: void
Synchronization: Prior unlock() operations on the same object shall synchronize with (1.10) this
operation.
Throws: system_error when an exception is required (30.2.2).
Error conditions:
—
—
—

operation_not_permitted — if the thread does not have the privilege to perform the operation.
resource_deadlock_would_occur — if the implementation detects that a deadlock would occur.
device_or_resource_busy — if the mutex is already locked and blocking is not possible.

8

9

10

11

12

13

(13.1)
(13.2)
(13.3)

14 The expression m.try_lock() shall be well-formed and have the following semantics:
15

Requires: If m is of type std::mutex, std::timed_mutex, or std::shared_timed_mutex, the calling
thread does not own the mutex.
Eﬀects: Attempts to obtain ownership of the mutex for the calling thread without blocking. If own-
ership is not obtained, there is no eﬀect and try_lock() immediately returns. An implementation
may fail to obtain the lock even if it is not held by any other thread. [ Note: This spurious failure is
normally uncommon, but allows interesting implementations based on a simple compare and exchange
(Clause 29). — end note ] An implementation should ensure that try_lock() does not consistently
return false in the absence of contending mutex acquisitions.
Return type: bool
Returns: true if ownership of the mutex was obtained for the calling thread, otherwise false.
Synchronization: If try_lock() returns true, prior unlock() operations on the same object synchro-
nize with (1.10) this operation.
[ Note: Since lock() does not synchronize with a failed subsequent
try_lock(), the visibility rules are weak enough that little would be known about the state after a
failure, even in the absence of spurious failures. — end note ]
Throws: Nothing.

20
21 The expression m.unlock() shall be well-formed and have the following semantics:
22

Requires: The calling thread shall own the mutex.
Eﬀects: Releases the calling thread’s ownership of the mutex.
Return type: void
Synchronization: This operation synchronizes with (1.10) subsequent lock operations that obtain own-
ership on the same object.
Throws: Nothing.

16

17

18

19

23

24

25

26

§ 30.4.1.2

1169

N4296

[thread.mutex.class]

c(cid:13) ISO/IEC

30.4.1.2.1 Class mutex

namespace std {
class mutex {
public:

constexpr mutex() noexcept;
~mutex();

mutex(const mutex&) = delete;
mutex& operator=(const mutex&) = delete;

void lock();
bool try_lock();
void unlock();

typedef implementation-defined native_handle_type; // See 30.2.3
// See 30.2.3
native_handle_type native_handle();

};

}

2

1 The class mutex provides a non-recursive mutex with exclusive ownership semantics. If one thread owns a
mutex object, attempts by another thread to acquire ownership of that object will fail (for try_lock()) or
block (for lock()) until the owning thread has released ownership with a call to unlock().
[ Note: After a thread A has called unlock(), releasing a mutex, it is possible for another thread B to lock
the same mutex, observe that it is no longer in use, unlock it, and destroy it, before thread A appears to
have returned from its unlock call. Implementations are required to handle such scenarios correctly, as long
as thread A doesn’t access the mutex after the unlock call returns. These cases typically occur when a
reference-counted object contains a mutex that is used to protect the reference count. — end note ]

3 The class mutex shall satisfy all the Mutex requirements (30.4.1).

It shall be a standard-layout class

(Clause 9).
[ Note: A program may deadlock if the thread that owns a mutex object calls lock() on that object. If
the implementation can detect the deadlock, a resource_deadlock_would_occur error condition may be
observed. — end note ]

4

5 The behavior of a program is undeﬁned if it destroys a mutex object owned by any thread or a thread

terminates while owning a mutex object.
30.4.1.2.2 Class recursive_mutex

[thread.mutex.recursive]

namespace std {

class recursive_mutex {
public:

recursive_mutex();
~recursive_mutex();

recursive_mutex(const recursive_mutex&) = delete;
recursive_mutex& operator=(const recursive_mutex&) = delete;

void lock();
bool try_lock() noexcept;
void unlock();

typedef implementation-defined native_handle_type; // See 30.2.3
// See 30.2.3
native_handle_type native_handle();

};

§ 30.4.1.2.2

1170

c(cid:13) ISO/IEC

}

N4296

1 The class recursive_mutex provides a recursive mutex with exclusive ownership semantics. If one thread
owns a recursive_mutex object, attempts by another thread to acquire ownership of that object will fail
(for try_lock()) or block (for lock()) until the ﬁrst thread has completely released ownership.

2 The class recursive_mutex shall satisfy all the Mutex requirements (30.4.1). It shall be a standard-layout

class (Clause 9).

3 A thread that owns a recursive_mutex object may acquire additional levels of ownership by calling lock()
or try_lock() on that object. It is unspeciﬁed how many levels of ownership may be acquired by a single
thread. If a thread has already acquired the maximum level of ownership for a recursive_mutex object,
additional calls to try_lock() shall fail, and additional calls to lock() shall throw an exception of type
system_error. A thread shall call unlock() once for each level of ownership acquired by calls to lock() and
try_lock(). Only when all levels of ownership have been released may ownership be acquired by another
thread.

4 The behavior of a program is undeﬁned if:

(4.1)

(4.2)

—
—

it destroys a recursive_mutex object owned by any thread or
a thread terminates while owning a recursive_mutex object.

30.4.1.3 Timed mutex types

[thread.timedmutex.requirements]
1 The timed mutex types are the standard library types std::timed_mutex, std::recursive_timed_mutex,
and std::shared_timed_mutex. They shall meet the requirements set out below. In this description, m
denotes an object of a mutex type, rel_time denotes an object of an instantiation of duration (20.12.5),
and abs_time denotes an object of an instantiation of time_point (20.12.6).

2 The timed mutex types shall meet the TimedLockable requirements (30.2.5.4).
3 The expression m.try_lock_for(rel_time) shall be well-formed and have the following semantics:
4

5

6

7

8

12

Requires: If m is of type std::timed_mutex or std::shared_timed_mutex, the calling thread does
not own the mutex.
Eﬀects: The function attempts to obtain ownership of the mutex within the relative timeout (30.2.4)
speciﬁed by rel_time. If the time speciﬁed by rel_time is less than or equal to rel_time.zero(), the
function attempts to obtain ownership without blocking (as if by calling try_lock()). The function
shall return within the timeout speciﬁed by rel_time only if it has obtained ownership of the mutex
object. [ Note: As with try_lock(), there is no guarantee that ownership will be obtained if the lock
is available, but implementations are expected to make a strong eﬀort to do so. — end note ]
Return type: bool
Returns: true if ownership was obtained, otherwise false.
Synchronization:
synchronize with (1.10) this operation.
Throws: Timeout-related exceptions (30.2.4).

If try_lock_for() returns true, prior unlock() operations on the same object

9
10 The expression m.try_lock_until(abs_time) shall be well-formed and have the following semantics:
11

Requires: If m is of type std::timed_mutex or std::shared_timed_mutex, the calling thread does
not own the mutex.
Eﬀects: The function attempts to obtain ownership of the mutex. If abs_time has already passed, the
function attempts to obtain ownership without blocking (as if by calling try_lock()). The function
shall return before the absolute timeout (30.2.4) speciﬁed by abs_time only if it has obtained ownership
of the mutex object. [ Note: As with try_lock(), there is no guarantee that ownership will be obtained

§ 30.4.1.3

1171

c(cid:13) ISO/IEC

N4296

if the lock is available, but implementations are expected to make a strong eﬀort to do so. — end
note ]
Return type: bool
Returns: true if ownership was obtained, otherwise false.
Synchronization: If try_lock_until() returns true, prior unlock() operations on the same object
synchronize with (1.10) this operation.
Throws: Timeout-related exceptions (30.2.4).

13

14

15

16

30.4.1.3.1 Class timed_mutex

[thread.timedmutex.class]

namespace std {

class timed_mutex {
public:

timed_mutex();
~timed_mutex();

timed_mutex(const timed_mutex&) = delete;
timed_mutex& operator=(const timed_mutex&) = delete;

void lock(); // blocking
bool try_lock();
template <class Rep, class Period>

bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);

template <class Clock, class Duration>

bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);

void unlock();

typedef implementation-defined native_handle_type; // See 30.2.3
// See 30.2.3
native_handle_type native_handle();

};

}

1 The class timed_mutex provides a non-recursive mutex with exclusive ownership semantics. If one thread
owns a timed_mutex object, attempts by another thread to acquire ownership of that object will fail (for
try_lock()) or block (for lock(), try_lock_for(), and try_lock_until()) until the owning thread has
released ownership with a call to unlock() or the call to try_lock_for() or try_lock_until() times out
(having failed to obtain ownership).

2 The class timed_mutex shall satisfy all of the TimedMutex requirements (30.4.1.3). It shall be a standard-

layout class (Clause 9).

3 The behavior of a program is undeﬁned if:

(3.1)

(3.2)

(3.3)

—
—

—

it destroys a timed_mutex object owned by any thread,
a thread that owns a timed_mutex object calls lock(), try_lock(), try_lock_for(), or try_lock_-
until() on that object, or
a thread terminates while owning a timed_mutex object.

30.4.1.3.2 Class recursive_timed_mutex

[thread.timedmutex.recursive]

namespace std {

class recursive_timed_mutex {
public:

recursive_timed_mutex();

§ 30.4.1.3.2

1172

c(cid:13) ISO/IEC

~recursive_timed_mutex();

recursive_timed_mutex(const recursive_timed_mutex&) = delete;
recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;

N4296

void lock(); // blocking
bool try_lock() noexcept;
template <class Rep, class Period>

bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);

template <class Clock, class Duration>

bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);

void unlock();

typedef implementation-defined native_handle_type; // See 30.2.3
// See 30.2.3
native_handle_type native_handle();

};

}

1 The class recursive_timed_mutex provides a recursive mutex with exclusive ownership semantics. If one
thread owns a recursive_timed_mutex object, attempts by another thread to acquire ownership of that
object will fail (for try_lock()) or block (for lock(), try_lock_for(), and try_lock_until()) until the
owning thread has completely released ownership or the call to try_lock_for() or try_lock_until() times
out (having failed to obtain ownership).

2 The class recursive_timed_mutex shall satisfy all of the TimedMutex requirements (30.4.1.3). It shall be a

standard-layout class (Clause 9).

3 A thread that owns a recursive_timed_mutex object may acquire additional levels of ownership by calling
lock(), try_lock(), try_lock_for(), or try_lock_until() on that object. It is unspeciﬁed how many
levels of ownership may be acquired by a single thread. If a thread has already acquired the maximum level of
ownership for a recursive_timed_mutex object, additional calls to try_lock(), try_lock_for(), or try_-
lock_until() shall fail, and additional calls to lock() shall throw an exception of type system_error. A
thread shall call unlock() once for each level of ownership acquired by calls to lock(), try_lock(), try_-
lock_for(), and try_lock_until(). Only when all levels of ownership have been released may ownership
of the object be acquired by another thread.

4 The behavior of a program is undeﬁned if:

(4.1)

(4.2)

—
—

it destroys a recursive_timed_mutex object owned by any thread, or
a thread terminates while owning a recursive_timed_mutex object.

30.4.1.4 Shared timed mutex types

[thread.sharedtimedmutex.requirements]
1 The standard library type std::shared_timed_mutex is a shared timed mutex type. Shared timed mu-
tex types shall meet the requirements of timed mutex types (30.4.1.3), and additionally shall meet the
requirements set out below. In this description, m denotes an object of a mutex type, rel_type denotes
an object of an instantiation of duration (20.12.5), and abs_time denotes an object of an instantiation of
time_point (20.12.6).
In addition to the exclusive lock ownership mode speciﬁed in 30.4.1.2, shared mutex types provide a shared
lock ownership mode. Multiple execution agents can simultaneously hold a shared lock ownership of a shared
mutex type. But no execution agent shall hold a shared lock while another execution agent holds an exclusive
lock on the same shared mutex type, and vice-versa. The maximum number of execution agents which can
share a shared lock on a single shared mutex type is unspeciﬁed, but shall be at least 10000. If more than
the maximum number of execution agents attempt to obtain a shared lock, the excess execution agents shall

2

§ 30.4.1.4

1173

c(cid:13) ISO/IEC

N4296

block until the number of shared locks are reduced below the maximum amount by other execution agents
releasing their shared lock.

3 The expression m.lock_shared() shall be well-formed and have the following semantics:
4

Requires: The calling thread has no ownership of the mutex.
Eﬀects: Blocks the calling thread until shared ownership of the mutex can be obtained for the calling
thread.
If an exception is thrown then a shared lock shall not have been acquired for the current
thread.
Postcondition: The calling thread has a shared lock on the mutex.
Return type: void.
Synchronization: Prior unlock() operations on the same object shall synchronize with (1.10) this
operation.
Throws: system_error when an exception is required (30.2.2).
Error conditions:
—
—
—

operation_not_permitted — if the thread does not have the privilege to perform the operation.
resource_deadlock_would_occur — if the implementation detects that a deadlock would occur.
device_or_resource_busy — if the mutex is already locked and blocking is not possible.

5

6

7

8

9

10

(10.1)

(10.2)

(10.3)

13

14

15

11 The expression m.unlock_shared() shall be well-formed and have the following semantics:
12

Requires: The calling thread shall hold a shared lock on the mutex.
Eﬀects: Releases a shared lock on the mutex held by the calling thread.
Return type: void.
Synchronization: This operation synchronizes with (1.10) subsequent lock() operations that obtain
ownership on the same object.
Throws: Nothing.

16
17 The expression m.try_lock_shared() shall be well-formed and have the following semantics:
18

19

20

21

22

Requires: The calling thread has no ownership of the mutex.
Eﬀects: Attempts to obtain shared ownership of the mutex for the calling thread without blocking. If
shared ownership is not obtained, there is no eﬀect and try_lock_shared() immediately returns. An
implementation may fail to obtain the lock even if it is not held by any other thread.
Return type: bool.
Returns: true if the shared ownership lock was acquired, false otherwise.
Synchronization: If try_lock_shared() returns true, prior unlock() operations on the same object
synchronize with (1.10) this operation.
Throws: Nothing.

23
24 The expression m.try_lock_shared_for(rel_time) shall be well-formed and have the following semantics:
25

Requires: The calling thread has no ownership of the mutex.
Eﬀects: Attempts to obtain shared lock ownership for the calling thread within the relative time-
out (30.2.4) speciﬁed by rel_time. If the time speciﬁed by rel_time is less than or equal to rel_-
time.zero(), the function attempts to obtain ownership without blocking (as if by calling try_-
lock_shared()). The function shall return within the timeout speciﬁed by rel_time only if it has
obtained shared ownership of the mutex object.
[ Note: As with try_lock(), there is no guarantee

26

§ 30.4.1.4

1174

c(cid:13) ISO/IEC

N4296

27

28

29

that ownership will be obtained if the lock is available, but implementations are expected to make a
strong eﬀort to do so. — end note ] If an exception is thrown then a shared lock shall not have been
acquired for the current thread.
Return type: bool.
Returns: true if the shared lock was acquired, false otherwise.
Synchronization: If try_lock_shared_for() returns true, prior unlock() operations on the same
object synchronize with (1.10) this operation.
Throws: Timeout-related exceptions (30.2.4).

30
31 The expression m.try_lock_shared_until(abs_time) shall be well-formed and have the following seman-

tics:

32

33

34

35

36

37

Requires: The calling thread has no ownership of the mutex.
Eﬀects: The function attempts to obtain shared ownership of the mutex. If abs_time has already
passed, the function attempts to obtain shared ownership without blocking (as if by calling try_-
lock_shared()). The function shall return before the absolute timeout (30.2.4) speciﬁed by abs_time
only if it has obtained shared ownership of the mutex object. [ Note: As with try_lock(), there is no
guarantee that ownership will be obtained if the lock is available, but implementations are expected
to make a strong eﬀort to do so. — end note ] If an exception is thrown then a shared lock shall not
have been acquired for the current thread.
Return type: bool.
Returns: true if the shared lock was acquired, false otherwise.
Synchronization: If try_lock_shared_until() returns true, prior unlock() operations on the same
object synchronize with (1.10) this operation.
Throws: Timeout-related exceptions (30.2.4).

30.4.1.4.1 Class shared_timed_mutex

[thread.sharedtimedmutex.class]

namespace std {

class shared_timed_mutex {
public:

shared_timed_mutex();
~shared_timed_mutex();

shared_timed_mutex(const shared_timed_mutex&) = delete;
shared_timed_mutex& operator=(const shared_timed_mutex&) = delete;

// Exclusive ownership
void lock(); // blocking
bool try_lock();
template <class Rep, class Period>

bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);

template <class Clock, class Duration>

bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);

void unlock();

// Shared ownership
void lock_shared(); // blocking
bool try_lock_shared();
template <class Rep, class Period>

bool
try_lock_shared_for(const chrono::duration<Rep, Period>& rel_time);

§ 30.4.1.4.1

1175

c(cid:13) ISO/IEC

N4296

template <class Clock, class Duration>

bool
try_lock_shared_until(const chrono::time_point<Clock, Duration>& abs_time);

void unlock_shared();

};

}

1 The class shared_timed_mutex provides a non-recursive mutex with shared ownership semantics.
2 The class shared_timed_mutex shall satisfy all of the SharedTimedMutex requirements (30.4.1.4). It shall

be a standard-layout class (Clause 9).

3 The behavior of a program is undeﬁned if:

(3.1)

(3.2)

(3.3)

—
—
—

it destroys a shared_timed_mutex object owned by any thread,
a thread attempts to recursively gain any ownership of a shared_timed_mutex, or
a thread terminates while possessing any ownership of a shared_timed_mutex.

30.4.2 Locks

[thread.lock]
1 A lock is an object that holds a reference to a lockable object and may unlock the lockable object during the
lock’s destruction (such as when leaving block scope). An execution agent may use a lock to aid in managing
ownership of a lockable object in an exception safe manner. A lock is said to own a lockable object if it is
currently managing the ownership of that lockable object for an execution agent. A lock does not manage
the lifetime of the lockable object it references. [ Note: Locks are intended to ease the burden of unlocking
the lockable object under both normal and exceptional circumstances. — end note ]

2 Some lock constructors take tag types which describe what should be done with the lockable object during

the lock’s construction.

namespace std {

struct defer_lock_t
{ };
struct try_to_lock_t { };

struct adopt_lock_t

{ };

// do not acquire ownership of the mutex
// try to acquire ownership of the mutex
// without blocking
// assume the calling thread has already
// obtained mutex ownership and manage it

constexpr defer_lock_t
constexpr try_to_lock_t
constexpr adopt_lock_t

defer_lock { };
try_to_lock { };
adopt_lock { };

}

30.4.2.1 Class template lock_guard

[thread.lock.guard]

namespace std {

template <class Mutex>
class lock_guard {
public:

typedef Mutex mutex_type;

explicit lock_guard(mutex_type& m);
lock_guard(mutex_type& m, adopt_lock_t);
~lock_guard();

lock_guard(lock_guard const&) = delete;
lock_guard& operator=(lock_guard const&) = delete;

§ 30.4.2.1

1176

c(cid:13) ISO/IEC

N4296

mutex_type& pm; // exposition only

private:

};

}

1 An object of type lock_guard controls the ownership of a lockable object within a scope. A lock_guard
object maintains ownership of a lockable object throughout the lock_guard object’s lifetime (3.8). The
behavior of a program is undeﬁned if the lockable object referenced by pm does not exist for the entire lifetime
of the lock_guard object. The supplied Mutex type shall meet the BasicLockable requirements (30.2.5.2).

explicit lock_guard(mutex_type& m);

Requires: If mutex_type is not a recursive mutex, the calling thread does not own the mutex m.
Eﬀects: m.lock()
Postcondition: &pm == &m

lock_guard(mutex_type& m, adopt_lock_t);

Requires: The calling thread owns the mutex m.
Postcondition: &pm == &m
Throws: Nothing.

~lock_guard();

Eﬀects: pm.unlock()

2

3

4

5

6

7

8

30.4.2.2 Class template unique_lock

[thread.lock.unique]

namespace std {

template <class Mutex>
class unique_lock {
public:

typedef Mutex mutex_type;

// 30.4.2.2.1, construct/copy/destroy:
unique_lock() noexcept;
explicit unique_lock(mutex_type& m);
unique_lock(mutex_type& m, defer_lock_t) noexcept;
unique_lock(mutex_type& m, try_to_lock_t);
unique_lock(mutex_type& m, adopt_lock_t);
template <class Clock, class Duration>

~unique_lock();

unique_lock(mutex_type& m, const chrono::time_point<Clock, Duration>& abs_time);

template <class Rep, class Period>

unique_lock(mutex_type& m, const chrono::duration<Rep, Period>& rel_time);

unique_lock(unique_lock const&) = delete;
unique_lock& operator=(unique_lock const&) = delete;

unique_lock(unique_lock&& u) noexcept;
unique_lock& operator=(unique_lock&& u);

// 30.4.2.2.2, locking:
void lock();
bool try_lock();

§ 30.4.2.2

1177

c(cid:13) ISO/IEC

N4296

template <class Rep, class Period>

bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);

template <class Clock, class Duration>

bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);

void unlock();

// 30.4.2.2.3, modiﬁers:
void swap(unique_lock& u) noexcept;
mutex_type* release() noexcept;

// 30.4.2.2.4, observers:
bool owns_lock() const noexcept;
explicit operator bool () const noexcept;
mutex_type* mutex() const noexcept;

private:

};

mutex_type* pm; // exposition only
// exposition only
bool owns;

template <class Mutex>

void swap(unique_lock<Mutex>& x, unique_lock<Mutex>& y) noexcept;

}

1 An object of type unique_lock controls the ownership of a lockable object within a scope. Ownership
of the lockable object may be acquired at construction or after construction, and may be transferred, after
acquisition, to another unique_lock object. Objects of type unique_lock are not copyable but are movable.
The behavior of a program is undeﬁned if the contained pointer pm is not null and the lockable object pointed
to by pm does not exist for the entire remaining lifetime (3.8) of the unique_lock object. The supplied Mutex
type shall meet the BasicLockable requirements (30.2.5.2).
If Mutex meets the Lockable re-
[ Note: unique_lock<Mutex> meets the BasicLockable requirements.
quirements (30.2.5.3), unique_lock<Mutex> also meets the Lockable requirements;
if Mutex meets the
TimedLockable requirements (30.2.5.4), unique_lock<Mutex> also meets the TimedLockable requirements.
— end note ]
30.4.2.2.1 unique_lock constructors, destructor, and assignment
unique_lock() noexcept;

[thread.lock.unique.cons]

2

1

2

3

4

5

6

7

Eﬀects: Constructs an object of type unique_lock.
Postconditions: pm == 0 and owns == false.

explicit unique_lock(mutex_type& m);

Requires: If mutex_type is not a recursive mutex the calling thread does not own the mutex.
Eﬀects: Constructs an object of type unique_lock and calls m.lock().
Postconditions: pm == &m and owns == true.

unique_lock(mutex_type& m, defer_lock_t) noexcept;

Eﬀects: Constructs an object of type unique_lock.
Postconditions: pm == &m and owns == false.

§ 30.4.2.2.1

1178

c(cid:13) ISO/IEC

N4296

unique_lock(mutex_type& m, try_to_lock_t);

Requires: The supplied Mutex type shall meet the Lockable requirements (30.2.5.3). If mutex_type is
not a recursive mutex the calling thread does not own the mutex.
Eﬀects: Constructs an object of type unique_lock and calls m.try_lock().
Postconditions: pm == &m and owns == res, where res is the value returned by the call to m.try_-
lock().

unique_lock(mutex_type& m, adopt_lock_t);

Requires: The calling thread own the mutex.
Eﬀects: Constructs an object of type unique_lock.
Postconditions: pm == &m and owns == true.
Throws: Nothing.

template <class Clock, class Duration>

unique_lock(mutex_type& m, const chrono::time_point<Clock, Duration>& abs_time);

Requires: If mutex_type is not a recursive mutex the calling thread does not own the mutex. The
supplied Mutex type shall meet the TimedLockable requirements (30.2.5.4).
Eﬀects: Constructs an object of type unique_lock and calls m.try_lock_until(abs_time).
Postconditions: pm == &m and owns == res, where res is the value returned by the call to m.try_-
lock_until(abs_time).

template <class Rep, class Period>

unique_lock(mutex_type& m, const chrono::duration<Rep, Period>& rel_time);

Requires: If mutex_type is not a recursive mutex the calling thread does not own the mutex. The
supplied Mutex type shall meet the TimedLockable requirements (30.2.5.4).
Eﬀects: Constructs an object of type unique_lock and calls m.try_lock_for(rel_time).
Postconditions: pm == &m and owns == res, where res is the value returned by the call to m.try_-
lock_for(rel_time).

unique_lock(unique_lock&& u) noexcept;

Postconditions: pm == u_p.pm and owns == u_p.owns (where u_p is the state of u just prior to this
construction), u.pm == 0 and u.owns == false.

unique_lock& operator=(unique_lock&& u);
Eﬀects: If owns calls pm->unlock().
Postconditions: pm == u_p.pm and owns == u_p.owns (where u_p is the state of u just prior to this
construction), u.pm == 0 and u.owns == false.
[ Note: With a recursive mutex it is possible for both *this and u to own the same mutex before the
assignment. In this case, *this will own the mutex after the assignment and u will not. — end note ]
Throws: Nothing.

~unique_lock();

Eﬀects: If owns calls pm->unlock().

§ 30.4.2.2.1

1179

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

c(cid:13) ISO/IEC

30.4.2.2.2 unique_lock locking
void lock();

N4296

[thread.lock.unique.locking]

Eﬀects: pm->lock()
Postcondition: owns == true
Throws: Any exception thrown by pm->lock(). system_error if an exception is required (30.2.2).
system_error with an error condition of operation_not_permitted if pm is 0. system_error with
an error condition of resource_deadlock_would_occur if on entry owns is true.

bool try_lock();

Requires: The supplied Mutex shall meet the Lockable requirements (30.2.5.3).
Eﬀects: pm->try_lock()
Returns: The value returned by the call to try_lock().
Postcondition: owns == res, where res is the value returned by the call to try_lock().
Throws: Any exception thrown by pm->try_lock(). system_error if an exception is required (30.2.2).
system_error with an error condition of operation_not_permitted if pm is 0. system_error with
an error condition of resource_deadlock_would_occur if on entry owns is true.

template <class Clock, class Duration>

bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);

Requires: The supplied Mutex type shall meet the TimedLockable requirements (30.2.5.4).
Eﬀects: pm->try_lock_until(abs_time)
Returns: The value returned by the call to try_lock_until(abs_time).
Postcondition: owns == res, where res is the value returned by the call to try_lock_until(abs_-
time).
Throws: Any exception thrown by pm->try_lock_until(). system_error if an exception is re-
quired (30.2.2). system_error with an error condition of operation_not_permitted if pm is 0.
system_error with an error condition of resource_deadlock_would_occur if on entry owns is true.

template <class Rep, class Period>

bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);

Requires: The supplied Mutex type shall meet the TimedLockable requirements (30.2.5.4).
Eﬀects: pm->try_lock_for(rel_time).
Returns: The value returned by the call to try_lock_until(rel_time).
Postcondition: owns == res, where res is the value returned by the call to try_lock_for(rel_time).
Throws: Any exception thrown by pm->try_lock_for(). system_error if an exception is required
(30.2.2). system_error with an error condition of operation_not_permitted if pm is 0. system_-
error with an error condition of resource_deadlock_would_occur if on entry owns is true.

void unlock();

Eﬀects: pm->unlock()
Postcondition: owns == false
Throws: system_error when an exception is required (30.2.2).
Error conditions:
—

operation_not_permitted — if on entry owns is false.

§ 30.4.2.2.2

1180

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

(22.1)

1

2

3

4

1

2

3

c(cid:13) ISO/IEC

30.4.2.2.3 unique_lock modiﬁers
void swap(unique_lock& u) noexcept;

Eﬀects: Swaps the data members of *this and u.

mutex_type* release() noexcept;

Returns: The previous value of pm.
Postconditions: pm == 0 and owns == false.

template <class Mutex>

void swap(unique_lock<Mutex>& x, unique_lock<Mutex>& y) noexcept;

Eﬀects: x.swap(y)

30.4.2.2.4 unique_lock observers
bool owns_lock() const noexcept;

Returns: owns

explicit operator bool() const noexcept;

Returns: owns

mutex_type *mutex() const noexcept;

Returns: pm

30.4.2.3 Class template shared_lock

namespace std {

template <class Mutex>
class shared_lock {
public:

typedef Mutex mutex_type;

N4296

[thread.lock.unique.mod]

[thread.lock.unique.obs]

[thread.lock.shared]

// Shared locking
shared_lock() noexcept;
explicit shared_lock(mutex_type& m); // blocking
shared_lock(mutex_type& m, defer_lock_t) noexcept;
shared_lock(mutex_type& m, try_to_lock_t);
shared_lock(mutex_type& m, adopt_lock_t);
template <class Clock, class Duration>

shared_lock(mutex_type& m,

template <class Rep, class Period>

shared_lock(mutex_type& m,

~shared_lock();

const chrono::time_point<Clock, Duration>& abs_time);

const chrono::duration<Rep, Period>& rel_time);

shared_lock(shared_lock const&) = delete;
shared_lock& operator=(shared_lock const&) = delete;

shared_lock(shared_lock&& u) noexcept;
shared_lock& operator=(shared_lock&& u) noexcept;

§ 30.4.2.3

1181

c(cid:13) ISO/IEC

N4296

void lock(); // blocking
bool try_lock();
template <class Rep, class Period>

bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);

template <class Clock, class Duration>

bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);

void unlock();

// Setters
void swap(shared_lock& u) noexcept;
mutex_type* release() noexcept;

// Getters
bool owns_lock() const noexcept;
explicit operator bool () const noexcept;
mutex_type* mutex() const noexcept;

private:

};

mutex_type* pm; // exposition only
// exposition only
bool owns;

template <class Mutex>

void swap(shared_lock<Mutex>& x, shared_lock<Mutex>& y) noexcept;

} // std

1 An object of type shared_lock controls the shared ownership of a lockable object within a scope. Shared
ownership of the lockable object may be acquired at construction or after construction, and may be trans-
ferred, after acquisition, to another shared_lock object. Objects of type shared_lock are not copyable but
are movable. The behavior of a program is undeﬁned if the contained pointer pm is not null and the lockable
object pointed to by pm does not exist for the entire remaining lifetime (3.8) of the shared_lock object.
The supplied Mutex type shall meet the shared mutex requirements (30.4.1.4).
[ Note: shared_lock<Mutex> meets the TimedLockable requirements (30.2.5.4). — end note ]
30.4.2.3.1 shared_lock constructors, destructor, and assignment
shared_lock() noexcept;

[thread.lock.shared.cons]

2

1

2

3

4

5

6

7

Eﬀects: Constructs an object of type shared_lock.
Postconditions: pm == nullptr and owns == false.

explicit shared_lock(mutex_type& m);

Requires: The calling thread does not own the mutex for any ownership mode.
Eﬀects: Constructs an object of type shared_lock and calls m.lock_shared().
Postconditions: pm == &m and owns == true.

shared_lock(mutex_type& m, defer_lock_t) noexcept;

Eﬀects: Constructs an object of type shared_lock.
Postconditions: pm == &m and owns == false.

shared_lock(mutex_type& m, try_to_lock_t);

§ 30.4.2.3.1

1182

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

1

2

3

c(cid:13) ISO/IEC

N4296

Requires: The calling thread does not own the mutex for any ownership mode.
Eﬀects: Constructs an object of type shared_lock and calls m.try_lock_shared().
Postconditions: pm == &m and owns == res where res is the value returned by the call to m.try_-
lock_shared().

shared_lock(mutex_type& m, adopt_lock_t);

Requires: The calling thread has shared ownership of the mutex.
Eﬀects: Constructs an object of type shared_lock.
Postconditions: pm == &m and owns == true.

template <class Clock, class Duration>

shared_lock(mutex_type& m,

const chrono::time_point<Clock, Duration>& abs_time);

Requires: The calling thread does not own the mutex for any ownership mode.
Eﬀects: Constructs an object of type shared_lock and calls m.try_lock_shared_until(abs_time).
Postconditions: pm == &m and owns == res where res is the value returned by the call to m.try_-
lock_shared_until(abs_time).

template <class Rep, class Period>

shared_lock(mutex_type& m,

const chrono::duration<Rep, Period>& rel_time);

Requires: The calling thread does not own the mutex for any ownership mode.
Eﬀects: Constructs an object of type shared_lock and calls m.try_lock_shared_for(rel_time).
Postconditions: pm == &m and owns == res where res is the value returned by the call to m.try_-
lock_shared_for(rel_time).

~shared_lock();

Eﬀects: If owns calls pm->unlock_shared().

shared_lock(shared_lock&& sl) noexcept;

Postconditions: pm == &sl_p.pm and owns == sl_p.owns (where sl_p is the state of sl just prior to
this construction), sl.pm == nullptr and sl.owns == false.

shared_lock& operator=(shared_lock&& sl) noexcept;

Eﬀects: If owns calls pm->unlock_shared().
Postconditions: pm == &sl_p.pm and owns == sl_p.owns (where sl_p is the state of sl just prior to
this assignment), sl.pm == nullptr and sl.owns == false.

30.4.2.3.2 shared_lock locking
void lock();

[thread.lock.shared.locking]

Eﬀects: pm->lock_shared().
Postconditions: owns == true.
Throws: Any exception thrown by pm->lock_shared(). system_error if an exception is required (30.2.2).
system_error with an error condition of operation_not_permitted if pm is nullptr. system_error
with an error condition of resource_deadlock_would_occur if on entry owns is true.

§ 30.4.2.3.2

1183

c(cid:13) ISO/IEC

bool try_lock();

N4296

Eﬀects: pm->try_lock_shared().
Returns: The value returned by the call to pm->try_lock_shared().
Postconditions: owns == res, where res is the value returned by the call to pm->try_lock_shared().
Throws: Any exception thrown by pm->try_lock_shared(). system_error if an exception is re-
quired (30.2.2). system_error with an error condition of operation_not_permitted if pm is nullptr.
system_error with an error condition of resource_deadlock_would_occur if on entry owns is true.

template <class Clock, class Duration>

bool
try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);

Eﬀects: pm->try_lock_shared_until(abs_time).
Returns: The value returned by the call to pm->try_lock_shared_until(abs_time).
Postconditions: owns == res, where res is the value returned by the call to pm->try_lock_shared_-
until(abs_time).
Throws: Any exception thrown by pm->try_lock_shared_until(abs_time). system_error if an
exception is required (30.2.2). system_error with an error condition of operation_not_permitted
if pm is nullptr. system_error with an error condition of resource_deadlock_would_occur if on
entry owns is true.

template <class Rep, class Period>

bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);

Eﬀects: pm->try_lock_shared_for(rel_time).
Returns: The value returned by the call to pm->try_lock_shared_for(rel_time).
Postconditions: owns == res, where res is the value returned by the call to pm->try_lock_shared_-
for(rel_time).
Throws: Any exception thrown by pm->try_lock_shared_for(rel_time). system_error if an ex-
ception is required (30.2.2). system_error with an error condition of operation_not_permitted
if pm is nullptr. system_error with an error condition of resource_deadlock_would_occur if on
entry owns is true.

void unlock();

Eﬀects: pm->unlock_shared().
Postconditions: owns == false.
Throws: system_error when an exception is required (30.2.2).
Error conditions:
—

operation_not_permitted — if on entry owns is false.

30.4.2.3.3 shared_lock modiﬁers
void swap(shared_lock& sl) noexcept;

Eﬀects: Swaps the data members of *this and sl.

mutex_type* release() noexcept;

Returns: The previous value of pm.
Postconditions: pm == nullptr and owns == false.

§ 30.4.2.3.3

[thread.lock.shared.mod]

1184

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

(19.1)

1

2

3

c(cid:13) ISO/IEC

N4296

template <class Mutex>

void swap(shared_lock<Mutex>& x, shared_lock<Mutex>& y) noexcept;

Eﬀects: x.swap(y).

30.4.2.3.4 shared_lock observers
bool owns_lock() const noexcept;

Returns: owns.

explicit operator bool () const noexcept;

Returns: owns.

mutex_type* mutex() const noexcept;

Returns: pm.

[thread.lock.shared.obs]

30.4.3 Generic locking algorithms
template <class L1, class L2, class... L3> int try_lock(L1&, L2&, L3&...);

[thread.lock.algorithm]

Requires: Each template parameter type shall meet the Lockable requirements. [ Note: The unique_-
lock class template meets these requirements when suitably instantiated. — end note ]
Eﬀects: Calls try_lock() for each argument in order beginning with the ﬁrst until all arguments have
been processed or a call to try_lock() fails, either by returning false or by throwing an exception.
If a call to try_lock() fails, unlock() shall be called for all prior arguments and there shall be no
further calls to try_lock().
Returns: -1 if all calls to try_lock() returned true, otherwise a 0-based index value that indicates
the argument for which try_lock() returned false.

template <class L1, class L2, class... L3> void lock(L1&, L2&, L3&...);

Requires: Each template parameter type shall meet the Lockable requirements, [ Note: The unique_-
lock class template meets these requirements when suitably instantiated. — end note ]
Eﬀects: All arguments are locked via a sequence of calls to lock(), try_lock(), or unlock() on each
argument. The sequence of calls shall not result in deadlock, but is otherwise unspeciﬁed. [ Note: A
deadlock avoidance algorithm such as try-and-back-oﬀ must be used, but the speciﬁc algorithm is not
speciﬁed to avoid over-constraining implementations. — end note ] If a call to lock() or try_lock()
throws an exception, unlock() shall be called for any argument that had been locked by a call to
lock() or try_lock().

30.4.4 Call once
[thread.once]
The class once_flag is an opaque data structure that call_once uses to initialize data without causing a
data race or deadlock.
30.4.4.1 Struct once_flag
constexpr once_flag() noexcept;

[thread.once.onceﬂag]

Eﬀects: Constructs an object of type once_flag.
Synchronization: The construction of a once_flag object is not synchronized.
Postcondition: The object’s internal state is set to indicate to an invocation of call_once with the
object as its initial argument that no function has been called.

§ 30.4.4.1

1185

4

1

2

3

1

2

3

4

5

1

2

3

c(cid:13) ISO/IEC

30.4.4.2 Function call_once
template<class Callable, class ...Args>

void call_once(once_flag& flag, Callable&& func, Args&&... args);

N4296

[thread.once.callonce]

1

2

3

4

5

Requires: Callable and each Ti in Args shall satisfy the MoveConstructible requirements. INVOKE (
DECAY_COPY ( std::forward<Callable>(func)), DECAY_COPY (std::forward<Args>(args))...)
(20.9.2) shall be a valid expression.
Eﬀects: An execution of call_once that does not call its func is a passive execution. An execution of
call_once that calls its func is an active execution. An active execution shall call INVOKE (DECAY_-
COPY ( std::forward<Callable>(func)), DECAY_COPY (std::forward<Args>(args))...). If such
a call to func throws an exception the execution is exceptional, otherwise it is returning. An exceptional
execution shall propagate the exception to the caller of call_once. Among all executions of call_-
once for any given once_flag: at most one shall be a returning execution; if there is a returning
execution, it shall be the last active execution; and there are passive executions only if there is a
returning execution.
[ Note: passive executions allow other threads to reliably observe the results
produced by the earlier returning execution. — end note ]
Synchronization: For any given once_flag: all active executions occur in a total order; completion
of an active execution synchronizes with (1.10) the start of the next one in this total order; and the
returning execution synchronizes with the return from all passive executions.
Throws: system_error when an exception is required (30.2.2), or any exception thrown by func.
[ Example:

// global ﬂag, regular function
void init();
std::once_flag flag;

void f() {

std::call_once(flag, init);

}

}

// function static ﬂag, function object
struct initializer {
void operator()();

};

void g() {

static std::once_flag flag2;
std::call_once(flag2, initializer());

// object ﬂag, member function
class information {

std::once_flag verified;
void verifier();

public:

};

void verify() { std::call_once(verified, &information::verifier, *this); }

— end example ]

30.5 Condition variables

[thread.condition]
1 Condition variables provide synchronization primitives used to block a thread until notiﬁed by some other
thread that some condition is met or until a system time is reached. Class condition_variable provides

§ 30.5

1186

c(cid:13) ISO/IEC

N4296

a condition variable that can only wait on an object of type unique_lock<mutex>, allowing maximum
eﬃciency on some platforms. Class condition_variable_any provides a general condition variable that
can wait on objects of user-supplied lock types.

2 Condition variables permit concurrent invocation of the wait, wait_for, wait_until, notify_one and

notify_all member functions.

3 The execution of notify_one and notify_all shall be atomic. The execution of wait, wait_for, and

wait_until shall be performed in three atomic parts:

1. the release of the mutex and entry into the waiting state;
2. the unblocking of the wait; and
3. the reacquisition of the lock.

4 The implementation shall behave as if all executions of notify_one, notify_all, and each part of the wait,
wait_for, and wait_until executions are executed in a single unspeciﬁed total order consistent with the
"happens before" order.

5 Condition variable construction and destruction need not be synchronized.

Header condition_variable synopsis

namespace std {

class condition_variable;
class condition_variable_any;

void notify_all_at_thread_exit(condition_variable& cond, unique_lock<mutex> lk);

enum class cv_status { no_timeout, timeout };

}

void notify_all_at_thread_exit(condition_variable& cond, unique_lock<mutex> lk);

6
(6.1)

(6.2)

7

8

9

10

Requires: lk is locked by the calling thread and either
—
—

no other thread is waiting on cond, or
lk.mutex() returns the same value for each of the lock arguments supplied by all concurrently
waiting (via wait, wait_for, or wait_until) threads.

Eﬀects: transfers ownership of the lock associated with lk into internal storage and schedules cond to
be notiﬁed when the current thread exits, after all objects of thread storage duration associated with
the current thread have been destroyed. This notiﬁcation shall be as if

lk.unlock();
cond.notify_all();

Synchronization: The implied lk.unlock() call is sequenced after the destruction of all objects with
thread storage duration associated with the current thread.
Note: The supplied lock will be held until the thread exits, and care must be taken to ensure that
this does not cause deadlock due to lock ordering issues. After calling notify_all_at_thread_exit
it is recommended that the thread should be exited as soon as possible, and that no blocking or
time-consuming tasks are run on that thread.
Note: It is the user’s responsibility to ensure that waiting threads do not erroneously assume that the
thread has ﬁnished if they experience spurious wakeups. This typically requires that the condition
being waited for is satisﬁed while holding the lock on lk, and that this lock is not released and
reacquired prior to calling notify_all_at_thread_exit.

§ 30.5

1187

c(cid:13) ISO/IEC

N4296

30.5.1 Class condition_variable

[thread.condition.condvar]

namespace std {

class condition_variable {
public:

condition_variable();
~condition_variable();

condition_variable(const condition_variable&) = delete;
condition_variable& operator=(const condition_variable&) = delete;

void notify_one() noexcept;
void notify_all() noexcept;
void wait(unique_lock<mutex>& lock);
template <class Predicate>

void wait(unique_lock<mutex>& lock, Predicate pred);

template <class Clock, class Duration>

cv_status wait_until(unique_lock<mutex>& lock,

template <class Clock, class Duration, class Predicate>

bool wait_until(unique_lock<mutex>& lock,

const chrono::time_point<Clock, Duration>& abs_time);

const chrono::time_point<Clock, Duration>& abs_time,
Predicate pred);

template <class Rep, class Period>

cv_status wait_for(unique_lock<mutex>& lock,

const chrono::duration<Rep, Period>& rel_time);

template <class Rep, class Period, class Predicate>

bool wait_for(unique_lock<mutex>& lock,

const chrono::duration<Rep, Period>& rel_time,
Predicate pred);

typedef implementation-defined native_handle_type; // See 30.2.3
// See 30.2.3
native_handle_type native_handle();

};

}

1 The class condition_variable shall be a standard-layout class (Clause 9).

condition_variable();

2

3

4

(4.1)

5

Eﬀects: Constructs an object of type condition_variable.
Throws: system_error when an exception is required (30.2.2).
Error conditions:
—

resource_unavailable_try_again — if some non-memory resource limitation prevents initial-
ization.

~condition_variable();

[ Note: That is, all threads shall have been
Requires: There shall be no thread blocked on *this.
notiﬁed; they may subsequently block on the lock speciﬁed in the wait. This relaxes the usual rules,
which would have required all wait calls to happen before destruction. Only the notiﬁcation to unblock
the wait must happen before destruction. The user must take care to ensure that no threads wait on
*this once the destructor has been started, especially when the waiting threads are calling the wait

§ 30.5.1

1188

c(cid:13) ISO/IEC

N4296

functions in a loop or using the overloads of wait, wait_for, or wait_until that take a predicate.
— end note ]
Eﬀects: Destroys the object.

void notify_one() noexcept;

Eﬀects: If any threads are blocked waiting for *this, unblocks one of those threads.

void notify_all() noexcept;

Eﬀects: Unblocks all threads that are blocked waiting for *this.

void wait(unique_lock<mutex>& lock);

Requires: lock.owns_lock() is true and lock.mutex() is locked by the calling thread, and either
—
—

no other thread is waiting on this condition_variable object or
lock.mutex() returns the same value for each of the lock arguments supplied by all concurrently
waiting (via wait, wait_for, or wait_until) threads.

Eﬀects:
—
—
—

Atomically calls lock.unlock() and blocks on *this.
When unblocked, calls lock.lock() (possibly blocking on the lock), then returns.
The function will unblock when signaled by a call to notify_one() or a call to notify_all(),
or spuriously.

Remarks: If the function fails to meet the postcondition, std::terminate() shall be called (15.5.1).
[ Note: This can happen if the re-locking of the mutex throws an exception. — end note ]
Postcondition: lock.owns_lock() is true and lock.mutex() is locked by the calling thread.
Throws: Nothing.

template <class Predicate>

void wait(unique_lock<mutex>& lock, Predicate pred);

Requires: lock.owns_lock() is true and lock.mutex() is locked by the calling thread, and either
—
—

no other thread is waiting on this condition_variable object or
lock.mutex() returns the same value for each of the lock arguments supplied by all concurrently
waiting (via wait, wait_for, or wait_until) threads.

Eﬀects: Equivalent to:

while (!pred())

wait(lock);

Remarks: If the function fails to meet the postcondition, std::terminate() shall be called (15.5.1).
[ Note: This can happen if the re-locking of the mutex throws an exception. — end note ]
Postcondition: lock.owns_lock() is true and lock.mutex() is locked by the calling thread.
Throws: Timeout-related exceptions (30.2.4) or any exception thrown by pred.

template <class Clock, class Duration>

cv_status wait_until(unique_lock<mutex>& lock,

const chrono::time_point<Clock, Duration>& abs_time);

Requires: lock.owns_lock() is true and lock.mutex() is locked by the calling thread, and either

§ 30.5.1

1189

6

7

8

9

(9.1)

(9.2)

10

(10.1)

(10.2)

(10.3)

11

12

13

14
(14.1)

(14.2)

15

16

17

18

19

(19.1)

(19.2)

20

(20.1)

(20.2)

(20.3)

(20.4)

21

22

23

24

25

(25.1)

(25.2)

26

27

28

29

30

31
(31.1)

(31.2)

32

c(cid:13) ISO/IEC

N4296

—
—

no other thread is waiting on this condition_variable object or
lock.mutex() returns the same value for each of the lock arguments supplied by all concurrently
waiting (via wait, wait_for, or wait_until) threads.

Eﬀects:
—
—
—

Atomically calls lock.unlock() and blocks on *this.
When unblocked, calls lock.lock() (possibly blocking on the lock), then returns.
The function will unblock when signaled by a call to notify_one(), a call to notify_all(),
expiration of the absolute timeout (30.2.4) speciﬁed by abs_time, or spuriously.
If the function exits via an exception, lock.lock() shall be called prior to exiting the function.
—
Remarks: If the function fails to meet the postcondition, std::terminate() shall be called (15.5.1).
[ Note: This can happen if the re-locking of the mutex throws an exception. — end note ]
Postcondition: lock.owns_lock() is true and lock.mutex() is locked by the calling thread.
Returns: cv_status::timeout if the absolute timeout (30.2.4) speciﬁed by abs_time expired, other-
wise cv_status::no_timeout.
Throws: Timeout-related exceptions (30.2.4).

template <class Rep, class Period>

cv_status wait_for(unique_lock<mutex>& lock,

const chrono::duration<Rep, Period>& rel_time);

Requires: lock.owns_lock() is true and lock.mutex() is locked by the calling thread, and either
—
—

no other thread is waiting on this condition_variable object or
lock.mutex() returns the same value for each of the lock arguments supplied by all concurrently
waiting (via wait, wait_for, or wait_until) threads.

Eﬀects: Equivalent to:

return wait_until(lock, chrono::steady_clock::now() + rel_time);

Returns: cv_status::timeout if the relative timeout (30.2.4) speciﬁed by rel_time expired, otherwise
cv_status::no_timeout.
Remarks: If the function fails to meet the postcondition, std::terminate() shall be called (15.5.1).
[ Note: This can happen if the re-locking of the mutex throws an exception. — end note ]
Postcondition: lock.owns_lock() is true and lock.mutex() is locked by the calling thread.
Throws: Timeout-related exceptions (30.2.4).

template <class Clock, class Duration, class Predicate>

bool wait_until(unique_lock<mutex>& lock,

const chrono::time_point<Clock, Duration>& abs_time,
Predicate pred);

Requires: lock.owns_lock() is true and lock.mutex() is locked by the calling thread, and either
—
—

no other thread is waiting on this condition_variable object or
lock.mutex() returns the same value for each of the lock arguments supplied by all concurrently
waiting (via wait, wait_for, or wait_until) threads.

Eﬀects: Equivalent to:

§ 30.5.1

1190

c(cid:13) ISO/IEC

N4296

while (!pred())

if (wait_until(lock, abs_time) == cv_status::timeout)

return pred();

return true;

33

34

35

36

37

(37.1)

(37.2)

38

39

40

41

42

43

Remarks: If the function fails to meet the postcondition, std::terminate() shall be called (15.5.1).
[ Note: This can happen if the re-locking of the mutex throws an exception. — end note ]
Postcondition: lock.owns_lock() is true and lock.mutex() is locked by the calling thread.
[ Note: The returned value indicates whether the predicate evaluated to true regardless of whether
the timeout was triggered. — end note ]
Throws: Timeout-related exceptions (30.2.4) or any exception thrown by pred.

template <class Rep, class Period, class Predicate>

bool wait_for(unique_lock<mutex>& lock,

const chrono::duration<Rep, Period>& rel_time,
Predicate pred);

Requires: lock.owns_lock() is true and lock.mutex() is locked by the calling thread, and either
—
—

no other thread is waiting on this condition_variable object or
lock.mutex() returns the same value for each of the lock arguments supplied by all concurrently
waiting (via wait, wait_for, or wait_until) threads.

Eﬀects: Equivalent to:

return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));

[ Note: There is no blocking if pred() is initially true, even if the timeout has already expired. — end
note ]
Remarks: If the function fails to meet the postcondition, std::terminate() shall be called (15.5.1).
[ Note: This can happen if the re-locking of the mutex throws an exception. — end note ]
Postcondition: lock.owns_lock() is true and lock.mutex() is locked by the calling thread.
[ Note: The returned value indicates whether the predicate evaluates to true regardless of whether the
timeout was triggered. — end note ]
Throws: Timeout-related exceptions (30.2.4) or any exception thrown by pred.

30.5.2 Class condition_variable_any

[thread.condition.condvarany]
1 A Lock type shall meet the BasicLockable requirements (30.2.5.2). [ Note: All of the standard mutex types
meet this requirement. If a Lock type other than one of the standard mutex types or a unique_lock wrapper
for a standard mutex type is used with condition_variable_any, the user must ensure that any necessary
synchronization is in place with respect to the predicate associated with the condition_variable_any
instance. — end note ]

namespace std {

class condition_variable_any {
public:

condition_variable_any();
~condition_variable_any();

condition_variable_any(const condition_variable_any&) = delete;
condition_variable_any& operator=(const condition_variable_any&) = delete;

§ 30.5.2

1191

c(cid:13) ISO/IEC

N4296

void notify_one() noexcept;
void notify_all() noexcept;
template <class Lock>

void wait(Lock& lock);

template <class Lock, class Predicate>

void wait(Lock& lock, Predicate pred);

template <class Lock, class Clock, class Duration>

cv_status wait_until(Lock& lock, const chrono::time_point<Clock, Duration>& abs_time);

template <class Lock, class Clock, class Duration, class Predicate>

bool wait_until(Lock& lock, const chrono::time_point<Clock, Duration>& abs_time,

Predicate pred);

template <class Lock, class Rep, class Period>

cv_status wait_for(Lock& lock, const chrono::duration<Rep, Period>& rel_time);

template <class Lock, class Rep, class Period, class Predicate>

bool wait_for(Lock& lock, const chrono::duration<Rep, Period>& rel_time,

Predicate pred);

};

}

condition_variable_any();

2

3

4

(4.1)

(4.2)

5

6

7

8

9

10

Eﬀects: Constructs an object of type condition_variable_any.
Throws: bad_alloc or system_error when an exception is required (30.2.2).
Error conditions:
—

resource_unavailable_try_again — if some non-memory resource limitation prevents initial-
ization.
operation_not_permitted — if the thread does not have the privilege to perform the operation.

—

~condition_variable_any();

Requires: There shall be no thread blocked on *this.
[ Note: That is, all threads shall have been
notiﬁed; they may subsequently block on the lock speciﬁed in the wait. This relaxes the usual rules,
which would have required all wait calls to happen before destruction. Only the notiﬁcation to unblock
the wait must happen before destruction. The user must take care to ensure that no threads wait on
*this once the destructor has been started, especially when the waiting threads are calling the wait
functions in a loop or using the overloads of wait, wait_for, or wait_until that take a predicate.
— end note ]
Eﬀects: Destroys the object.

void notify_one() noexcept;

Eﬀects: If any threads are blocked waiting for *this, unblocks one of those threads.

void notify_all() noexcept;

Eﬀects: Unblocks all threads that are blocked waiting for *this.

template <class Lock>

void wait(Lock& lock);

Note: if any of the wait functions exits via an exception, it is unspeciﬁed whether the Lock is held.
One can use a Lock type that allows to query that, such as the unique_lock wrapper.
Eﬀects:

§ 30.5.2

1192

(10.1)

(10.2)

(10.3)

11

12

13

14

15
(15.1)

(15.2)

(15.3)

(15.4)
16

17

18

19

20

21

22

23

24

c(cid:13) ISO/IEC

N4296

—
—
—

Atomically calls lock.unlock() and blocks on *this.
When unblocked, calls lock.lock() (possibly blocking on the lock) and returns.
The function will unblock when signaled by a call to notify_one(), a call to notify_all(), or
spuriously.

Remarks: If the function fails to meet the postcondition, std::terminate() shall be called (15.5.1).
[ Note: This can happen if the re-locking of the mutex throws an exception. — end note ]
Postcondition: lock is locked by the calling thread.
Throws: Nothing.

template <class Lock, class Predicate>

void wait(Lock& lock, Predicate pred);

Eﬀects: Equivalent to:

while (!pred())

wait(lock);

template <class Lock, class Clock, class Duration>

cv_status wait_until(Lock& lock, const chrono::time_point<Clock, Duration>& abs_time);

Eﬀects:
—
—
—

Atomically calls lock.unlock() and blocks on *this.
When unblocked, calls lock.lock() (possibly blocking on the lock) and returns.
The function will unblock when signaled by a call to notify_one(), a call to notify_all(),
expiration of the absolute timeout (30.2.4) speciﬁed by abs_time, or spuriously.
If the function exits via an exception, lock.lock() shall be called prior to exiting the function.
—
Remarks: If the function fails to meet the postcondition, std::terminate() shall be called (15.5.1).
[ Note: This can happen if the re-locking of the mutex throws an exception. — end note ]
Postcondition: lock is locked by the calling thread.
Returns: cv_status::timeout if the absolute timeout (30.2.4) speciﬁed by abs_time expired, other-
wise cv_status::no_timeout.
Throws: Timeout-related exceptions (30.2.4).

template <class Lock, class Rep, class Period>

cv_status wait_for(Lock& lock, const chrono::duration<Rep, Period>& rel_time);

Eﬀects: Equivalent to:

return wait_until(lock, chrono::steady_clock::now() + rel_time);

Returns: cv_status::timeout if the relative timeout (30.2.4) speciﬁed by rel_time expired, otherwise
cv_status::no_timeout.
Remarks: If the function fails to meet the postcondition, std::terminate() shall be called (15.5.1).
[ Note: This can happen if the re-locking of the mutex throws an exception. — end note ]
Postcondition: lock is locked by the calling thread.
Throws: Timeout-related exceptions (30.2.4).

template <class Lock, class Clock, class Duration, class Predicate>

bool wait_until(Lock& lock, const chrono::time_point<Clock, Duration>& abs_time, Predicate pred);

§ 30.5.2

1193

c(cid:13) ISO/IEC

Eﬀects: Equivalent to:

N4296

if (wait_until(lock, abs_time) == cv_status::timeout)

while (!pred())

return pred();

return true;

[ Note: There is no blocking if pred() is initially true, or if the timeout has already expired. — end
note ]
[ Note: The returned value indicates whether the predicate evaluates to true regardless of whether the
timeout was triggered. — end note ]

template <class Lock, class Rep, class Period, class Predicate>

bool wait_for(Lock& lock, const chrono::duration<Rep, Period>& rel_time, Predicate pred);

Eﬀects: Equivalent to:

return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));

25

26

27

28

30.6 Futures
30.6.1 Overview

[futures]
[futures.overview]
1 30.6 describes components that a C++ program can use to retrieve in one thread the result (value or
[ Note: These components
exception) from a function that has run in the same thread or another thread.
are not restricted to multi-threaded programs but can be useful in single-threaded programs as well. — end
note ]
Header <future> synopsis

namespace std {

enum class future_errc {

broken_promise = implementation-defined ,
future_already_retrieved = implementation-defined ,
promise_already_satisfied = implementation-defined ,
no_state = implementation-defined

};

};

};

enum class launch : unspecified {

async = unspecified ,
deferred = unspecified ,
implementation-defined

enum class future_status {

ready,
timeout,
deferred

template <> struct is_error_code_enum<future_errc> : public true_type { };
error_code make_error_code(future_errc e) noexcept;
error_condition make_error_condition(future_errc e) noexcept;

const error_category& future_category() noexcept;

class future_error;

§ 30.6.1

1194

c(cid:13) ISO/IEC

N4296

template <class R> class promise;
template <class R> class promise<R&>;
template <> class promise<void>;

template <class R>

void swap(promise<R>& x, promise<R>& y) noexcept;

template <class R, class Alloc>

struct uses_allocator<promise<R>, Alloc>;

template <class R> class future;
template <class R> class future<R&>;
template <> class future<void>;

template <class R> class shared_future;
template <class R> class shared_future<R&>;
template <> class shared_future<void>;

template <class> class packaged_task;
template <class R, class... ArgTypes>
class packaged_task<R(ArgTypes...)>;

// undeﬁned

template <class R, class... ArgTypes>

void swap(packaged_task<R(ArgTypes...)>&, packaged_task<R(ArgTypes...)>&) noexcept;

template <class R, class Alloc>

struct uses_allocator<packaged_task<R>, Alloc>;

template <class F, class... Args>

future<result_of_t<decay_t<F>(decay_t<Args>...)>>
async(F&& f, Args&&... args);

template <class F, class... Args>

future<result_of_t<decay_t<F>(decay_t<Args>...)>>
async(launch policy, F&& f, Args&&... args);

}

2 The enum type launch is a bitmask type (17.5.2.1.3) with launch::async and launch::deferred denoting
individual bits. [ Note: Implementations can provide bitmasks to specify restrictions on task interaction by
functions launched by async() applicable to a corresponding subset of available launch policies. Implemen-
tations can extend the behavior of the ﬁrst overload of async() by adding their extensions to the launch
policy under the “as if” rule. — end note ]

3 The enum values of future_errc are distinct and not zero.

30.6.2 Error handling
const error_category& future_category() noexcept;

[futures.errors]

1

2

Returns: A reference to an object of a type derived from class error_category.
The object’s default_error_condition and equivalent virtual functions shall behave as speciﬁed for
the class error_category. The object’s name virtual function shall return a pointer to the string
"future".

error_code make_error_code(future_errc e) noexcept;

§ 30.6.2

1195

c(cid:13) ISO/IEC

N4296

Returns: error_code(static_cast<int>(e), future_category()).

error_condition make_error_condition(future_errc e) noexcept;

Returns: error_condition(static_cast<int>(e), future_category()).

30.6.3 Class future_error

[futures.future_error]

namespace std {

class future_error : public logic_error {
public:

future_error(error_code ec); // exposition only

const error_code& code() const noexcept;
const char*
what() const noexcept;

};

}

const error_code& code() const noexcept;

Returns: The value of ec that was passed to the object’s constructor.

const char* what() const noexcept;

Returns: An ntbs incorporating code().message().

3

4

1

2

30.6.4 Shared state

[futures.state]
1 Many of the classes introduced in this sub-clause use some state to communicate results. This shared state
consists of some state information and some (possibly not yet evaluated) result, which can be a (possibly
void) value or an exception. [ Note: Futures, promises, and tasks deﬁned in this clause reference such shared
state. — end note ]
[ Note: The result can be any kind of object including a function to compute that result, as used by async
when policy is launch::deferred. — end note ]

2

3 An asynchronous return object is an object that reads results from a shared state. A waiting function of an
asynchronous return object is one that potentially blocks to wait for the shared state to be made ready. If a
waiting function can return before the state is made ready because of a timeout (30.2.5), then it is a timed
waiting function, otherwise it is a non-timed waiting function.

4 An asynchronous provider is an object that provides a result to a shared state. The result of a shared state
is set by respective functions on the asynchronous provider. [ Note: Such as promises or tasks. — end note ]
The means of setting the result of a shared state is speciﬁed in the description of those classes and functions
that create such a state object.

(5.1)

(5.2)

(5.3)

—

5 When an asynchronous return object or an asynchronous provider is said to release its shared state, it means:
if the return object or provider holds the last reference to its shared state, the shared state is destroyed;
and
the return object or provider gives up its reference to its shared state; and
these actions will not block for the shared state to become ready, except that it may block if all of the
following are true: the shared state was created by a call to std::async, the shared state is not yet
ready, and this was the last reference to the shared state.

—
—

6 When an asynchronous provider is said to make its shared state ready, it means:

(6.1)

—

ﬁrst, the provider marks its shared state as ready; and

§ 30.6.4

1196

c(cid:13) ISO/IEC

N4296

(6.2)

—

second, the provider unblocks any execution agents waiting for its shared state to become ready.

7 When an asynchronous provider is said to abandon its shared state, it means:

(7.1)
(7.1.1)

(7.1.2)

(7.2)

—

—

ﬁrst, if that state is not ready, the provider
—

stores an exception object of type future_error with an error condition of broken_promise
within its shared state; and then
makes its shared state ready;

—
second, the provider releases its shared state.

8 A shared state is ready only if it holds a value or an exception ready for retrieval. Waiting for a shared
state to become ready may invoke code to compute the result on the waiting thread if so speciﬁed in the
description of the class or function that creates the state object.

9 Calls to functions that successfully set the stored result of a shared state synchronize with (1.10) calls
to functions successfully detecting the ready state resulting from that setting. The storage of the result
(whether normal or exceptional) into the shared state synchronizes with (1.10) the successful return from a
call to a waiting function on the shared state.

10 Some functions (e.g., promise::set_value_at_thread_exit) delay making the shared state ready until the
calling thread exits. The destruction of each of that thread’s objects with thread storage duration (3.7.2) is
sequenced before making that shared state ready.

11 Access to the result of the same shared state may conﬂict (1.10).

[ Note: this explicitly speciﬁes that the
result of the shared state is visible in the objects that reference this state in the sense of data race avoid-
ance (17.6.5.9). For example, concurrent accesses through references returned by shared_future::get() (30.6.7)
must either use read-only operations or provide additional synchronization. — end note ]
30.6.5 Class template promise

[futures.promise]

namespace std {

template <class R>
class promise {
public:

promise();
template <class Allocator>

promise(allocator_arg_t, const Allocator& a);

promise(promise&& rhs) noexcept;
promise(const promise& rhs) = delete;
~promise();

// assignment
promise& operator=(promise&& rhs) noexcept;
promise& operator=(const promise& rhs) = delete;
void swap(promise& other) noexcept;

// retrieving the result
future<R> get_future();

// setting the result
void set_value(see below );
void set_exception(exception_ptr p);

// setting the result with deferred notiﬁcation
void set_value_at_thread_exit(const R& r);
void set_value_at_thread_exit(see below );

§ 30.6.5

1197

c(cid:13) ISO/IEC

N4296

void set_exception_at_thread_exit(exception_ptr p);

};
template <class R>

void swap(promise<R>& x, promise<R>& y) noexcept;

template <class R, class Alloc>

struct uses_allocator<promise<R>, Alloc>;

}

1 The implementation shall provide the template promise and two specializations, promise<R&> and promise<
void>. These diﬀer only in the argument type of the member function set_value, as set out in its description,
below.

2 The set_value, set_exception, set_value_at_thread_exit, and set_exception_at_thread_exit mem-
ber functions behave as though they acquire a single mutex associated with the promise object while updating
the promise object.

template <class R, class Alloc>

struct uses_allocator<promise<R>, Alloc>

: true_type { };
Requires: Alloc shall be an Allocator (17.6.3.5).

promise();
template <class Allocator>

promise(allocator_arg_t, const Allocator& a);

Eﬀects: constructs a promise object and a shared state. The second constructor uses the allocator a
to allocate memory for the shared state.

promise(promise&& rhs) noexcept;

Eﬀects: constructs a new promise object and transfers ownership of the shared state of rhs (if any)
to the newly-constructed object.
Postcondition: rhs has no shared state.

~promise();

Eﬀects: Abandons any shared state (30.6.4).

promise& operator=(promise&& rhs) noexcept;

Eﬀects: Abandons any shared state (30.6.4) and then as if promise(std::move(rhs)).swap(*this).
Returns: *this.

void swap(promise& other) noexcept;

Eﬀects: Exchanges the shared state of *this and other.
Postcondition: *this has the shared state (if any) that other had prior to the call to swap. other
has the shared state (if any) that *this had prior to the call to swap.

future<R> get_future();

Returns: A future<R> object with the same shared state as *this.
Throws: future_error if *this has no shared state or if get_future has already been called on a
promise with the same shared state as *this.
Error conditions:

§ 30.6.5

1198

3

4

5

6

7

8

9

10

11

12

13

14

c(cid:13) ISO/IEC

N4296

—

—

future_already_retrieved if get_future has already been called on a promise with the same
shared state as *this.
no_state if *this has no shared state.

void promise::set_value(const R& r);
void promise::set_value(R&& r);
void promise<R&>::set_value(R& r);
void promise<void>::set_value();

future_error if its shared state already has a stored value or exception, or
for the ﬁrst version, any exception thrown by the constructor selected to copy an object of R, or
for the second version, any exception thrown by the constructor selected to move an object of R.

Eﬀects: atomically stores the value r in the shared state and makes that state ready (30.6.4).
Throws:
—
—
—
Error conditions:
—
—

promise_already_satisfied if its shared state already has a stored value or exception.
no_state if *this has no shared state.

void set_exception(exception_ptr p);

Eﬀects: atomically stores the exception pointer p in the shared state and makes that state ready (30.6.4).
Throws: future_error if its shared state already has a stored value or exception.
Error conditions:
—
—

promise_already_satisfied if its shared state already has a stored value or exception.
no_state if *this has no shared state.

void promise::set_value_at_thread_exit(const R& r);
void promise::set_value_at_thread_exit(R&& r);
void promise<R&>::set_value_at_thread_exit(R& r);
void promise<void>::set_value_at_thread_exit();

Eﬀects: Stores the value r in the shared state without making that state ready immediately. Schedules
that state to be made ready when the current thread exits, after all objects of thread storage duration
associated with the current thread have been destroyed.
Throws:
—
—
—
Error conditions:
—
—

future_error if its shared state already has a stored value or exception, or
for the ﬁrst version, any exception thrown by the constructor selected to copy an object of R, or
for the second version, any exception thrown by the constructor selected to move an object of R.

promise_already_satisfied if its shared state already has a stored value or exception.
no_state if *this has no shared state.

void set_exception_at_thread_exit(exception_ptr p);

Eﬀects: Stores the exception pointer p in the shared state without making that state ready immediately.
Schedules that state to be made ready when the current thread exits, after all objects of thread storage
duration associated with the current thread have been destroyed.
Throws: future_error if an error condition occurs.
Error conditions:

§ 30.6.5

1199

(14.1)

(14.2)

15

16
(16.1)

(16.2)

(16.3)
17

(17.1)

(17.2)

18

19

20
(20.1)

(20.2)

21

22
(22.1)

(22.2)

(22.3)
23

(23.1)

(23.2)

24

25

26

c(cid:13) ISO/IEC

N4296

(26.1)

(26.2)

—
—

promise_already_satisfied if its shared state already has a stored value or exception.
no_state if *this has no shared state.

template <class R>

void swap(promise<R>& x, promise<R>& y);

27

Eﬀects: x.swap(y).

30.6.6 Class template future

[futures.unique_future]
1 The class template future deﬁnes a type for asynchronous return objects which do not share their shared
state with other asynchronous return objects. A default-constructed future object has no shared state. A
future object with shared state can be created by functions on asynchronous providers (30.6.4) or by the
move constructor and shares its shared state with the original asynchronous provider. The result (value or
exception) of a future object can be set by calling a respective function on an object that shares the same
shared state.
[ Note: Member functions of future do not synchronize with themselves or with member functions of
shared_future. — end note ]

2

3 The eﬀect of calling any member function other than the destructor, the move-assignment operator, or valid
on a future object for which valid() == false is undeﬁned. [ Note: Implementations are encouraged to
detect this case and throw an object of type future_error with an error condition of future_errc::no_-
state. — end note ]

namespace std {

template <class R>
class future {
public:

future() noexcept;
future(future &&) noexcept;
future(const future& rhs) = delete;
~future();
future& operator=(const future& rhs) = delete;
future& operator=(future&&) noexcept;
shared_future<R> share();

// retrieving the value
see below get();

// functions to check state
bool valid() const noexcept;

void wait() const;
template <class Rep, class Period>

future_status wait_for(const chrono::duration<Rep, Period>& rel_time) const;

template <class Clock, class Duration>

future_status wait_until(const chrono::time_point<Clock, Duration>& abs_time) const;

};

}

4 The implementation shall provide the template future and two specializations, future<R&> and future<
void>. These diﬀer only in the return type and return value of the member function get, as set out in its
description, below.

future() noexcept;

§ 30.6.6

1200

5

6

7

8

(8.1)

(8.2)

9

(9.1)

(9.2)

10

(10.1)

(10.2)

11

(11.1)

(11.2)

12

13

14

15

16

(16.1)

(16.2)

(16.3)

17

18

c(cid:13) ISO/IEC

N4296

Eﬀects: constructs an empty future object that does not refer to a shared state.
Postcondition: valid() == false.

future(future&& rhs) noexcept;

Eﬀects: move constructs a future object that refers to the shared state that was originally referred
to by rhs (if any).
Postconditions:
—
—

valid() returns the same value as rhs.valid() prior to the constructor invocation.
rhs.valid() == false.

~future();

Eﬀects:
—
—

releases any shared state (30.6.4);
destroys *this.

future& operator=(future&& rhs) noexcept;

releases any shared state (30.6.4).
move assigns the contents of rhs to *this.

Eﬀects:
—
—
Postconditions:
—
—

valid() returns the same value as rhs.valid() prior to the assignment.
rhs.valid() == false.

shared_future<R> share();

Returns: shared_future<R>(std::move(*this)).
Postcondition: valid() == false.

R future::get();
R& future<R&>::get();
void future<void>::get();

Note: as described above, the template and its two required specializations diﬀer only in the return
type and return value of the member function get.
Eﬀects: wait()s until the shared state is ready, then retrieves the value stored in the shared state.
Returns:
—
—
—
Throws: the stored exception, if an exception was stored in the shared state.
Postcondition: valid() == false.

future::get() returns the value v stored in the object’s shared state as std::move(v).
future<R&>::get() returns the reference stored as value in the object’s shared state.
future<void>::get() returns nothing.

bool valid() const noexcept;

§ 30.6.6

1201

c(cid:13) ISO/IEC

N4296

Returns: true only if *this refers to a shared state.

void wait() const;

Eﬀects: blocks until the shared state is ready.

template <class Rep, class Period>

future_status wait_for(const chrono::duration<Rep, Period>& rel_time) const;

Eﬀects: none if the shared state contains a deferred function (30.6.8), otherwise blocks until the shared
state is ready or until the relative timeout (30.2.4) speciﬁed by rel_time has expired.
Returns:
—
—
—

future_status::deferred if the shared state contains a deferred function.
future_status::ready if the shared state is ready.
future_status::timeout if the function is returning because the relative timeout (30.2.4) spec-
iﬁed by rel_time has expired.

Throws: timeout-related exceptions (30.2.4).

template <class Clock, class Duration>

future_status wait_until(const chrono::time_point<Clock, Duration>& abs_time) const;

Eﬀects: none if the shared state contains a deferred function (30.6.8), otherwise blocks until the shared
state is ready or until the absolute timeout (30.2.4) speciﬁed by abs_time has expired.
Returns:
—
—
—

future_status::deferred if the shared state contains a deferred function.
future_status::ready if the shared state is ready.
future_status::timeout if the function is returning because the absolute timeout (30.2.4) spec-
iﬁed by abs_time has expired.

Throws: timeout-related exceptions (30.2.4).

19

20

21

22
(22.1)

(22.2)

(22.3)

23

24

25
(25.1)

(25.2)

(25.3)

26

30.6.7 Class template shared_future

[futures.shared_future]
1 The class template shared_future deﬁnes a type for asynchronous return objects which may share their
shared state with other asynchronous return objects. A default-constructed shared_future object has no
shared state. A shared_future object with shared state can be created by conversion from a future object
and shares its shared state with the original asynchronous provider (30.6.4) of the shared state. The result
(value or exception) of a shared_future object can be set by calling a respective function on an object that
shares the same shared state.
[ Note: Member functions of shared_future do not synchronize with themselves, but they synchronize with
the shared shared state. — end note ]

2

3 The eﬀect of calling any member function other than the destructor, the move-assignment operator, or
valid() on a shared_future object for which valid() == false is undeﬁned.
[ Note: Implementations
are encouraged to detect this case and throw an object of type future_error with an error condition of
future_errc::no_state. — end note ]

namespace std {

template <class R>
class shared_future {
public:

shared_future() noexcept;
shared_future(const shared_future& rhs);
shared_future(future<R>&&) noexcept;

§ 30.6.7

1202

c(cid:13) ISO/IEC

N4296

shared_future(shared_future&& rhs) noexcept;
~shared_future();
shared_future& operator=(const shared_future& rhs);
shared_future& operator=(shared_future&& rhs) noexcept;

// retrieving the value
see below get() const;

// functions to check state
bool valid() const noexcept;

void wait() const;
template <class Rep, class Period>

future_status wait_for(const chrono::duration<Rep, Period>& rel_time) const;

template <class Clock, class Duration>

future_status wait_until(const chrono::time_point<Clock, Duration>& abs_time) const;

};

}

4 The implementation shall provide the template shared_future and two specializations, shared_future<R&>
and shared_future<void>. These diﬀer only in the return type and return value of the member function
get, as set out in its description, below.

shared_future() noexcept;

Eﬀects: constructs an empty shared_future object that does not refer to a shared state.
Postcondition: valid() == false.

shared_future(const shared_future& rhs);

Eﬀects: constructs a shared_future object that refers to the same shared state as rhs (if any).
Postcondition: valid() returns the same value as rhs.valid().

shared_future(future<R>&& rhs) noexcept;
shared_future(shared_future&& rhs) noexcept;

Eﬀects: move constructs a shared_future object that refers to the shared state that was originally
referred to by rhs (if any).
Postconditions:
—
—

valid() returns the same value as rhs.valid() returned prior to the constructor invocation.
rhs.valid() == false.

~shared_future();

Eﬀects:
—
—

releases any shared state (30.6.4);
destroys *this.

shared_future& operator=(shared_future&& rhs) noexcept;

Eﬀects:
—

releases any shared state (30.6.4);

5

6

7

8

9

10

(10.1)

(10.2)

11

(11.1)

(11.2)

12

(12.1)

§ 30.6.7

1203

c(cid:13) ISO/IEC

N4296

(12.2)

13

(13.1)

(13.2)

14

(14.1)

(14.2)

15

16

17

18

19

(19.1)

(19.2)

(19.3)

20

21

22

23

24
(24.1)

(24.2)

move assigns the contents of rhs to *this.

—
Postconditions:
—
—

valid() returns the same value as rhs.valid() returned prior to the assignment.
rhs.valid() == false.

shared_future& operator=(const shared_future& rhs);

Eﬀects:
—
—

releases any shared state (30.6.4);
assigns the contents of rhs to *this. [ Note: As a result, *this refers to the same shared state
as rhs (if any). — end note ]

Postconditions: valid() == rhs.valid().

const R& shared_future::get() const;
R& shared_future<R&>::get() const;
void shared_future<void>::get() const;

Note: as described above, the template and its two required specializations diﬀer only in the return
type and return value of the member function get.
Note: access to a value object stored in the shared state is unsynchronized, so programmers should
apply only those operations on R that do not introduce a data race (1.10).
Eﬀects: wait()s until the shared state is ready, then retrieves the value stored in the shared state.
Returns:
—

shared_future::get() returns a const reference to the value stored in the object’s shared state.
[ Note: Access through that reference after the shared state has been destroyed produces undeﬁned
behavior; this can be avoided by not storing the reference in any storage with a greater lifetime
than the shared_future object that returned the reference. — end note ]
shared_future<R&>::get() returns the reference stored as value in the object’s shared state.
shared_future<void>::get() returns nothing.

—
—
Throws: the stored exception, if an exception was stored in the shared state.

bool valid() const noexcept;

Returns: true only if *this refers to a shared state.

void wait() const;

Eﬀects: blocks until the shared state is ready.

template <class Rep, class Period>

future_status wait_for(const chrono::duration<Rep, Period>& rel_time) const;

Eﬀects: none if the shared state contains a deferred function (30.6.8), otherwise blocks until the shared
state is ready or until the relative timeout (30.2.4) speciﬁed by rel_time has expired.
Returns:
—
—

future_status::deferred if the shared state contains a deferred function.
future_status::ready if the shared state is ready.

§ 30.6.7

1204

c(cid:13) ISO/IEC

N4296

(24.3)

—

future_status::timeout if the function is returning because the relative timeout (30.2.4) spec-
iﬁed by rel_time has expired.

Throws: timeout-related exceptions (30.2.4).

template <class Clock, class Duration>

future_status wait_until(const chrono::time_point<Clock, Duration>& abs_time) const;

Eﬀects: none if the shared state contains a deferred function (30.6.8), otherwise blocks until the shared
state is ready or until the absolute timeout (30.2.4) speciﬁed by abs_time has expired.
Returns:
—
—
—

future_status::deferred if the shared state contains a deferred function.
future_status::ready if the shared state is ready.
future_status::timeout if the function is returning because the absolute timeout (30.2.4) spec-
iﬁed by abs_time has expired.

Throws: timeout-related exceptions (30.2.4).

30.6.8 Function template async

[futures.async]
1 The function template async provides a mechanism to launch a function potentially in a new thread and

provides the result of the function in a future object with which it shares a shared state.

template <class F, class... Args>

template <class F, class... Args>

future<result_of_t<decay_t<F>(decay_t<Args>...)>> async(F&& f, Args&&... args);

future<result_of_t<decay_t<F>(decay_t<Args>...)>> async(launch policy, F&& f, Args&&... args);

25

26

27
(27.1)

(27.2)

(27.3)

28

2

3

(3.1)

Requires: F and each Ti in Args shall satisfy the MoveConstructible requirements. INVOKE (DECAY_-
COPY (std::forward<F>(f)), DECAY_COPY (std::forward<Args>(args))...) (20.9.2, 30.3.1.2) shall
be a valid expression.
Eﬀects: The ﬁrst function behaves the same as a call to the second function with a policy argument of
launch::async | launch::deferred and the same arguments for F and Args. The second function
creates a shared state that is associated with the returned future object. The further behavior of
the second function depends on the policy argument as follows (if more than one of these conditions
applies, the implementation may choose any of the corresponding policies):
—

if policy & launch::async is non-zero — calls INVOKE (DECAY_COPY (std::forward<F>(f)),
DECAY_COPY (std::forward<Args>(args))...) (20.9.2, 30.3.1.2) as if in a new thread of exe-
cution represented by a thread object with the calls to DECAY_COPY () being evaluated in the
thread that called async. Any return value is stored as the result in the shared state. Any excep-
tion propagated from the execution of INVOKE (DECAY_COPY (std::forward<F>(f)), DECAY_-
COPY (std::forward<Args>(args))...) is stored as the exceptional result in the shared state.
The thread object is stored in the shared state and aﬀects the behavior of any asynchronous
return objects that reference that state.
if policy & launch::deferred is non-zero — Stores DECAY_COPY (std::forward<F>(f)) and
DECAY_COPY (std::forward<Args>(args))... in the shared state. These copies of f and args
constitute a deferred function. Invocation of the deferred function evaluates INVOKE (std::move(g),
std::move(xyz)) where g is the stored value of DECAY_COPY (std::forward<F>(f)) and xyz is
the stored copy of DECAY_COPY (std::forward<Args>(args)).... Any return value is stored
as the result in the shared state. Any exception propagated from the execution of the deferred
function is stored as the exceptional result in the shared state. The shared state is not made
ready until the function has completed. The ﬁrst call to a non-timed waiting function (30.6.4)
on an asynchronous return object referring to this shared state shall invoke the deferred func-
tion in the thread that called the waiting function. Once evaluation of INVOKE (std::move(g),

§ 30.6.8

1205

(3.2)

—

c(cid:13) ISO/IEC

N4296

(3.3)

—

[ Note: If this policy is
std::move(xyz)) begins, the function is no longer considered deferred.
speciﬁed together with other policies, such as when using a policy value of launch::async |
launch::deferred, implementations should defer invocation or the selection of the policy when
no more concurrency can be eﬀectively exploited. — end note ]
If no value is set in the launch policy, or a value is set that is neither speciﬁed in this International
Standard or by the implementation, the behaviour is undeﬁned.

Returns: An object of type future<result_of_t<decay_t<F>(decay_t<Args>...)>> that refers to
the shared state created by this call to async.
[ Note: If a future obtained from std::async is moved
outside the local scope, other code that uses the future must be aware that the future’s destructor may
block for the shared state to become ready. — end note ]
Synchronization: Regardless of the provided policy argument,
—

[ Note: This statement
the invocation of async synchronizes with (1.10) the invocation of f.
applies even when the corresponding future object is moved to another thread. — end note ];
and
the completion of the function f is sequenced before (1.10) the shared state is made ready. [ Note:
f might not be called at all, so its completion might never happen. — end note ]

—

—

If the implementation chooses the launch::async policy,
—

a call to a waiting function on an asynchronous return object that shares the shared state created
by this async call shall block until the associated thread has completed, as if joined, or else time
out (30.3.1.5);
the associated thread completion synchronizes with (1.10) the return from the ﬁrst function that
successfully detects the ready status of the shared state or with the return from the last function
that releases the shared state, whichever happens ﬁrst.

Throws: system_error if policy == launch::async and the implementation is unable to start a
new thread.
Error conditions:
—

resource_unavailable_try_again — if policy == launch::async and the system is unable
to start a new thread.

4

5

(5.1)

(5.2)

(5.3)

(5.4)

6

7

(7.1)

8

[ Example:

int work1(int value);
int work2(int value);
int work(int value) {

auto handle = std::async([=]{ return work2(value); });
int tmp = work1(value);
return tmp + handle.get();

// #1

}

[ Note: Line #1 might not result in concurrency because the async call uses the default policy, which may
use launch::deferred, in which case the lambda might not be invoked until the get() call; in that case,
work1 and work2 are called on the same thread and there is no concurrency. — end note ] — end example ]
30.6.9 Class template packaged_task
[futures.task]
1 The class template packaged_task deﬁnes a type for wrapping a function or callable object so that the

return value of the function or callable object is stored in a future when it is invoked.

2 When the packaged_task object is invoked, its stored task is invoked and the result (whether normal or
exceptional) stored in the shared state. Any futures that share the shared state will then be able to access
the stored result.

§ 30.6.9

1206

c(cid:13) ISO/IEC

N4296

namespace std {

template<class> class packaged_task; // undeﬁned

template<class R, class... ArgTypes>
class packaged_task<R(ArgTypes...)> {
public:

// construction and destruction
packaged_task() noexcept;
template <class F>

explicit packaged_task(F&& f);

template <class F, class Allocator>

~packaged_task();

explicit packaged_task(allocator_arg_t, const Allocator& a, F&& f);

// no copy
packaged_task(const packaged_task&) = delete;
packaged_task& operator=(const packaged_task&) = delete;

// move support
packaged_task(packaged_task&& rhs) noexcept;
packaged_task& operator=(packaged_task&& rhs) noexcept;
void swap(packaged_task& other) noexcept;

bool valid() const noexcept;

// result retrieval
future<R> get_future();

// execution
void operator()(ArgTypes... );
void make_ready_at_thread_exit(ArgTypes...);

void reset();

};
template <class R, class... ArgTypes>

template <class R, class Alloc>

struct uses_allocator<packaged_task<R>, Alloc>;

}

void swap(packaged_task<R(ArgTypes...)>& x, packaged_task<R(ArgTypes...)>& y) noexcept;

1

2

3

30.6.9.1 packaged_task member functions
packaged_task() noexcept;

[futures.task.members]

Eﬀects: constructs a packaged_task object with no shared state and no stored task.

template <class F>

packaged_task(F&& f);

template <class F, class Allocator>

explicit packaged_task(allocator_arg_t, const Allocator& a, F&& f);

Requires: INVOKE (f, t1, t2, ..., tN, R), where t1, t2, ..., tN are values of the corresponding
types in ArgTypes..., shall be a valid expression.
Invoking a copy of f shall behave the same as
invoking f.
Remarks: These constructors shall not participate in overload resolution if decay_t<F> is the same
type as std::packaged_task<R(ArgTypes...)>.

§ 30.6.9.1

1207

c(cid:13) ISO/IEC

N4296

Eﬀects: constructs a new packaged_task object with a shared state and initializes the object’s stored
task with std::forward<F>(f). The constructors that take an Allocator argument use it to allocate
memory needed to store the internal data structures.
Throws: any exceptions thrown by the copy or move constructor of f, or std::bad_alloc if memory
for the internal data structures could not be allocated.

packaged_task(packaged_task&& rhs) noexcept;

Eﬀects: constructs a new packaged_task object and transfers ownership of rhs’s shared state to
*this, leaving rhs with no shared state. Moves the stored task from rhs to *this.
Postcondition: rhs has no shared state.

packaged_task& operator=(packaged_task&& rhs) noexcept;

Eﬀects:
—
—

releases any shared state (30.6.4).
packaged_task(std::move(rhs)).swap(*this).

~packaged_task();

Eﬀects: Abandons any shared state. (30.6.4).

void swap(packaged_task& other) noexcept;

Eﬀects: exchanges the shared states and stored tasks of *this and other.
Postcondition: *this has the same shared state and stored task (if any) as other prior to the call to
swap. other has the same shared state and stored task (if any) as *this prior to the call to swap.

bool valid() const noexcept;

Returns: true only if *this has a shared state.

future<R> get_future();

Returns: A future object that shares the same shared state as *this.
Throws: a future_error object if an error occurs.
Error conditions:
—

future_already_retrieved if get_future has already been called on a packaged_task object
with the same shared state as *this.
no_state if *this has no shared state.

—

void operator()(ArgTypes... args);

Eﬀects: INVOKE (f, t1, t2, ..., tN, R), where f is the stored task of *this and t1, t2, ..., tN
are the values in args.... If the task returns normally, the return value is stored as the asynchronous
result in the shared state of *this, otherwise the exception thrown by the task is stored. The shared
state of *this is made ready, and any threads blocked in a function waiting for the shared state of
*this to become ready are unblocked.
Throws: a future_error exception object if there is no shared state or the stored task has already
been invoked.
Error conditions:
—

promise_already_satisfied if the stored task has already been invoked.

§ 30.6.9.1

1208

4

5

6

7

8
(8.1)

(8.2)

9

10

11

12

13

14

15

(15.1)

(15.2)

16

17

18

(18.1)

c(cid:13) ISO/IEC

N4296

(18.2)

—

no_state if *this has no shared state.

void make_ready_at_thread_exit(ArgTypes... args);

19

20

21

(21.1)

(21.2)

22

23

(23.1)

(23.2)

(23.3)

1

2

Eﬀects: INVOKE (f, t1, t2, ..., tN, R), where f is the stored task and t1, t2, ..., tN are the
values in args.... If the task returns normally, the return value is stored as the asynchronous result
in the shared state of *this, otherwise the exception thrown by the task is stored. In either case, this
shall be done without making that state ready (30.6.4) immediately. Schedules the shared state to be
made ready when the current thread exits, after all objects of thread storage duration associated with
the current thread have been destroyed.
Throws: future_error if an error condition occurs.
Error conditions:
—
—

promise_already_satisfied if the stored task has already been invoked.
no_state if *this has no shared state.

void reset();

Eﬀects: as if *this = packaged_task(std::move(f)), where f is the task stored in *this. [ Note:
This constructs a new shared state for *this. The old state is abandoned (30.6.4). — end note ]
Throws:
—
—
—

bad_alloc if memory for the new shared state could not be allocated.
any exception thrown by the move constructor of the task stored in the shared state.
future_error with an error condition of no_state if *this has no shared state.

[futures.task.nonmembers]

30.6.9.2 packaged_task globals
template <class R, class... ArgTypes>

void swap(packaged_task<R(ArgTypes...)>& x, packaged_task<R(ArgTypes...)>& y) noexcept;

Eﬀects: x.swap(y)

template <class R, class Alloc>

struct uses_allocator<packaged_task<R>, Alloc>

: true_type { };
Requires: Alloc shall be an Allocator (17.6.3.5).

§ 30.6.9.2

1209

c(cid:13) ISO/IEC

Annex A (informative)
Grammar summary

N4296

[gram]

1 This summary of C++ syntax is intended to be an aid to comprehension.

It is not an exact statement
of the language.
In particular, the grammar described here accepts a superset of valid C++ constructs.
Disambiguation rules (6.8, 7.1, 10.2) must be applied to distinguish expressions from declarations. Further,
access control, ambiguity, and type rules must be used to weed out syntactically valid but meaningless
constructs.
A.1 Keywords

[gram.key]
1 New context-dependent keywords are introduced into a program by typedef (7.1.3), namespace (7.3.1),

class (Clause 9), enumeration (7.2), and template (Clause 14) declarations.

typedef-name:
identiﬁer

namespace-name:

original-namespace-name
namespace-alias

original-namespace-name:

identiﬁer
namespace-alias:
identiﬁer

class-name:

identiﬁer
simple-template-id

enum-name:

identiﬁer
template-name:
identiﬁer

Note that a typedef-name naming a class is also a class-name (9.1).
A.2 Lexical conventions

hex-quad:

hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit

[gram.lex]

universal-character-name:

\u hex-quad
\U hex-quad hex-quad

preprocessing-token:
header-name
identiﬁer
pp-number
character-literal
user-deﬁned-character-literal
string-literal
user-deﬁned-string-literal
preprocessing-op-or-punc
each non-white-space character that cannot be one of the above

§ A.2

1210

c(cid:13) ISO/IEC

N4296

token:

identiﬁer
keyword
literal
operator
punctuator

header-name:

< h-char-sequence >
" q-char-sequence "

h-char-sequence:

h-char
h-char-sequence h-char

h-char:

any member of the source character set except new-line and >

q-char-sequence:

q-char
q-char-sequence q-char

q-char:

any member of the source character set except new-line and "

pp-number:
digit
. digit
pp-number digit
pp-number identiﬁer-nondigit
pp-number ’ digit
pp-number ’ nondigit
pp-number e sign
pp-number E sign
pp-number .

identiﬁer:

identiﬁer-nondigit
identiﬁer identiﬁer-nondigit
identiﬁer digit

identiﬁer-nondigit:

nondigit
universal-character-name
other implementation-deﬁned characters

nondigit: one of

a b c d e f g h i j k l m
n o p q r s t u v w x y z
A B C D E F G H I J K L M
N O P Q R S T U V W X Y Z _

digit: one of

0 1 2 3 4 5 6 7 8 9

§ A.2

1211

c(cid:13) ISO/IEC

N4296

preprocessing-op-or-punc: one of

{
<:
new
+
!
ˆ=
<=
and
or

}
:>
delete
-
=
&=
>=
and_eq
or_eq

[
<%
?
*
<
|=
&&
bitand
xor

]
%>
::
/
>
<<
||
bitor
xor_eq

#
%:
.
%
+=
>>
++
compl

##
%:%:
.*
ˆ
-=
>>=
--
not

(
;

&
*=
<<=
,
not_eq

)
:

|
/=
==
->*

...

~
%=
!=
->

literal:

integer-literal
character-literal
ﬂoating-literal
string-literal
boolean-literal
pointer-literal
user-deﬁned-literal

integer-literal:

binary-literal integer-suﬃxopt
octal-literal integer-suﬃxopt
decimal-literal integer-suﬃxopt
hexadecimal-literal integer-suﬃxopt

binary-literal:

0b binary-digit
0B binary-digit
binary-literal ’opt binary-digit

octal-literal:

0
octal-literal ’opt octal-digit

decimal-literal:

nonzero-digit
decimal-literal ’opt digit

hexadecimal-literal:

0x hexadecimal-digit
0X hexadecimal-digit
hexadecimal-literal ’opt hexadecimal-digit

binary-digit:

0
1

octal-digit: one of

0 1 2 3 4 5 6 7

nonzero-digit: one of

1 2 3 4 5 6 7 8 9
hexadecimal-digit: one of

0 1 2 3 4 5 6 7 8 9
a b c d e f
A B C D E F

integer-suﬃx:

unsigned-suﬃx long-suﬃxopt
unsigned-suﬃx long-long-suﬃxopt
long-suﬃx unsigned-suﬃxopt
long-long-suﬃx unsigned-suﬃxopt

§ A.2

1212

c(cid:13) ISO/IEC

N4296

unsigned-suﬃx: one of

long-suﬃx: one of

u U

l L

long-long-suﬃx: one of

ll LL

character-literal:

encoding-preﬁxopt’ c-char-sequence ’

encoding-preﬁx: one of
L

U
c-char-sequence:

u8

u

c-char
c-char-sequence c-char

c-char:

any member of the source character set except

the single-quote ’, backslash \, or new-line character

escape-sequence
universal-character-name

escape-sequence:

simple-escape-sequence
octal-escape-sequence
hexadecimal-escape-sequence

simple-escape-sequence: one of

\’
\a

\"
\b

\?
\f

\\
\n

octal-escape-sequence:

\r

\t

\v

\ octal-digit
\ octal-digit octal-digit
\ octal-digit octal-digit octal-digit

hexadecimal-escape-sequence:

\x hexadecimal-digit
hexadecimal-escape-sequence hexadecimal-digit

ﬂoating-literal:

fractional-constant exponent-partopt ﬂoating-suﬃxopt
digit-sequence exponent-part ﬂoating-suﬃxopt

fractional-constant:

digit-sequenceopt. digit-sequence
digit-sequence .

exponent-part:

e signopt digit-sequence
E signopt digit-sequence

sign: one of

+ -

digit-sequence:

digit
digit-sequence ’opt digit

ﬂoating-suﬃx: one of

f l F L
string-literal:

encoding-preﬁxopt" s-char-sequenceopt"
encoding-preﬁxoptR raw-string

§ A.2

1213

c(cid:13) ISO/IEC

s-char-sequence:

s-char
s-char-sequence s-char

s-char:

any member of the source character set except

the double-quote ", backslash \, or new-line character

escape-sequence
universal-character-name

raw-string:

" d-char-sequenceopt( r-char-sequenceopt) d-char-sequenceopt"

r-char-sequence:

r-char
r-char-sequence r-char

r-char:

any member of the source character set, except

a right parenthesis ) followed by the initial d-char-sequence
(which may be empty) followed by a double quote ".

d-char-sequence:

d-char
d-char-sequence d-char

d-char:

any member of the basic source character set except:

space, the left parenthesis (, the right parenthesis ), the backslash \,
and the control characters representing horizontal tab,
vertical tab, form feed, and newline.

boolean-literal:

false
true

pointer-literal:
nullptr

user-deﬁned-literal:

user-deﬁned-integer-literal
user-deﬁned-ﬂoating-literal
user-deﬁned-string-literal
user-deﬁned-character-literal

user-deﬁned-integer-literal:

decimal-literal ud-suﬃx
octal-literal ud-suﬃx
hexadecimal-literal ud-suﬃx
binary-literal ud-suﬃx
user-deﬁned-ﬂoating-literal:

fractional-constant exponent-partopt ud-suﬃx
digit-sequence exponent-part ud-suﬃx

user-deﬁned-string-literal:

string-literal ud-suﬃx
user-deﬁned-character-literal:

character-literal ud-suﬃx

ud-suﬃx:

identiﬁer

§ A.2

N4296

1214

N4296

[gram.basic]

[gram.expr]

c(cid:13) ISO/IEC

A.3 Basic concepts

translation-unit:

declaration-seqopt

A.4 Expressions

primary-expression:

literal
this
( expression )
id-expression
lambda-expression
fold-expression

id-expression:

unqualiﬁed-id
qualiﬁed-id

unqualiﬁed-id:
identiﬁer
operator-function-id
conversion-function-id
literal-operator-id
~ class-name
~ decltype-speciﬁer
template-id

qualiﬁed-id:

nested-name-speciﬁer templateopt unqualiﬁed-id

nested-name-speciﬁer:

::
type-name ::
namespace-name ::
decltype-speciﬁer ::
nested-name-speciﬁer identiﬁer ::
nested-name-speciﬁer templateopt simple-template-id ::

lambda-expression:

lambda-introducer lambda-declaratoropt compound-statement

lambda-introducer:

[ lambda-captureopt]

lambda-capture:

capture-default
capture-list
capture-default , capture-list

capture-default:

&
=

capture-list:

capture ...opt
capture-list , capture ...opt

capture:

simple-capture
init-capture

simple-capture:
identiﬁer
& identiﬁer
this

§ A.4

1215

c(cid:13) ISO/IEC

init-capture:

identiﬁer initializer
& identiﬁer initializer

N4296

lambda-declarator:

( parameter-declaration-clause ) mutableopt

exception-speciﬁcationopt attribute-speciﬁer-seqopt trailing-return-typeopt

fold-expression:

( cast-expression fold-operator ... )
( ... fold-operator cast-expression )
( cast-expression fold-operator ... fold-operator cast-expression )

fold-operator: one of

+
+=
==

*
*=
<
postﬁx-expression:

-
-=
!=

/
/=
>

%
%=
<=

ˆ
ˆ=
>=

&
&=
&&

|
|=
||

<<
<<=
,

>>
>>=
.*

=
->*

primary-expression
postﬁx-expression [ expression ]
postﬁx-expression [ braced-init-list ]
postﬁx-expression ( expression-listopt)
simple-type-speciﬁer ( expression-listopt)
typename-speciﬁer ( expression-listopt)
simple-type-speciﬁer braced-init-list
typename-speciﬁer braced-init-list
postﬁx-expression . templateopt id-expression
postﬁx-expression -> templateopt id-expression
postﬁx-expression . pseudo-destructor-name
postﬁx-expression -> pseudo-destructor-name
postﬁx-expression ++
postﬁx-expression --
dynamic_cast < type-id > ( expression )
static_cast < type-id > ( expression )
reinterpret_cast < type-id > ( expression )
const_cast < type-id > ( expression )
typeid ( expression )
typeid ( type-id )

expression-list:

initializer-list

pseudo-destructor-name:

nested-name-speciﬁeropt type-name :: ~ type-name
nested-name-speciﬁer template simple-template-id :: ~ type-name
~ type-name
~ decltype-speciﬁer

unary-expression:

postﬁx-expression
++ cast-expression
-- cast-expression
unary-operator cast-expression
sizeof unary-expression
sizeof ( type-id )
sizeof ... ( identiﬁer )
alignof ( type-id )
noexcept-expression
new-expression
delete-expression

§ A.4

1216

c(cid:13) ISO/IEC

N4296

unary-operator: one of

* & + - ! ~

new-expression:

::optnew new-placementopt new-type-id new-initializeropt
::optnew new-placementopt( type-id ) new-initializeropt

new-placement:

( expression-list )

new-type-id:

type-speciﬁer-seq new-declaratoropt

new-declarator:

ptr-operator new-declaratoropt
noptr-new-declarator

noptr-new-declarator:

[ expression ] attribute-speciﬁer-seqopt
noptr-new-declarator [ constant-expression ] attribute-speciﬁer-seqopt

new-initializer:

( expression-listopt)
braced-init-list

delete-expression:

::optdelete cast-expression
::optdelete [ ] cast-expression

noexcept-expression:

noexcept ( expression )

cast-expression:

unary-expression
( type-id ) cast-expression

pm-expression:

cast-expression
pm-expression .* cast-expression
pm-expression ->* cast-expression

multiplicative-expression:

pm-expression
multiplicative-expression * pm-expression
multiplicative-expression / pm-expression
multiplicative-expression % pm-expression

additive-expression:

multiplicative-expression
additive-expression + multiplicative-expression
additive-expression - multiplicative-expression

shift-expression:

additive-expression
shift-expression << additive-expression
shift-expression >> additive-expression

relational-expression:
shift-expression
relational-expression < shift-expression
relational-expression > shift-expression
relational-expression <= shift-expression
relational-expression >= shift-expression

equality-expression:

relational-expression
equality-expression == relational-expression
equality-expression != relational-expression

§ A.4

1217

c(cid:13) ISO/IEC

N4296

and-expression:

equality-expression
and-expression & equality-expression

exclusive-or-expression:

and-expression
exclusive-or-expression ˆ and-expression

inclusive-or-expression:

exclusive-or-expression
inclusive-or-expression | exclusive-or-expression

logical-and-expression:

inclusive-or-expression
logical-and-expression && inclusive-or-expression

logical-or-expression:

logical-and-expression
logical-or-expression || logical-and-expression

conditional-expression:

logical-or-expression
logical-or-expression ? expression : assignment-expression

throw-expression:

throw assignment-expressionopt

assignment-expression:

conditional-expression
logical-or-expression assignment-operator initializer-clause
throw-expression

assignment-operator: one of

= *= /= %= += -= >>= <<= &= ˆ= |=

expression:

assignment-expression
expression , assignment-expression

constant-expression:

conditional-expression

A.5 Statements

statement:

labeled-statement
attribute-speciﬁer-seqopt expression-statement
attribute-speciﬁer-seqopt compound-statement
attribute-speciﬁer-seqopt selection-statement
attribute-speciﬁer-seqopt iteration-statement
attribute-speciﬁer-seqopt jump-statement
declaration-statement
attribute-speciﬁer-seqopt try-block

[gram.stmt]

labeled-statement:

attribute-speciﬁer-seqopt identiﬁer : statement
attribute-speciﬁer-seqoptcase constant-expression : statement
attribute-speciﬁer-seqoptdefault : statement

expression-statement:
expressionopt;
compound-statement:

{ statement-seqopt}

statement-seq:

statement
statement-seq statement

§ A.5

1218

c(cid:13) ISO/IEC

N4296

selection-statement:

if ( condition ) statement
if ( condition ) statement else statement
switch ( condition ) statement

condition:

expression
attribute-speciﬁer-seqopt decl-speciﬁer-seq declarator = initializer-clause
attribute-speciﬁer-seqopt decl-speciﬁer-seq declarator braced-init-list

iteration-statement:

while ( condition ) statement
do statement while ( expression ) ;
for ( for-init-statement conditionopt; expressionopt) statement
for ( for-range-declaration : for-range-initializer ) statement

for-init-statement:

expression-statement
simple-declaration

for-range-declaration:

attribute-speciﬁer-seqopt decl-speciﬁer-seq declarator

for-range-initializer:

expression
braced-init-list

jump-statement:

break ;
continue ;
return expressionopt;
return braced-init-list ;
goto identiﬁer ;
declaration-statement:
block-declaration

A.6 Declarations

declaration-seq:

declaration
declaration-seq declaration

[gram.dcl]

declaration:

block-declaration
function-deﬁnition
template-declaration
explicit-instantiation
explicit-specialization
linkage-speciﬁcation
namespace-deﬁnition
empty-declaration
attribute-declaration

block-declaration:

simple-declaration
asm-deﬁnition
namespace-alias-deﬁnition
using-declaration
using-directive
static_assert-declaration
alias-declaration
opaque-enum-declaration

§ A.6

1219

c(cid:13) ISO/IEC

N4296

alias-declaration:

using identiﬁer attribute-speciﬁer-seqopt= type-id ;

simple-declaration:

decl-speciﬁer-seqopt init-declarator-listopt;
attribute-speciﬁer-seq decl-speciﬁer-seqopt init-declarator-list ;

static_assert-declaration:

static_assert ( constant-expression ) ;
static_assert ( constant-expression , string-literal ) ;

empty-declaration:

;

attribute-declaration:

attribute-speciﬁer-seq ;

decl-speciﬁer:

storage-class-speciﬁer
type-speciﬁer
function-speciﬁer
friend
typedef
constexpr
decl-speciﬁer-seq:

decl-speciﬁer attribute-speciﬁer-seqopt
decl-speciﬁer decl-speciﬁer-seq

storage-class-speciﬁer:

register
static
thread_local
extern
mutable

function-speciﬁer:

inline
virtual
explicit

typedef-name:
identiﬁer

type-speciﬁer:

trailing-type-speciﬁer
class-speciﬁer
enum-speciﬁer
trailing-type-speciﬁer:

simple-type-speciﬁer
elaborated-type-speciﬁer
typename-speciﬁer
cv-qualiﬁer
type-speciﬁer-seq:

type-speciﬁer attribute-speciﬁer-seqopt
type-speciﬁer type-speciﬁer-seq

trailing-type-speciﬁer-seq:

trailing-type-speciﬁer attribute-speciﬁer-seqopt
trailing-type-speciﬁer trailing-type-speciﬁer-seq

§ A.6

1220

c(cid:13) ISO/IEC

N4296

simple-type-speciﬁer:

nested-name-speciﬁeropt type-name
nested-name-speciﬁer template simple-template-id
char
char16_t
char32_t
wchar_t
bool
short
int
long
signed
unsigned
float
double
void
auto
decltype-speciﬁer

type-name:

class-name
enum-name
typedef-name
simple-template-id

decltype-speciﬁer:

decltype ( expression )
decltype ( auto )
elaborated-type-speciﬁer:

enum-name:

identiﬁer
enum-speciﬁer:

enum-head:

enum-head { enumerator-listopt}
enum-head { enumerator-list , }

class-key attribute-speciﬁer-seqopt nested-name-speciﬁeropt identiﬁer
class-key simple-template-id
class-key nested-name-speciﬁer templateopt simple-template-id
enum nested-name-speciﬁeropt identiﬁer

enum-key attribute-speciﬁer-seqopt identiﬁeropt enum-baseopt
enum-key attribute-speciﬁer-seqopt nested-name-speciﬁer identiﬁer

enum-baseopt
opaque-enum-declaration:

enum-key attribute-speciﬁer-seqopt identiﬁer enum-baseopt;

enum-key:
enum
enum class
enum struct

enum-base:

: type-speciﬁer-seq

enumerator-list:

enumerator-deﬁnition
enumerator-list , enumerator-deﬁnition

enumerator-deﬁnition:

enumerator
enumerator = constant-expression

§ A.6

1221

c(cid:13) ISO/IEC

N4296

enumerator:

identiﬁer attribute-speciﬁer-seqopt

namespace-name:

identiﬁer
namespace-alias
namespace-deﬁnition:

named-namespace-deﬁnition
unnamed-namespace-deﬁnition nested-namespace-deﬁnition

named-namespace-deﬁnition:

inlineopt namespace attribute-speciﬁer-seqopt identiﬁer { namespace-body }

unnamed-namespace-deﬁnition:

inlineopt namespace attribute-speciﬁer-seqopt{ namespace-body }

nested-namespace-deﬁnition:

namespace enclosing-namespace-speciﬁer :: identiﬁer { namespace-body }

enclosing-namespace-speciﬁer:

identiﬁer enclosing-namespace-speciﬁer :: identiﬁer

namespace-body:

declaration-seqopt

namespace-alias:
identiﬁer

namespace-alias-deﬁnition:

namespace identiﬁer = qualiﬁed-namespace-speciﬁer ;

qualiﬁed-namespace-speciﬁer:

nested-name-speciﬁeropt namespace-name

using-declaration:

using typenameopt nested-name-speciﬁer unqualiﬁed-id ;

using-directive:

attribute-speciﬁer-seqoptusing namespace nested-name-speciﬁeropt namespace-name ;

asm-deﬁnition:

asm ( string-literal ) ;

linkage-speciﬁcation:

extern string-literal { declaration-seqopt}
extern string-literal declaration

attribute-speciﬁer-seq:

attribute-speciﬁer-seqopt attribute-speciﬁer

attribute-speciﬁer:

[ [ attribute-list ] ]
alignment-speciﬁer

alignment-speciﬁer:

alignas ( type-id ...opt)
alignas ( constant-expression ...opt)

attribute-list:

attributeopt
attribute-list , attributeopt
attribute ...
attribute-list , attribute ...

attribute:

attribute-token attribute-argument-clauseopt

attribute-token:
identiﬁer
attribute-scoped-token

§ A.6

1222

c(cid:13) ISO/IEC

N4296

attribute-scoped-token:

attribute-namespace :: identiﬁer

attribute-namespace:

identiﬁer

attribute-argument-clause:

( balanced-token-seq )

balanced-token-seq:

balanced-tokenopt
balanced-token-seq balanced-token

balanced-token:

( balanced-token-seq )
[ balanced-token-seq ]
{ balanced-token-seq }
any token other than a parenthesis, a bracket, or a brace

[gram.decl]

A.7 Declarators
init-declarator-list:

init-declarator
init-declarator-list , init-declarator

init-declarator:

declarator initializeropt

declarator:

ptr-declarator
noptr-declarator parameters-and-qualiﬁers trailing-return-type

ptr-declarator:

noptr-declarator
ptr-operator ptr-declarator

noptr-declarator:

declarator-id attribute-speciﬁer-seqopt
noptr-declarator parameters-and-qualiﬁers
noptr-declarator [ constant-expressionopt] attribute-speciﬁer-seqopt
( ptr-declarator )

parameters-and-qualiﬁers:

( parameter-declaration-clause ) cv-qualiﬁer-seqopt

ref-qualiﬁeropt exception-speciﬁcationopt attribute-speciﬁer-seqopt

trailing-return-type:

ptr-operator:

-> trailing-type-speciﬁer-seq abstract-declaratoropt

* attribute-speciﬁer-seqopt cv-qualiﬁer-seqopt
& attribute-speciﬁer-seqopt
&& attribute-speciﬁer-seqopt
nested-name-speciﬁer * attribute-speciﬁer-seqopt cv-qualiﬁer-seqopt

cv-qualiﬁer-seq:

cv-qualiﬁer cv-qualiﬁer-seqopt

cv-qualiﬁer:
const
volatile

ref-qualiﬁer:

&
&&

declarator-id:

...opt id-expression

§ A.7

1223

c(cid:13) ISO/IEC

N4296

type-id:

type-speciﬁer-seq abstract-declaratoropt

abstract-declarator:

ptr-abstract-declarator
noptr-abstract-declaratoropt parameters-and-qualiﬁers trailing-return-type
abstract-pack-declarator

ptr-abstract-declarator:

noptr-abstract-declarator
ptr-operator ptr-abstract-declaratoropt

noptr-abstract-declarator:

noptr-abstract-declaratoropt parameters-and-qualiﬁers
noptr-abstract-declaratoropt[ constant-expressionopt ] attribute-speciﬁer-seqopt
( ptr-abstract-declarator )

abstract-pack-declarator:

noptr-abstract-pack-declarator
ptr-operator abstract-pack-declarator

noptr-abstract-pack-declarator:

noptr-abstract-pack-declarator parameters-and-qualiﬁers
noptr-abstract-pack-declarator [ constant-expressionopt ] attribute-speciﬁer-seqopt
...

parameter-declaration-clause:

parameter-declaration-listopt...opt
parameter-declaration-list , ...

parameter-declaration-list:

parameter-declaration
parameter-declaration-list , parameter-declaration

parameter-declaration:

attribute-speciﬁer-seqopt decl-speciﬁer-seq declarator
attribute-speciﬁer-seqopt decl-speciﬁer-seq declarator = initializer-clause
attribute-speciﬁer-seqopt decl-speciﬁer-seq abstract-declaratoropt
attribute-speciﬁer-seqopt decl-speciﬁer-seq abstract-declaratoropt= initializer-clause

function-deﬁnition:

attribute-speciﬁer-seqopt decl-speciﬁer-seqopt declarator virt-speciﬁer-seqopt function-body

function-body:

ctor-initializeropt compound-statement
function-try-block
= default ;
= delete ;

initializer:

brace-or-equal-initializer
( expression-list )
brace-or-equal-initializer:
= initializer-clause
braced-init-list

initializer-clause:

assignment-expression
braced-init-list

initializer-list:

initializer-clause ...opt
initializer-list , initializer-clause ...opt

braced-init-list:

{ initializer-list ,opt }
{ }

§ A.7

1224

c(cid:13) ISO/IEC

A.8 Classes
class-name:

identiﬁer
simple-template-id

class-speciﬁer:

class-head { member-speciﬁcationopt}

class-head:

class-key attribute-speciﬁer-seqopt class-head-name class-virt-speciﬁeropt base-clauseopt
class-key attribute-speciﬁer-seqopt base-clauseopt

class-head-name:

nested-name-speciﬁeropt class-name

N4296

[gram.class]

class-virt-speciﬁer:

class-key:

final

class
struct
union

member-speciﬁcation:

member-declaration member-speciﬁcationopt
access-speciﬁer : member-speciﬁcationopt

member-declaration:

attribute-speciﬁer-seqopt decl-speciﬁer-seqopt member-declarator-listopt;
function-deﬁnition
using-declaration
static_assert-declaration
template-declaration
alias-declaration
empty-declaration
member-declarator-list:

member-declarator
member-declarator-list , member-declarator

member-declarator:

declarator virt-speciﬁer-seqopt pure-speciﬁeropt
declarator brace-or-equal-initializeropt
identiﬁeropt attribute-speciﬁer-seqopt: constant-expression

virt-speciﬁer-seq:

virt-speciﬁer
virt-speciﬁer-seq virt-speciﬁer

virt-speciﬁer:

override
final

pure-speciﬁer:

= 0

A.9 Derived classes

base-clause:

: base-speciﬁer-list

base-speciﬁer-list:

base-speciﬁer ...opt
base-speciﬁer-list , base-speciﬁer ...opt

[gram.derived]

§ A.9

1225

c(cid:13) ISO/IEC

N4296

base-speciﬁer:

attribute-speciﬁer-seqopt base-type-speciﬁer
attribute-speciﬁer-seqoptvirtual access-speciﬁeropt base-type-speciﬁer
attribute-speciﬁer-seqopt access-speciﬁer virtualopt base-type-speciﬁer

class-or-decltype:

nested-name-speciﬁeropt class-name
decltype-speciﬁer

base-type-speciﬁer:

class-or-decltype

access-speciﬁer:
private
protected
public

A.10 Special member functions

conversion-function-id:

operator conversion-type-id

conversion-type-id:

type-speciﬁer-seq conversion-declaratoropt

conversion-declarator:

ptr-operator conversion-declaratoropt

ctor-initializer:

: mem-initializer-list

mem-initializer-list:

mem-initializer ...opt
mem-initializer-list , mem-initializer ...opt

mem-initializer:

mem-initializer-id ( expression-listopt)
mem-initializer-id braced-init-list

mem-initializer-id:

class-or-decltype
identiﬁer

A.11 Overloading
operator-function-id:

operator operator

operator: one of

new
+
!
ˆ=
<=
( )

delete
-
=
&=
>=
[ ]

new[]
*
<
|=
&&

delete[]
/
>
<<
||

%
+=
>>
++

ˆ
-=
>>=
--

&
*=
<<=
,

|
/=
==
->*

~
%=
!=
->

literal-operator-id:

operator string-literal identiﬁer
operator user-deﬁned-string-literal

A.12 Templates

template-declaration:

template < template-parameter-list > declaration

template-parameter-list:

template-parameter
template-parameter-list , template-parameter

§ A.12

[gram.special]

[gram.over]

[gram.temp]

1226

c(cid:13) ISO/IEC

N4296

template-parameter:
type-parameter
parameter-declaration

type-parameter:

type-parameter-key ...opt identiﬁeropt
type-parameter-key identiﬁeropt= type-id
template < template-parameter-list > type-parameter-key ...opt identiﬁeropt
template < template-parameter-list > type-parameter-key identiﬁeropt= id-expression

type-parameter-key:

class
typename

simple-template-id:

template-name < template-argument-listopt>

template-id:

simple-template-id
operator-function-id < template-argument-listopt>
literal-operator-id < template-argument-listopt>

template-name:
identiﬁer

template-argument-list:

template-argument ...opt
template-argument-list , template-argument ...opt

template-argument:

constant-expression
type-id
id-expression
typename-speciﬁer:

typename nested-name-speciﬁer identiﬁer
typename nested-name-speciﬁer templateopt simple-template-id

explicit-instantiation:

externopt template declaration

explicit-specialization:

template < > declaration

A.13 Exception handling

try-block:

try compound-statement handler-seq

function-try-block:

try ctor-initializeropt compound-statement handler-seq

handler-seq:

handler handler-seqopt

handler:

catch ( exception-declaration ) compound-statement

[gram.except]

exception-declaration:

attribute-speciﬁer-seqopt type-speciﬁer-seq declarator
attribute-speciﬁer-seqopt type-speciﬁer-seq abstract-declaratoropt
...

exception-speciﬁcation:

dynamic-exception-speciﬁcation
noexcept-speciﬁcation

dynamic-exception-speciﬁcation:

throw ( type-id-listopt)

§ A.13

1227

c(cid:13) ISO/IEC

type-id-list:

type-id ...opt
type-id-list , type-id ...opt

noexcept-speciﬁcation:

noexcept ( constant-expression )
noexcept

A.14 Preprocessing directives

N4296

[gram.cpp]

preprocessing-ﬁle:

groupopt

group:

group-part:

group-part
group group-part

if-section
control-line
text-line
# non-directive

if-section:

if-group elif-groupsopt else-groupopt endif-line

if-group:

# if
# ifdef
# ifndef

constant-expression new-line groupopt
identiﬁer new-line groupopt
identiﬁer new-line groupopt

elif-groups:

elif-group
elif-groups elif-group

elif-group:

# elif

else-group:

# else

endif-line:

# endif

control-line:

# include
# define
# define
# define
# define
# undef
# line
# error
# pragma
# new-line

constant-expression new-line groupopt

new-line groupopt

new-line

pp-tokens new-line
identiﬁer replacement-list new-line
identiﬁer lparen identiﬁer-listopt) replacement-list new-line
identiﬁer lparen ... ) replacement-list new-line
identiﬁer lparen identiﬁer-list, ... ) replacement-list new-line
identiﬁer new-line
pp-tokens new-line
pp-tokensopt new-line
pp-tokensopt new-line

text-line:

pp-tokensopt new-line

non-directive:

pp-tokens new-line

lparen:

a ( character not immediately preceded by white-space

§ A.14

1228

c(cid:13) ISO/IEC

N4296

identiﬁer-list:

identiﬁer
identiﬁer-list , identiﬁer

replacement-list:

pp-tokensopt

pp-tokens:

preprocessing-token
pp-tokens preprocessing-token

new-line:

the new-line character

§ A.14

1229

c(cid:13) ISO/IEC

N4296

Annex B (informative)
Implementation quantities

[implimits]

1 Because computers are ﬁnite, C++ implementations are inevitably limited in the size of the programs they
can successfully process. Every implementation shall document those limitations where known. This docu-
mentation may cite ﬁxed limits where they exist, say how to compute variable limits as a function of available
resources, or say that ﬁxed limits do not exist or are unknown.

2 The limits may constrain quantities that include those described below or others. The bracketed number
following each quantity is recommended as the minimum for that quantity. However, these quantities are
only guidelines and do not determine compliance.

(2.1)

(2.2)

(2.3)

(2.4)

(2.5)

(2.6)

(2.7)

(2.8)

(2.9)

(2.10)

(2.11)

(2.12)

(2.13)

(2.14)

(2.15)

(2.16)

(2.17)

(2.18)

(2.19)

(2.20)

—

—
—

—
—
—
—
—
—
—
—
—
—
—
—
—
—
—
—
—

Nesting levels of compound statements, iteration control structures, and selection control structures
[256].
Nesting levels of conditional inclusion [256].
Pointer, array, and function declarators (in any combination) modifying a class, arithmetic, or incom-
plete type in a declaration [256].
Nesting levels of parenthesized expressions within a full-expression [256].
Number of characters in an internal identiﬁer or macro name [1 024].
Number of characters in an external identiﬁer [1 024].
External identiﬁers in one translation unit [65 536].
Identiﬁers with block scope declared in one block [1 024].
Macro identiﬁers simultaneously deﬁned in one translation unit [65 536].
Parameters in one function deﬁnition [256].
Arguments in one function call [256].
Parameters in one macro deﬁnition [256].
Arguments in one macro invocation [256].
Characters in one logical source line [65 536].
Characters in a string literal (after concatenation) [65 536].
Size of an object [262 144].
Nesting levels for #include ﬁles [256].
Case labels for a switch statement (excluding those for any nested switch statements) [16 384].
Data members in a single class [16 384].
Enumeration constants in a single enumeration [4 096].

Implementation quantities

1230

c(cid:13) ISO/IEC

N4296

(2.21)

(2.22)

(2.23)

(2.24)

(2.25)

(2.26)

(2.27)

(2.28)

(2.29)

(2.30)

(2.31)

(2.32)

(2.33)

(2.34)

(2.35)

(2.36)

(2.37)

(2.38)

(2.39)

(2.40)

(2.41)

—
—
—
—
—
—
—
—
—
—
—
—
—
—
—
—
—
—

—
—
—

Levels of nested class deﬁnitions in a single member-speciﬁcation [256].
Functions registered by atexit() [32].
Functions registered by at_quick_exit() [32].
Direct and indirect base classes [16 384].
Direct base classes for a single class [1 024].
Members declared in a single class [4 096].
Final overriding virtual functions in a class, accessible or not [16 384].
Direct and indirect virtual bases of a class [1 024].
Static members of a class [1 024].
Friend declarations in a class [4 096].
Access control declarations in a class [4 096].
Member initializers in a constructor deﬁnition [6 144].
Scope qualiﬁcations of one identiﬁer [256].
Nested external speciﬁcations [1 024].
Recursive constexpr function invocations [512].
Full-expressions evaluated within a core constant expression [1 048 576].
Template arguments in a template declaration [1 024].
Recursively nested template instantiations, including substitution during template argument deduc-
tion (14.8.2) [1 024].
Handlers per try block [256].
Throw speciﬁcations on a single function declaration [256].
Number of placeholders (20.9.10.4) [10].

Implementation quantities

1231

c(cid:13) ISO/IEC

Annex C (informative)
Compatibility
C.1 C++ and ISO C

N4296

[diﬀ]
[diﬀ.iso]

1 This subclause lists the diﬀerences between C++ and ISO C, by the chapters of this document.

[diﬀ.lex]

C.1.1 Clause 2: lexical conventions
2.11
Change: New Keywords
New keywords are added to C++; see 2.11.
Rationale: These keywords were added in order to implement the new semantics of C++.
Eﬀect on original feature: Change to semantics of well-deﬁned feature. Any ISO C programs that used
any of these keywords as identiﬁers are not valid C++ programs.
Diﬃculty of converting: Syntactic transformation. Converting one speciﬁc program is easy. Converting
a large collection of related programs takes more work.
How widely used: Common.
2.13.3
Change: Type of character literal is changed from int to char
Rationale: This is needed for improved overloaded function argument type matching. For example:

int function( int i );
int function( char c );

function( ’x’ );

It is preferable that this call match the second version of function rather than the ﬁrst.
Eﬀect on original feature: Change to semantics of well-deﬁned feature. ISO C programs which depend
on

sizeof(’x’) == sizeof(int)

will not work the same as C++ programs.
Diﬃculty of converting: Simple.
How widely used: Programs which depend upon sizeof(’x’) are probably rare.
Subclause 2.13.5:
Change: String literals made const
The type of a string literal is changed from “array of char” to “array of const char.” The type of a
char16_t string literal is changed from “array of some-integer-type” to “array of const char16_t.” The
type of a char32_t string literal is changed from “array of some-integer-type” to “array of const char32_t.”
The type of a wide string literal is changed from “array of wchar_t” to “array of const wchar_t.”
Rationale: This avoids calling an inappropriate overloaded function, which might expect to be able to
modify its argument.
Eﬀect on original feature: Change to semantics of well-deﬁned feature.
Diﬃculty of converting: Syntactic transformation. The ﬁx is to add a cast:

char* p = "abc";
void f(char*) {

char* p = (char*)"abc";

// valid in C, invalid in C++

// OK: cast added

§ C.1.1

1232

c(cid:13) ISO/IEC

f(p);
f((char*)"def");

}

// OK: cast added

N4296

How widely used: Programs that have a legitimate reason to treat string literals as pointers to potentially
modiﬁable memory are probably rare.
C.1.2 Clause 3: basic concepts
3.1
Change: C++ does not have “tentative deﬁnitions” as in C E.g., at ﬁle scope,

[diﬀ.basic]

int i;
int i;

is valid in C, invalid in C++. This makes it impossible to deﬁne mutually referential ﬁle-local static objects,
if initializers are restricted to the syntactic forms of C. For example,

struct X { int i; struct X* next; };

static struct X a;
static struct X b = { 0, &a };
static struct X a = { 1, &b };

Rationale: This avoids having diﬀerent initialization rules for fundamental types and user-deﬁned types.
Eﬀect on original feature: Deletion of semantically well-deﬁned feature.
Diﬃculty of converting: Semantic transformation.
Rationale: In C++, the initializer for one of a set of mutually-referential ﬁle-local static objects must invoke
a function call to achieve the initialization.
How widely used: Seldom.
3.3
Change: A struct is a scope in C++, not in C
Rationale: Class scope is crucial to C++, and a struct is a class.
Eﬀect on original feature: Change to semantics of well-deﬁned feature.
Diﬃculty of converting: Semantic transformation.
How widely used: C programs use struct extremely frequently, but the change is only noticeable when
struct, enumeration, or enumerator names are referred to outside the struct. The latter is probably rare.
3.5 [also 7.1.6]
Change: A name of ﬁle scope that is explicitly declared const, and not explicitly declared extern, has
internal linkage, while in C it would have external linkage
Rationale: Because const objects can be used as compile-time values in C++, this feature urges program-
mers to provide explicit initializer values for each const. This feature allows the user to put constobjects
in header ﬁles that are included in many compilation units.
Eﬀect on original feature: Change to semantics of well-deﬁned feature.
Diﬃculty of converting: Semantic transformation
How widely used: Seldom
3.6
Change: Main cannot be called recursively and cannot have its address taken
Rationale: The main function may require special actions.
Eﬀect on original feature: Deletion of semantically well-deﬁned feature

§ C.1.2

1233

c(cid:13) ISO/IEC

N4296

Diﬃculty of converting: Trivial: create an intermediary function such as mymain(argc, argv).
How widely used: Seldom
3.9
Change: C allows “compatible types” in several places, C++ does not For example, otherwise-identical
struct types with diﬀerent tag names are “compatible” in C but are distinctly diﬀerent types in C++.
Rationale: Stricter type checking is essential for C++.
Eﬀect on original feature: Deletion of semantically well-deﬁned feature.
Diﬃculty of converting: Semantic transformation. The “typesafe linkage” mechanism will ﬁnd many, but
not all, of such problems. Those problems not found by typesafe linkage will continue to function properly,
according to the “layout compatibility rules” of this International Standard.
How widely used: Common.
C.1.3 Clause 4: standard conversions
4.10
Change: Converting void* to a pointer-to-object type requires casting

[diﬀ.conv]

char a[10];
void* b=a;
void foo() {
char* c=b;

}

ISO C will accept this usage of pointer to void being assigned to a pointer to object type. C++ will not.
Rationale: C++ tries harder than C to enforce compile-time type safety.
Eﬀect on original feature: Deletion of semantically well-deﬁned feature.
Diﬃculty of converting: Could be automated. Violations will be diagnosed by the C++ translator. The
ﬁx is to add a cast. For example:

char* c = (char*) b;

How widely used: This is fairly widely used but it is good programming practice to add the cast when
assigning pointer-to-void to pointer-to-object. Some ISO C translators will give a warning if the cast is not
used.
C.1.4 Clause 5: expressions
5.2.2
Change: Implicit declaration of functions is not allowed
Rationale: The type-safe nature of C++.
Eﬀect on original feature: Deletion of semantically well-deﬁned feature. Note: the original feature was
labeled as “obsolescent” in ISO C.
Diﬃculty of converting: Syntactic transformation. Facilities for producing explicit function declarations
are fairly widespread commercially.
How widely used: Common.
5.3.3, 5.4
Change: Types must be declared in declarations, not in expressions In C, a sizeof expression or cast
expression may create a new type. For example,

[diﬀ.expr]

p = (void*)(struct x {int i;} *)0;

declares a new type, struct x .
Rationale: This prohibition helps to clarify the location of declarations in the source code.

§ C.1.4

1234

c(cid:13) ISO/IEC

N4296

Eﬀect on original feature: Deletion of a semantically well-deﬁned feature.
Diﬃculty of converting: Syntactic transformation.
How widely used: Seldom.
5.16, 5.18, 5.19

Change: The result of a conditional expression, an assignment expression, or a comma expression may be
an lvalue
Rationale: C++ is an object-oriented language, placing relatively more emphasis on lvalues. For example,
functions may return lvalues.
Eﬀect on original feature: Change to semantics of well-deﬁned feature. Some C expressions that implicitly
rely on lvalue-to-rvalue conversions will yield diﬀerent results. For example,

char arr[100];
sizeof(0, arr)

[diﬀ.stat]

yields 100 in C++ and sizeof(char*) in C.
Diﬃculty of converting: Programs must add explicit casts to the appropriate rvalue.
How widely used: Rare.
C.1.5 Clause 6: statements
6.4.2, 6.6.4
Change: It is now invalid to jump past a declaration with explicit or implicit initializer (except across
entire block not entered)
Rationale: Constructors used in initializers may allocate resources which need to be de-allocated upon
leaving the block. Allowing jump past initializers would require complicated run-time determination of
allocation. Furthermore, any use of the uninitialized object could be a disaster. With this simple compile-
time rule, C++ assures that if an initialized variable is in scope, then it has assuredly been initialized.
Eﬀect on original feature: Deletion of semantically well-deﬁned feature.
Diﬃculty of converting: Semantic transformation.
How widely used: Seldom.
6.6.3
Change: It is now invalid to return (explicitly or implicitly) from a function which is declared to return a
value without actually returning a value
Rationale: The caller and callee may assume fairly elaborate return-value mechanisms for the return of
class objects. If some ﬂow paths execute a return without specifying any value, the implementation must
embody many more complications. Besides, promising to return a value of a given type, and then not
returning such a value, has always been recognized to be a questionable practice, tolerated only because
very-old C had no distinction between void functions and int functions.
Eﬀect on original feature: Deletion of semantically well-deﬁned feature.
Diﬃculty of converting: Semantic transformation. Add an appropriate return value to the source code,
such as zero.
How widely used: Seldom. For several years, many existing C implementations have produced warnings
in this case.
C.1.6 Clause 7: declarations
7.1.1
Change: In C++, the static or extern speciﬁers can only be applied to names of objects or functions
Using these speciﬁers with type declarations is illegal in C++. In C, these speciﬁers are ignored when used
on type declarations.
Example:

[diﬀ.dcl]

§ C.1.6

1235

c(cid:13) ISO/IEC

N4296

static struct S {

int i;

};

// valid C, invalid in C++

Rationale: Storage class speciﬁers don’t have any meaning when associated with a type. In C++, class
members can be declared with the static storage class speciﬁer. Allowing storage class speciﬁers on type
declarations could render the code confusing for users.
Eﬀect on original feature: Deletion of semantically well-deﬁned feature.
Diﬃculty of converting: Syntactic transformation.
How widely used: Seldom.
7.1.3
Change: A C++ typedef name must be diﬀerent from any class type name declared in the same scope
(except if the typedef is a synonym of the class name with the same name).
In C, a typedef name and
a struct tag name declared in the same scope can have the same name (because they have diﬀerent name
spaces)
Example:

typedef struct name1 { /∗...∗/ } name1;
struct name { /∗...∗/ };
typedef int name;

// valid C, invalid C++

// valid C and C++

Rationale: For ease of use, C++ doesn’t require that a type name be preﬁxed with the keywords class,
struct or union when used in object declarations or type casts.
Example:

class name { /∗...∗/ };
name i;

// i has type class name

Eﬀect on original feature: Deletion of semantically well-deﬁned feature.
Diﬃculty of converting: Semantic transformation. One of the 2 types has to be renamed.
How widely used: Seldom.
7.1.6 [see also 3.5]
Change: const objects must be initialized in C++ but can be left uninitialized in C
Rationale: A const object cannot be assigned to so it must be initialized to hold a useful value.
Eﬀect on original feature: Deletion of semantically well-deﬁned feature.
Diﬃculty of converting: Semantic transformation.
How widely used: Seldom.
7.1.6
Change: Banning implicit int
In C++ a decl-speciﬁer-seq must contain a type-speciﬁer, unless it is followed by a declarator for a constructor,
a destructor, or a conversion function. In the following example, the left-hand column presents valid C; the
right-hand column presents equivalent C++:

void f(const parm);
const n = 3;
main()
/∗ ... ∗/

void f(const int parm);
const int n = 3;
int main()
/∗ ... ∗/

§ C.1.6

1236

c(cid:13) ISO/IEC

N4296

Rationale: In C++, implicit int creates several opportunities for ambiguity between expressions involving
function-like casts and declarations. Explicit declaration is increasingly considered to be proper style. Liaison
with WG14 (C) indicated support for (at least) deprecating implicit int in the next revision of C.
Eﬀect on original feature: Deletion of semantically well-deﬁned feature.
Diﬃculty of converting: Syntactic transformation. Could be automated.
How widely used: Common.
7.1.6.4
Change: The keyword auto cannot be used as a storage class speciﬁer.

void f() {

auto int x;

}

// valid C, invalid C++

Rationale: Allowing the use of auto to deduce the type of a variable from its initializer results in undesired
interpretations of auto as a storage class speciﬁer in certain contexts.
Eﬀect on original feature: Deletion of semantically well-deﬁned feature.
Diﬃculty of converting: Syntactic transformation.
How widely used: Rare.
7.2
Change: C++ objects of enumeration type can only be assigned values of the same enumeration type. In
C, objects of enumeration type can be assigned values of any integral type
Example:

enum color { red, blue, green };
enum color c = 1;

// valid C, invalid C++

Rationale: The type-safe nature of C++.
Eﬀect on original feature: Deletion of semantically well-deﬁned feature.
Diﬃculty of converting: Syntactic transformation. (The type error produced by the assignment can be
automatically corrected by applying an explicit cast.)
How widely used: Common.
7.2
Change: In C++, the type of an enumerator is its enumeration. In C, the type of an enumerator is int.
Example:

enum e { A };
sizeof(A) == sizeof(int)
sizeof(A) == sizeof(e)
/∗ and sizeof(int) is not necessarily equal to sizeof(e) ∗/

// in C
// in C++

Rationale: In C++, an enumeration is a distinct type.
Eﬀect on original feature: Change to semantics of well-deﬁned feature.
Diﬃculty of converting: Semantic transformation.
How widely used: Seldom. The only time this aﬀects existing C code is when the size of an enumerator
is taken. Taking the size of an enumerator is not a common C coding practice.

§ C.1.6

1237

c(cid:13) ISO/IEC

N4296

C.1.7 Clause 8: declarators
8.3.5
Change: In C++, a function declared with an empty parameter list takes no arguments. In C, an empty
parameter list means that the number and type of the function arguments are unknown.
Example:
int f();

[diﬀ.decl]

// means int f(void) in C++
// int f( unknown ) in C

Rationale: This is to avoid erroneous function calls (i.e., function calls with the wrong number or type of
arguments).
Eﬀect on original feature: Change to semantics of well-deﬁned feature. This feature was marked as
“obsolescent” in C.
Diﬃculty of converting: Syntactic transformation. The function declarations using C incomplete decla-
ration style must be completed to become full prototype declarations. A program may need to be updated
further if diﬀerent calls to the same (non-prototype) function have diﬀerent numbers of arguments or if the
type of corresponding arguments diﬀered.
How widely used: Common.
8.3.5 [see 5.3.3]
Change: In C++, types may not be deﬁned in return or parameter types. In C, these type deﬁnitions are
allowed
Example:

void f( struct S { int a; } arg ) {}
enum E { A, B, C } f() {}

// valid C, invalid C++
// valid C, invalid C++

Rationale: When comparing types in diﬀerent compilation units, C++ relies on name equivalence when
C relies on structural equivalence. Regarding parameter types: since the type deﬁned in an parameter list
would be in the scope of the function, the only legal calls in C++ would be from within the function itself.
Eﬀect on original feature: Deletion of semantically well-deﬁned feature.
Diﬃculty of converting: Semantic transformation. The type deﬁnitions must be moved to ﬁle scope, or
in header ﬁles.
How widely used: Seldom. This style of type deﬁnitions is seen as poor coding style.
8.4
Change: In C++, the syntax for function deﬁnition excludes the “old-style” C function. In C, “old-style”
syntax is allowed, but deprecated as “obsolescent.”
Rationale: Prototypes are essential to type safety.
Eﬀect on original feature: Deletion of semantically well-deﬁned feature.
Diﬃculty of converting: Syntactic transformation.
How widely used: Common in old programs, but already known to be obsolescent.
8.5.2
Change: In C++, when initializing an array of character with a string, the number of characters in the
string (including the terminating ’\0’) must not exceed the number of elements in the array. In C, an array
can be initialized with a string even if the array is not large enough to contain the string-terminating ’\0’
Example:

char array[4] = "abcd";

// valid C, invalid C++

§ C.1.7

1238

c(cid:13) ISO/IEC

N4296

Rationale: When these non-terminated arrays are manipulated by standard string routines, there is po-
tential for major catastrophe.
Eﬀect on original feature: Deletion of semantically well-deﬁned feature.
Diﬃculty of converting: Semantic transformation. The arrays must be declared one element bigger to
contain the string terminating ’\0’.
How widely used: Seldom. This style of array initialization is seen as poor coding style.
C.1.8 Clause 9: classes
9.1 [see also 7.1.3]
Change: In C++, a class declaration introduces the class name into the scope where it is declared and
hides any object, function or other declaration of that name in an enclosing scope. In C, an inner scope
declaration of a struct tag name never hides the name of an object or function in an outer scope
Example:

[diﬀ.class]

int x[99];
void f() {

}

struct x { int a; };
sizeof(x); /∗ size of the array in C ∗/
/∗ size of the struct in C++ ∗/

Rationale: This is one of the few incompatibilities between C and C++ that can be attributed to the new
C++ name space deﬁnition where a name can be declared as a type and as a non-type in a single scope
causing the non-type name to hide the type name and requiring that the keywords class, struct, union
or enum be used to refer to the type name. This new name space deﬁnition provides important notational
conveniences to C++ programmers and helps making the use of the user-deﬁned types as similar as possible
to the use of fundamental types. The advantages of the new name space deﬁnition were judged to outweigh
by far the incompatibility with C described above.
Eﬀect on original feature: Change to semantics of well-deﬁned feature.
Diﬃculty of converting: Semantic transformation. If the hidden name that needs to be accessed is at
global scope, the :: C++ operator can be used. If the hidden name is at block scope, either the type or the
struct tag has to be renamed.
How widely used: Seldom.
9.6
Change: Bit-ﬁelds of type plain int are signed.
Rationale: Leaving the choice of signedness to implementations could lead to inconsistent deﬁnitions of
template specializations. For consistency, the implementation freedom was eliminated for non-dependent
types, too.
Eﬀect on original feature: The choise is implementation-deﬁned in C, but not so in C++.
Diﬃculty of converting: Syntactic transformation.
How widely used: Seldom.
9.7
Change: In C++, the name of a nested class is local to its enclosing class. In C the name of the nested
class belongs to the same scope as the name of the outermost enclosing class.
Example:

struct X {

struct Y { /∗ ... ∗/ } y;

};

§ C.1.8

1239

c(cid:13) ISO/IEC

N4296

struct Y yy;

// valid C, invalid C++

Rationale: C++ classes have member functions which require that classes establish scopes. The C rule would
leave classes as an incomplete scope mechanism which would prevent C++ programmers from maintaining
locality within a class. A coherent set of scope rules for C++ based on the C rule would be very complicated
and C++ programmers would be unable to predict reliably the meanings of nontrivial examples involving
nested or local functions.
Eﬀect on original feature: Change of semantics of well-deﬁned feature.
Diﬃculty of converting: Semantic transformation. To make the struct type name visible in the scope of
the enclosing struct, the struct tag could be declared in the scope of the enclosing struct, before the enclosing
struct is deﬁned. Example:

struct Y;
struct X {

};

struct Y { /∗ ... ∗/ } y;

// struct Y and struct X are at the same scope

All the deﬁnitions of C struct types enclosed in other struct deﬁnitions and accessed outside the scope of
the enclosing struct could be exported to the scope of the enclosing struct. Note: this is a consequence of
the diﬀerence in scope rules, which is documented in 3.3.
How widely used: Seldom.
9.9
Change: In C++, a typedef name may not be redeclared in a class deﬁnition after being used in that
deﬁnition
Example:

typedef int I;
struct S {

I i;
int I;

};

// valid C, invalid C++

Rationale: When classes become complicated, allowing such a redeﬁnition after the type has been used
can create confusion for C++ programmers as to what the meaning of ’I’ really is.
Eﬀect on original feature: Deletion of semantically well-deﬁned feature.
Diﬃculty of converting: Semantic transformation. Either the type or the struct member has to be
renamed.
How widely used: Seldom.
C.1.9 Clause 12: special member functions
12.8
Change: Copying volatile objects
The implicitly-declared copy constructor and implicitly-declared copy assignment operator cannot make a
copy of a volatile lvalue. For example, the following is valid in ISO C:

[diﬀ.special]

struct X { int i; };
volatile struct X x1 = {0};
struct X x2(x1);
struct X x3;
x3 = x1;

// invalid C++

// also invalid C++

§ C.1.9

1240

c(cid:13) ISO/IEC

N4296

Rationale: Several alternatives were debated at length. Changing the parameter to volatile const X&
would greatly complicate the generation of eﬃcient code for class objects. Discussion of providing two
alternative signatures for these implicitly-deﬁned operations raised unanswered concerns about creating
ambiguities and complicating the rules that specify the formation of these operators according to the bases
and members.
Eﬀect on original feature: Deletion of semantically well-deﬁned feature.
Diﬃculty of converting: Semantic transformation.
If volatile semantics are required for the copy, a
user-declared constructor or assignment must be provided.
[ Note: This user-declared constructor may be
explicitly defaulted. — end note ] If non-volatile semantics are required, an explicit const_cast can be
used.
How widely used: Seldom.
C.1.10 Clause 16: preprocessing directives
16.8
Change: Whether __STDC__ is deﬁned and if so, what its value is, are implementation-deﬁned
Rationale: C++ is not identical to ISO C. Mandating that __STDC__ be deﬁned would require that
translators make an incorrect claim. Each implementation must choose the behavior that will be most
useful to its marketplace.
Eﬀect on original feature: Change to semantics of well-deﬁned feature.
Diﬃculty of converting: Semantic transformation.
How widely used: Programs and headers that reference __STDC__ are quite common.
C.2 C++ and ISO C++ 2003

[diﬀ.cpp03]
1 This subclause lists the diﬀerences between C++ and ISO C++ 2003 (ISO/IEC 14882:2003, Programming

[diﬀ.cpp]

Languages — C++), by the chapters of this document.
C.2.1 Clause 2: lexical conventions
2.4
Change: New kinds of string literals
Rationale: Required for new features.
Eﬀect on original feature: Valid C++ 2003 code may fail to compile or produce diﬀerent results in this
International Standard. Speciﬁcally, macros named R, u8, u8R, u, uR, U, UR, or LR will not be expanded when
adjacent to a string literal but will be interpreted as part of the string literal. For example,

[diﬀ.cpp03.lex]

#define u8 "abc"
const char* s = u8"def";

// Previously "abcdef", now "def"

2.4
Change: User-deﬁned literal string support
Rationale: Required for new features.
Eﬀect on original feature: Valid C++ 2003 code may fail to compile or produce diﬀerent results in this
International Standard, as the following example illustrates.

#define _x "there"
"hello"_x

// #1

Previously, #1 would have consisted of two separate preprocessing tokens and the macro _x would have
been expanded. In this International Standard, #1 consists of a single preprocessing tokens, so the macro
is not expanded.
2.11
Change: New keywords

§ C.2.1

1241

c(cid:13) ISO/IEC

N4296

Rationale: Required for new features.
Eﬀect on original feature: Added to Table 3, the following identiﬁers are new keywords: alignas,
alignof, char16_t, char32_t, constexpr, decltype, noexcept, nullptr, static_assert, and thread_-
local. Valid C++ 2003 code using these identiﬁers is invalid in this International Standard.
2.13.2
Change: Type of integer literals
Rationale: C99 compatibility.
Eﬀect on original feature: Certain integer literals larger than can be represented by long could change
from an unsigned integer type to signed long long.
C.2.2 Clause 4: standard conversions
4.10
Change: Only literals are integer null pointer constants
Rationale: Removing surprising interactions with templates and constant expressions
Eﬀect on original feature: Valid C++ 2003 code may fail to compile or produce diﬀerent results in this
International Standard, as the following example illustrates:

[diﬀ.cpp03.conv]

void f(void *); // #1
// #2
void f(...);
template<int N> void g() {

f(0*N);

}

// calls #2; used to call #1

[diﬀ.cpp03.expr]

C.2.3 Clause 5: expressions
5.6
Change: Specify rounding for results of integer / and %
Rationale: Increase portability, C99 compatibility.
Eﬀect on original feature: Valid C++ 2003 code that uses integer division rounds the result toward 0 or
toward negative inﬁnity, whereas this International Standard always rounds the result toward 0.
C.2.4 Clause 7: declarations
7.1
Change: Remove auto as a storage class speciﬁer
Rationale: New feature.
Eﬀect on original feature: Valid C++ 2003 code that uses the keyword auto as a storage class speciﬁer
may be invalid in this International Standard. In this International Standard, auto indicates that the type
of a variable is to be deduced from its initializer expression.
C.2.5 Clause 8: declarators
8.5.4
Change: Narrowing restrictions in aggregate initializers
Rationale: Catches bugs.
Eﬀect on original feature: Valid C++ 2003 code may fail to compile in this International Standard. For
example, the following code is valid in C++ 2003 but invalid in this International Standard because double
to int is a narrowing conversion:

[diﬀ.cpp03.dcl.decl]

[diﬀ.cpp03.dcl.dcl]

int x[] = { 2.0 };

C.2.6 Clause 12: special member functions
12.1, 12.4, 12.8
Change: Implicitly-declared special member functions are deﬁned as deleted when the implicit deﬁnition

[diﬀ.cpp03.special]

§ C.2.6

1242

c(cid:13) ISO/IEC

N4296

would have been ill-formed.
Rationale: Improves template argument deduction failure.
Eﬀect on original feature: A valid C++ 2003 program that uses one of these special member functions
in a context where the deﬁnition is not required (e.g., in an expression that is not potentially evaluated)
becomes ill-formed.
12.4 (destructors)
Change: User-declared destructors have an implicit exception speciﬁcation.
Rationale: Clariﬁcation of destructor requirements.
Eﬀect on original feature: Valid C++ 2003 code may execute diﬀerently in this International Standard. In
particular, destructors that throw exceptions will call std::terminate() (without calling std::unexpected())
if their exception speciﬁcation is noexcept or noexcept(true). For a throwing virtual destructor of a de-
rived class, std::terminate() can be avoided only if the base class virtual destructor has an exception
speciﬁcation that is not noexcept and not noexcept(true).
C.2.7 Clause 14: templates
14.1
Change: Remove export
Rationale: No implementation consensus.
Eﬀect on original feature: A valid C++ 2003 declaration containing export is ill-formed in this Interna-
tional Standard.
14.3
Change: Remove whitespace requirement for nested closing template right angle brackets
Rationale: Considered a persistent but minor annoyance. Template aliases representing nonclass types
would exacerbate whitespace issues.
Eﬀect on original feature: Change to semantics of well-deﬁned expression. A valid C++ 2003 expression
containing a right angle bracket (“>”) followed immediately by another right angle bracket may now be
treated as closing two templates. For example, the following code is valid in C++ 2003 because “>>” is a
right-shift operator, but invalid in this International Standard because “>>” closes two templates.

[diﬀ.cpp03.temp]

template <class T> struct X { };
template <int N> struct Y { };
X< Y< 1 >> 2 > > x;

14.6.4.2
Change: Allow dependent calls of functions with internal linkage
Rationale: Overly constrained, simplify overload resolution rules.
Eﬀect on original feature: A valid C++ 2003 program could get a diﬀerent result than this International
Standard.
C.2.8 Clause 17: library introduction
17 – 30
Change: New reserved identiﬁers
Rationale: Required by new features.
Eﬀect on original feature: Valid C++ 2003 code that uses any identiﬁers added to the C++ standard
library by this International Standard may fail to compile or produce diﬀerent results in This International
Standard. A comprehensive list of identiﬁers used by the C++ standard library can be found in the Index
of Library Names in this International Standard.
17.6.1.2
Change: New headers
Rationale: New functionality.

[diﬀ.cpp03.library]

§ C.2.8

1243

c(cid:13) ISO/IEC

N4296

Eﬀect on original feature: The following C++ headers are new: <array>, <atomic>, <chrono>, <codecvt>,
<condition_variable>, <forward_list>, <future>, <initializer_list>, <mutex>, <random>, <ratio>,
<regex>, <scoped_allocator>, <system_error>, <thread>, <tuple>, <typeindex>, <type_traits>,
<unordered_map>, and <unordered_set>.
In addition the following C compatibility headers are new:
<ccomplex>, <cfenv>, <cinttypes>, <cstdalign>, <cstdbool>, <cstdint>, <ctgmath>, and <cuchar>.
Valid C++ 2003 code that #includes headers with these names may be invalid in this International Stan-
dard.
17.6.3.2
Eﬀect on original feature: Function swap moved to a diﬀerent header
Rationale: Remove dependency on <algorithm> for swap.
Eﬀect on original feature: Valid C++ 2003 code that has been compiled expecting swap to be in
<algorithm> may have to instead include <utility>.
17.6.4.2.2
Change: New reserved namespace
Rationale: New functionality.
Eﬀect on original feature: The global namespace posix is now reserved for standardization. Valid C++
2003 code that uses a top-level namespace posix may be invalid in this International Standard.
17.6.5.3
Change: Additional restrictions on macro names
Rationale: Avoid hard to diagnose or non-portable constructs.
Eﬀect on original feature: Names of attribute identiﬁers may not be used as macro names. Valid C++
2003 code that deﬁnes override, final, carries_dependency, or noreturn as macros is invalid in this
International Standard.
C.2.9 Clause 18: language support library
18.6.1.1
Change: Linking new and delete operators
Rationale: The two throwing single-object signatures of operator new and operator delete are now
speciﬁed to form the base functionality for the other operators. This clariﬁes that replacing just these two
signatures changes others, even if they are not explicitly changed.
Eﬀect on original feature: Valid C++ 2003 code that replaces global new or delete operators may
execute diﬀerently in this International Standard. For example, the following program should write "custom
deallocation" twice, once for the single-object delete and once for the array delete.

[diﬀ.cpp03.language.support]

#include <cstdio>
#include <cstdlib>
#include <new>

void* operator new(std::size_t size) throw(std::bad_alloc) {

return std::malloc(size);

}

}

void operator delete(void* ptr) throw() {

std::puts("custom deallocation");
std::free(ptr);

int main() {

int* i = new int;
delete i;
int* a = new int[3];
delete [] a;

§ C.2.9

// single-object delete

// array delete

1244

c(cid:13) ISO/IEC

return 0;

}

N4296

[diﬀ.cpp03.diagnostics]

18.6.1.1
Change: operator new may throw exceptions other than std::bad_alloc
Rationale: Consistent application of noexcept.
Eﬀect on original feature: Valid C++ 2003 code that assumes that global operator new only throws
std::bad_alloc may execute diﬀerently in this International Standard.
C.2.10 Clause 19: diagnostics library
19.4
Change: Thread-local error numbers
Rationale: Support for new thread facilities.
Eﬀect on original feature: Valid but implementation-speciﬁc C++ 2003 code that relies on errno being
the same across threads may change behavior in this International Standard.
C.2.11 Clause 20: general utilities library
20.7.4
Change: Minimal support for garbage-collected regions
Rationale: Required by new feature.
Eﬀect on original feature: Valid C++ 2003 code, compiled without traceable pointer support, that
interacts with newer C++ code using regions declared reachable may have diﬀerent runtime behavior.
20.9.4, 20.9.5, 20.9.6, 20.9.7, 20.9.8, 20.9.9
Change: Standard function object types no longer derived from std::unary_function or std::binary_-
function
Rationale: Superseded by new feature; unary_function and binary_function are no longer deﬁned.
Eﬀect on original feature: Valid C++ 2003 code that depends on function object types being derived
from unary_function or binary_function may fail to compile in this International Standard.
C.2.12 Clause 21: strings library
21.3
Change: basic_string requirements no longer allow reference-counted strings
Rationale: Invalidation is subtly diﬀerent with reference-counted strings. This change regularizes behavior
for this International Standard.
Eﬀect on original feature: Valid C++ 2003 code may execute diﬀerently in this International Standard.
21.4.1
Change: Loosen basic_string invalidation rules
Rationale: Allow small-string optimization.
Eﬀect on original feature: Valid C++ 2003 code may execute diﬀerently in this International Standard.
Some const member functions, such as data and c_str, no longer invalidate iterators.
C.2.13 Clause 23: containers library
23.2
Change: Complexity of size() member functions now constant
Rationale: Lack of speciﬁcation of complexity of size() resulted in divergent implementations with in-
consistent performance characteristics.
Eﬀect on original feature: Some container implementations that conform to C++ 2003 may not conform
to the speciﬁed size() requirements in this International Standard. Adjusting containers such as std::list
to the stricter requirements may require incompatible changes.

[diﬀ.cpp03.containers]

[diﬀ.cpp03.utilities]

[diﬀ.cpp03.strings]

§ C.2.13

1245

c(cid:13) ISO/IEC

N4296

23.2
Change: Requirements change: relaxation
Rationale: Clariﬁcation.
Eﬀect on original feature: Valid C++ 2003 code that attempts to meet the speciﬁed container require-
ments may now be over-speciﬁed. Code that attempted to be portable across containers may need to be
adjusted as follows:

— not all containers provide size(); use empty() instead of size() == 0;
— not all containers are empty after construction (array);
— not all containers have constant complexity for swap() (array).

23.2
Change: Requirements change: default constructible
Rationale: Clariﬁcation of container requirements.
Eﬀect on original feature: Valid C++ 2003 code that attempts to explicitly instantiate a container using
a user-deﬁned type with no default constructor may fail to compile.
23.2.3, 23.2.4
Change: Signature changes: from void return types
Rationale: Old signature threw away useful information that may be expensive to recalculate.
Eﬀect on original feature: The following member functions have changed:

— erase(iter) for set, multiset, map, multimap
— erase(begin, end) for set, multiset, map, multimap
— insert(pos, num, val) for vector, deque, list, forward_list
— insert(pos, beg, end) for vector, deque, list, forward_list

Valid C++ 2003 code that relies on these functions returning void (e.g., code that creates a pointer to
member function that points to one of these functions) will fail to compile with this International Standard.
23.2.3, 23.2.4
Change: Signature changes: from iterator to const_iterator parameters
Rationale: Overspeciﬁcation. Eﬀects: The signatures of the following member functions changed from
taking an iterator to taking a const_iterator:

— insert(iter, val) for vector, deque, list, set, multiset, map, multimap
— insert(pos, beg, end) for vector, deque, list, forward_list
— erase(iter) for set, multiset, map, multimap
— erase(begin, end) for set, multiset, map, multimap
— all forms of list::splice
— all forms of list::merge

Valid C++ 2003 code that uses these functions may fail to compile with this International Standard.
23.2.3, 23.2.4
Change: Signature changes: resize
Rationale: Performance, compatibility with move semantics.
Eﬀect on original feature: For vector, deque, and list the ﬁll value passed to resize is now passed by
reference instead of by value, and an additional overload of resize has been added. Valid C++ 2003 code
that uses this function may fail to compile with this International Standard.

§ C.2.13

1246

c(cid:13) ISO/IEC

N4296

[diﬀ.cpp03.algorithms]

C.2.14 Clause 25: algorithms library
25.1
Change: Result state of inputs after application of some algorithms
Rationale: Required by new feature.
Eﬀect on original feature: A valid C++ 2003 program may detect that an object with a valid but
unspeciﬁed state has a diﬀerent valid but unspeciﬁed state with this International Standard. For example,
std::remove and std::remove_if may leave the tail of the input sequence with a diﬀerent set of values
than previously.
C.2.15 Clause 26: numerics library
26.4
Change: Speciﬁed representation of complex numbers
Rationale: Compatibility with C99.
Eﬀect on original feature: Valid C++ 2003 code that uses implementation-speciﬁc knowledge about the
binary representation of the required template specializations of std::complex may not be compatible with
this International Standard.
C.2.16 Clause 27: Input/output library
27.7.2.1.3, 27.7.3.4, 27.5.5.4
Change: Specify use of explicit in existing boolean conversion operators
Rationale: Clarify intentions, avoid workarounds.
Eﬀect on original feature: Valid C++ 2003 code that relies on implicit boolean conversions will fail to
compile with this International Standard. Such conversions occur in the following conditions:

[diﬀ.cpp03.input.output]

[diﬀ.cpp03.numerics]

— passing a value to a function that takes an argument of type bool;
— using operator== to compare to false or true;
— returning a value from a function with a return type of bool;
— initializing members of type bool via aggregate initialization;
— initializing a const bool& which would bind to a temporary.

27.5.3.1.1
Change: Change base class of std::ios_base::failure
Rationale: More detailed error messages.
Eﬀect on original feature: std::ios_base::failure is no longer derived directly from std::exception,
but is now derived from std::system_error, which in turn is derived from std::runtime_error. Valid
C++ 2003 code that assumes that std::ios_base::failure is derived directly from std::exception may
execute diﬀerently in this International Standard.
27.5.3
Change: Flag types in std::ios_base are now bitmasks with values deﬁned as constexpr static members
Rationale: Required for new features.
Eﬀect on original feature: Valid C++ 2003 code that relies on std::ios_base ﬂag types being represented
as std::bitset or as an integer type may fail to compile with this International Standard. For example:

#include <iostream>

int main() {

int flag = std::ios_base::hex;
std::cout.setf(flag);
return 0;

}

// error: setf does not take argument of type int

§ C.2.16

1247

c(cid:13) ISO/IEC

N4296

C.3 C++ and ISO C++ 2011

[diﬀ.cpp11]
1 This subclause lists the diﬀerences between C++ and ISO C++ 2011 (ISO/IEC 14882:2011, Programming

Languages — C++), by the chapters of this document.
C.3.1 Clause 2: lexical conventions
2.9
Change: pp-number can contain one or more single quotes.
Rationale: Necessary to enable single quotes as digit separators.
Eﬀect on original feature: Valid C++ 2011 code may fail to compile or may change meaning in this
International Standard. For example, the following code is valid both in C++ 2011 and in this International
Standard, but the macro invocation produces diﬀerent outcomes because the single quotes delimit a character
literal in C++ 2011, whereas they are digit separators in this International Standard:

[diﬀ.cpp11.lex]

#define M(x, ...) __VA_ARGS__
int x[2] = { M(1’2,3’4) };
// int x[2] = {};
// int x[2] = { 3’4 }; — this International Standard

— C++ 2011

C.3.2 Clause 3: basic concepts
3.7.4.2
Change: New usual (non-placement) deallocator
Rationale: Required for sized deallocation.
Eﬀect on original feature: Valid C++ 2011 code could declare a global placement allocation function and
deallocation function as follows:

[diﬀ.cpp11.basic]

void operator new(std::size_t, std::size_t);
void operator delete(void*, std::size_t) noexcept;

In this International Standard, however, the declaration of operator delete might match a predeﬁned
usual (non-placement) operator delete (3.7.4). If so, the program is ill-formed, as it was for class member
allocation functions and deallocation functions (5.3.4).
C.3.3 Clause 7: declarations
7.1.5
Change: constexpr non-static member functions are not implicitly const member functions.
Rationale: Necessary to allow constexpr member functions to mutate the object.
Eﬀect on original feature: Valid C++ 2011 code may fail to compile in this International Standard.
For example, the following code is valid in C++ 2011 but invalid in this International Standard because it
declares the same member function twice with diﬀerent return types:

[diﬀ.cpp11.dcl.dcl]

struct S {

constexpr const int &f();
int &f();

};

C.3.4 Clause 27: input/output library
27.9.2
Change: gets is not deﬁned.
Rationale: Use of gets is considered dangerous.
Eﬀect on original feature: Valid C++ 2011 code that uses the gets function may fail to compile in this
International Standard.

[diﬀ.cpp11.input.output]

§ C.3.4

1248

c(cid:13) ISO/IEC

N4296

C.4 C++ and ISO C++ 2014

[diﬀ.cpp14]
1 This subclause lists the diﬀerences between C++ and ISO C++ 2014 (ISO/IEC 14882:2014, Programming

Languages — C++), by the chapters of this document.
C.4.1 Clause 2: lexical conventions
2.2
Change: Removal of trigraph support as a required feature.
Rationale: Prevents accidental uses of trigraphs in non-raw string literals and comments.
Eﬀect on original feature: Valid C++ 2014 code that uses trigraphs may not be valid or may have diﬀerent
semantics in this International Standard. Implementations may choose to translate trigraphs as speciﬁed in
C++ 2014 if they appear outside of a raw string literal, as part of the implementation-deﬁned mapping from
physical source ﬁle characters to the basic source character set.
C.4.2 Annex D: compatibility features

[diﬀ.cpp14.depr]

[diﬀ.cpp14.lex]

Change: The class templates auto_ptr, unary_function, and binary_function, the function templates
random_shuffle, and the function templates (and their return types) ptr_fun, mem_fun, mem_fun_ref,
bind1st, and bind2nd are not deﬁned.
Rationale: Superseded by new features.
Eﬀect on original feature: Valid C++ 2014 code that uses these class templates and function templates
may fail to compile in this International Standard.
C.5 C standard library

[diﬀ.library]
1 This subclause summarizes the contents of the C++ standard library included from the Standard C library.
It also summarizes the explicit changes in deﬁnitions, declarations, or behavior from the Standard C library
noted in other subclauses (17.6.1.2, 18.2, 21.8).

2 The C++ standard library provides 57 standard macros from the C library, as shown in Table 150.
3 The header names (enclosed in < and >) indicate that the macro may be deﬁned in more than one header.

All such deﬁnitions are equivalent (3.2).

assert
BUFSIZ
CLOCKS_PER_SEC
EDOM
EILSEQ
EOF
ERANGE
errno
EXIT_FAILURE
EXIT_SUCCESS
FILENAME_MAX
FOPEN_MAX

Table 150 — Standard macros

HUGE_VAL
LC_ALL
LC_COLLATE
LC_CTYPE
LC_MONETARY
LC_NUMERIC
LC_TIME
L_tmpnam
MB_CUR_MAX
NULL <clocale>
NULL <cstddef>
NULL <cstdlib>

NULL <cstring>
NULL <ctime>
NULL <cwchar>
offsetof
RAND_MAX
SEEK_CUR
SEEK_END
SEEK_SET
setjmp
SIGABRT
SIGFPE
SIGILL

SIGINT
SIGSEGV
SIGTERM
SIG_DFL
SIG_ERR
SIG_IGN
stderr
stdin
stdout
TMP_MAX
va_arg
va_copy

va_end
va_start
WCHAR_MAX
WCHAR_MIN
WEOF <cwchar>
WEOF <cwctype>
_IOFBF
_IOLBF
_IONBF

4 The C++ standard library provides 57 standard values from the C library, as shown in Table 151.
5 The C++ standard library provides 20 standard types from the C library, as shown in Table 152.
6 The C++ standard library provides 2 standard structs from the C library, as shown in Table 153.
7 The C++ standard library provides 209 standard functions from the C library, as shown in Table 154.

§ C.5

1249

c(cid:13) ISO/IEC

N4296

CHAR_BIT
CHAR_MAX
CHAR_MIN
DBL_DIG
DBL_EPSILON
DBL_MANT_DIG
DBL_MAX
DBL_MAX_10_EXP
DBL_MAX_EXP
DBL_MIN
DBL_MIN_10_EXP
DBL_MIN_EXP

Table 151 — Standard values

FLT_DIG
FLT_EPSILON
FLT_MANT_DIG
FLT_MAX
FLT_MAX_10_EXP
FLT_MAX_EXP
FLT_MIN
FLT_MIN_10_EXP
FLT_MIN_EXP
FLT_RADIX
FLT_ROUNDS
INT_MAX

INT_MIN
LDBL_DIG
LDBL_EPSILON
LDBL_MANT_DIG
LDBL_MAX
LDBL_MAX_10_EXP
LDBL_MAX_EXP
LDBL_MIN
LDBL_MIN_10_EXP
LDBL_MIN_EXP
LONG_MAX
LONG_MIN

MB_LEN_MAX
SCHAR_MAX
SCHAR_MIN
SHRT_MAX
SHRT_MIN
UCHAR_MAX
UINT_MAX
ULONG_MAX
USHRT_MAX

Table 152 — Standard types
size_t <cstdio>
size_t <cstdlib>
size_t <cstring>
size_t <ctime>
time_t

ldiv_t
mbstate_t
ptrdiff_t
sig_atomic_t
size_t <cstddef>

clock_t
div_t
FILE
fpos_t
jmp_buf

va_list
wctrans_t
wctype_t
wint_t <cwchar>
wint_t <cwctype>

Table 153 — Standard structs

lconv

tm

C.5.1 Modiﬁcations to headers

[diﬀ.mods.to.headers]
1 For compatibility with the Standard C library, the C++ standard library provides the C headers enumerated

in D.5, but their use is deprecated in C++.
C.5.2 Modiﬁcations to deﬁnitions
C.5.2.1 Types char16_t and char32_t

[diﬀ.mods.to.deﬁnitions]
[diﬀ.char16]

1 The types char16_t and char32_t are distinct types rather than typedefs to existing integral types.

C.5.2.2 Type wchar_t

[diﬀ.wchar.t]
1 wchar_t is a keyword in this International Standard (2.11). It does not appear as a type name deﬁned in

any of <cstddef>, <cstdlib>, or <cwchar> (21.8).
C.5.2.3 Header <iso646.h>

[diﬀ.header.iso646.h]
1 The tokens and, and_eq, bitand, bitor, compl, not_eq, not, or, or_eq, xor, and xor_eq are keywords in

this International Standard (2.11). They do not appear as macro names deﬁned in <ciso646>.
C.5.2.4 Macro NULL

[diﬀ.null]
1 The macro NULL, deﬁned in any of <clocale>, <cstddef>, <cstdio>, <cstdlib>, <cstring>, <ctime>, or

<cwchar>, is an implementation-deﬁned C++ null pointer constant in this International Standard (18.2).
C.5.3 Modiﬁcations to declarations

[diﬀ.mods.to.declarations]

1 Header <cstring>: The following functions have diﬀerent declarations:

§ C.5.3

1250

c(cid:13) ISO/IEC

N4296

Table 154 — Standard functions

abort
abs
acos
asctime
asin
atan
atan2
atexit
atof
atoi
atol
bsearch
btowc
calloc
ceil
clearerr
clock
cos
cosh
ctime
difftime
div
exit
exp
fabs
fclose
feof
ferror
fflush
fgetc
fgetpos
fgets
fgetwc
fgetws
floor

fmod
fopen
fprintf
fputc
fputs
fputwc
fputws
fread
free
freopen
frexp
fscanf
fseek
fsetpos
ftell
fwide
fwprintf
fwrite
fwscanf
getc
getchar
getenv
getwc
getwchar
gmtime
isalnum
isalpha
iscntrl
isdigit
isgraph
islower
isprint
ispunct
isspace
isupper

iswalnum
iswalpha
iswcntrl
iswctype
iswdigit
iswgraph
iswlower
iswprint
iswpunct
iswspace
iswupper
iswxdigit
isxdigit
labs
ldexp
ldiv
localeconv
localtime
log
log10
longjmp
malloc
mblen
mbrlen
mbrtowc
mbsinit
mbsrtowcs
mbstowcs
mbtowc
memchr
memcmp
memcpy
memmove
memset
mktime

modf
perror
pow
printf
putc
putchar
puts
putwc
putwchar
qsort
raise
rand
realloc
remove
rename
rewind
scanf
setbuf
setlocale
setvbuf
signal
sin
sinh
sprintf
sqrt
srand
sscanf
strcat
strchr
strcmp
strcoll
strcpy
strcspn
strerror
strftime

strlen
strncat
strncmp
strncpy
strpbrk
strrchr
strspn
strstr
strtod
strtok
strtol
strtoul
strxfrm
swprintf
swscanf
system
tan
tanh
time
tmpfile
tmpnam
tolower
toupper
towctrans
towlower
towupper
ungetc
ungetwc
vfprintf
vfwprintf
vprintf
vsprintf
vswprintf
vwprintf
wcrtomb

wcscat
wcschr
wcscmp
wcscoll
wcscpy
wcscspn
wcsftime
wcslen
wcsncat
wcsncmp
wcsncpy
wcspbrk
wcsrchr
wcsrtombs
wcsspn
wcsstr
wcstod
wcstok
wcstol
wcstombs
wcstoul
wcsxfrm
wctob
wctomb
wctrans
wctype
wmemchr
wmemcmp
wmemcpy
wmemmove
wmemset
wprintf
wscanf

§ C.5.3

1251

c(cid:13) ISO/IEC

(1.1)

(1.2)

(1.3)

(1.4)

(1.5)

—
—
—
—
—

strchr

strpbrk

strrchr

strstr

memchr

N4296

21.8 describes the changes.
C.5.4 Modiﬁcations to behavior

1 Header <cstdlib>: The following functions have diﬀerent behavior:

[diﬀ.mods.to.behavior]

(1.1)

(1.2)

(1.3)

—
—
—

atexit

exit

abort

18.5 describes the changes.

2 Header <csetjmp>: The following functions have diﬀerent behavior:

(2.1)

—

longjmp

18.10 describes the changes.
C.5.4.1 Macro offsetof(type, member-designator)

[diﬀ.oﬀsetof]
1 The macro offsetof, deﬁned in <cstddef>, accepts a restricted set of type arguments in this International

Standard. 18.2 describes the change.
C.5.4.2 Memory allocation functions

[diﬀ.malloc]
1 The functions calloc, malloc, and realloc are restricted in this International Standard. 20.7.13 describes

the changes.

§ C.5.4.2

1252

c(cid:13) ISO/IEC

Annex D (normative)
Compatibility features

N4296

[depr]

1 This Clause describes features of the C++ Standard that are speciﬁed for compatibility with existing imple-

mentations.

2 These are deprecated features, where deprecated is deﬁned as: Normative for the current edition of the
Standard, but having been identiﬁed as a candidate for removal from future revisions. An implementation
may declare library names and entities described in this section with the deprecated attribute (7.6.5).
D.1

Increment operator with bool operand

[depr.incr.bool]

1 The use of an operand of type bool with the ++ operator is deprecated (see 5.3.2 and 5.2.6).

D.2 register keyword

1 The use of the register keyword as a storage-class-speciﬁer (7.1.1) is deprecated.

[depr.register]

D.3

Implicit declaration of copy functions

[depr.impldec]
1 The implicit deﬁnition of a copy constructor as defaulted is deprecated if the class has a user-declared copy
assignment operator or a user-declared destructor. The implicit deﬁnition of a copy assignment operator
as defaulted is deprecated if the class has a user-declared copy constructor or a user-declared destructor
(12.4, 12.8).
In a future revision of this International Standard, these implicit deﬁnitions could become
deleted (8.4).
D.4 Dynamic exception speciﬁcations

[depr.except.spec]

1 The use of dynamic-exception-speciﬁcations is deprecated.

D.5 C standard library headers

[depr.c.headers]
1 For compatibility with the C standard library and the C Unicode TR, the C++ standard library provides

the 26 C headers, as shown in Table 155.

Table 155 — C headers

<assert.h>
<complex.h>
<ctype.h>
<errno.h>
<fenv.h>
<float.h>

<inttypes.h>
<iso646.h>
<limits.h>
<locale.h>
<math.h>
<setjmp.h>

<signal.h>
<stdalign.h>
<stdarg.h>
<stdbool.h>
<stddef.h>
<stdint.h>

<stdio.h>
<stdlib.h>
<string.h>
<tgmath.h>
<time.h>
<uchar.h>

<wchar.h>
<wctype.h>

2 Every C header, each of which has a name of the form name.h, behaves as if each name placed in the standard
library namespace by the corresponding cname header is placed within the global namespace scope. It is
unspeciﬁed whether these names are ﬁrst declared or deﬁned within namespace scope (3.3.6) of the namespace
std and are then injected into the global namespace scope by explicit using-declarations (7.3.3).
[ Example: The header <cstdlib> assuredly provides its declarations and deﬁnitions within the namespace
std.
It may also provide these names within the global namespace. The header <stdlib.h> assuredly
provides the same declarations and deﬁnitions within the global namespace, much as in the C Standard. It
may also provide these names within the namespace std. — end example ]

3

§ D.5

1253

c(cid:13) ISO/IEC

N4296

D.6 Old iostreams members

[depr.ios.members]

1 The following member names are in addition to names speciﬁed in Clause 27:

namespace std {

class ios_base {
public:

typedef T1 io_state;
typedef T2 open_mode;
typedef T3 seek_dir;
typedef implementation-defined streamoff;
typedef implementation-defined streampos;
// remainder unchanged

2 The type io_state is a synonym for an integer type (indicated here as T1 ) that permits certain member

functions to overload others on parameters of type iostate and provide the same behavior.

3 The type open_mode is a synonym for an integer type (indicated here as T2 ) that permits certain member

functions to overload others on parameters of type openmode and provide the same behavior.

4 The type seek_dir is a synonym for an integer type (indicated here as T3 ) that permits certain member

functions to overload others on parameters of type seekdir and provide the same behavior.

5 The type streamoff is an implementation-deﬁned type that satisﬁes the requirements of oﬀ_type in 27.2.2.
6 The type streampos is an implementation-deﬁned type that satisﬁes the requirements of pos_type in 27.2.2.
7 An implementation may provide the following additional member function, which has the eﬀect of calling

sbumpc() (27.6.3.2.3):

namespace std {

template<class charT, class traits = char_traits<charT> >
class basic_streambuf {
public:

void stossc();
// remainder unchanged

8 An implementation may provide the following member functions that overload signatures speciﬁed in Clause 27:

};

}

};

}

};

};

namespace std {

template<class charT, class traits> class basic_ios {
public:

void clear(io_state state);
void setstate(io_state state);
void exceptions(io_state);
// remainder unchanged

class ios_base {
public:

// remainder unchanged

template<class charT, class traits = char_traits<charT> >
class basic_streambuf {
public:

§ D.6

1254

c(cid:13) ISO/IEC

N4296

pos_type pubseekoff(off_type off, ios_base::seek_dir way,

ios_base::open_mode which = ios_base::in | ios_base::out);

pos_type pubseekpos(pos_type sp,

ios_base::open_mode which);

// remainder unchanged

};

};

template <class charT, class traits = char_traits<charT> >
class basic_filebuf : public basic_streambuf<charT,traits> {
public:

basic_filebuf<charT,traits>* open
(const char* s, ios_base::open_mode mode);
// remainder unchanged

template <class charT, class traits = char_traits<charT> >
class basic_ifstream : public basic_istream<charT,traits> {
public:

void open(const char* s, ios_base::open_mode mode);
// remainder unchanged

};

template <class charT, class traits = char_traits<charT> >
class basic_ofstream : public basic_ostream<charT,traits> {
public:

void open(const char* s, ios_base::open_mode mode);
// remainder unchanged

};

}

9 The eﬀects of these functions is to call the corresponding member function speciﬁed in Clause 27.

D.7 char* streams

[depr.str.strstreams]
1 The header <strstream> deﬁnes three types that associate stream buﬀers with character array objects and

assist reading and writing such objects.
D.7.1 Class strstreambuf

namespace std {

class strstreambuf : public basic_streambuf<char> {
public:

explicit strstreambuf(streamsize alsize_arg = 0);
strstreambuf(void* (*palloc_arg)(size_t), void (*pfree_arg)(void*));
strstreambuf(char* gnext_arg, streamsize n, char* pbeg_arg = 0);
strstreambuf(const char* gnext_arg, streamsize n);

[depr.strstreambuf]

strstreambuf(signed char* gnext_arg, streamsize n,

signed char* pbeg_arg = 0);

strstreambuf(const signed char* gnext_arg, streamsize n);
strstreambuf(unsigned char* gnext_arg, streamsize n,

unsigned char* pbeg_arg = 0);

strstreambuf(const unsigned char* gnext_arg, streamsize n);

virtual ~strstreambuf();

§ D.7.1

1255

c(cid:13) ISO/IEC

N4296

freeze(bool freezefl = true);

void
char* str();
int

pcount();

protected:

virtual int_type overflow (int_type c = EOF);
virtual int_type pbackfail(int_type c = EOF);
virtual int_type underflow();
virtual pos_type seekoff(off_type off, ios_base::seekdir way,

ios_base::openmode which

= ios_base::in | ios_base::out);

virtual pos_type seekpos(pos_type sp, ios_base::openmode which

= ios_base::in | ios_base::out);

virtual streambuf* setbuf(char* s, streamsize n);

private:

// exposition only
typedef T1 strstate;
static const strstate allocated; // exposition only
// exposition only
static const strstate constant;
// exposition only
static const strstate dynamic;
// exposition only
static const strstate frozen;
// exposition only
strstate strmode;
// exposition only
streamsize alsize;
// exposition only
void* (*palloc)(size_t);
// exposition only
void (*pfree)(void*);

};

}

1 The class strstreambuf associates the input sequence, and possibly the output sequence, with an object of
some character array type, whose elements store arbitrary values. The array object has several attributes.
[ Note: For the sake of exposition, these are represented as elements of a bitmask type (indicated here as
T1) called strstate. The elements are:

2

(2.1)

(2.2)

(2.3)

(2.4)

—

—
—

—

allocated, set when a dynamic array object has been allocated, and hence should be freed by the
destructor for the strstreambuf object;
constant, set when the array object has const elements, so the output sequence cannot be written;
dynamic, set when the array object is allocated (or reallocated) as necessary to hold a character
sequence that can change in length;
frozen, set when the program has requested that the array object not be altered, reallocated, or freed.

— end note ]
[ Note: For the sake of exposition, the maintained data is presented here as:

3

(3.1)

(3.2)

(3.3)

(3.4)

—
—
—
—

strstate strmode, the attributes of the array object associated with the strstreambuf object;
int alsize, the suggested minimum size for a dynamic array object;
void* (*palloc)(size_t), points to the function to call to allocate a dynamic array object;
void (*pfree)(void*), points to the function to call to free a dynamic array object.

§ D.7.1

1256

c(cid:13) ISO/IEC

— end note ]

N4296

4 Each object of class strstreambuf has a seekable area, delimited by the pointers seeklow and seekhigh.
If gnext is a null pointer, the seekable area is undeﬁned. Otherwise, seeklow equals gbeg and seekhigh is
either pend, if pend is not a null pointer, or gend.
D.7.1.1 strstreambuf constructors
explicit strstreambuf(streamsize alsize_arg = 0);

[depr.strstreambuf.cons]

1

2

3

4

Eﬀects: Constructs an object of class strstreambuf, initializing the base class with streambuf().
The postconditions of this function are indicated in Table 156.

Table 156 — strstreambuf(streamsize) eﬀects

Element
strmode
alsize
palloc
pfree

Value
dynamic
alsize_arg
a null pointer
a null pointer

strstreambuf(void* (*palloc_arg)(size_t), void (*pfree_arg)(void*));

Eﬀects: Constructs an object of class strstreambuf, initializing the base class with streambuf().
The postconditions of this function are indicated in Table 157.

Table 157 — strstreambuf(void* (*)(size_t), void (*)(void*)) eﬀects

Element
strmode
alsize
palloc
pfree

Value

dynamic
an unspeciﬁed value
palloc_arg
pfree_arg

strstreambuf(char* gnext_arg, streamsize n, char* pbeg_arg = 0);
strstreambuf(signed char* gnext_arg, streamsize n,

signed char* pbeg_arg = 0);

strstreambuf(unsigned char* gnext_arg, streamsize n,

unsigned char* pbeg_arg = 0);

Eﬀects: Constructs an object of class strstreambuf, initializing the base class with streambuf().
The postconditions of this function are indicated in Table 158.

Table 158 — strstreambuf(charT*, streamsize, charT*) eﬀects

Element
strmode
alsize
palloc
pfree

Value

0
an unspeciﬁed value
a null pointer
a null pointer

gnext_arg shall point to the ﬁrst element of an array object whose number of elements N is determined
as follows:

§ D.7.1.1

1257

c(cid:13) ISO/IEC

N4296

(4.1)

(4.2)

(4.3)

5

6

7

8

1

(1.1)

(1.2)

2

3

4

1

(1.1)

If n > 0, N is n.
If n == 0, N is std::strlen(gnext_arg).
If n < 0, N is INT_MAX.338

—
—
—
If pbeg_arg is a null pointer, the function executes:

setg(gnext_arg, gnext_arg, gnext_arg + N);
Otherwise, the function executes:

setg(gnext_arg, gnext_arg, pbeg_arg);
setp(pbeg_arg,

pbeg_arg + N);

strstreambuf(const char* gnext_arg, streamsize n);
strstreambuf(const signed char* gnext_arg, streamsize n);
strstreambuf(const unsigned char* gnext_arg, streamsize n);

Eﬀects: Behaves the same as strstreambuf((char*)gnext_arg,n), except that the constructor also
sets constant in strmode.

virtual ~strstreambuf();

Eﬀects: Destroys an object of class strstreambuf. The function frees the dynamically allocated array
object only if strmode & allocated != 0 and strmode & frozen == 0. (D.7.1.3 describes how a
dynamically allocated array object is freed.)

D.7.1.2 Member functions
void freeze(bool freezefl = true);

[depr.strstreambuf.members]

Eﬀects: If strmode & dynamic is non-zero, alters the freeze status of the dynamic array object as
follows:
—
—

If freezefl is true, the function sets frozen in strmode.
Otherwise, it clears frozen in strmode.

char* str();

Eﬀects: Calls freeze(), then returns the beginning pointer for the input sequence, gbeg.
Remarks: The return value can be a null pointer.

int pcount() const;

Eﬀects: If the next pointer for the output sequence, pnext, is a null pointer, returns zero. Otherwise,
returns the current eﬀective length of the array object as the next pointer minus the beginning pointer
for the output sequence, pnext - pbeg.

D.7.1.3 strstreambuf overridden virtual functions
int_type overflow(int_type c = EOF);

[depr.strstreambuf.virtuals]

Eﬀects: Appends the character designated by c to the output sequence, if possible, in one of two ways:
If c != EOF and if either the output sequence has a write position available or the function makes
—
a write position available (as described below), assigns c to *pnext++.
Returns (unsigned char)c.

338) The function signature strlen(const char*) is declared in <cstring>.
<climits> (18.3).

(21.8). The macro INT_MAX is deﬁned in

§ D.7.1.3

1258

c(cid:13) ISO/IEC

N4296

(1.2)

—

If c == EOF, there is no character to append.
Returns a value other than EOF.

2

3

4

5

6

7

(7.1)

(7.2)

(7.3)

8

9

10

(10.1)

(10.2)

Returns EOF to indicate failure.
Remarks: The function can alter the number of write positions available as a result of any call.
To make a write position available, the function reallocates (or initially allocates) an array object with
a suﬃcient number of elements n to hold the current array object (if any), plus at least one additional
write position. How many additional write positions are made available is otherwise unspeciﬁed.339
If palloc is not a null pointer, the function calls (*palloc)(n) to allocate the new dynamic array
object. Otherwise, it evaluates the expression new charT[n]. In either case, if the allocation fails, the
function returns EOF. Otherwise, it sets allocated in strmode.
To free a previously existing dynamic array object whose ﬁrst element address is p: If pfree is not a
null pointer, the function calls (*pfree)(p). Otherwise, it evaluates the expression delete[]p.
If strmode & dynamic == 0, or if strmode & frozen != 0, the function cannot extend the array
(reallocate it with greater length) to make a write position available.

int_type pbackfail(int_type c = EOF);

Puts back the character designated by c to the input sequence, if possible, in one of three ways:
—

If c != EOF, if the input sequence has a putback position available, and if (char)c == gnext[-1],
assigns gnext - 1 to gnext.
Returns c.
If c != EOF, if the input sequence has a putback position available, and if strmode & constant
is zero, assigns c to *--gnext.
Returns c.
If c == EOF and if the input sequence has a putback position available, assigns gnext - 1 to
gnext.
Returns a value other than EOF.

—

—

Returns EOF to indicate failure.
Remarks: If the function can succeed in more than one of these ways, it is unspeciﬁed which way is
chosen. The function can alter the number of putback positions available as a result of any call.

int_type underflow();

Eﬀects: Reads a character from the input sequence, if possible, without moving the stream position
past it, as follows:
—

If the input sequence has a read position available, the function signals success by returning
(unsigned char)*gnext.
Otherwise, if the current write next pointer pnext is not a null pointer and is greater than the
current read end pointer gend, makes a read position available by assigning to gend a value greater
than gnext and no greater than pnext.
Returns (unsigned char*)gnext.

—

11

12

Returns EOF to indicate failure.
Remarks: The function can alter the number of read positions available as a result of any call.

pos_type seekoff(off_type off, seekdir way, openmode which = in | out);

§ D.7.1.3

1259

c(cid:13) ISO/IEC

N4296

Conditions
(which & ios::in) != 0
(which & ios::out) != 0
(which & (ios::in |
ios::out)) == (ios::in |
ios::out)) and
way == either
ios::beg or
ios::end
Otherwise

Table 159 — seekoff positioning

Result
positions the input sequence
positions the output sequence
positions both the input and the output sequences

the positioning operation fails.

Eﬀects: Alters the stream position within one of the controlled sequences, if possible, as indicated in
Table 159.
For a sequence to be positioned, if its next pointer is a null pointer, the positioning operation fails.
Otherwise, the function determines newoff as indicated in Table 160.

Table 160 — newoff values

Condition

way == ios::beg
way == ios::cur

way == ios::end

newoff Value

0
the next pointer minus the begin-
ning pointer (xnext - xbeg).
seekhigh minus the beginning
pointer (seekhigh - xbeg).

If (newoff + off) < (seeklow - xbeg) or (seekhigh - xbeg) < (newoff + off), the position-
ing operation fails. Otherwise, the function assigns xbeg + newoff + off to the next pointer xnext.
Returns: pos_type(newoff), constructed from the resultant oﬀset newoff (of type off_type), that
stores the resultant stream position, if possible. If the positioning operation fails, or if the constructed
object cannot represent the resultant stream position, the return value is pos_type(off_type(-1)).

pos_type seekpos(pos_type sp, ios_base::openmode which

= ios_base::in | ios_base::out);

If (which & ios::in) != 0, positions the input sequence.
If (which & ios::out) != 0, positions the output sequence.
If the function positions neither sequence, the positioning operation fails.

Eﬀects: Alters the stream position within one of the controlled sequences, if possible, to correspond
to the stream position stored in sp (as described below).
—
—
—
For a sequence to be positioned, if its next pointer is a null pointer, the positioning operation fails.
Otherwise, the function determines newoff from sp.offset():
—

If newoff is an invalid stream position, has a negative value, or has a value greater than (seekhigh
- seeklow), the positioning operation fails

339) An implementation should consider alsize in making this decision.

§ D.7.1.3

1260

13

14

15

16

17

(17.1)

(17.2)

(17.3)

18

(18.1)

c(cid:13) ISO/IEC

N4296

(18.2)

19

20

—

Otherwise, the function adds newoff to the beginning pointer xbeg and stores the result in the
next pointer xnext.

Returns: pos_type(newoff), constructed from the resultant oﬀset newoff (of type off_type), that
stores the resultant stream position, if possible. If the positioning operation fails, or if the constructed
object cannot represent the resultant stream position, the return value is pos_type(off_type(-1)).

streambuf<char>* setbuf(char* s, streamsize n);

Eﬀects: Implementation deﬁned, except that setbuf(0, 0) has no eﬀect.

D.7.2 Class istrstream

[depr.istrstream]

namespace std {

class istrstream : public basic_istream<char> {
public:

explicit istrstream(const char* s);
explicit istrstream(char* s);
istrstream(const char* s, streamsize n);
istrstream(char* s, streamsize n);
virtual ~istrstream();

strstreambuf* rdbuf() const;
char* str();

strstreambuf sb; // exposition only

private:

};

}

1 The class istrstream supports the reading of objects of class strstreambuf. It supplies a strstreambuf
object to control the associated array object. For the sake of exposition, the maintained data is presented
here as:

(1.1)

—

sb, the strstreambuf object.

D.7.2.1 istrstream constructors
explicit istrstream(const char* s);
explicit istrstream(char* s);

[depr.istrstream.cons]

1

2

1

2

Eﬀects: Constructs an object of class istrstream, initializing the base class with istream(&sb) and
initializing sb with strstreambuf(s,0)). s shall designate the ﬁrst element of an ntbs.

istrstream(const char* s, streamsize n);

Eﬀects: Constructs an object of class istrstream, initializing the base class with istream(&sb) and
initializing sb with strstreambuf(s,n)). s shall designate the ﬁrst element of an array whose length
is n elements, and n shall be greater than zero.

D.7.2.2 Member functions
strstreambuf* rdbuf() const;

Returns: const_cast<strstreambuf*>(&sb).

char* str();

Returns: rdbuf()->str().

[depr.istrstream.members]

§ D.7.2.2

1261

c(cid:13) ISO/IEC

D.7.3 Class ostrstream

N4296

[depr.ostrstream]

namespace std {

class ostrstream : public basic_ostream<char> {
public:

ostrstream();
ostrstream(char* s, int n, ios_base::openmode mode = ios_base::out);
virtual ~ostrstream();

strstreambuf* rdbuf() const;
void freeze(bool freezefl = true);
char* str();
int pcount() const;

strstreambuf sb; // exposition only

private:

};

}

1 The class ostrstream supports the writing of objects of class strstreambuf. It supplies a strstreambuf
object to control the associated array object. For the sake of exposition, the maintained data is presented
here as:

(1.1)

—

sb, the strstreambuf object.

D.7.3.1 ostrstream constructors

[depr.ostrstream.cons]

1

2

(2.1)

(2.2)

1

2

3

4

ostrstream();
Eﬀects: Constructs an object of class ostrstream, initializing the base class with ostream(&sb) and
initializing sb with strstreambuf()).

ostrstream(char* s, int n, ios_base::openmode mode = ios_base::out);

Eﬀects: Constructs an object of class ostrstream, initializing the base class with ostream(&sb), and
initializing sb with one of two constructors:
—

If (mode & app) == 0, then s shall designate the ﬁrst element of an array of n elements.
The constructor is strstreambuf(s, n, s).
If (mode & app) != 0, then s shall designate the ﬁrst element of an array of n elements that
contains an ntbs whose ﬁrst element is designated by s. The constructor is strstreambuf(s,
n, s + std::strlen(s)).340

—

[depr.ostrstream.members]

D.7.3.2 Member functions
strstreambuf* rdbuf() const;

Returns: (strstreambuf*)&sb .

void freeze(bool freezefl = true);

Eﬀects: Calls rdbuf()->freeze(freezefl).

char* str();

Returns: rdbuf()->str().

int pcount() const;

Returns: rdbuf()->pcount().

340) The function signature strlen(const char*) is declared in <cstring> (21.8).

§ D.7.3.2

1262

c(cid:13) ISO/IEC

D.7.4 Class strstream

N4296

[depr.strstream]

namespace std {

class strstream

public:

: public basic_iostream<char> {

// Types
typedef char
char_type;
typedef typename char_traits<char>::int_type int_type;
typedef typename char_traits<char>::pos_type pos_type;
typedef typename char_traits<char>::off_type off_type;

// constructors/destructor
strstream();
strstream(char* s, int n,

virtual ~strstream();

ios_base::openmode mode = ios_base::in|ios_base::out);

// Members:
strstreambuf* rdbuf() const;
void freeze(bool freezefl = true);
int pcount() const;
char* str();

private:
strstreambuf sb; // exposition only
};

}

1 The class strstream supports reading and writing from objects of class strstreambuf.

It supplies a
strstreambuf object to control the associated array object. For the sake of exposition, the maintained
data is presented here as:

(1.1)

1

2

(2.1)

(2.2)

—

sb, the strstreambuf object.
D.7.4.1 strstream constructors
strstream();

[depr.strstream.cons]

Eﬀects: Constructs an object of class strstream, initializing the base class with iostream(&sb).

strstream(char* s, int n,

ios_base::openmode mode = ios_base::in|ios_base::out);

Eﬀects: Constructs an object of class strstream, initializing the base class with iostream(&sb) and
initializing sb with one of the two constructors:
—

If (mode & app) == 0, then s shall designate the ﬁrst element of an array of n elements. The
constructor is strstreambuf(s,n,s).
If (mode & app) != 0, then s shall designate the ﬁrst element of an array of n elements that
contains an ntbs whose ﬁrst element is designated by s. The constructor is strstreambuf(s,n,s
+ std::strlen(s)).

—

D.7.4.2 strstream destructor
virtual ~strstream();

1

Eﬀects: Destroys an object of class strstream.

§ D.7.4.2

[depr.strstream.dest]

1263

c(cid:13) ISO/IEC

N4296

2

1

2

3

1

2

3

1

2

3

1

1

2

1

strstreambuf* rdbuf() const;

Returns: &sb.

D.7.4.3 strstream operations
void freeze(bool freezefl = true);

Eﬀects: Calls rdbuf()->freeze(freezefl).

char* str();

Returns: rdbuf()->str().

int pcount() const;

Returns: rdbuf()->pcount().

D.8 Violating exception-speciﬁcations
D.8.1 Type unexpected_handler
typedef void (*unexpected_handler)();

[depr.strstream.oper]

[exception.unexpected]
[unexpected.handler]

The type of a handler function to be called by unexpected() when a function attempts to throw an
exception not listed in its dynamic-exception-speciﬁcation.
Required behavior: An unexpected_handler shall not return. See also 15.5.2.
Default behavior: The implementation’s default unexpected_handler calls std::terminate().

D.8.2 set_unexpected
unexpected_handler set_unexpected(unexpected_handler f) noexcept;

[set.unexpected]

Eﬀects: Establishes the function designated by f as the current unexpected_handler.
Remark: It is unspeciﬁed whether a null pointer value designates the default unexpected_handler.
Returns: The previous unexpected_handler.

D.8.3 get_unexpected
unexpected_handler get_unexpected() noexcept;

[get.unexpected]

Returns: The current unexpected_handler. [ Note: This may be a null pointer value. — end note ]
[unexpected]

D.8.4 unexpected
[[noreturn]] void unexpected();

Remarks: Called by the implementation when a function exits via an exception not allowed by its
exception-speciﬁcation (15.5.2), in eﬀect after evaluating the throw-expression (D.8.1). May also be
called directly by the program.
Eﬀects: Calls the current unexpected_handler function.
always considered a callable handler in this context. — end note ]

[ Note: A default unexpected_handler is

D.9 uncaught_exception
bool uncaught_exception() noexcept;

Returns: uncaught_exceptions() > 0.

[depr.uncaught]

§ D.9

1264

c(cid:13) ISO/IEC

N4296

Annex E (normative)
Universal character names for identiﬁer
characters
E.1 Ranges of characters allowed

[charname]
[charname.allowed]

00A8, 00AA, 00AD, 00AF, 00B2-00B5, 00B7-00BA, 00BC-00BE, 00C0-00D6, 00D8-00F6, 00F8-00FF

0100-167F, 1681-180D, 180F-1FFF

200B-200D, 202A-202E, 203F-2040, 2054, 2060-206F

2070-218F, 2460-24FF, 2776-2793, 2C00-2DFF, 2E80-2FFF

3004-3007, 3021-302F, 3031-303F

3040-D7FF

F900-FD3D, FD40-FDCF, FDF0-FE44, FE47-FFFD

10000-1FFFD, 20000-2FFFD, 30000-3FFFD, 40000-4FFFD, 50000-5FFFD,

60000-6FFFD, 70000-7FFFD, 80000-8FFFD, 90000-9FFFD, A0000-AFFFD,
B0000-BFFFD, C0000-CFFFD, D0000-DFFFD, E0000-EFFFD

E.2 Ranges of characters disallowed initially

[charname.disallowed]

0300-036F, 1DC0-1DFF, 20D0-20FF, FE20-FE2F

§ E.2

1265

c(cid:13) ISO/IEC

Annex F (informative)
Cross references

N4296

[xref]

This annex lists each section label and the corresponding section number, in alphabetical order by label. All
of the section labels are the same as in the 2003 standard, except:

— labels that begin with lib. in the 2003 standard have had the lib. removed so that they do not all
appear in the same part of this list. For example, in the 2003 standard, the non-modifying sequence
algorithms were found in a section with the label [lib.alg.nonmodifying]. The label for that section
is now [alg.nonmodifying].

— the label for Annex B has been changed from [limits] to [implimits]. The label [limits] refers

to section 18.3.2.

25.2.1
25.2.2

A
accumulate
26.7.2
adjacent.diﬀerence
26.7.5
adjustﬁeld.manip 27.5.6.2
alg.adjacent.ﬁnd 25.2.8
alg.all_of
alg.any_of
alg.binary.search 25.4.3
alg.c.library 25.5
alg.copy 25.3.1
alg.count
25.2.9
alg.equal 25.2.11
alg.ﬁll 25.3.6
alg.ﬁnd 25.2.5
alg.ﬁnd.end 25.2.6
alg.ﬁnd.ﬁrst.of 25.2.7
alg.foreach 25.2.4
alg.generate
25.3.7
alg.heap.operations 25.4.6
alg.is_permutation 25.2.12
alg.lex.comparison 25.4.8
alg.merge
alg.min.max 25.4.7
alg.modifying.operations 25.3
alg.move
alg.none_of 25.2.3
alg.nonmodifying
25.2
alg.nth.element 25.4.2
alg.partitions
25.3.13
alg.permutation.generators 25.4.9
alg.random.shuﬄe 25.3.12
alg.remove

25.3.8

25.4.4

25.3.2

25.4.5

25.3.9

25.1

20.13

17.6.5.7

25.3.5
alg.replace
25.3.10
alg.reverse
alg.rotate
25.3.11
alg.search 25.2.13
alg.set.operations
25.4.1
alg.sort
alg.sorting
25.4
alg.swap 25.3.3
alg.transform 25.3.4
alg.unique
algorithm.stable
algorithms
25
algorithms.general
alloc.errors
18.6.2
allocator.adaptor
allocator.adaptor.cnstr
allocator.adaptor.members
allocator.adaptor.syn 20.13.1
allocator.adaptor.types
allocator.globals
allocator.members
allocator.requirements
allocator.tag
20.7.6
allocator.traits
20.7.8
allocator.traits.members
allocator.traits.types
allocator.uses 20.7.7
allocator.uses.construction 20.7.7.2
allocator.uses.trait
alt.headers
17.6.4.4
arithmetic.operations
array 23.3.2
array.cons

20.7.8.2

20.7.8.1

23.3.2.2

20.7.9.2

20.7.9.1

20.13.3

20.13.4

20.7.7.1

20.9.5

20.13.2

17.6.3.5

Cross references

1266

c(cid:13) ISO/IEC

N4296

23.3.2.6

23.3.2.4

23.3.2.3

array.data 23.3.2.5
array.ﬁll
array.overview 23.3.2.1
array.size
array.special
array.swap 23.3.2.7
23.3.2.9
array.tuple
array.zero
23.3.2.8
assertions 19.3
associative
23.4
associative.general 23.4.1
associative.map.syn 23.4.2
associative.reqmts 23.2.4
associative.reqmts.except 23.2.4.1
associative.set.syn 23.4.3
atomics
atomics.fences 29.8
atomics.ﬂag
atomics.general 29.1
atomics.lockfree
29.4
atomics.order
atomics.syn 29.2
atomics.types.generic 29.5
atomics.types.operations
atomics.types.operations.arith 29.6.3
atomics.types.operations.general
atomics.types.operations.pointer
atomics.types.operations.req 29.6.5
atomics.types.operations.templ

29.3

29.6

29.7

29

29.6.1
29.6.4

29.6.2

24.5.2.2.1
24.5.2.2.3

B
back.insert.iter.cons
back.insert.iter.op*
back.insert.iter.op++ 24.5.2.2.4
back.insert.iter.op= 24.5.2.2.2
back.insert.iter.ops
24.5.2.2
back.insert.iterator 24.5.2.1
back.inserter 24.5.2.2.5
bad.alloc 18.6.2.1
bad.cast
bad.exception 18.8.2
bad.typeid 18.7.3
baseﬁeld.manip 27.5.6.3
basic 3
basic.align 3.11
basic.compound 3.9.2
basic.def
basic.def.odr 3.2
basic.fundamental 3.9.1
basic.funscope 3.3.5

18.7.2

3.1

7.3

3.3.1

3.3.6

3.4.1

3.3.10

27.5.5.3

27.5.5.2

basic.ios.cons
basic.ios.members
basic.life
3.8
basic.link 3.5
basic.lookup 3.4
basic.lookup.argdep 3.4.2
basic.lookup.classref
3.4.5
basic.lookup.elab 3.4.4
3.4.3
basic.lookup.qual
basic.lookup.udir
3.4.6
basic.lookup.unqual
basic.lval
3.10
basic.namespace
basic.scope
3.3
basic.scope.block 3.3.3
basic.scope.class
3.3.7
basic.scope.declarative
basic.scope.enum 3.3.8
basic.scope.hiding
basic.scope.namespace
basic.scope.pdecl
3.3.2
basic.scope.proto
3.3.4
basic.scope.temp 3.3.9
basic.start
3.6
basic.start.init
3.6.2
basic.start.main 3.6.1
basic.start.term 3.6.3
basic.stc
3.7
basic.stc.auto
basic.stc.dynamic
basic.stc.dynamic.allocation 3.7.4.1
basic.stc.dynamic.deallocation 3.7.4.2
basic.stc.dynamic.safety 3.7.4.3
basic.stc.inherit
3.7.5
basic.stc.static
3.7.1
basic.stc.thread 3.7.2
basic.string
basic.string.hash 21.6
basic.string.literals 21.7
basic.type.qualiﬁer
3.9.3
basic.types
bidirectional.iterators 24.2.6
binary.search 25.4.3.4
bitmask.types
bitset.cons
20.6.1
bitset.hash 20.6.3
bitset.members
bitset.operators
bitwise.operations
byte.strings

20.9.8
17.5.2.1.4.1

20.6.2
20.6.4

17.5.2.1.3

3.7.4

3.7.3

21.4

3.9

Cross references

1267

c(cid:13) ISO/IEC

N4296

21.2.3.1

21.2.3.2
21.2.3.3

21.2.3.4

C
c.ﬁles 27.9.2
c.limits 18.3.3
c.locales 22.6
c.malloc 20.7.13
c.math 26.8
c.strings
21.8
category.collate 22.4.4
category.ctype
22.4.1
category.messages 22.4.7
category.monetary 22.4.6
category.numeric 22.4.2
category.time 22.4.5
ccmplx 26.4.11
cfenv 26.3
cfenv.syn 26.3.1
char.traits
21.2
char.traits.require 21.2.1
char.traits.specializations 21.2.3
char.traits.specializations.char
char.traits.specializations.char16_t
char.traits.specializations.char32_t
char.traits.specializations.wchar.t
char.traits.typedefs 21.2.2
character.seq 17.5.2.1.4
charname E
charname.allowed E.1
charname.disallowed E.2
class
class.abstract
class.access 11
class.access.base 11.2
class.access.nest 11.7
class.access.spec 11.1
class.access.virt 11.5
class.base.init
12.6.2
class.bit
9.6
12.7
class.cdtor
class.conv 12.3
class.conv.ctor 12.3.1
class.conv.fct
12.3.2
class.copy 12.8
class.ctor 12.1
class.derived 10
class.dtor
12.4
class.expl.init
class.free
class.friend 11.3
class.gslice 26.6.6
class.gslice.overview 26.6.6.1

12.6.1

10.4

12.5

9

12.9

11.6

10.3

9.3.1

9.3

10.1

9.1
9.7

3.4.3.1
26.6.4

class.inhctor
12.6
class.init
class.local
9.8
class.mem 9.2
class.member.lookup 10.2
class.mfct
class.mfct.non-static
class.mi
class.name
class.nest
class.nested.type 9.9
class.paths
class.protected 11.4
class.qual
class.slice
class.slice.overview 26.6.4.1
class.static
9.4
9.4.2
class.static.data
class.static.mfct
9.4.1
class.temporary 12.2
class.this
9.3.2
class.union 9.5
class.virtual
classiﬁcation 22.3.3.1
cmplx.over
comparisons
complex 26.4.2
complex.literals
complex.member.ops
complex.members
complex.numbers
complex.ops
complex.special
complex.syn 26.4.1
complex.transcendentals
complex.value.ops
compliance
conforming
conforming.overview 17.6.5.1
cons.slice
26.6.4.2
constexpr.functions
constraints
17.6.4
constraints.overview 17.6.4.1
container.adaptors
23.6
container.adaptors.general
container.requirements
container.requirements.dataraces
container.requirements.general
containers
containers.general
contents
17.6.1.1

17.6.1.3
17.6.5

26.4.9
20.9.6

26.4.4
26.4

17.6.5.6

26.4.10

26.4.8

26.4.6

26.4.3

26.4.5

26.4.7

23

23.1

23.6.1

23.2

23.2.2

23.2.1

Cross references

1268

c(cid:13) ISO/IEC

N4296

4.9

4.3

4.7

conv 4
conv.array 4.2
4.12
conv.bool
conv.double
4.8
conv.fpint
conv.fpprom 4.6
conv.func
conv.integral
conv.lval 4.1
conv.mem 4.11
conv.prom 4.5
4.10
conv.ptr
conv.qual
4.4
conv.rank 4.13
conventions
17.5.2
conversions 22.3.3.2
conversions.buﬀer
conversions.character
conversions.string
cpp 16
cpp.concat 16.3.3
cpp.cond 16.1
cpp.error 16.5
cpp.include
cpp.line 16.4
cpp.null
16.7
cpp.pragma
cpp.pragma.op 16.9
cpp.predeﬁned 16.8
cpp.replace 16.3
cpp.rescan 16.3.4
cpp.scope 16.3.5
cpp.stringize 16.3.2
cpp.subst
cstdint
cstdint.syn 18.4.1

16.3.1

16.2

16.6

18.4

22.3.3.2.3

22.3.3.2.1

22.3.3.2.2

8.2

D
date.time 20.12.8
dcl.align 7.6.2
dcl.ambig.res
dcl.array 8.3.4
dcl.asm 7.4
dcl.attr 7.6
dcl.attr.depend 7.6.4
dcl.attr.deprecated 7.6.5
dcl.attr.grammar 7.6.1
dcl.attr.noreturn 7.6.3
dcl.constexpr
dcl.dcl 7

7.1.5

8

8.4

8.3

8.5.2

8.3.6

7.1.2

7.1.6.4

8.4.2
8.4.3
8.4.1

8.5.1
8.5.4
8.5.3

dcl.decl
dcl.enum 7.2
dcl.fct
8.3.5
dcl.fct.def
dcl.fct.def.default
dcl.fct.def.delete
dcl.fct.def.general
dcl.fct.default
dcl.fct.spec
dcl.friend 7.1.4
dcl.init
8.5
dcl.init.aggr
dcl.init.list
dcl.init.ref
dcl.init.string
dcl.link 7.5
dcl.meaning
8.3.3
dcl.mptr
8.1
dcl.name
8.3.1
dcl.ptr
dcl.ref
8.3.2
dcl.spec 7.1
dcl.spec.auto
7.1.1
dcl.stc
dcl.type
7.1.6
dcl.type.cv 7.1.6.1
dcl.type.elab 7.1.6.3
dcl.type.simple
dcl.typedef
20.2.5
declval
default.allocator
deﬁnitions
17.3
defns.additional
defns.arbitrary.stream 17.3
defns.argument
1.3
1.3
defns.argument.macro
defns.argument.templ
1.3
defns.argument.throw 1.3
defns.block 17.3
defns.blocked 17.3
defns.character
defns.character.container
defns.comparison 17.3
defns.component
17.3
defns.cond.supp 1.3
defns.deadlock 17.3
defns.default.behavior.func
defns.default.behavior.impl
defns.diagnostic
defns.dynamic.type 1.3
defns.dynamic.type.prvalue

7.1.6.2

20.7.9

7.1.3

17.3

17.4

17.3

17.3
17.3

1.3

1.3

Cross references

1269

c(cid:13) ISO/IEC

N4296

28.2

17.3

17.3

28.2

defns.handler 17.3
defns.ill.formed 1.3
defns.impl.deﬁned 1.3
defns.impl.limits
1.3
defns.iostream.templates
defns.locale.speciﬁc
1.3
defns.modiﬁer
17.3
defns.move.assign 17.3
defns.move.constr
17.3
defns.multibyte 1.3
defns.ntcts 17.3
defns.obj.state 17.3
17.3
defns.observer
defns.parameter
1.3
defns.parameter.macro 1.3
defns.parameter.templ 1.3
defns.referenceable
defns.regex.collating.element 28.2
defns.regex.ﬁnite.state.machine
defns.regex.format.speciﬁer
defns.regex.matched 28.2
defns.regex.primary.equivalence.class
defns.regex.regular.expression 28.2
defns.regex.subexpression 28.2
defns.replacement 17.3
defns.repositional.stream 17.3
defns.required.behavior 17.3
defns.reserved.function 17.3
defns.signature 1.3
1.3
defns.signature.member
defns.signature.member.spec
1.3
defns.signature.member.templ 1.3
defns.signature.spec
1.3
defns.signature.templ 1.3
defns.stable
defns.static.type
defns.traits 17.3
defns.unblock 17.3
defns.undeﬁned 1.3
defns.unspeciﬁed 1.3
defns.valid 17.3
defns.well.formed 1.3
denorm.style
18.3.2.6
depr D
depr.c.headers D.5
depr.except.spec D.4
depr.impldec D.3
depr.incr.bool D.1
depr.ios.members D.6
depr.istrstream D.7.2
depr.istrstream.cons D.7.2.1

17.3

1.3

28.2

19

23.3.3

23.3.3.2

23.3.3.5

17.6.4.5

depr.istrstream.members D.7.2.2
depr.ostrstream D.7.3
depr.ostrstream.cons D.7.3.1
depr.ostrstream.members D.7.3.2
depr.register D.2
depr.str.strstreams D.7
depr.strstream D.7.4
depr.strstream.cons D.7.4.1
depr.strstream.dest D.7.4.2
depr.strstream.oper D.7.4.3
depr.strstreambuf D.7.1
depr.strstreambuf.cons D.7.1.1
depr.strstreambuf.members D.7.1.2
depr.strstreambuf.virtuals D.7.1.3
depr.uncaught D.9
deque
deque.capacity 23.3.3.3
deque.cons
deque.modiﬁers
23.3.3.4
deque.overview 23.3.3.1
deque.special
derivation 17.6.5.11
derived.classes
description 17.5
diagnostics
diagnostics.general
diﬀ C
diﬀ.basic C.1.2
diﬀ.char16 C.5.2.1
diﬀ.class C.1.8
diﬀ.conv C.1.3
diﬀ.cpp C.1.10
diﬀ.cpp03 C.2
diﬀ.cpp03.algorithms C.2.14
diﬀ.cpp03.containers C.2.13
diﬀ.cpp03.conv C.2.2
diﬀ.cpp03.dcl.dcl C.2.4
diﬀ.cpp03.dcl.decl C.2.5
diﬀ.cpp03.diagnostics C.2.10
diﬀ.cpp03.expr C.2.3
diﬀ.cpp03.input.output C.2.16
diﬀ.cpp03.language.support C.2.9
diﬀ.cpp03.lex C.2.1
diﬀ.cpp03.library C.2.8
diﬀ.cpp03.numerics C.2.15
diﬀ.cpp03.special C.2.6
diﬀ.cpp03.strings C.2.12
diﬀ.cpp03.temp C.2.7
diﬀ.cpp03.utilities C.2.11
diﬀ.cpp11 C.3
diﬀ.cpp11.basic C.3.2

19.1

Cross references

1270

c(cid:13) ISO/IEC

diﬀ.cpp11.dcl.dcl C.3.3
diﬀ.cpp11.input.output C.3.4
diﬀ.cpp11.lex C.3.1
diﬀ.cpp14 C.4
diﬀ.cpp14.depr C.4.2
diﬀ.cpp14.lex C.4.1
diﬀ.dcl C.1.6
diﬀ.decl C.1.7
diﬀ.expr C.1.4
diﬀ.header.iso646.h C.5.2.3
diﬀ.iso C.1
diﬀ.lex C.1.1
diﬀ.library C.5
diﬀ.malloc C.5.4.2
diﬀ.mods.to.behavior C.5.4
diﬀ.mods.to.declarations C.5.3
diﬀ.mods.to.deﬁnitions C.5.2
diﬀ.mods.to.headers C.5.1
diﬀ.null C.5.2.4
diﬀ.oﬀsetof C.5.4.1
diﬀ.special C.1.9
diﬀ.stat C.1.5
diﬀ.wchar.t C.5.2.2
domain.error 19.2.2

15

25.4.3.3

27.5.6.5

E
enumerated.types 17.5.2.1.2
equal.range
errno 19.4
error.reporting
except
except.ctor 15.2
except.handle 15.3
except.nested 18.8.6
except.spec 15.4
except.special 15.5
except.terminate
except.throw 15.1
except.uncaught
except.unexpected 15.5.2
exception 18.8.1
18.8.3
exception.terminate
exception.unexpected D.8
expr 5
expr.add 5.7
expr.alignof
expr.ass
expr.bit.and 5.11
expr.call
expr.cast

5.2.2
5.4

15.5.1

15.5.3

5.3.6

5.18

N4296

5.5

5.15

5.19

5.2.6
5.3.2

expr.comma
expr.cond 5.16
expr.const
5.20
expr.const.cast
5.3.5
expr.delete
expr.dynamic.cast
expr.eq 5.10
expr.log.and 5.14
expr.log.or
expr.mptr.oper
expr.mul
5.6
expr.new 5.3.4
expr.or
5.13
expr.post
5.2
expr.post.incr
expr.pre.incr
expr.prim 5.1
expr.prim.fold 5.1.3
expr.prim.general
expr.prim.lambda
expr.pseudo
5.2.4
expr.ref
expr.reinterpret.cast
expr.rel
expr.shift
expr.sizeof
expr.static.cast
expr.sub 5.2.1
expr.throw 5.17
expr.type.conv 5.2.3
expr.typeid 5.2.8
expr.unary 5.3
expr.unary.noexcept
expr.unary.op 5.3.1
expr.xor
ext.manip 27.7.5
extern.names
extern.types

5.8
5.3.3

5.2.5

5.12

5.9

5.2.9

17.6.4.3.2
17.6.4.3.3

5.2.11

5.2.7

5.1.1
5.1.2

5.2.10

5.3.7

F
facet.ctype.char.dtor
facet.ctype.char.members
facet.ctype.char.statics
facet.ctype.char.virtuals
facet.ctype.special
facet.num.get.members
facet.num.get.virtuals
facet.num.put.members
facet.num.put.virtuals
facet.numpunct
22.4.3

22.4.1.3.1

22.4.1.3.2

22.4.1.3.3
22.4.1.3.4

22.4.1.3

22.4.2.1.1
22.4.2.1.2

22.4.2.2.1
22.4.2.2.2

Cross references

1271

c(cid:13) ISO/IEC

N4296

22.4.3.1.1
22.4.3.1.2

27.9.1.2

facet.numpunct.members
facet.numpunct.virtuals
facets.examples
22.4.8
ﬁle.streams 27.9
ﬁlebuf
27.9.1.1
ﬁlebuf.assign 27.9.1.3
ﬁlebuf.cons
ﬁlebuf.members 27.9.1.4
ﬁlebuf.virtuals
27.9.1.5
ﬂoatﬁeld.manip 27.5.6.4
fmtﬂags.manip 27.5.6.1
fmtﬂags.state 27.5.3.2
forward 20.2.4
forward.iterators 24.2.5
forwardlist 23.3.4
forwardlist.access 23.3.4.4
forwardlist.cons 23.3.4.2
forwardlist.iter 23.3.4.3
forwardlist.modiﬁers 23.3.4.5
forwardlist.ops 23.3.4.6
forwardlist.overview 23.3.4.1
forwardlist.spec 23.3.4.7
fpos
27.5.4
fpos.members
27.5.4.1
fpos.operations 27.5.4.2
24.5.2.4.1
front.insert.iter.cons
front.insert.iter.op* 24.5.2.4.3
front.insert.iter.op++ 24.5.2.4.4
front.insert.iter.op= 24.5.2.4.2
24.5.2.4
front.insert.iter.ops
front.insert.iterator 24.5.2.3
front.inserter 24.5.2.4.5
fstream 27.9.1.14
fstream.assign 27.9.1.16
fstream.cons
fstream.members
fstreams
27.9.1
func.bind 20.9.10
func.bind.bind 20.9.10.3
func.bind.isbind 20.9.10.1
func.bind.isplace
20.9.10.2
func.bind.place 20.9.10.4
func.def 20.9.1
func.invoke 20.9.3
func.memfn 20.9.11
func.require
20.9.2
func.wrap 20.9.12
func.wrap.badcall 20.9.12.1
func.wrap.badcall.const
func.wrap.func 20.9.12.2
func.wrap.func.alg

20.9.12.2.7

27.9.1.17

27.9.1.15

20.9.12.1.1

20.9.12.2.6

17.5.2.2

20.9.12.2.5

func.wrap.func.cap 20.9.12.2.3
func.wrap.func.con 20.9.12.2.1
func.wrap.func.inv 20.9.12.2.4
func.wrap.func.mod 20.9.12.2.2
func.wrap.func.nullptr
func.wrap.func.targ
function.objects
20.9
functions.within.classes
futures
30.6
30.6.8
futures.async
futures.errors
30.6.2
futures.future_error
futures.overview 30.6.1
futures.promise
30.6.5
futures.shared_future
futures.state
30.6.4
futures.task 30.6.9
futures.task.members
futures.task.nonmembers
futures.unique_future

30.6.9.1

30.6.7

30.6.3

30.6.9.2

30.6.6

17.6.5.4

18.6.2.5

G
get.new.handler
get.terminate
18.8.3.3
get.unexpected D.8.3
global.functions
gram A
gram.basic A.3
gram.class A.8
gram.cpp A.14
gram.dcl A.6
gram.decl A.7
gram.derived A.9
gram.except A.13
gram.expr A.4
gram.key A.1
gram.lex A.2
gram.over A.11
gram.special A.10
gram.stmt A.5
gram.temp A.12
gslice.access
gslice.array.assign 26.6.7.2
gslice.array.comp.assign 26.6.7.3
gslice.array.ﬁll
gslice.cons

26.6.6.3

26.6.6.2

26.6.7.4

H

Cross references

1272

N4296

27.5.3.1

c(cid:13) ISO/IEC

17.6.4.7
handler.functions
hash.requirements 17.6.3.4
headers 17.6.1.2

27

25.4.5.1

27.7.2
24.5.2.6.1
24.5.2.6.3

I
ifstream 27.9.1.6
ifstream.assign 27.9.1.8
ifstream.cons 27.9.1.7
ifstream.members 27.9.1.9
implimits B
includes
indirect.array.assign 26.6.9.2
indirect.array.comp.assign 26.6.9.3
indirect.array.ﬁll 26.6.9.4
inner.product
26.7.3
input.iterators 24.2.3
input.output
input.output.general 27.1
input.streams
insert.iter.cons
insert.iter.op*
insert.iter.op++ 24.5.2.6.4
insert.iter.op= 24.5.2.6.2
insert.iter.ops 24.5.2.6
24.5.2.5
insert.iterator
insert.iterators
24.5.2
inserter 24.5.2.6.5
intro 1
intro.ack 1.11
intro.compliance 1.4
intro.defs 1.3
intro.execution 1.9
intro.memory 1.7
intro.multithread 1.10
intro.object
intro.refs
intro.scope
intro.structure 1.5
intseq 20.5
intseq.general 20.5.1
intseq.intseq 20.5.2
intseq.make 20.5.3
invalid.argument 19.2.3
ios 27.5.5
ios.base 27.5.3
ios.base.callback 27.5.3.6
ios.base.cons
ios.base.locales 27.5.3.3
ios.base.storage 27.5.3.5
ios.members.static

27.5.3.7

27.5.3.4

1.8

1.2

1.1

27.7

27.2.1

27.5.3.1.3

27.5.3.1.6

27.5.3.1.4

27.7.2.5
27.5

27.5.3.1.5
27.5.5.4

27.7.2.5.1
27.7.2.5.2

27.5.3.1.1
27.5.3.1.2

ios.overview 27.5.5.1
ios.types
ios::failure
ios::fmtﬂags
ios::Init
ios::iostate
ios::openmode
ios::seekdir
iostate.ﬂags
iostream.assign 27.7.2.5.3
iostream.cons
iostream.dest
iostream.format
iostream.format.overview 27.7.1
iostream.forward 27.3
iostream.limits.imbue
iostream.objects
27.4
iostream.objects.overview 27.4.1
iostreamclass
iostreams.base
iostreams.base.overview 27.5.1
27.2.2
iostreams.limits.pos
iostreams.requirements
27.2
iostreams.threadsafety 27.2.3
is.heap 25.4.6.5
is.sorted 25.4.1.5
istream 27.7.2.1
istream.assign 27.7.2.1.2
istream.cons
istream.formatted 27.7.2.2
istream.formatted.arithmetic
istream.formatted.reqmts
istream.iterator
24.6.1
istream.iterator.cons
istream.iterator.ops
istream.manip 27.7.2.4
istream.rvalue
27.7.2.6
istream.unformatted 27.7.2.3
istream::extractors
27.7.2.2.3
istream::sentry 27.7.2.1.3
istreambuf.iterator
24.6.3
istreambuf.iterator.cons
24.6.3.2
istreambuf.iterator::equal
24.6.3.5
istreambuf.iterator::op!= 24.6.3.7
istreambuf.iterator::op*
24.6.3.3
istreambuf.iterator::op++ 24.6.3.4
istreambuf.iterator::op== 24.6.3.6
istreambuf.iterator::proxy 24.6.3.1
istringstream 27.8.3
istringstream.assign 27.8.3.2
istringstream.cons

24.6.1.1
24.6.1.2

27.7.2.1.1

27.7.2.2.2

27.7.2.2.1

Cross references

1273

27.8.3.1

c(cid:13) ISO/IEC

N4296

24.8
24.2.2

istringstream.members 27.8.3.3
iterator.basic 24.4.2
iterator.container
iterator.iterators
iterator.operations 24.4.4
iterator.primitives
iterator.range 24.7
iterator.requirements 24.2
iterator.requirements.general 24.2.1
iterator.synopsis
iterator.traits
iterators
24
iterators.general 24.1

24.3
24.4.1

24.4

J
K
L
language.support 18
length.error 19.2.4
lex 2
lex.bool
2.13.6
lex.ccon 2.13.3
lex.charset
2.3
lex.comment
2.7
lex.digraph 2.5
lex.ext
2.13.8
lex.fcon 2.13.4
lex.header 2.8
lex.icon 2.13.2
lex.key 2.11
lex.literal 2.13
lex.literal.kinds 2.13.1
2.10
lex.name
lex.nullptr
2.13.7
lex.operators 2.12
lex.phases 2.2
lex.ppnumber
lex.pptoken 2.4
lex.separate 2.1
lex.string 2.13.5
lex.token 2.6
lib.types.movedfrom 17.6.5.15
library 17
library.c 17.2
library.general 17.1
limits 18.3.2
limits.numeric 18.3.2.1
limits.syn 18.3.2.2
list

23.3.5

2.9

22.3.1

22.4

22.3.3

23.3.5.2

23.3.5.4

23.3.5.5

23.3.5.6

22.4.4.2
22.4.4.1.1
22.4.4.1.2

22.4.1.2
22.4.1.1.1
22.4.1.1.2

list.capacity 23.3.5.3
list.cons
list.modiﬁers
list.ops
list.overview 23.3.5.1
list.special
locale
locale.categories
locale.category 22.3.1.1.1
locale.codecvt
22.4.1.4
locale.codecvt.byname
locale.codecvt.members
locale.codecvt.virtuals
locale.collate
22.4.4.1
locale.collate.byname
locale.collate.members
locale.collate.virtuals
locale.cons
22.3.1.2
locale.convenience
locale.ctype
22.4.1.1
locale.ctype.byname
locale.ctype.members
locale.ctype.virtuals
locale.facet
22.3.1.1.2
locale.global.templates
locale.id 22.3.1.1.3
locale.members
locale.messages
locale.messages.byname 22.4.7.2
locale.messages.members
locale.messages.virtuals
locale.money.get
22.4.6.1
locale.money.get.members
locale.money.get.virtuals
locale.money.put
22.4.6.2
locale.money.put.members
locale.money.put.virtuals
locale.moneypunct
22.4.6.3
locale.moneypunct.byname
locale.moneypunct.members
locale.moneypunct.virtuals
locale.nm.put
locale.num.get
locale.numpunct
22.4.3.1
locale.numpunct.byname
locale.operators
22.3.1.4
locale.statics 22.3.1.5
locale.stdcvt
locale.syn 22.2
locale.time.get
22.4.5.1
locale.time.get.byname

22.4.2.2
22.4.2.1

22.3.1.3
22.4.7.1

22.4.5.2

22.3.2

22.5

22.4.1.5
22.4.1.4.1
22.4.1.4.2

22.4.7.1.1
22.4.7.1.2

22.4.6.1.1
22.4.6.1.2

22.4.6.2.1
22.4.6.2.2

22.4.6.4
22.4.6.3.1
22.4.6.3.2

22.4.3.2

Cross references

1274

c(cid:13) ISO/IEC

N4296

22.4.5.1.1
22.4.5.1.2

locale.time.get.members
locale.time.get.virtuals
locale.time.put 22.4.5.3
locale.time.put.byname 22.4.5.4
locale.time.put.members 22.4.5.3.1
locale.time.put.virtuals
22.4.5.3.2
locale.types 22.3.1.1
locales
localization 22
localization.general 22.1
logic.error 19.2.1
logical.operations
lower.bound 25.4.3.1

20.9.7

22.3

23.4.4.3

17.6.4.3.1

M
macro.names
make.heap 25.4.6.3
map 23.4.4
map.access
map.cons 23.4.4.2
map.modiﬁers 23.4.4.4
map.overview 23.4.4.1
map.special 23.4.4.5
mask.array.assign 26.6.8.2
mask.array.comp.assign 26.6.8.3
mask.array.ﬁll 26.6.8.4
member.functions 17.6.5.5
memory 20.7
memory.general 20.7.1
memory.syn 20.7.2
meta 20.10
meta.help 20.10.3
meta.rel 20.10.6
meta.rqmts 20.10.1
meta.trans 20.10.7
meta.trans.arr 20.10.7.4
meta.trans.cv 20.10.7.1
meta.trans.other
meta.trans.ptr 20.10.7.5
meta.trans.ref
20.10.7.2
meta.trans.sign 20.10.7.3
meta.type.synop 20.10.2
meta.unary 20.10.4
meta.unary.cat
meta.unary.comp 20.10.4.2
meta.unary.prop 20.10.4.3
meta.unary.prop.query 20.10.5
mismatch 25.2.10
move.iter.nonmember 24.5.3.3.14
move.iter.op.+ 24.5.3.3.8

20.10.7.6

20.10.4.1

24.5.3.3.10

24.5.3.3.5
24.5.3.3.4

move.iter.op.+= 24.5.3.3.9
move.iter.op.-
move.iter.op.-= 24.5.3.3.11
move.iter.op.comp 24.5.3.3.13
move.iter.op.const
24.5.3.3.1
move.iter.op.conv 24.5.3.3.3
24.5.3.3.7
move.iter.op.decr
move.iter.op.incr
24.5.3.3.6
move.iter.op.index 24.5.3.3.12
move.iter.op.ref
move.iter.op.star
move.iter.op= 24.5.3.3.2
move.iter.ops
24.5.3.3
move.iter.requirements
24.5.3.1
move.iterator
move.iterators
24.5.3
multibyte.strings
multimap 23.4.5
multimap.cons
multimap.modiﬁers
23.4.5.3
multimap.overview 23.4.5.1
multimap.special
multiset
23.4.7
multiset.cons
multiset.overview 23.4.7.1
multiset.special

17.5.2.1.4.2

23.4.5.4

23.4.7.3

23.4.5.2

23.4.7.2

24.5.3.2

17.6.4.2

3.4.3.2

7.3.3
7.3.4

N
namespace.alias
7.3.2
namespace.constraints
namespace.def
7.3.1
namespace.memdef
7.3.1.2
namespace.posix 17.6.4.2.2
namespace.qual
namespace.std 17.6.4.2.1
namespace.udecl
namespace.udir
namespace.unnamed 7.3.1.1
narrow.stream.objects
27.4.2
negators
new.badlength 18.6.2.2
new.delete
new.delete.array 18.6.1.2
new.delete.dataraces 18.6.1.4
new.delete.placement
18.6.1.3
new.delete.single 18.6.1.1
new.handler
nullablepointer.requirements
numarray 26.6
numeric.iota

18.6.2.3

20.9.9

18.6.1

17.6.3.3

26.7.6

Cross references

1275

c(cid:13) ISO/IEC

N4296

26.7

numeric.limits 18.3.2.3
numeric.limits.members 18.3.2.4
numeric.ops
numeric.ops.overview 26.7.1
numeric.requirements 26.2
numeric.special
numerics
numerics.general 26.1

18.3.2.7

26

20.2.1

27.7.3.2

17.5.2.3

27.9.1.11

27.7.3.6.1

O
objects.within.classes
ofstream 27.9.1.10
ofstream.assign 27.9.1.12
ofstream.cons
ofstream.members 27.9.1.13
operators
organization 17.6.1
ostream 27.7.3.1
ostream.assign 27.7.3.3
ostream.cons
ostream.formatted 27.7.3.6
ostream.formatted.reqmts
ostream.inserters 27.7.3.6.3
ostream.inserters.arithmetic
27.7.3.6.2
ostream.inserters.character 27.7.3.6.4
ostream.iterator 24.6.2
ostream.iterator.cons.des 24.6.2.1
ostream.iterator.ops 24.6.2.2
ostream.manip 27.7.3.8
ostream.rvalue 27.7.3.9
ostream.seeks
27.7.3.5
ostream.unformatted 27.7.3.7
ostream::sentry 27.7.3.4
ostreambuf.iter.cons
ostreambuf.iter.ops
ostreambuf.iterator 24.6.4
ostringstream 27.8.4
ostringstream.assign 27.8.4.2
ostringstream.cons 27.8.4.1
ostringstream.members 27.8.4.3
out.of.range 19.2.5
output.iterators 24.2.4
output.streams
27.7.3
over 13
over.ass 13.5.3
over.best.ics
over.binary 13.5.2
over.built
over.call
over.call.func

24.6.4.1
24.6.4.2

13.6
13.5.4

13.3.1.1.1

13.3.3.1

13.3.1.1.2

13.3.3.1.3

13.5.7

13.5.8

over.call.object
over.dcl
13.2
over.ics.ellipsis
over.ics.list
13.3.3.1.5
over.ics.rank 13.3.3.2
13.3.3.1.4
over.ics.ref
13.3.3.1.1
over.ics.scs
over.ics.user
13.3.3.1.2
over.inc
over.literal
over.load 13.1
over.match 13.3
over.match.best
13.3.3
over.match.call
13.3.1.1
over.match.conv 13.3.1.5
over.match.copy 13.3.1.4
13.3.1.3
over.match.ctor
over.match.funcs
13.3.1
13.3.1.7
over.match.list
over.match.oper
13.3.1.2
over.match.ref
over.match.viable
13.5
over.oper
13.4
over.over
over.ref
13.5.6
over.sub 13.5.5
over.unary 13.5.1
overﬂow.error

13.3.1.6
13.3.2

19.2.8

20.3.4

20.3.5

20.3.1

20.3.2
20.3.3
25.4.1.3

P
pair.astuple
pair.piecewise
pairs
20.3
pairs.general
pairs.pair
pairs.spec
partial.sort
partial.sort.copy 25.4.1.4
partial.sum 26.7.4
pointer.traits
20.7.3
pointer.traits.functions
pointer.traits.types
pop.heap 25.4.6.2
predef.iterators
priority.queue
priqueue.cons
priqueue.cons.alloc
23.6.4.2
priqueue.members 23.6.4.3
priqueue.special
propagation 18.8.5

24.5
23.6.4
23.6.4.1

23.6.4.4

20.7.3.1

20.7.3.2

Cross references

1276

c(cid:13) ISO/IEC

protection.within.classes 17.6.5.10
ptr.align 20.7.5
push.heap 25.4.6.1

23.6.3.2

Q
queue 23.6.3
queue.cons
queue.cons.alloc
queue.defn 23.6.3.1
queue.ops
23.6.3.4
queue.special 23.6.3.5
queue.syn 23.6.2
quoted.manip 27.7.6

23.6.3.3

R
rand 26.5
rand.adapt 26.5.4
rand.adapt.disc 26.5.4.2
rand.adapt.general 26.5.4.1
rand.adapt.ibits 26.5.4.3
rand.adapt.shuf 26.5.4.4
rand.device 26.5.6
rand.dist 26.5.8
rand.dist.bern 26.5.8.3
rand.dist.bern.bernoulli 26.5.8.3.1
rand.dist.bern.bin 26.5.8.3.2
rand.dist.bern.geo 26.5.8.3.3
rand.dist.bern.negbin 26.5.8.3.4
rand.dist.general 26.5.8.1
rand.dist.norm 26.5.8.5
rand.dist.norm.cauchy 26.5.8.5.4
rand.dist.norm.chisq 26.5.8.5.3
rand.dist.norm.f 26.5.8.5.5
rand.dist.norm.lognormal 26.5.8.5.2
rand.dist.norm.normal 26.5.8.5.1
rand.dist.norm.t 26.5.8.5.6
rand.dist.pois
rand.dist.pois.exp 26.5.8.4.2
rand.dist.pois.extreme 26.5.8.4.5
rand.dist.pois.gamma 26.5.8.4.3
rand.dist.pois.poisson 26.5.8.4.1
rand.dist.pois.weibull 26.5.8.4.4
rand.dist.samp 26.5.8.6
rand.dist.samp.discrete
26.5.8.6.1
rand.dist.samp.pconst 26.5.8.6.2
rand.dist.samp.plinear 26.5.8.6.3
rand.dist.uni 26.5.8.2
rand.dist.uni.int 26.5.8.2.1
rand.dist.uni.real 26.5.8.2.2

26.5.8.4

Cross references

26.5.7

19.2.7

26.5.7.2

24.2.7

26.5.3

20.11.6

28.11

26.5.5

26.5.1.5

20.11.1

20.11.3

26.5.1.3
26.5.2

26.5.1.6
26.5.1.4
26.5.1.1

rand.eng
26.5.3.1
rand.eng.lcong
rand.eng.mers
26.5.3.2
rand.eng.sub 26.5.3.3
rand.predef
rand.req 26.5.1
rand.req.adapt
rand.req.dist
rand.req.eng
rand.req.genl
rand.req.seedseq 26.5.1.2
rand.req.urng
rand.synopsis
rand.util
rand.util.canonical
rand.util.seedseq 26.5.7.1
random.access.iterators
range.error
ratio
20.11
ratio.arithmetic
20.11.4
ratio.comparison 20.11.5
ratio.general
ratio.ratio
ratio.si
ratio.syn 20.11.2
28
re
re.alg
re.alg.match 28.11.2
re.alg.replace
28.11.4
re.alg.search 28.11.3
re.badexp 28.6
re.const
re.def
re.err
re.except
re.general
re.grammar
re.iter
28.12
re.matchﬂag
re.regex 28.8
re.regex.assign 28.8.3
re.regex.const
28.8.1
re.regex.construct
re.regex.locale
re.regex.nmswap 28.8.7.1
re.regex.nonmemb 28.8.7
re.regex.operations
28.8.4
re.regex.swap 28.8.6
re.regiter
re.regiter.cnstr
28.12.1.1
re.regiter.comp 28.12.1.2

28.11.1
28.1

28.5

28.2
28.5.3

28.8.2

28.8.5

28.13

28.5.2

28.12.1

N4296

1277

c(cid:13) ISO/IEC

N4296

28.10

28.10.8

re.regiter.deref 28.12.1.3
re.regiter.incr
28.12.1.4
re.req 28.3
re.results
28.10.4
re.results.acc
re.results.all 28.10.6
re.results.const 28.10.1
re.results.form 28.10.5
re.results.nonmember
re.results.size 28.10.3
re.results.state 28.10.2
re.results.swap 28.10.7
re.submatch 28.9
re.submatch.members 28.9.1
re.submatch.op 28.9.2
re.syn 28.4
re.synopt
28.5.1
re.tokiter 28.12.2
re.tokiter.cnstr 28.12.2.1
re.tokiter.comp 28.12.2.2
re.tokiter.deref 28.12.2.3
re.tokiter.incr
28.12.2.4
re.traits 28.7
reentrancy 17.6.5.8
refwrap 20.9.4
refwrap.access 20.9.4.3
refwrap.assign 20.9.4.2
refwrap.const
20.9.4.1
refwrap.helpers
refwrap.invoke
replacement.functions 17.6.4.6
requirements
res.on.arguments
17.6.4.9
res.on.data.races 17.6.5.9
res.on.exception.handling 17.6.5.12
res.on.functions 17.6.4.8
res.on.headers 17.6.5.2
res.on.macro.deﬁnitions
res.on.objects 17.6.4.10
res.on.pointer.storage
res.on.required 17.6.4.11
reserved.names 17.6.4.3
reverse.iter.cons
24.5.1.3.1
reverse.iter.conv 24.5.1.3.3
reverse.iter.make
24.5.1.3.21
reverse.iter.op!= 24.5.1.3.15
reverse.iter.op+ 24.5.1.3.8
reverse.iter.op++ 24.5.1.3.6
reverse.iter.op+= 24.5.1.3.9
reverse.iter.op-
reverse.iter.op-= 24.5.1.3.11

20.9.4.5
20.9.4.4

24.5.1.3.10

17.6.5.13

17.6.5.3

17.6

24.5.1.3.4
reverse.iter.op.star
reverse.iter.op< 24.5.1.3.14
reverse.iter.op<= 24.5.1.3.18
reverse.iter.op= 24.5.1.3.2
reverse.iter.op== 24.5.1.3.13
reverse.iter.op> 24.5.1.3.16
reverse.iter.op>= 24.5.1.3.17
reverse.iter.opdiﬀ 24.5.1.3.19
reverse.iter.opindex 24.5.1.3.12
reverse.iter.opref
reverse.iter.ops
reverse.iter.opsum 24.5.1.3.20
reverse.iter.op--
reverse.iter.requirements
24.5.1.1
reverse.iterator
reverse.iterators
24.5.1
round.style
runtime.error

18.3.2.5
19.2.6

24.5.1.3.7

24.5.1.3.5

24.5.1.3

24.5.1.2

20.13.5

25.4.5.5

23.3.1

23.4.6

23.4.6.2

23.4.6.3

25.4.5.4

S
scoped.adaptor.operators
sequence.reqmts
23.2.3
sequences
23.3
sequences.general
set
set.cons
set.diﬀerence
set.intersection 25.4.5.3
set.new.handler
18.6.2.4
set.overview 23.4.6.1
set.special
set.symmetric.diﬀerence
set.terminate
18.8.3.2
set.unexpected D.8.2
set.union 25.4.5.2
slice.access
slice.arr.assign 26.6.5.2
slice.arr.comp.assign 26.6.5.3
slice.arr.ﬁll
smartptr
sort
sort.heap 25.4.6.4
special
specialized.addressof
specialized.algorithms
stable.sort
25.4.1.2
stack 23.6.5
stack.cons
stack.cons.alloc
stack.defn 23.6.5.2

20.8
25.4.1.1

23.6.5.3

26.6.4.3

23.6.5.4

26.6.5.4

12

20.7.12.1
20.7.12

Cross references

1278

c(cid:13) ISO/IEC

N4296

6

24.4.3

23.6.5.5

stack.ops
stack.special 23.6.5.6
stack.syn 23.6.5.1
std.exceptions
19.2
std.ios.manip 27.5.6
std.iterator.tags
std.manip 27.7.4
stmt.ambig 6.8
stmt.block 6.3
stmt.break 6.6.1
6.6.2
stmt.cont
stmt.dcl
6.7
stmt.do 6.5.2
stmt.expr 6.2
stmt.for
6.5.3
stmt.goto 6.6.4
stmt.if
6.4.1
stmt.iter 6.5
stmt.jump 6.6
stmt.label
6.1
stmt.ranged 6.5.4
stmt.return 6.6.3
stmt.select 6.4
stmt.stmt
stmt.switch 6.4.2
stmt.while 6.5.1
storage.iterator 20.7.10
stream.buﬀers
stream.buﬀers.overview 27.6.1
24.6
stream.iterators
stream.types 27.5.2
streambuf 27.6.3
streambuf.assign 27.6.3.3.1
streambuf.buﬀer
27.6.3.2.2
streambuf.cons 27.6.3.1
streambuf.get.area
27.6.3.3.2
streambuf.locales 27.6.3.2.1
streambuf.members
27.6.3.2
streambuf.protected 27.6.3.3
streambuf.pub.get 27.6.3.2.3
streambuf.pub.pback 27.6.3.2.4
streambuf.pub.put
27.6.3.2.5
streambuf.put.area 27.6.3.3.3
streambuf.reqts
streambuf.virt.buﬀer
streambuf.virt.get
27.6.3.4.1
streambuf.virt.locales
streambuf.virt.pback 27.6.3.4.4
streambuf.virt.put 27.6.3.4.5
streambuf.virtuals 27.6.3.4
string.access

27.6.3.4.2

27.6.3.4.3

27.6.2

21.4.5

27.6

21.4.7.1

21.4.7.5

21.4.7.9

21.4.3
21.4.6

21.4.1
21.4.8.8
27.8

string.accessors
string.capacity 21.4.4
21.3
string.classes
string.cons
21.4.2
string.conversions
string.io
21.4.8.9
string.iterators
string.modiﬁers
string.nonmembers
string.ops
21.4.7
string.require
string.special
string.streams
string.streams.overview 27.8.1
string::append 21.4.6.2
string::assign 21.4.6.3
string::compare
string::copy 21.4.6.7
string::erase
21.4.6.5
string::ﬁnd 21.4.7.2
string::ﬁnd.ﬁrst.not.of
string::ﬁnd.ﬁrst.of 21.4.7.4
string::ﬁnd.last.not.of 21.4.7.7
string::ﬁnd.last.of
string::insert
21.4.6.4
string::op!= 21.4.8.3
string::op+ 21.4.8.1
string::op+= 21.4.6.1
string::op< 21.4.8.4
string::op<= 21.4.8.6
string::op> 21.4.8.5
string::op>= 21.4.8.7
string::operator== 21.4.8.2
string::replace
string::rﬁnd 21.4.7.3
string::substr
21.4.7.8
string::swap 21.4.6.8
stringbuf
stringbuf.assign 27.8.2.2
stringbuf.cons
stringbuf.members 27.8.2.3
stringbuf.virtuals
27.8.2.4
strings
strings.general
21.1
stringstream 27.8.5
stringstream.assign 27.8.5.2
stringstream.cons
stringstream.members
structure
17.5.1
structure.elements
structure.requirements

17.5.1.1

21.4.6.6

27.8.5.1

27.8.2.1

27.8.2

21

21.5

21.4.8

21.4.7.6

27.8.5.3

17.5.1.3

Cross references

1279

c(cid:13) ISO/IEC

N4296

18.2

19.5.4

17.5.1.5

17.6.3.2

structure.see.also
structure.speciﬁcations 17.5.1.4
structure.summary 17.5.1.2
support.dynamic 18.6
support.exception 18.8
support.general 18.1
support.initlist 18.9
support.initlist.access 18.9.2
support.initlist.cons
18.9.1
support.initlist.range 18.9.3
support.limits 18.3
support.limits.general 18.3.1
support.rtti 18.7
support.runtime
18.10
support.start.term 18.5
support.types
swappable.requirements
syntax 1.6
syserr 19.5
syserr.compare
syserr.errcat
syserr.errcat.derived 19.5.1.4
syserr.errcat.nonvirtuals
syserr.errcat.objects 19.5.1.5
syserr.errcat.overview 19.5.1.1
syserr.errcat.virtuals 19.5.1.2
syserr.errcode
syserr.errcode.constructors
syserr.errcode.modiﬁers
syserr.errcode.nonmembers
syserr.errcode.observers 19.5.2.4
syserr.errcode.overview 19.5.2.1
syserr.errcondition 19.5.3
syserr.errcondition.constructors
syserr.errcondition.modiﬁers
syserr.errcondition.nonmembers
syserr.errcondition.observers 19.5.3.4
syserr.errcondition.overview 19.5.3.1
syserr.hash 19.5.5
syserr.syserr 19.5.6
syserr.syserr.members
19.5.6.2
syserr.syserr.overview 19.5.6.1

19.5.3.3

19.5.2.2

19.5.2.3

19.5.2.5

19.5.1.3

19.5.1

19.5.2

19.5.3.2

19.5.3.5

14.5.7

T
temp 14
temp.alias
temp.arg 14.3
temp.arg.explicit 14.8.1
temp.arg.nontype 14.3.2
temp.arg.template 14.3.3

Cross references

14.5.6

14.5

14.8.2

14.3.1

14.5.1

14.7.2

14.8.2.5

14.8.2.4

14.8.2.2

14.5.5.2
14.5.5

14.6.2.2
14.6.4

temp.arg.type
temp.class
temp.class.order
temp.class.spec
temp.class.spec.match 14.5.5.1
temp.class.spec.mfunc
14.5.5.3
temp.decls
temp.deduct
temp.deduct.call
14.8.2.1
temp.deduct.conv 14.8.2.3
temp.deduct.decl 14.8.2.6
temp.deduct.funcaddr
temp.deduct.partial
temp.deduct.type
temp.dep 14.6.2
temp.dep.candidate 14.6.4.2
temp.dep.constexpr 14.6.2.3
temp.dep.expr
temp.dep.res
temp.dep.temp 14.6.2.4
14.6.2.1
temp.dep.type
temp.expl.spec
14.7.3
temp.explicit
temp.fct
temp.fct.spec
14.8
temp.friend 14.5.4
temp.func.order
temp.inject
14.7.1
temp.inst
14.6.1
temp.local
temp.mem 14.5.2
temp.mem.class
14.5.1.2
temp.mem.enum 14.5.1.4
temp.mem.func
14.5.1.1
temp.names
temp.nondep 14.6.3
temp.over
temp.over.link 14.5.6.1
temp.param 14.1
temp.point
temp.res
14.6
temp.spec 14.7
temp.static
temp.type
temp.variadic
template.bitset
template.gslice.array 26.6.7
template.gslice.array.overview 26.6.7.1
template.indirect.array 26.6.9
template.indirect.array.overview 26.6.9.1
template.mask.array 26.6.8

14.5.1.3
14.4

14.5.3
20.6

14.6.4.1

14.5.6.2

14.6.5

14.2

14.8.3

1280

c(cid:13) ISO/IEC

N4296

20.7.11

30.4.2.2

18.8.3.1

30.4.2.2.1

30.4.2.3.2

30.4.2.3.1

template.mask.array.overview 26.6.8.1
template.slice.array 26.6.5
template.slice.array.overview 26.6.5.1
template.valarray 26.6.2
template.valarray.overview 26.6.2.1
temporary.buﬀer
terminate 18.8.3.4
terminate.handler
thread 30
thread.condition 30.5
thread.condition.condvar 30.5.1
thread.condition.condvarany 30.5.2
thread.decaycopy 30.2.6
thread.general 30.1
thread.lock 30.4.2
thread.lock.algorithm 30.4.3
thread.lock.guard 30.4.2.1
thread.lock.shared 30.4.2.3
thread.lock.shared.cons
thread.lock.shared.locking
thread.lock.shared.mod 30.4.2.3.3
thread.lock.shared.obs
30.4.2.3.4
thread.lock.unique
thread.lock.unique.cons
thread.lock.unique.locking 30.4.2.2.2
thread.lock.unique.mod 30.4.2.2.3
thread.lock.unique.obs
30.4.2.2.4
thread.mutex 30.4
thread.mutex.class
30.4.1.2.2
thread.mutex.recursive
thread.mutex.requirements 30.4.1
thread.mutex.requirements.general
30.4.1.1
thread.mutex.requirements.mutex 30.4.1.2
thread.once 30.4.4
thread.once.callonce 30.4.4.2
thread.once.onceﬂag
30.4.4.1
thread.req 30.2
thread.req.exception 30.2.2
thread.req.lockable
30.2.5
thread.req.lockable.basic 30.2.5.2
thread.req.lockable.general 30.2.5.1
thread.req.lockable.req 30.2.5.3
thread.req.lockable.timed 30.2.5.4
thread.req.native 30.2.3
thread.req.paramname
thread.req.timing
thread.sharedtimedmutex.class
thread.sharedtimedmutex.requirements
thread.thread.algorithm 30.3.1.7
thread.thread.assign 30.3.1.4
thread.thread.class

30.4.1.4.1

30.4.1.2.1

30.3.1

30.2.4

30.2.1

30.4.1.4

30.4.1.3.1

30.4.1.3.2

30.4.1.3

20.12.5.3

20.12.5.6

20.12.5.5

20.12.5.2
20.12.5.4

30.3

20.12

30.3.1.6

30.3.2

30.3.1.5

20.12.5.8

20.12.5.1

20.12.5.7

20.12.7.3

30.3.1.2
30.3.1.3

thread.thread.constr
thread.thread.destr
thread.thread.id 30.3.1.1
thread.thread.member
thread.thread.static
thread.thread.this
thread.threads
thread.timedmutex.class
thread.timedmutex.recursive
thread.timedmutex.requirements
time
time.clock 20.12.7
time.clock.hires
time.clock.req 20.12.3
time.clock.steady 20.12.7.2
time.clock.system 20.12.7.1
time.duration 20.12.5
time.duration.arithmetic
time.duration.cast
time.duration.comparisons
time.duration.cons
time.duration.literals
time.duration.nonmember
time.duration.observer
time.duration.special
time.general
20.12.1
time.point
time.point.arithmetic
time.point.cast
time.point.comparisons
time.point.cons
time.point.nonmember
time.point.observer
time.point.special
time.syn 20.12.2
time.traits
time.traits.duration_values
time.traits.is_fp 20.12.4.1
time.traits.specializations
tuple
tuple.assign 20.4.2.2
tuple.cnstr
20.4.2.1
tuple.creation 20.4.2.4
tuple.elem 20.4.2.6
20.4.1
tuple.general
tuple.helper
20.4.2.5
tuple.rel
tuple.special
tuple.swap 20.4.2.3
20.4.2.8
tuple.traits
tuple.tuple
20.4.2

20.12.6.2
20.12.6.4

20.12.6.7

20.12.6.3

20.12.6.1

20.4.2.7

20.4.2.9

20.12.4

20.12.6

20.4

20.12.6.6

20.12.6.5

20.12.4.2

20.12.4.3

Cross references

1281

c(cid:13) ISO/IEC

type.descriptions 17.5.2.1
type.descriptions.general 17.5.2.1.1
type.index 20.14
type.index.hash 20.14.4
type.index.members 20.14.3
type.index.overview 20.14.2
type.index.synopsis 20.14.1
type.info 18.7.1

20.8.1.3.4
20.8.1.3.3

20.8.1.1

20.8.1.3

U
uncaught.exceptions 18.8.4
underﬂow.error 19.2.9
unexpected D.8.4
unexpected.handler D.8.1
uninitialized.copy 20.7.12.2
uninitialized.ﬁll 20.7.12.3
uninitialized.ﬁll.n 20.7.12.4
unique.ptr 20.8.1
unique.ptr.create 20.8.1.4
unique.ptr.dltr
20.8.1.1.2
unique.ptr.dltr.dﬂt
unique.ptr.dltr.dﬂt1 20.8.1.1.3
unique.ptr.dltr.general 20.8.1.1.1
unique.ptr.runtime
unique.ptr.runtime.asgn 20.8.1.3.2
unique.ptr.runtime.ctor 20.8.1.3.1
unique.ptr.runtime.modiﬁers
unique.ptr.runtime.observers
unique.ptr.single 20.8.1.2
unique.ptr.single.asgn 20.8.1.2.3
unique.ptr.single.ctor 20.8.1.2.1
unique.ptr.single.dtor
20.8.1.2.2
unique.ptr.single.modiﬁers
20.8.1.2.5
unique.ptr.single.observers 20.8.1.2.4
unique.ptr.special 20.8.1.5
unord 23.5
unord.general 23.5.1
unord.hash 20.9.13
unord.map 23.5.4
unord.map.cnstr 23.5.4.2
unord.map.elem 23.5.4.3
23.5.4.4
unord.map.modiﬁers
unord.map.overview 23.5.4.1
unord.map.swap 23.5.4.5
unord.map.syn 23.5.2
unord.multimap 23.5.5
unord.multimap.cnstr
unord.multimap.modiﬁers 23.5.5.3
unord.multimap.overview 23.5.5.1
unord.multimap.swap 23.5.5.4

23.5.5.2

N4296

23.5.7

23.2.5.1

23.5.6.2

23.5.7.2

20.8.2.4

20.8.2.2.10

unord.multiset
unord.multiset.cnstr
unord.multiset.overview 23.5.7.1
unord.multiset.swap 23.5.7.3
unord.req 23.2.5
unord.req.except
unord.set
23.5.6
unord.set.cnstr
unord.set.overview 23.5.6.1
unord.set.swap 23.5.6.3
unord.set.syn 23.5.3
upper.bound 25.4.3.2
using
17.6.2
17.6.2.2
using.headers
using.linkage
17.6.2.3
using.overview 17.6.2.1
usrlit.suﬃx 17.6.4.3.4
util.dynamic.safety 20.7.4
util.smartptr
util.smartptr.enab 20.8.2.5
util.smartptr.getdeleter
util.smartptr.hash 20.8.2.7
util.smartptr.ownerless
util.smartptr.shared 20.8.2.2
util.smartptr.shared.assign 20.8.2.2.3
util.smartptr.shared.atomic
20.8.2.6
util.smartptr.shared.cast
20.8.2.2.9
util.smartptr.shared.cmp 20.8.2.2.7
20.8.2.2.1
util.smartptr.shared.const
util.smartptr.shared.create
20.8.2.2.6
20.8.2.2.2
util.smartptr.shared.dest
util.smartptr.shared.io
20.8.2.2.11
util.smartptr.shared.mod 20.8.2.2.4
20.8.2.2.5
util.smartptr.shared.obs
util.smartptr.shared.spec
20.8.2.2.8
util.smartptr.weak 20.8.2.3
util.smartptr.weak.assign 20.8.2.3.3
util.smartptr.weak.const
20.8.2.3.1
util.smartptr.weak.dest
20.8.2.3.2
util.smartptr.weak.mod 20.8.2.3.4
util.smartptr.weak.obs
20.8.2.3.5
util.smartptr.weak.spec 20.8.2.3.6
util.smartptr.weakptr
utilities
utilities.general
utility 20.2
utility.arg.requirements
utility.exchange
20.2.3
utility.requirements
utility.swap 20.2.2

17.6.3.1

20.8.2.1

20.8.2

20

20.1

17.6.3

Cross references

1282

c(cid:13) ISO/IEC

N4296

26.6.2.2

V
valarray.access 26.6.2.4
valarray.assign 26.6.2.3
valarray.binary 26.6.3.1
valarray.cassign 26.6.2.7
valarray.comparison 26.6.3.2
valarray.cons
valarray.members 26.6.2.8
valarray.nonmembers
valarray.range
valarray.special 26.6.3.4
valarray.sub 26.6.2.5
valarray.syn 26.6.1
valarray.transcend 26.6.3.3
valarray.unary 26.6.2.6
value.error.codes 17.6.5.14
vector 23.3.6

26.6.10

26.6.3

23.3.7

vector.bool
vector.capacity 23.3.6.3
vector.cons
vector.data
23.3.6.5
vector.modiﬁers
vector.overview 23.3.6.1
vector.special

23.3.6.2
23.3.6.4

23.3.6.6

W
wide.stream.objects

27.4.3

X
xref F

Y
Z

Cross references

1283

c(cid:13) ISO/IEC

Index

N4296

tion

!, see operator, logical negation
!=, see inequality operator
(), see operator, function call, see declarator, func-

*, see operator, indirection, see multiplication op-

erator, see declarator, pointer

+, see operator, unary plus, see addition operator
++, see operator, increment
,, see comma operator
-, see operator, unary minus, see subtraction op-

erator

->, see operator, class member access
->*, see pointer to member operator
--, see operator, decrement
., see operator, class member access
.*, see pointer to member operator
..., see ellipsis
/, see division operator
:

ﬁeld declaration, 240
label speciﬁer, 137

::, see scope resolution operator
::*, see declarator, pointer to member
<, see less than operator

template and, 336, 338

<...>, see preprocessing directive, header
<=, see less than or equal to operator
<<, see left shift operator
=, see assignment operator
==, see equality operator
>, see greater than operator
>=, see greater than or equal operator
>>, see right shift operator
?:, see conditional expression operator
[], see operator, subscripting, see declarator, ar-

¨...¨, see preprocessing directives, source-ﬁle in-

ray

clusion

# operator, 430, 431
## operator, 431
#define, 430
#elif, 428
#else, 428
#endif, 428
#error, see preprocessing directives, error

#if, 428, 464
#ifdef, 428
#ifndef, 428
#include, 429, 449
#line, see preprocessing directives, line control
#pragma, see preprocessing directives, pragma
#undef, 433, 461
%, see remainder operator
&, see operator, address-of, see bitwise AND oper-

ator, see declarator, reference

&&, see logical AND operator
ˆ, see bitwise exclusive OR operator
__DATE__, 436
__FILE__, 436
__LINE__, 436
__STDC__, 436

implementation-deﬁned, 436

__STDCPP_STRICT_POINTER_SAFETY__, 437

implementation-deﬁned, 437

__STDCPP_THREADS__, 437

implementation-deﬁned, 437

__STDC_HOSTED__, 436

implementation-deﬁned, 436

__STDC_ISO_10646__, 436

implementation-deﬁned, 436
__STDC_MB_MIGHT_NEQ_WC__, 436
implementation-deﬁned, 436

__STDC_VERSION__, 436

implementation-deﬁned, 436

__TIME__, 436
__VA_ARGS__, 430
__cplusplus, 436
~, see destructor
\, see backslash
{}

block statement, 137
class declaration, 226
class deﬁnition, 226
enum declaration, 166
initializer list, 214

_, see character, underscore
|, see bitwise inclusive OR operator
||, see logical OR operator
~, see operator, one’s complement
0, see also zero, null

Cross references

1284

N4296

unspeciﬁed, 232

allocation functions, 66
allowing all exceptions, see exception speciﬁcation,

allowing all exceptions

allowing an exception, see exception speciﬁcation,

allowing an exception

alternative token, see token, alternative
ambiguity

base class member, 246
class conversion, 249
declaration type, 149
declaration versus cast, 193
declaration versus expression, 145
function declaration, 212
member access, 246
overloaded function, 303
parentheses and, 116

Amendment 1, 461
and-expression, 128, 1218
anonymous union, 239
appertain, 186
argc, 62
argument, 2, 463–465, 500

access checking and default, 257
binding of default, 205
evaluation of default, 205, 206
example of default, 204, 205
function call expression, 2
function-like macro, 2
overloaded operator and default, 325
reference, 104
scope of default, 206
template, 339
template instantiation, 2
throw expression, 2
type checking of default, 205

arguments

implementation-deﬁned order of evaluation of

c(cid:13) ISO/IEC

null character, 30
string terminator, 30

abort, 65, 143
abstract-declarator, 192, 1224
abstract-pack-declarator, 192, 1224
access control, 256–266

base class, 259
base class member, 243
class member, 105
default, 256
default argument, 257
friend function, 261
member name, 256
multiple access, 266
nested class, 266
overloading and, 303
private, 256
protected, 256, 264
public, 256
union default member, 227
using-declaration and, 178
virtual function, 265
access-speciﬁer, 243, 1226
access control

anonymous union, 239
member function and, 267
overloading resolution and, 247

access speciﬁer, 257, 259
addition operator, 124
additive-expression, 125, 1217
address, 77, 127
address of member function

unspeciﬁed, 465

aggregate, 214
aggregate initialization, 214
algorithm

stable, 442, 465

alias

namespace, 173
alias template, 363
alias-declaration, 147, 1220
alignment

extended, 80
fundamental, 80

alignment-speciﬁer, 185, 1222
alignment requirement

implementation-deﬁned, 80

allocation

alignment storage, 118
implementation deﬁned bit-ﬁeld, 240

function, 206

argument and name hiding

default, 206

argument and virtual function

default, 206

argument list

empty, 201
variable, 201

argument passing, 104
reference and, 218

stitution

argument type

argument substitution, see macro, argument sub-

Cross references

1285

c(cid:13) ISO/IEC

N4296

unknown, 201

argv, 62
arithmetic

pointer, 125
unsigned, 75

array, 201

bound, 199
const, 78
delete, 121
multidimensional, 200
new, 117
overloading and pointer versus, 301
sizeof, 115
storage of, 200

array

as aggregate, 777
contiguous storage, 776
initialization, 777, 778
tuple interface to, 779
zero sized, 779

array size

default, 199

arrow operator, see operator, class member access
as-if rule, 8
asm

implementation-deﬁned, 182

asm-deﬁnition, 182, 1222
assembler, 182
<assert.h>, 450
assignment

and lvalue, 131
conversion by, 131
copy, see assignment operator, copy
move, see assignment operator, move, 441
reference, 218

assignment operator

copy, 267, 291–294

hidden, 293
implicitly declared, 291
implicitly deﬁned, 293
inaccessible, 294
trivial, 293
virtual bases and, 294

move, 267, 291–294

hidden, 293
implicitly declared, 292
implicitly deﬁned, 293
inaccessible, 294
trivial, 293

overloaded, 326

assignment-expression, 131, 1218

assignment-operator, 131, 1218
associative containers

exception safety, 764
requirements, 764
unordered, see unordered associative contain-

ers

asynchronous provider, 1196
asynchronous return object, 1196
atexit, 65
atomic operations, see operation, atomic
attribute, 185–189
alignment, 186
carries dependency, 188
deprecated, 189
noreturn, 188
syntax and semantics, 185

attribute, 185, 1222
attribute-argument-clause, 186, 1223
attribute-declaration, 147, 1220
attribute-list, 185, 1222
attribute-namespace, 186, 1223
attribute-scoped-token, 186, 1223
attribute-speciﬁer, 185, 1222
attribute-speciﬁer-seq, 185, 1222
attribute-token, 185, 1222
automatic storage duration, 66
awk, 1106

backslash character, 27
bad_alloc, 119
bad_cast, 107
bad_exception, 425
bad_typeid, 108
bad_typeid::what

implementation-deﬁned, 489

balanced-token, 186, 1223
balanced-token-seq, 186, 1223
base class

dependent, 373
overloading and, 302

base class subobject, 7
base-clause, 243, 1225
base-speciﬁer, 243, 1226
base-speciﬁer-list, 243, 1225
base-type-speciﬁer, 243, 1226
BaseCharacteristic, 603
base class, 243, 244

direct, 243
indirect, 243
private, 259
protected, 259

Cross references

1286

c(cid:13) ISO/IEC

N4296

public, 259

base class virtual, see virtual base class
basic_ios::failure argument

implementation-deﬁned, 1028

unordered associative containers, 772

begin

behavior

conditionally-supported, 2, 5
default, 440, 444
implementation-deﬁned, 3, 8
locale-speciﬁc, 3
observable, 8, 9
on receipt of signal, 8
required, 441, 444
undeﬁned, 4, 5, 8
unspeciﬁed, 4, 8

Ben, 303
Bernoulli distributions, 962–965
bernoulli_distribution

discrete probability function, 962

binary fold, 101
binary function, 586
binary left fold, 102
binary operator

overloaded, 326
binary right fold, 102
binary-digit, 24, 1212
binary-literal, 24, 1212
BinaryTypeTrait, 603
binary operator

interpretation of, 326

bind directly, 220
binding

reference, 218

binomial_distribution

discrete probability function, 963

bit-ﬁeld, 240

address of, 240
alignment of, 240
implementation-deﬁned sign of, 1239
implementation deﬁned alignment of, 240
type of, 240
unnamed, 240
zero width of, 240

bitmask

empty, 446

block, 439

initialization in, 144

block scope, 41
block statement, see statement, compound
block-declaration, 147, 1219

block structure, 144
body

function, 207

Boolean, 240
Boolean literal, 31
boolean literal, see literal, boolean
boolean-literal, 31, 1214
Boolean type, 76
bound arguments, 596
bound, of array, 199
brace-or-equal-initializer, 210, 1224
braced-init-list, 210, 1224
bucket

unordered associative containers, 772

unordered associative containers, 772

unordered associative containers, 772

bucket_count

bucket_size

buckets, 765
byte, 6, 115

C

linkage to, 183
standard, 1
standard library, 1
Unicode TR, 1

c-char, 26, 1213
c-char-sequence, 26, 1213
call

operator function, 325
pseudo destructor, 105

call signature, 585
call wrapper, 585

forwarding, 585
simple, 585
type, 585
Callable, 599
callable object, 585, 599
callable type, 585
capture, 94, 1215
capture-default, 94, 1215
capture-list, 94, 1215
captured, 98

by copy, 99
by reference, 99

carries a dependency, 12
carry

<cassert>, 450
cast

base class, 110

subtract_with_carry_engine, 951

Cross references

1287

c(cid:13) ISO/IEC

N4296

const, 112, 122
derived class, 110
dynamic, 107, 488

construction and, 288
destruction and, 288
integer to pointer, 111
lvalue, 109, 111
pointer-to-function, 111
pointer-to-member, 110, 112
pointer to integer, 111
reference, 109, 112
reinterpret, 111, 122

integer to pointer, 111
lvalue, 111
pointer to integer, 111
pointer-to-function, 111
pointer-to-member, 112
reference, 112
static, 109, 122

lvalue, 109
reference, 109

undeﬁned pointer-to-function, 111

cast-expression, 122, 1217
casting, 105
casting away constness, 113
catch, 414
cauchy_distribution

probability density function, 972

unordered associative containers, 772

unordered associative containers, 772

cbegin

cend

<cerrno>, 461
char

implementation-deﬁned sign of, 75

char-like object, 648
char-like type, 648
char16_t, 26
char16_t character, 26
char32_t, 26
char32_t character, 26
char_class_type

decimal-point, 446
multibyte, 3
signed, 75
source ﬁle, 17
underscore, 23

in identiﬁer, 23

regular expression traits, 1096

character, 439

character literal, see literal, character

Cross references

1288

character set, 18–19

basic execution, 6
basic source, 17, 18

character string literal, 431
character-literal, 26, 1213
character string, 29
checking

point of error, 366
syntax, 366

chi_squared_distribution

probability density function, 972

class, 77, 226–242
abstract, 254
base, 461, 466
cast to incomplete, 123
constructor and abstract, 255
deﬁnition, 36
derived, 466
linkage of, 59
linkage speciﬁcation, 184
member function, see member function, class
pointer to abstract, 254
polymorphic, 249
scope of enumerator, 168
standard-layout, 227
trivial, 227
unnamed, 154

class-head, 226, 1225
class-head-name, 226, 1225
class-key, 226, 1225
class-name, 226, 1225
class-or-decltype, 243, 1226
class-speciﬁer, 226, 1225
class-virt-speciﬁer, 226, 1225
class local, see local class
class name

elaborated, 162, 229, 230
point of declaration, 230
scope of, 229
typedef, 153, 154, 230
class nested, see nested class
class object

assignment to, 131
member, 232
sizeof, 115

class object copy, see copy constructor
class object initialization, see constructor
clear

unordered associative containers, 771

<clocale>, 446
closure object, 94

c(cid:13) ISO/IEC

N4296

closure type, 94
collating element, 1095
comment, 19, 21

/* */, 21
//, 21

common initial sequence, 233
comparison

pointer, 127
pointer to function, 127
undeﬁned pointer, 125

ble
compilation

separate, 17

compatible, see exception speciﬁcation, compati-

compiler control line, see preprocessing directives
complete object, 7
complete object of, 7
completely deﬁned, 231
component, 440
compound-statement, 137, 1218
concatenation

macro argument, see ##
string, 30

condition, 138, 1219
conditions

rules for, 138

conditional-expression

throw-expression in, 129

conditional-expression, 129, 1218
conditionally-supported behavior

seebehavior, conditionally-supported, 1

conﬂict, 12
conformance requirements, 5, 8

class templates, 5
classes, 5
general, 5
library, 5
method of description, 5

linkage, 150
linkage speciﬁcation, 184
type declaration, 62

consistency

const, 77

cast away, 113
constructor and, 236, 268
destructor and, 236, 275
linkage of, 59
overloading and, 302

const_cast, see cast, const
const_local_iterator, 766

unordered associative containers, 766

Cross references

1289

constant, 24, 91

enumeration, 167
null pointer, 86
constant expression

permitted result of, 135

constant iterator, 852
constant-expression, 132, 1218
constexpr function, 154
construction, 286–288

constructor, 267

dynamic cast and, 288
member access, 286
move, 440
pointer to member or base, 286
typeid operator, 287
virtual function call, 287

address of, 269
array of class objects and, 280
converting, 273
copy, 267, 270, 288–291, 447

elision, 294
implicitly declared, 289
implicitly deﬁned, 291
inaccessible, 294
trivial, 290

default, 267, 268
exception handling, see exception handling,

constructors and destructors

explicit call, 269
implicitly called, 269
implicitly deﬁned, 269
inheritance of, 268
inheriting, 296–299
move, 267, 288–291

elision, 294
implicitly declared, 290
implicitly deﬁned, 291
inaccessible, 294
trivial, 290

non-trivial, 268
random number distribution requirement, 943
random number engine requirement, 940
union, 238
unspeciﬁed argument to, 119

constructor, conversion by, see conversion, user-

deﬁned

constructor, default, see default constructor
const-object

undeﬁned change to, 158

container

contiguous, 749

c(cid:13) ISO/IEC

N4296

contextually converted to bool, see conversion, con-

context

non-deduced, 405

textual

contiguous container, 749
contiguous iterators, 853
continue

and handler, 414
and try block, 414

control line, see preprocessing directives
control-line, 426, 1228
conventions, 445
lexical, 17–33

conversion

conversion rank, 316
conversion-declarator, 273, 1226
conversion-function-id, 273, 1226
conversion-type-id, 273, 1226
conversion explicit type, see casting
conversion function, see conversion, user-deﬁned
copy

class object, see constructor, copy; assignment,

copy

copy constructor

random number engine requirement, 940

copy elision, see constructor, copy, elision; con-

structor, move, elision

copy-initialization, 213
CopyInsertable into X, 750
count

unordered associative containers, 772

conversion operator, see conversion, user deﬁned

Cross references

1290

argument, 201
array-to-pointer, 83
bool, 85
boolean, 87
class, 272
contextual, 82
contextual to bool, 82
deduced return type of user-deﬁned, 275
derived-to-base, 315
ﬂoating point, 85
ﬂoating to integral, 86
function-to-pointer, 83
implementation deﬁned pointer integer, 111
implicit, 82, 272
implicit user-deﬁned, 272
inheritance of user-deﬁned, 274
integer rank, 87
integral, 85
integral to ﬂoating, 86
lvalue-to-rvalue, 83, 1235
narrowing, 224
overload resolution and pointer, 324
overload resolution and, 312
pointer, 86
pointer to member, 86

void*, 87

qualiﬁcation, 84
return type, 143
standard, 82–87
static user-deﬁned, 275
to signed, 85
to unsigned, 85
type of, 273
user-deﬁned, 272, 273
usual arithmetic, 89
virtual user-deﬁned, 275

<cstdarg>, 201
<cstddef>, 115, 125
<cstdint>, 478
<cstdlib>, 65, 449
<cstring>, 447
ctor-initializer, 281, 1226
<cuchar>, 461
cv-decomposition, 84
cv-qualiﬁcation signature, 84
cv-qualiﬁer, 77

top-level, 78

cv-qualiﬁer, 192, 1223
cv-qualiﬁer-seq, 192, 1223
<cwchar>, 461
<cwctype>, 461

d-char, 29, 1214
d-char-sequence, 28, 1214
DAG

multiple inheritance, 245, 246
non-virtual base class, 246
virtual base class, 245, 246

data race, 14
data member, see member
data race, 14
deadlock, 440
deallocation, see delete
deallocation functions, 66
decay, see conversion, array to pointer; conversion,

function to pointer

DECAY_COPY, 1162
decimal-literal, 24, 1212
decl-speciﬁer, 149, 1220
decl-speciﬁer-seq, 149, 1220

c(cid:13) ISO/IEC

N4296

declaration, 34, 147–189

array, 198
asm, 182
bit-ﬁeld, 240
class name, 35
constant pointer, 195
default argument, 204–207
deﬁnition versus, 34
ellipsis in function, 104, 201
enumerator point of, 40
extern, 35
extern reference, 218
forward, 151
forward class, 229
function, 35, 200
local class, 242
member, 230
multiple, 62
name, 34
opaque enum, 35
overloaded, 300
overloaded name and friend, 263
parameter, 35, 201
parentheses in, 193, 195
pointer, 195
reference, 196
register, 150
static member, 35
storage class, 149
type, 194
typedef, 35
typedef as type, 152

declaration, 147, 1219
declaration-seq, 147, 1219
declaration-statement, 143, 1219
declaration hiding, see name hiding
declarative region, 39
declarator, 35, 148, 191–225

array, 198
function, 200–203
meaning of, 194–207
multidimensional array, 199
pointer, 195
pointer to member, 198
reference, 196

declarator, 191, 1223
declarator-id, 192, 1223
decltype-speciﬁer, 159, 1221
decrement operator

default access control, see access control, default
default constructor

random number distribution requirement, 943
seed sequence requirement, 938

default-initialization, 211
default-inserted, 750
defaulted, 209
DefaultInsertable into X, 750
default argument

overload resolution and, 312

default initializers

overloading and, 302

deferred function, 1205
deﬁnition, 35

alternate, 461
class, 226, 231
class name as type, 229
constructor, 207
declaration as, 148
function, 207–210

deleted, 209
explicitly-defaulted, 208

local class, 242
member function, 233
namespace, 169
nested class, 240
pure virtual function, 254
scope of class, 229
static member, 237
virtual function, 252

deﬁnitions, 2–4
delete, 66, 120, 121, 278

array, 121
destructor and, 121, 276
object, 120
operator, 462
overloading and, 68
type of, 278
undeﬁned, 121

delete-expression, 120, 1217
deleter, 556
dependency-ordered before, 13
deprecated features, 106, 115
dereferencing, see also indirection
derivation, see inheritance
derived class

most, see most derived class

derived object

most, see most derived object

derived class, 243–255
destruction, 286–288

overloaded, see overloading, decrement oper-

ator

Cross references

1291

c(cid:13) ISO/IEC

N4296

dynamic cast and, 288
member access, 286
pointer to member or base, 286
typeid operator, 287
virtual function call, 287

destructor, 275, 447

default, 275
exception handling, see exception handling,

constructors and destructors

explicit call, 276
implicit call, 276
implicitly deﬁned, 276
non-trivial, 275
program termination and, 276
pure virtual, 276
union, 238
virtual, 276

diagnosable rules, 5
diagnostic message, see message, diagnostic
digit, 22, 1211
digit-sequence, 28, 1213
digraph, see token, alternative, 20
directed acyclic graph, see DAG
directive, preprocessing, see preprocessing direc-

tives

discard

random number engine requirement, 940

discard_block_engine

generation algorithm, 952
state, 952
textual representation, 953
transition algorithm, 952
discarded-value expression, 90
discrete probability function

bernoulli_distribution, 962
binomial_distribution, 963
discrete_distribution, 975
geometric_distribution, 964
negative_binomial_distribution, 965
poisson_distribution, 965
uniform_int_distribution, 960

discrete_distribution

discrete probability function, 975
weights, 975

distribution, see random number distribution
dominance

virtual base class, 248

dot operator, see operator, class member access
dynamic binding, see virtual function
dynamic initialization, 63
dynamic type, see type, dynamic

dynamic-exception-speciﬁcation, 419, 1227
dynamic_cast, see cast, dynamic

ECMA-262, 1
ECMAScript, 1106, 1139
egrep, 1106
elaborated-type-speciﬁer, 162, 1221
elaborated type speciﬁer, see class name, elabo-

rated

elif-group, 426, 1228
elif-groups, 426, 1228
elision

copy, see constructor, copy, elision; construc-

tor, move, elision

copy constructor, see constructor, copy, eli-

move constructor, see constructor, move, eli-

sion

sion

ellipsis

conversion sequence, 104, 317
overload resolution and, 312

else-group, 426, 1228
EmplaceConstructible into X from args, 750
empty future object, 1201
empty shared_future object, 1203
empty-declaration, 147, 1220
enclosing-namespace-speciﬁer, 169, 1222
encoding

multibyte, 30

encoding-preﬁx, 26, 1213
end

unordered associative containers, 772

end-of-ﬁle, 540
endif-line, 426, 1228
engine, see random number engine
engine adaptor, see random number engine adap-

tor

engines with predeﬁned parameters
default_random_engine, 956
knuth_b, 956
minstd_rand, 955
minstd_rand0, 955
mt19937, 955
mt19937_64, 956
ranlux24, 956
ranlux24_base, 956
ranlux48, 956
ranlux48_base, 956

entity, 34
enum, 77

overloading and, 301

Cross references

1292

c(cid:13) ISO/IEC

N4296

type of, 166, 167
underlying type, 167

enum-base, 166, 1221
enum-head, 166, 1221
enum-key, 166, 1221
enum-name, 166, 1221
enum-speciﬁer, 166, 1221
enumeration, 166, 167

linkage of, 59
scoped, 167
unscoped, 167

enumeration scope, 44
enumeration type

conversion to, 110
static_cast

conversion to, 110

enumerator

deﬁnition, 36
value of, 167

enumerator, 166, 1222
enumerator-deﬁnition, 166, 1221
enumerator-list, 166, 1221
enum name

typedef, 154

environment

program, 62

epoch, 628
equal_range

unordered associative containers, 772

equality-expression, 127, 1217
equivalence

template type, 344
type, 152, 229

equivalent-key group, 764
equivalently-valued, 459
equivalent parameter declarations, 301

overloading and, 301

Erasable from X, 751
erase

unordered associative containers, 771

escape-sequence, 26, 1213
escape character, see backslash
escape sequence

undeﬁned, 27

Evaluation, 10
evaluation

order of argument, 104
unspeciﬁed order of, 10, 64
unspeciﬁed order of argument, 104
unspeciﬁed order of function call, 104

example

array, 199
class deﬁnition, 232
const, 195
constant pointer, 195
constructor, 269
constructor and initialization, 280
declaration, 35, 202
declarator, 192
deﬁnition, 35
delete, 278
derived class, 243
destructor and delete, 278
ellipsis, 201
enumeration, 168
explicit destructor call, 277
explicit qualiﬁcation, 247
friend, 230
friend function, 261
function declaration, 202
function deﬁnition, 207
linkage consistency, 150
local class, 242
member function, 234, 261
nested type name, 242
nested class, 240
nested class deﬁnition, 241, 266
nested class forward declaration, 241
pointer to member, 198
pure virtual function, 254
scope of delete, 278
scope resolution operator, 247
static member, 237
subscripting, 199
typedef, 152
type name, 192
unnamed parameter, 207
variable parameter list, 201
virtual function, 251, 252

exception

arithmetic, 88
undeﬁned arithmetic, 88

<exception>, 489
exception handling, 414–425

constructors and destructors, 417
exception object, 416

constructor, 416
destructor, 416

function try block, 415
goto, 414
handler, 414, 416–419, 466

array in, 417

Cross references

1293

c(cid:13) ISO/IEC

N4296

exception object, see exception handling, excep-

incomplete type in, 417
match, 417–419
pointer to function in, 417
rvalue reference in, 417

memory, 416
nearest handler, 416
rethrow, 130, 131, 416
rethrowing, 416
switch, 414
terminate() called, 131, 416, 421
throwing, 130, 415, 416
try block, 414
unexpected() called, 421

tion object

exception speciﬁcation, 419–424
allowing all exceptions, 421
allowing an exception, 421
compatible, 420
incomplete type and, 419
noexcept

constant expression and, 419

non-throwing, 419
virtual function and, 420

exception-declaration, 414, 1227
exception-speciﬁcation, 419, 1227
exception::what message

implementation-deﬁned, 490
exclusive-or-expression, 128, 1218
execution agent, 1160
exit, 62, 64, 143
explicit-instantiation, 384, 1227
explicit-specialization, 386, 1227
explicitly captured, 97
explicit type conversion, see casting
exponent-part, 28, 1213
exponential_distribution

probability density function, 966

expression, 88–136

decrement, 106, 115
delete, 120
dynamic cast, 107
equality operators, 127
fold, 101–102
function call, 103
increment, 106, 115
lambda, 94–101
left-shift-operator, 126
logical AND, 128
logical OR, 129
multiplicative operators, 124
new, 115
noexcept, 122
order of evaluation of, 9
parenthesized, 92
pointer-to-member, 123
pointer to member constant, 114
postﬁx, 102–113
primary, 91–101
pseudo-destructor call, 105
reference, 88
reinterpret cast, 111
relational operators, 126
right-shift-operator, 126
rvalue reference, 88
sizeof, 115
static cast, 109
throw, 130
type identiﬁcation, 108
unary, 113–122
unary operator, 113

expression, 132, 1218
expression-list, 102, 1216
expression-statement, 137, 1218
extend, see namespace, extend
extended alignment, 80
extended integer type, 75
extended signed integer type, 75
extended unsigned integer type, 75
extern, 149

linkage of, 150

extern "C", 450, 461
extern "C++", 450, 461
external linkage, 59
extreme_value_distribution

probability density function, 969

ﬁle, source, see source ﬁle
ﬁnal overrider, 250
find

additive operators, 124
alignof, 122
assignment and compound assignment, 131
bitwise AND, 128
bitwise exclusive OR, 128
bitwise inclusive OR, 128
cast, 105, 122–123
class member access, 105
comma, 132
conditional operator, 129
constant, 132
const cast, 112

Cross references

1294

c(cid:13) ISO/IEC

N4296

unordered associative containers, 771

ﬁnite state machine, 1095
fisher_f_distribution

probability density function, 973

ﬂoating literal, see literal, ﬂoating
ﬂoating-literal, 27, 1213
ﬂoating-point literal, see literal, ﬂoating
ﬂoating-suﬃx, 28, 1213
ﬂoating point type, 76

implementation-deﬁned, 76

fold

binary, 101
unary, 101

fold-expression, 101, 1216
fold-operator, 101, 1216
for

scope of declaration in, 141

for-init-statement, 139, 1219
for-range-declaration, 140, 1219
for-range-initializer, 140, 1219
format speciﬁer, 1095
forwarding call wrapper, 585
forwarding reference, 400
fractional-constant, 28, 1213
free store, 278
freestanding implementation, 5
free store, see also new, delete
friend

virtual and, 252
access speciﬁer and, 263
class access and, 261
inheritance and, 263
local class and, 264
template and, 352

friend function

access and, 261
inline, 263
linkage of, 263
member function and, 261

friend function

nested class, 241

allocation, 67, 117
comparison, 440
conversion, 273
deallocation, 67, 121, 278
deﬁnition, 36
global, 461, 464, 465
handler, 440

linkage speciﬁcation overloaded, 184
modiﬁer, 440
observer, 441
operator, 325
overload resolution and, 304
plain old, 495
pointer to member, 124
replacement, 441
reserved, 441
viable, 304
virtual member, 461, 465

function object, 582
binders, 594–597
mem_fn, 597
reference_wrapper, 586
type, 582
wrapper, 597–602

function pointer type, 77
function try block, see exception handling, func-

tion try block

function, overloaded, see overloading
function, virtual, see virtual function
function-deﬁnition, 207, 1224
function-like macro, see macro, function-like
function-speciﬁer, 151, 1220
function-try-block, 414, 1227
functions

candidate, 378

function argument, see argument
function call, 104
recursive, 104
undeﬁned, 111

function call operator
overloaded, 326

function parameter, see parameter
function prototype, 41
function return, see return
function return type, see return type
fundamental alignment, 80
fundamental type

destructor and, 277

deﬁned

future

shared state, 1196

gamma_distribution

probability density function, 967

generate

seed sequence requirement, 938

generated destructor, see destructor, default

full-expression, 9
function, see also friend function; member func-
tion; inline function; virtual function, 201

fundamental type conversion, see conversion, user-

Cross references

1295

c(cid:13) ISO/IEC

N4296

generation algorithm

discard_block_engine, 952
independent_bits_engine, 953
linear_congruential_engine, 948
mersenne_twister_engine, 949
shuffle_order_engine, 954
subtract_with_carry_engine, 951

generic lambda

deﬁnition of, 163

geometric_distribution

discrete probability function, 964

global, 42
global namespace, 42
global namespace scope, 42
global scope, 42
glvalue, 79
goto

and handler, 414
and try block, 414
initialization and, 144

grammar

regular expression, 1139

grep, 1106
group, 426, 1228
group-part, 426, 1228

h-char, 21, 1211
h-char-sequence, 21, 1211
handler, see exception handling, handler
handler, 414, 1227
handler-seq, 414, 1227
happens before, 13
hash

instantiation restrictions, 602

hash code, 765
hash function, 764
hash tables, see unordered associative containers
hash_function

unordered associative containers, 769

hasher

header

C, 461, 464, 1253
C library, 450
C++ library, 448
name, 21

header-name, 21, 1211
hex-quad, 18, 1210
hexadecimal-digit, 24, 1212
hexadecimal-escape-sequence, 26, 1213
hexadecimal-literal, 24, 1212

hiding, see name hiding
high-order bit, 6
hosted implementation, 5

id

qualiﬁed, 93
id-expression, 92
id-expression, 91, 1215
identiﬁer, 22–23, 92, 148
identiﬁer, 22, 1211
identiﬁer-list, 427, 1229
identiﬁer-nondigit, 22, 1211
if-group, 426, 1228
if-section, 426, 1228
ill-formed program, see program, ill-formed
immediate subexpression, 421
immolation
self, 389

implementation

freestanding, 449
hosted, 449

implementation limits, see limits, implementation
implementation-deﬁned, 461, 469, 480, 486, 488–

491, 697, 1021, 1074, 1250

implementation-deﬁned behavior, see behavior, implemen-

tation-deﬁned

implementation-dependent, 1046
implementation-generated, 35
implicit capture

deﬁnition of, 98

implicit object parameter, 304
implicitly-declared default constructor, see con-

structor, default, 268

implicit conversion, see conversion, implicit
implied object argument, 304

implicit conversion sequences, 305
non-static member function and, 305

inclusion

conditional, see preprocessing directive, con-

ditional inclusion

ﬁle inclusion

inclusive-or-expression, 128, 1218
incomplete, 125
incompletely-deﬁned object type, 73
increment

bool, 106, 115
increment operator

overloaded, see overloading, increment oper-

ator

independent_bits_engine

unordered associative containers, 765

source ﬁle, see preprocessing directives, source-

Cross references

1296

c(cid:13) ISO/IEC

N4296

generation algorithm, 953
state, 953
textual representation, 954
transition algorithm, 953
indeterminately sequenced, 10
indeterminate value, 212
indirection, 113
inheritance, 243
init-capture, 94, 1216
init-declarator, 191, 1223
init-declarator-list, 191, 1223
initialization, 62, 210–225

aggregate, 214
array, 214
array of class objects, 217, 280
automatic, 144
automatic object, 210
base class, 281, 282
character array, 217
character array, 217
class member, 212
class object, see also constructor, 214, 279–

285

const, 158, 214
const member, 282
constant, 63
constructor and, 279, 280
copy, 213
default, 211
default constructor and, 279
deﬁnition and, 148
direct, 213
dynamic, 62
explicit, 280
jump past, 144
list-initialization, 220–225
local static, 144
member, 281
member function call during, 285
member object, 282
non-vacuous, 69
order of, 62, 244
order of base class, 284
order of member, 284
order of virtual base class, 283
overloaded assignment and, 280
parameter, 103
reference, 197, 218
reference member, 282
run-time, 62
static and thread, 62

static member, 237
static object, 62
static object, 210, 211
union, 217, 239
virtual base class, 291

initializer

base class, 207
member, 207
pack expansion, 285
scope of member, 284
temporary and declarator, 271

seed sequence requirement, 938

initializer, 210, 1224
initializer-clause, 210, 1224
initializer-list, 210, 1224
initializer-list constructor

<initializer_list>, 494
injected-class-name, 226
inline, 464
inline

linkage of, 59
inline function, 151
insert

unordered associative containers, 770, 771

instantiation

dependent member of the current, 373
explicit, 384
member of the current, 373
point of, 377
template implicit, 380

instantiation units, 18
integer literal, see literal, integer
integer representation, 69
integer-literal, 24, 1212
integer-suﬃx, 24, 1212
integer type, 76
integral type, 76
sizeof, 75

inter-thread happens before, 13
internal linkage, 59
interval boundaries

invocation

macro, 431

isctype

regular expression traits, 1097
iteration-statement, 139, 143, 1219

Jessie, 273
jump-statement, 142, 1219

piecewise_constant_distribution, 977
piecewise_linear_distribution, 978

Cross references

1297

c(cid:13) ISO/IEC

N4296

linkage speciﬁcation, see speciﬁcation, linkage
linkage-speciﬁcation, 182, 1222
literal, 24–33, 91

unordered associative containers, 769

unordered associative containers, 766

unordered associative containers, 765

key_eq

key_equal

key_type

keyword, 23

label, 143

case, 137, 139
default, 137, 139
scope of, 42, 137

labeled-statement, 137, 1218
lambda-capture, 94, 1215
lambda-declarator, 94, 1216
lambda-expression, 94, 1215
lambda-introducer, 94, 159, 1215
lattice, see DAG, subobject
layout

bit-ﬁeld, 240
class object, 232, 244
layout-compatible, 75, 168
layout-compatible type, 75
left shift

undeﬁned, 126

left shift operator, 126
lexical conventions, see conventions, lexical
library

C standard, 439, 446, 448, 450, 1249, 1250,

C++ standard, 438, 461, 463, 466

1253

library clauses, 5
lifetime, 69
limits

implementation, 3

<limits>, 469
line splicing, 17
linear_congruential_engine
generation algorithm, 948
modulus, 949
state, 948
textual representation, 949
transition algorithm, 948

linkage, 34, 59–62
const and, 59
external, 59, 450, 461
implementation-deﬁned object, 185
inline and, 59
internal, 59
no, 59, 60
static and, 59

base of integer, 25
binary, 25
boolean, 31
char16_t, 26
char32_t, 26
character, 26
constant, 24
decimal, 25
double, 28
float, 28
ﬂoating, 27, 28
hexadecimal, 25
char, 27
integer, 24, 25
long, 25
long double, 28
multicharacter, 26

narrow-character, 26
octal, 25
pointer, 31
string, 28, 29

char16_t, 29
char32_t, 29, 30
narrow, 29
type of, 29
undeﬁned change to, 30
wide, 29, 30

type of character, 26
type of ﬂoating point, 28
type of integer, 25
unsigned, 25
user deﬁned, 31

implementation-deﬁned value of, 26

literal, 24, 1212
literal type, 74
literal-operator-id, 328, 1226
load_factor

local lambda expression, 97
local variable, 41
local_iterator, 766

unordered associative containers, 773

unordered associative containers, 766

locale, 1095, 1096, 1098, 1106
locale-speciﬁc behavior, see behavior, locale-speciﬁc
local class

friend, 264
member function in, 234
scope of, 242

Cross references

1298

c(cid:13) ISO/IEC

N4296

local scope, see block scope
local variable

destruction of, 142, 144

lock-free executions, 11
logical-and-expression, 128, 1218
logical-or-expression, 129, 1218
lognormal_distribution

probability density function, 971

long

typedef and, 149

long-long-suﬃx, 25, 1213
long-suﬃx, 25, 1213
lookup

argument-dependent, 49
class member, 58
class member, 52
elaborated type speciﬁer, 57
member name, 246
name, 34, 45–59
namespace aliases and, 59
namespace member, 53
qualiﬁed name, 51–56
template name, 364
unqualiﬁed name, 45
using-directives and, 59

lookup_classname

regular expression traits, 1141

lookup_classname

regular expression traits, 1097

lookup_collatename

regular expression traits, 1097

low-order bit, 6
lowercase, 446
lparen, 427, 1228
lvalue, 79, 1235
lvalue reference, 76, 196

macro

argument substitution, 431
function-like, 430
arguments, 431

masking, 464
name, 430
object-like, 430
pragma operator, 437
predeﬁned, 436
replacement, 430–435
replacement list, 430
rescanning and replacement, 432
scope of deﬁnition, 432

main(), 62

implementation-deﬁned linkage of, 62
implementation-deﬁned parameters to, 62
parameters to, 62
return from, 62, 64

match_results

as sequence, 1123

matched, 1095
max

random number distribution requirement, 944
uniform random number generator require-

ment, 939
max_bucket_count

max_load_factor

unordered associative containers, 772

unordered associative containers, 773

mean

normal_distribution, 970
poisson_distribution, 966

mem-initializer, 281, 1226
mem-initializer-id, 281, 1226
mem-initializer-list, 281, 1226
member

class static, 66
enumerator, 169
static, 236
template and static, 347

member access operator

overloaded, 327

member function

call undeﬁned, 234
class, 233
const, 235
constructor and, 269
destructor and, 276
friend, 263
inline, 233
local class, 242
nested class, 266
nonstatic, 234
overload resolution and, 304
static, 236, 237
this, 235
union, 238
volatile, 235
member names, 42
member subobject, 7
member-declaration, 231, 1225
member-declarator, 231, 1225
member-declarator-list, 231, 1225
member-speciﬁcation, 230, 1225
members, 42

Cross references

1299

c(cid:13) ISO/IEC

N4296

member data

static, 237

member pointer to, see pointer to member
memory location, 6
memory model, 6–7
memory management, see also new, delete
mersenne_twister_engine

generation algorithm, 949
state, 949
textual representation, 950
transition algorithm, 949

message

min

diagnostic, 2, 5

random number distribution requirement, 944
uniform random number generator require-

ment, 939

modiﬁcation order, 12
more specialized

function template, 404

most derived class, 7
most derived object, 7

bit-ﬁeld, 7
zero size subobject, 7

move

class object, see constructor, move; assign-

ment, move

MoveInsertable into X, 750
multi-pass guarantee, 856
multibyte character, see character, multibyte
multicharacter literal, see literal, multicharacter
multiple threads, see threads, multiple
multiple inheritance, 243, 244

virtual and, 252

multiplicative-expression, 124, 1217
mutable, 149
mutable iterator, 852
mutex types, 1168

name, 22, 34, 92

address of cv-qualiﬁed, 114
dependent, 370, 377
elaborated
enum, 162

global, 42
length of, 22
macro, see macro, name
point of declaration, 40
predeﬁned macro, see macro, predeﬁned
qualiﬁed, 51
reserved, 460

scope of, 39
unqualiﬁed, 45

name hiding

function, 303
overloading versus, 303
using-declaration and, 178

named-namespace-deﬁnition, 169, 1222
namespace, 448, 1253

alias, 173
deﬁnition, 169
extend, 170
global, 23
member deﬁnition, 172
unnamed, 171

namespace-alias, 173, 1222
namespace-alias-deﬁnition, 173, 1222
namespace-body, 170, 1222
namespace-deﬁnition, 169, 1222
namespace-name, 169, 1222
namespaces, 169–182
name class, see class name
name hiding, 40, 45, 93, 144

class deﬁnition, 229
user-deﬁned conversion and, 272

name space

label, 137

narrowing conversion, 224
NDEBUG, 450
negative_binomial_distribution

discrete probability function, 965

nested-name-speciﬁer, 93, 1215
nested-namespace-deﬁnition, 169, 1222
nested class

local class, 242
scope of, 240

<new>, 481
new, 66, 115, 117

array of class objects and, 119
constructor and, 119
default constructor and, 119
exception and, 119
initialization and, 119
operator, 461, 462
scoping and, 116
storage allocation, 116
type of, 278
unspeciﬁed constructor and, 119
unspeciﬁed order of evaluation, 119

new-declarator, 116, 1217
new-expression, 116, 1217
new-initializer, 116, 1217

Cross references

1300

c(cid:13) ISO/IEC

N4296

new-line, 427, 1229
new-placement, 116, 1217
new-type-id, 116, 1217
new_handler, 67
no linkage, 59
noexcept-expression, 122, 1217
noexcept-speciﬁcation, 419, 1228
non-directive, 427, 1228
non-throwing exception speciﬁcation, 419
nondigit, 22, 1211
nonzero-digit, 24, 1212
noptr-abstract-declarator, 192, 1224
noptr-abstract-pack-declarator, 192, 1224
noptr-declarator, 191, 1223
noptr-new-declarator, 116, 1217
normal distributions, 970–975
normal_distribution

mean, 970
probability density function, 970
standard deviation, 970

normative references, see references, normative
notation

syntax, 6

NTBS, 447, 1083, 1261, 1262

static, 447

NTCTS, 441
NTMBS, 447

static, 447

number

hex, 27
octal, 27

numeric_limits, 469

specializations for arithmetic types, 76

object, see also object model, 7, 34

byte copying and, 73
complete, 7
deﬁnition, 36
delete, 121
destructor static, 64
destructor and placement of, 277
linkage speciﬁcation, 185
local static, 66
undeﬁned deleted, 68
unnamed, 269

object expression, 105
object model, 7–8
object pointer type, 77
object representation, 73
object type, 7, 74

incompletely-deﬁned, 73

object, exception, see exception handling, excep-

tion object

object-like macro, see macro, object-like
object class, see also class object
object lifetime, 69–73
object temporary, see temporary
object type, 74
observable behavior, see behavior, observable
octal-digit, 24, 1212
octal-escape-sequence, 26, 1213
octal-literal, 24, 1212
odr-used, 36
one-deﬁnition rule, 36–39
opaque-enum-declaration, 166, 1221
operation

atomic, 11–15

operator, 23–24, 325

*=, 131
+=, 115, 131
-=, 131
/=, 131
<<=, 131
>>=, 131
%=, 131
&=, 131
ˆ=, 131
|=, 131
additive, 124
address-of, 113
assignment, 131, 447
bitwise, 128
bitwise AND, 128
bitwise exclusive OR, 128
bitwise inclusive OR, 128
cast, 113, 192
class member access, 105
comma, 132
conditional expression, 129
copy assignment, see assignment, copy
decrement, 106, 113, 115
division, 124
equality, 127
function call, 103, 325
greater than, 126
greater than or equal to, 126
increment, 106, 113, 115
indirection, 113
inequality, 127
less than, 126
less than or equal to, 126
logical AND, 128

Cross references

1301

c(cid:13) ISO/IEC

N4296

order of evaluation in expression, see expression,

order of evaluation of

logical negation, 113, 114
logical OR, 129
move assignment, see assignment, move
multiplication, 124
multiplicative, 124
one’s complement, 113, 114
overloaded, 88, 325
pointer to member, 123
pragma, see macro, pragma operator
precedence of, 9
relational, 126
remainder, 124
scope resolution, 93, 117, 233, 243, 253
side eﬀects and comma, 132
side eﬀects and logical AND, 128
side eﬀects and logical OR, 129
sizeof, 113, 115
subscripting, 102, 325
unary, 113
unary minus, 113, 114
unary plus, 113, 114

operator, 325, 1226
operator delete, see also delete, 117, 121, 278
operator new, see also new, 117
operator overloading, see overloading, operator
operator!=

random number distribution requirement, 944
random number engine requirement, 940

operator()

944

random number distribution requirement, 943,

random number engine requirement, 940
uniform random number generator require-

ment, 939

operator-function-id, 325, 1226
operator<<

random number distribution requirement, 944
random number engine requirement, 941

random number distribution requirement, 944
random number engine requirement, 940

operator==

operator>>

random number distribution requirement, 944
random number engine requirement, 941

operator , see delete
operator left shift, see left shift operator
operator right shift, see right shift operator
operator use

scope resolution, 237

optimization of temporary, see elimination of tem-

porary

ordered, 63
ordering

function template partial, 361

order of execution

base class constructor, 269
base class destructor, 276
constructor and static objects, 280
constructor and array, 279
destructor, 276
destructor and array, 276
member constructor, 269
member destructor, 276
ordinary character literal, 26
over-aligned type, 80
overﬂow, 88

undeﬁned, 88

overloaded function, see overloading
overloaded operator, see overloading, operator
overloadedfunction
address of, 323
overloaded function
address of, 114
overloaded operator

inheritance of, 325

overloading, 201, 229, 300–332, 359

access control and, 303
address of overloaded function, 323
argument lists, 304–311
assignment operator, 326
binary operator, 326
built-in operators and, 329
candidate functions, 304–311
declaration matching, 302
declarations, 300
example of, 300
function call operator, 326
member access operator, 327
operator, 325–329
prohibited, 300
resolution, 303–323

best viable function, 312–325
contexts, 304
function call syntax, 306–307
function template, 411
implicit conversions and, 314–323
initialization, 310, 311
operators, 307
scoping ambiguity, 247
template, 361

Cross references

1302

c(cid:13) ISO/IEC

N4296

template name, 364
viable functions, 312–325
subscripting operator, 327
unary operator, 326
user-deﬁned literal, 328
using directive and, 181
using-declaration and, 178

ﬂoating point, 935

overloads

overrider

own, 556

ﬁnal, 250

pair

param

tuple interface to, 519

random number distribution requirement, 943
seed sequence requirement, 938

random number distribution requirement, 943

param_type

parameter, 3

catch clause, 3
function, 3
function-like macro, 3
reference, 196
scope of, 41
template, 3, 35
void, 201

parameter declaration, 35
parameter-declaration, 201, 1224
parameter-declaration-clause, 200, 1224
parameter-declaration-list, 200, 1224
parameterized type, see template
parameters

macro, 430

parameters-and-qualiﬁers, 191, 1223
parameter list

variable, 104, 201

period, 446
phases of translation, see translation, phases
piecewise construction, 520
piecewise_constant_distribution

interval boundaries, 977
probability density function, 976
weights, 977

piecewise_linear_distribution

interval boundaries, 978
probability density function, 978
weights at boundaries, 978
placement new-expression, 119
placement syntax

Cross references

1303

error, 435
header inclusion, 429
line control, 435
macro replacement, see macro, replacement

new, 119

pm-expression, 123, 1217
POD class, 228
POD struct, 228
POD union, 228
POF, 495
point of declaration, 40
pointer, see also void*

safely-derived, 68–69
to traceable object, 467
to traceable object, 68
zero, 86

pointer literal, see literal, pointer
pointer,

integer representation of safely-derived,
69

pointer-literal, 31, 1214
pointer to member, 77, 123
Poisson distributions, 965–970
poisson_distribution

discrete probability function, 965
mean, 966

POSIX, 1

extended regular expressions, 1106
regular expressions, 1106
postﬁx-expression, 102, 1216
postﬁx ++ and --

overloading, 327

postﬁx ++, 106
postﬁx --, 106
potential exception, 421
potential results, 36
potential scope, 39
potentially evaluated, 36
potentially concurrent, 14
pp-number, 22, 1211
pp-tokens, 427, 1229
precedence of operator, see operator, precedence

of

preﬁx

L, 26, 30

preﬁx ++ and --

overloading, 327

preﬁx ++, 115
preﬁx --, 115
preprocessing directive, 426

conditional inclusion, 427

preprocessing directives, 426–437

c(cid:13) ISO/IEC

N4296

null, 436
pragma, 435
source-ﬁle inclusion, 429
preprocessing-ﬁle, 426, 1228
preprocessing-op-or-punc, 23, 1212
preprocessing-token, 19, 1210
primary equivalence class, 1096
primary-expression, 91, 1215
private, see access control, private
probability density function

cauchy_distribution, 972
chi_squared_distribution, 972
exponential_distribution, 966
extreme_value_distribution, 969
fisher_f_distribution, 973
gamma_distribution, 967
lognormal_distribution, 971
normal_distribution, 970
piecewise_constant_distribution, 976
piecewise_linear_distribution, 978
student_t_distribution, 974
uniform_real_distribution, 961
weibull_distribution, 968

program, 59

ill-formed, 2
start, 62–64
termination, 64–65
well-formed, 4, 8

program execution, 8–11
abstract machine, 8
as-if rule, see as-if rule

promotion

bool to int, 85
ﬂoating point, 85
integral, 84

protected, see access control, protected
protection, see access control, 466
prvalue, 79
pseudo-destructor-name, 105
pseudo-destructor-name, 102, 1216
ptr-abstract-declarator, 192, 1224
ptr-declarator, 191, 1223
ptr-operator, 192, 1223
ptrdiff_t, 125

implementation deﬁned type of, 125

public, see access control, public
punctuator, 23–24
pure-speciﬁer, 231, 1225

q-char, 21, 1211
q-char-sequence, 21, 1211

Cross references

qualiﬁcation

explicit, 51

qualiﬁed-id, 93, 1215
qualiﬁed-namespace-speciﬁer, 173, 1222

r-char, 28, 1214
r-char-sequence, 28, 1214
random number distribution

bernoulli_distribution, 962
binomial_distribution, 963
chi_squared_distribution, 972
discrete_distribution, 975
exponential_distribution, 966
extreme_value_distribution, 969
fisher_f_distribution, 973
gamma_distribution, 967
geometric_distribution, 964
lognormal_distribution, 971
negative_binomial_distribution, 965
normal_distribution, 970
piecewise_constant_distribution, 976
piecewise_linear_distribution, 978
poisson_distribution, 965
requirements, 942–945
student_t_distribution, 974
uniform_int_distribution, 960
uniform_real_distribution, 961

random number distributions

Bernoulli, 962–965
normal, 970–975
Poisson, 965–970
sampling, 975–980
uniform, 960–962
random number engine

linear_congruential_engine, 948
mersenne_twister_engine, 949
requirements, 939–941
subtract_with_carry_engine, 951
with predeﬁned parameters, 955–956

random number engine adaptor

discard_block_engine, 952
independent_bits_engine, 953
shuffle_order_engine, 954
with predeﬁned parameters, 955–956

random number generation, 936–980

distributions, 960–980
engines, 947–955
predeﬁned engines and adaptors, 955–956
requirements, 937–945
synopsis, 945–947
utilities, 958–960

1304

c(cid:13) ISO/IEC

N4296

random number generator, see uniform random

translate_nocase, 1097

number generator

random_device

implementation leeway, 957

raw string literal, 29
raw-string, 28, 1214
reaching scope, 97
ready, 1123, 1197
redeﬁnition

typedef, 152

ref-qualiﬁer, 192, 1223
reference, 76

assignment to, 131
call by, 104
forwarding, 400
lvalue, 76
null, 197
rvalue, 76
sizeof, 115

reference collapsing, 197
reference-compatible, 218
reference-related, 218
references

normative, 1
regex_iterator

end-of-sequence, 1134

regex_token_iterator

end-of-sequence, 1136

regex_traits

specializations, 1109

region

declarative, 34, 39

register, 149
regular expression, 1095–1141

grammar, 1139
matched, 1095
requirements, 1096

regular expression traits, 1139
char_class_type, 1096
isctype, 1097
lookup_classname, 1141
lookup_classname, 1097
lookup_collatename, 1097
requirements, 1096, 1109
transform, 1141
transform, 1097
transform_primary, 1141
transform_primary, 1097
translate, 1141
translate, 1097
translate_nocase, 1141

rehash

unordered associative containers, 773
reinterpret_cast, see cast, reinterpret
relational-expression, 126, 1217
relaxed pointer safety, 69
release sequence, 12
remainder operator, see remainder operator
replacement

macro, see macro, replacement

replacement-list, 427, 1229
representation
object, 73
value, 73

requirements, 443

Allocator, 454
container, 745, 765, 777, 778, 1123

not required for unordered associated con-

tainers, 764

CopyAssignable, 451
CopyConstructible, 451
DefaultConstructible, 451
Destructible, 451
EqualityComparable, 451
Hash, 454
iterator, 852
LessThanComparable, 451
MoveAssignable, 451
MoveConstructible, 451
NullablePointer, 454
numeric type, 924
random number distribution, 942–945
random number engine, 939–941
regular expression traits, 1096, 1109
seed sequence, 937–938
sequence, 1123
uniform random number generator, 939
unordered associative container, 765
reraise, see exception handling, rethrow
rescanning and replacement, see macro, rescan-

ning and replacement

reserved identiﬁer, 23
reset, 556
reset

random number distribution requirement, 943

resolution, see overloading, resolution
restriction, 463, 464, 466

address of bit-ﬁeld, 240
anonymous union, 239
bit-ﬁeld, 240
constructor, 268, 269

Cross references

1305

c(cid:13) ISO/IEC

N4296

function, 42
function prototype, 41
global, 42
global namespace, 42
iteration-statement, 140
macro deﬁnition, see macro, scope of deﬁni-

destructor, 275
extern, 150
local class, 242
operator overloading, 325
overloading, 325
pointer to bit-ﬁeld, 240
reference, 197
register, 150
static, 150
static member local class, 238
union, 238

result_type

result_type

entity characterization based on, 936

random number distribution requirement, 943
seed sequence requirement, 938
uniform random number generator require-

ment, 939

rethrow, see exception handling, rethrow
return, 142, 143

lvalue conversion to, see conversion, lvalue to

and handler, 414
and try block, 414
constructor and, 143
reference and, 218

return statement, see return
return type, 202

overloading and, 300

right shift

implementation deﬁned, 126

right shift operator, 126
rounding, 86
rvalue, 79

rvalue

lvalue conversion to, 1235

rvalue reference, 76, 196

s-char, 28, 1214
s-char-sequence, 28, 1214
safely-derived pointer, 68

integer representation, 69

sampling distributions, 975–980
scalar type, 74
scope, 1, 34, 39–45, 148

anonymous union at namespace, 239
block, 41
class, 42
declarations and, 39–41
destructor and exit from, 142
enumeration, 44
exception declaration, 41

tion

namespace, 42
name lookup and, 45–59
overloading and, 302
potential, 39
selection-statement, 138
template parameter, 44
scope name hiding and, 45
scope resolution operator, 52
seed

seed sequence, 937

requirements, 937–938

selection-statement, 138, 1219
semantics

class member, 105

random number engine requirement, 940

separate compilation, see compilation, separate
separate translation, see compilation, separate
sequence

ambiguous conversion, 315
implicit conversion, 314
standard conversion, 82

sequence constructor

seed sequence requirement, 938

Sequenced before, 10
sequencing operator, see comma operator
set of potential exceptions of a function, function
pointer, or member function pointer, 421

set of potential exceptions of an expression, 421
set of potential exceptions of the implicitly-declared

member function, 422

setlocale, 446
shared state, see future, shared state
shift-expression, 126, 1217
shift operator, see left shift operator, right shift op-

erator

short

typedef and, 149

shuffle_order_engine

generation algorithm, 954
state, 954
textual representation, 955
transition algorithm, 954

side eﬀects, 8, 10–15, 128, 129, 137, 271, 283, 294,

433, 466

Cross references

1306

c(cid:13) ISO/IEC

N4296

visible, 14
sign, 28, 1213
signal, 8
signature, 3, 4
signed

typedef and, 149
signed integer type, 75
similar types, 84
simple call wrapper, 585
simple-capture, 94, 1215
simple-declaration, 147, 1220
simple-escape-sequence, 26, 1213
simple-template-id, 337, 1227
simple-type-speciﬁer, 159, 1221
size

seed sequence requirement, 938

size_t, 115
smart pointers, 567–582
source ﬁle, 17, 449, 461
source ﬁle character, see character, source ﬁle
space

white, 19
specialization

class template, 339
class template partial, 355
template, 379
template explicit, 386

special member function, see constructor, destruc-
tor, inline function, user-deﬁned conver-
sion, virtual function

speciﬁcation

linkage, 182–185

extern, 182
implementation-deﬁned, 183
nesting, 183

template argument, 392

speciﬁcations

C standard library exception, 466
C++, 467
implementation-deﬁned exception, 467

speciﬁer, 149–164
friend, 466
constexpr, 154

constructor, 154, 155
function, 154
cv-qualiﬁer, 158
declaration, 149
explicit, 152
friend, 154
function, 151
inline, 151

static, 150
storage class, 149
type, see type speciﬁer
typedef, 152
virtual, 152

speciﬁer access, see access speciﬁer
stable algorithm, 442, 465
stack unwinding, 417

see exception handling, constructors and de-

structors, 417

standard

structure of, 5–6

standard deviation

normal_distribution, 970

standard-layout types, 74
standard-layout class, 227
standard-layout struct, 228
standard-layout union, 228
standard integer type, 75
standard signed integer type, 75
standard unsigned integer type, 75
start

program, 62

startup

state

program, 450, 462

discard_block_engine, 952
independent_bits_engine, 953
linear_congruential_engine, 948
mersenne_twister_engine, 949
object, 441
shuffle_order_engine, 954
subtract_with_carry_engine, 951

statement, 137–146

continue in for, 141
break, 142, 143
compound, 137
continue, 142, 143
declaration, 143
declaration in if, 138
declaration in switch, 138
declaration in for, 141
declaration in switch, 139
declaration in while, 140
do, 139, 141
empty, 137
expression, 137
for, 139, 141
goto, 137, 142, 143
if, 138, 139
iteration, 139–142

Cross references

1307

c(cid:13) ISO/IEC

N4296

jump, 142
labeled, 137
null, 137
for, 141
selection, 138–139
switch, 138, 139, 143
while, 139, 140
statement, 137, 1218
statement-seq, 137, 1218
static, 149

destruction of local, 144
linkage of, 59, 150
overloading and, 300

static initialization, 63
static storage duration, 66
static type, see type, static
static_assert, 148
static_assert-declaration, 147, 1220
static_cast, see cast, static
<stddef.h>, 26, 30
<stdexcept>, 498
storage-class-speciﬁer, 149, 1220
storage class, 34
storage duration, 65–69
automatic, 65, 66
class member, 69
dynamic, 65–69, 116
local object, 66
register, 66
static, 65, 66
thread, 65, 66

storage management, see new, delete
stream

arbitrary-positional, 439
repositional, 441

streambuf

implementation-deﬁned, 1010

strict pointer safety, 69
string

distinct, 30
null-terminated byte, 447
null-terminated character type, 441
null-terminated multibyte, 447
sizeof, 30
type of, 29

string literal, see literal, string
string-literal, 28, 1213
stringize, see #
struct

standard-layout, 228

struct

class versus, 227

structure, 227
structure tag, see class name
student_t_distribution

probability density function, 974

sub-expression, 1096
subobject, see also object model, 7
subscripting operator
overloaded, 327

subsequence rule

overloading, 321

subtract_with_carry_engine

carry, 951
generation algorithm, 951
state, 951
textual representation, 951
transition algorithm, 951

subtraction

implementation deﬁned pointer, 125

subtraction operator, 124
suﬃx

E, 28
e, 28
F, 28
f, 28
L, 25, 28
l, 25, 28
U, 25
u, 25
summary

x C++ 2003, 1241
x C++ 2011, 1248
x C++ 2014, 1249
compatibility with ISO C, 1232

swappable, 452
swappable with, 452
switch

and handler, 414
and try block, 414

synchronize with, 12
synonym, 173

type name as, 152

syntax

class member, 105

target object, 585
template, 333–413

deﬁnition of, 333
function, 392
member function, 347
primary, 355

Cross references

1308

c(cid:13) ISO/IEC

N4296

constructor for, 270
destruction of, 270
destructor for, 270
elimination of, 270, 294
implementation-deﬁned generation of, 270
order of destruction of, 271

terminate(), 424, 425

called, 131, 416, 421, 424

termination

program, 62, 65

terminology

pointer, 77

text-line, 427, 1228
textual representation

discard_block_engine, 953
independent_bits_engine, 954
shuffle_order_engine, 955
subtract_with_carry_engine, 951

static data member, 333
variable, 333

template, 333
template parameter, 35
template-argument, 338, 1227
template-argument-list, 338, 1227
template-declaration, 333, 1226
template-id, 337, 1227
template-name, 338, 1227
template-parameter, 334, 1227
template-parameter-list, 333, 1226
template name

linkage of, 334

template parameter scope, 44
temporary, 270

this, 91, 235

type of, 235

this pointer, see this
thread, 11
thread of execution, 11
thread storage duration, 66
thread, blocked, 439
thread_local, 149
threads

multiple, 11–15

throw, 130
throw-expression, 130, 1218
throwing, see exception handling, throwing
timed mutex types, 1171
token, 21

alternative, 20
preprocessing, 19–20, 1210

token, 21, 1211

traceable pointer object, 68, 467
trailing-return-type, 192, 1223
trailing-type-speciﬁer, 157, 1220
trailing-type-speciﬁer-seq, 157, 1220
traits, 442
transfer ownership, 556
transform

regular expression traits, 1141

transform

regular expression traits, 1097

transform_primaryl

regular expression traits, 1141

transform_primary

regular expression traits, 1141

transform_primaryl

regular expression traits, 1097

TransformationTrait, 603
transition algorithm

discard_block_engine, 952
independent_bits_engine, 953
linear_congruential_engine, 948
mersenne_twister_engine, 949
shuffle_order_engine, 954
subtract_with_carry_engine, 951

regular expression traits, 1141

translate

translate

regular expression traits, 1097

translate_nocase

regular expression traits, 1141

translate_nocase

regular expression traits, 1097

translation

phases, 17–18
separate, see compilation, separate

translation unit, 17
translation units, 59
translation-unit, 59, 1215
translation unit, 59
name and, 34

trigraph sequence, 1249
trivial types, 74
trivially copyable class, 227
trivially copyable types, 74
trivial class, 227
trivial class type, 119
trivial type, 119
truncation, 86
try, 414
try block, see exception handling, try block
try-block, 414, 1227

Cross references

1309

c(cid:13) ISO/IEC

N4296

tuple

and pair, 519

type, 34, 73–78

arithmetic, 76
array, 76, 201
bitmask, 445, 446
Boolean, 75
char, 75
char16_t, 76
char32_t, 76
character, 75
character container, 439
class and, 226
compound, 76
const, 157
destination, 213
double, 76
dynamic, 2
enumerated, 77, 445
example of incomplete, 74
extended integer, 75
extended signed integer, 75
extended unsigned integer, 75
float, 76
ﬂoating point, 75
function, 76, 200, 201
fundamental, 75
sizeof, 75
incomplete, 36, 37, 40, 73, 83, 102, 103, 105,

107, 108, 113, 115, 121, 131, 243

incompletely-deﬁned object, 73
int, 75
integral, 75
long, 75
long double, 76
long long, 75
narrow character, 75
over-aligned, 80
POD, 74
pointer, 76
polymorphic, 249
referenceable, 441
short, 75
signed char, 75
signed integer, 75
similar, see similar types
standard integer, 75
standard signed integer, 75
standard unsigned integer, 75
static, 4
trivially copyable, 73

underlying wchar_t, 76
unsigned, 75
unsigned char, 75
unsigned int, 75
unsigned long, 75
unsigned long long, 75
unsigned short, 75
unsigned integer, 75
void, 76
volatile, 157
wchar_t, 76

type generator, see template
type speciﬁer
auto, 162
const, 158
elaborated, 162
simple, 159
volatile, 158
type-id, 192, 1224
type-id-list, 419, 1228
type-name, 159, 1221
type-parameter, 334, 1227
type-parameter-key, 334, 1227
type-speciﬁer
bool, 159
wchar_t, 159

type-speciﬁer, 157, 1220
type-speciﬁer-seq, 157, 1220
type_info, 108
typedef

function, 202

typedef

overloading and, 301
typedef-name, 152, 1220
typeid, 108

construction and, 287
destruction and, 287

<typeinfo>, 487
typename, 162
typename-speciﬁer, 365, 1227
types

implementation-deﬁned, 445
implementation-deﬁned exception, 467

type checking

argument, 104

type conversion, explicit, see casting
type name, 192
nested, 242

scope of, 242

type pun, 112
type speciﬁer

Cross references

1310

c(cid:13) ISO/IEC

N4296

auto, 159
char, 159
char16_t, 159
char32_t, 159
decltype, 159, 161
double, 159
elaborated, 57
enum, 162
float, 159
int, 159
long, 159
short, 159
signed, 159
unsigned, 159
void, 159
volatile, 159

ud-suﬃx, 31, 1214
unary fold, 101
unary function, 586
unary left fold, 101
unary operator

overloaded, 326
unary right fold, 101
unary-expression, 113, 1216
unary-operator, 113, 1217
UnaryTypeTrait, 603
unary operator

interpretation of, 326

unblock, 442
undeﬁned, 441, 460, 461, 463, 985, 986, 989–992,

996, 1000, 1024

undeﬁned behavior, see behavior, undeﬁned, 880
underlying type, 76
unevaluated operand, 89
unexpected(), 425

called, 421

Unicode required set, 437
uniform distributions, 960–962
uniform random number generator

requirements, 939

uniform_int_distribution

discrete probability function, 960

uniform_real_distribution

probability density function, 961

union

standard-layout, 228

union, 77, 238

class versus, 227
anonymous, 239
global anonymous, 239

unique pointer, 556
unit

translation, 449, 450, 461
universal character name, 17
universal-character-name, 19, 1210
unnamed-namespace-deﬁnition, 169, 1222
unordered, 63
unordered associative containers, 764–842

begin, 772
bucket, 772
bucket_count, 772
bucket_size, 772
cbegin, 772
cend, 772
clear, 771
complexity, 764
const_local_iterator, 766
count, 772
end, 772
equal_range, 772
equality function, 764
equivalent keys, 764, 765, 831, 838
erase, 771
exception safety, 774
find, 771
hash function, 764
hash_function, 769
hasher, 765
insert, 770, 771
iterator invalidation, 774
iterators, 773
key_eq, 769
key_equal, 766
key_type, 765
lack of comparison operators, 764
load_factor, 773
local_iterator, 766
max_bucket_count, 772
max_load_factor, 773
rehash, 773
requirements, 764, 765, 774
unique keys, 764, 765, 825, 835

unordered_map

element access, 829
unique keys, 825
unordered_multimap

equivalent keys, 831

unordered_multiset

equivalent keys, 838

unordered_set

unique keys, 835

Cross references

1311

c(cid:13) ISO/IEC

N4296

constructor and, 287
destructor and, 287
undeﬁned pure, 255

visibility, 45
visible, 45
void*

type, 77

void&, 196
volatile, 77

constructor and, 236, 268
destructor and, 236, 275
implementation-deﬁned, 159
overloading and, 302

waiting function, 1196
wchar_t, 26, 30, 686

implementation-deﬁned, 76

weak result type, 585
weibull_distribution

probability density function, 968

weights

discrete_distribution, 975
piecewise_constant_distribution, 977

weights at boundaries

piecewise_linear_distribution, 978

well-formed program, see program, well-formed
white space, 21
wide-character, 26

X(X&), see copy constructor
xvalue, 79

zero

division by undeﬁned, 88
remainder undeﬁned, 88
undeﬁned division by, 124

zero-initialization, 211

unqualiﬁed-id, 91, 1215
unsequenced, 10
unsigned

typedef and, 149

unsigned-suﬃx, 25, 1213
unsigned integer type, 75
unspeciﬁed, 482, 483, 488, 911, 1073, 1257, 1259
unspeciﬁed behavior, see behavior, unspeciﬁed, 990
unwinding

stack, 417

uppercase, 23, 446
user-deﬁned literal, see literal, user deﬁned

overloaded, 328

user-deﬁned-character-literal, 31, 1214
user-deﬁned-ﬂoating-literal, 31, 1214
user-deﬁned-integer-literal, 31, 1214
user-deﬁned-literal, 31, 1214
user-deﬁned-string-literal, 31, 1214
user-provided, 209
Uses-allocator construction, 548
using-declaration, 174–179
using-declaration, 174, 1222
using-directive, 179–182
using-directive, 179, 1222
usual arithmetic conversions, see conversion, usual

arithmetic

UTF-8 character literal, 26

valid, 39
valid but unspeciﬁed state, 442
value, 73

call by, 104
indeterminate, 212
null member pointer, 86
null pointer, 86
undeﬁned unrepresentable integral, 86

value category, 79
value computation, 10–11, 14, 15, 106, 119, 128,

indeterminate uninitialized, 211

129, 131, 132, 271

value representation, 73
value-initialization, 211
variable, 34

variable template

deﬁnition of, 333

virt-speciﬁer, 231, 1225
virt-speciﬁer-seq, 231, 1225
virtual base class, 245
virtual function, 249–254

pure, 254

virtual function call, 253

Cross references

1312

c(cid:13) ISO/IEC

N4296

Index of grammar productions

The ﬁrst page number for each entry is the page in the general text where the grammar production is
deﬁned. The second page number is the corresponding page in the Grammar summary (Annex A).

abstract-declarator, 192, 1224
abstract-pack-declarator, 192, 1224
access-speciﬁer, 243, 1226
additive-expression, 125, 1217
alias-declaration, 147, 1220
alignment-speciﬁer, 185, 1222
and-expression, 128, 1218
asm-deﬁnition, 182, 1222
assignment-expression, 131, 1218
assignment-operator, 131, 1218
attribute, 185, 1222
attribute-argument-clause, 186, 1223
attribute-declaration, 147, 1220
attribute-list, 185, 1222
attribute-namespace, 186, 1223
attribute-scoped-token, 186, 1223
attribute-speciﬁer, 185, 1222
attribute-speciﬁer-seq, 185, 1222
attribute-token, 185, 1222

balanced-token, 186, 1223
balanced-token-seq, 186, 1223
base-clause, 243, 1225
base-speciﬁer, 243, 1226
base-speciﬁer-list, 243, 1225
base-type-speciﬁer, 243, 1226
binary-digit, 24, 1212
binary-literal, 24, 1212
block-declaration, 147, 1219
boolean-literal, 31, 1214
brace-or-equal-initializer, 210, 1224
braced-init-list, 210, 1224

c-char, 26, 1213
c-char-sequence, 26, 1213
capture, 94, 1215
capture-default, 94, 1215
capture-list, 94, 1215
cast-expression, 122, 1217
character-literal, 26, 1213
class-head, 226, 1225
class-head-name, 226, 1225
class-key, 226, 1225

Cross references

class-name, 226, 1225
class-or-decltype, 243, 1226
class-speciﬁer, 226, 1225
class-virt-speciﬁer, 226, 1225
compound-statement, 137, 1218
condition, 138, 1219
conditional-expression, 129, 1218
constant-expression, 132, 1218
control-line, 426, 1228
conversion-declarator, 273, 1226
conversion-function-id, 273, 1226
conversion-type-id, 273, 1226
ctor-initializer, 281, 1226
cv-qualiﬁer, 192, 1223
cv-qualiﬁer-seq, 192, 1223

d-char, 29, 1214
d-char-sequence, 28, 1214
decimal-literal, 24, 1212
decl-speciﬁer, 149, 1220
decl-speciﬁer-seq, 149, 1220
declaration, 147, 1219
declaration-seq, 147, 1219
declaration-statement, 143, 1219
declarator, 191, 1223
declarator-id, 192, 1223
decltype-speciﬁer, 159, 1221
delete-expression, 120, 1217
digit, 22, 1211
digit-sequence, 28, 1213
dynamic-exception-speciﬁcation, 419, 1227

elaborated-type-speciﬁer, 162, 1221
elif-group, 426, 1228
elif-groups, 426, 1228
else-group, 426, 1228
empty-declaration, 147, 1220
enclosing-namespace-speciﬁer, 169, 1222
encoding-preﬁx, 26, 1213
endif-line, 426, 1228
enum-base, 166, 1221
enum-head, 166, 1221
enum-key, 166, 1221

1313

c(cid:13) ISO/IEC

enum-name, 166, 1221
enum-speciﬁer, 166, 1221
enumerator, 166, 1222
enumerator-deﬁnition, 166, 1221
enumerator-list, 166, 1221
equality-expression, 127, 1217
escape-sequence, 26, 1213
exception-declaration, 414, 1227
exception-speciﬁcation, 419, 1227
exclusive-or-expression, 128, 1218
explicit-instantiation, 384, 1227
explicit-specialization, 386, 1227
exponent-part, 28, 1213
expression, 132, 1218
expression-list, 102, 1216
expression-statement, 137, 1218

ﬂoating-literal, 27, 1213
ﬂoating-suﬃx, 28, 1213
fold-expression, 101, 1216
fold-operator, 101, 1216
for-init-statement, 139, 1219
for-range-declaration, 140, 1219
for-range-initializer, 140, 1219
fractional-constant, 28, 1213
function-deﬁnition, 207, 1224
function-speciﬁer, 151, 1220
function-try-block, 414, 1227

group, 426, 1228
group-part, 426, 1228

h-char, 21, 1211
h-char-sequence, 21, 1211
handler, 414, 1227
handler-seq, 414, 1227
header-name, 21, 1211
hex-quad, 18, 1210
hexadecimal-digit, 24, 1212
hexadecimal-escape-sequence, 26, 1213
hexadecimal-literal, 24, 1212

id-expression, 91, 1215
identiﬁer, 22, 1211
identiﬁer-list, 427, 1229
identiﬁer-nondigit, 22, 1211
if-group, 426, 1228
if-section, 426, 1228
inclusive-or-expression, 128, 1218
init-capture, 94, 1216
init-declarator, 191, 1223

Cross references

init-declarator-list, 191, 1223
initializer, 210, 1224
initializer-clause, 210, 1224
initializer-list, 210, 1224
integer-literal, 24, 1212
integer-suﬃx, 24, 1212
iteration-statement, 139, 1219

jump-statement, 142, 1219

labeled-statement, 137, 1218
lambda-capture, 94, 1215
lambda-declarator, 94, 1216
lambda-expression, 94, 1215
lambda-introducer, 94, 1215
linkage-speciﬁcation, 182, 1222
literal, 24, 1212
literal-operator-id, 328, 1226
logical-and-expression, 128, 1218
logical-or-expression, 129, 1218
long-long-suﬃx, 25, 1213
long-suﬃx, 25, 1213
lparen, 427, 1228

mem-initializer, 281, 1226
mem-initializer-id, 281, 1226
mem-initializer-list, 281, 1226
member-declaration, 231, 1225
member-declarator, 231, 1225
member-declarator-list, 231, 1225
member-speciﬁcation, 230, 1225
multiplicative-expression, 124, 1217

named-namespace-deﬁnition, 169, 1222
namespace-alias, 173, 1222
namespace-alias-deﬁnition, 173, 1222
namespace-body, 170, 1222
namespace-deﬁnition, 169, 1222
namespace-name, 169, 1222
nested-name-speciﬁer, 93, 1215
nested-namespace-deﬁnition, 169, 1222
new-declarator, 116, 1217
new-expression, 116, 1217
new-initializer, 116, 1217
new-line, 427, 1229
new-placement, 116, 1217
new-type-id, 116, 1217
noexcept-expression, 122, 1217
noexcept-speciﬁcation, 419, 1228
non-directive, 427, 1228
nondigit, 22, 1211

N4296

1314

c(cid:13) ISO/IEC

nonzero-digit, 24, 1212
noptr-abstract-declarator, 192, 1224
noptr-abstract-pack-declarator, 192, 1224
noptr-declarator, 191, 1223
noptr-new-declarator, 116, 1217

octal-digit, 24, 1212
octal-escape-sequence, 26, 1213
octal-literal, 24, 1212
opaque-enum-declaration, 166, 1221
operator, 325, 1226
operator-function-id, 325, 1226

parameter-declaration, 201, 1224
parameter-declaration-clause, 200, 1224
parameter-declaration-list, 200, 1224
parameters-and-qualiﬁers, 191, 1223
pm-expression, 123, 1217
pointer-literal, 31, 1214
postﬁx-expression, 102, 1216
pp-number, 22, 1211
pp-tokens, 427, 1229
preprocessing-ﬁle, 426, 1228
preprocessing-op-or-punc, 23, 1212
preprocessing-token, 19, 1210
primary-expression, 91, 1215
pseudo-destructor-name, 102, 1216
ptr-abstract-declarator, 192, 1224
ptr-declarator, 191, 1223
ptr-operator, 192, 1223
pure-speciﬁer, 231, 1225

q-char, 21, 1211
q-char-sequence, 21, 1211
qualiﬁed-id, 93, 1215
qualiﬁed-namespace-speciﬁer, 173, 1222

r-char, 28, 1214
r-char-sequence, 28, 1214
raw-string, 28, 1214
ref-qualiﬁer, 192, 1223
relational-expression, 126, 1217
replacement-list, 427, 1229

s-char, 28, 1214
s-char-sequence, 28, 1214
selection-statement, 138, 1219
shift-expression, 126, 1217
sign, 28, 1213
simple-capture, 94, 1215
simple-declaration, 147, 1220
simple-escape-sequence, 26, 1213

Cross references

simple-template-id, 337, 1227
simple-type-speciﬁer, 159, 1221
statement, 137, 1218
statement-seq, 137, 1218
static_assert-declaration, 147, 1220
storage-class-speciﬁer, 149, 1220
string-literal, 28, 1213

template-argument, 338, 1227
template-argument-list, 338, 1227
template-declaration, 333, 1226
template-id, 337, 1227
template-name, 338, 1227
template-parameter, 334, 1227
template-parameter-list, 333, 1226
text-line, 427, 1228
throw-expression, 130, 1218
token, 21, 1211
trailing-return-type, 192, 1223
trailing-type-speciﬁer, 157, 1220
trailing-type-speciﬁer-seq, 157, 1220
translation-unit, 59, 1215
try-block, 414, 1227
type-id, 192, 1224
type-id-list, 419, 1228
type-name, 159, 1221
type-parameter, 334, 1227
type-parameter-key, 334, 1227
type-speciﬁer, 157, 1220
type-speciﬁer-seq, 157, 1220
typedef-name, 152, 1220
typename-speciﬁer, 365, 1227

ud-suﬃx, 31, 1214
unary-expression, 113, 1216
unary-operator, 113, 1217
universal-character-name, 19, 1210
unnamed-namespace-deﬁnition, 169, 1222
unqualiﬁed-id, 91, 1215
unsigned-suﬃx, 25, 1213
user-deﬁned-character-literal, 31, 1214
user-deﬁned-ﬂoating-literal, 31, 1214
user-deﬁned-integer-literal, 31, 1214
user-deﬁned-literal, 31, 1214
user-deﬁned-string-literal, 31, 1214
using-declaration, 174, 1222
using-directive, 179, 1222

virt-speciﬁer, 231, 1225
virt-speciﬁer-seq, 231, 1225

N4296

1315

c(cid:13) ISO/IEC

N4296

Index of library names

_Exit, 479
__alignas_is_defined, 496
__bool_true_false_are_defined, 495, 496

_1, 596

operator!=, 552
operator==, 552
allocator_arg, 547
allocator_arg_t, 547
allocator_traits, 548

a

cauchy_distribution, 973
extreme_value_distribution, 970
uniform_int_distribution, 961
uniform_real_distribution, 962
weibull_distribution, 969
abort, 65, 143, 449, 479, 487, 491
abs, 993, 1005

allocate, 550
const_pointer, 549
const_void_pointer, 549
constructor, 550
deallocate, 550
destructor, 550
difference_type, 549
is_always_equal, 550
max_size, 550
pointer, 549
propagate_on_container_copy_assignment,

propagate_on_container_move_assignment,

propagate_on_container_swap, 550
rebind_alloc, 550
select_on_container_copy_construction,

550

550

551

size_type, 549
void_pointer, 549

alpha

gamma_distribution, 968

basic_string, 668, 669

always_noconv

codecvt, 711

any

bitset, 539

any_of, 897
append

apply

arg, 935

valarray, 990

complex, 933

<array>, 774
array, 776, 777, 779

begin, 777
data, 778
end, 777
fill, 778
get, 779

complex, 933
accumulate, 1002
acos, 993, 1005

complex, 934

acosh, 1005

complex, 934

address

allocator, 552

addressof, 554
adjacent_difference, 1003
adjacent_find, 899
adopt_lock, 1176
adopt_lock_t, 1176
advance, 863
<algorithm>, 886
align, 547
all

bitset, 539

all_of, 897
allocate

allocate_shared, 573
allocator, 1127
allocator, 551

address, 552
allocate, 552
constructor, 552
deallocate, 552
destructor, 552
max_size, 552

allocator, 552
allocator_traits, 550
scoped_allocator_adaptor, 644

Cross references

1316

c(cid:13) ISO/IEC

N4296

max_size, 777
size, 777, 778
swap, 778
asin, 993, 1005

complex, 934

asinh, 1005

complex, 934
<assert.h>, 450
assign

basic_regex, 1115, 1116
basic_string, 669, 670
error_code, 508
error_condition, 510
function, 601

async, 1205
at

basic_string, 667
map, 812
unordered_map, 829
at_quick_exit, 479, 480
atan, 993, 1005

complex, 934
atan2, 993, 1005
atanh, 1005

complex, 934

atexit, 65, 449, 479
<atomic>, 1142
atomic type

atomic_compare_exchange_strong, 1154
atomic_compare_exchange_strong_-

explicit, 1154

atomic_compare_exchange_weak, 1154
atomic_compare_exchange_weak_-

explicit, 1154

atomic_exchange, 1154
atomic_exchange_explicit, 1154
atomic_fetch_, 1155
atomic_is_lock_free, 1153
atomic_load, 1153
atomic_load_explicit, 1153
atomic_store, 1153
atomic_store_explicit, 1153
compare_exchange_strong, 1154
compare_exchange_strong_explicit, 1154
compare_exchange_weak, 1154
compare_exchange_weak_explicit, 1154
constructor, 1152
exchange, 1154
fetch_, 1155
load, 1153
operator @=, 1156

atomic_compare_exchange_strong

atomic_compare_exchange_strong_explicit

atomic_compare_exchange_weak

atomic_compare_exchange_weak_explicit

operator C , 1153
operator++, 1156
operator--, 1156
operator=, 1153
store, 1153

atomic type, 1154
shared_ptr, 581

atomic type, 1154
shared_ptr, 581

atomic type, 1154
shared_ptr, 581

atomic_exchange_explicit

atomic type, 1154
shared_ptr, 581

atomic_exchange

atomic type, 1154
shared_ptr, 580

atomic type, 1154
shared_ptr, 580

atomic_fetch_

atomic type, 1155

atomic_flag

clear, 1157

atomic_flag_clear, 1157
atomic_flag_clear_explicit, 1157
atomic_flag_test_and_set, 1157
atomic_flag_test_and_set_explicit, 1157
atomic_is_lock_free
atomic type, 1153
shared_ptr, 580

atomic_load

atomic type, 1153
shared_ptr, 580

atomic_load_explicit
atomic type, 1153
shared_ptr, 580

atomic_signal_fence, 1158
atomic_store

atomic type, 1153
shared_ptr, 580

atomic_store_explicit
atomic type, 1153
shared_ptr, 580

atomic_thread_fence, 1158

b

cauchy_distribution, 973

Cross references

1317

c(cid:13) ISO/IEC

N4296

extreme_value_distribution, 970
uniform_int_distribution, 961
uniform_real_distribution, 962
weibull_distribution, 969

back

basic_string, 668

back_insert_iterator, 869

back_insert_iterator, 869

back_inserter, 870
bad

basic_ios, 1029

bad_alloc, 119, 481, 486, 487

bad_alloc, 486
bad_alloc::what

implementation-deﬁned, 486

bad_array_new_length, 486

bad_array_new_length, 486

bad_cast, 107, 487, 488

bad_cast, 488

bad_cast::what

implementation-deﬁned, 489

bad_exception, 491

bad_exception, 491

bad_exception::what

implementation-deﬁned, 491

bad_function_call, 597

bad_function_call, 597

bad_typeid, 108, 487, 489

bad_typeid, 489

bad_weak_ptr, 567

bad_weak_ptr, 567
what, 567

base

move_iterator, 874
reverse_iterator, 866
basic_filebuf, 1010, 1080
basic_filebuf, 1081
constructor, 1081
destructor, 1082
operator=, 1082
swap, 1082

basic_filebuf<char>, 1079
basic_filebuf<wchar_t>, 1079
basic_fstream, 1010, 1091
basic_fstream, 1091
constructor, 1092
operator=, 1092
swap, 1092

basic_ifstream, 1010, 1087
basic_ifstream, 1087
constructor, 1087, 1088

operator=, 1088
swap, 1088

basic_ifstream<char>, 1079
basic_ifstream<wchar_t>, 1079
basic_ios, 1010, 1024
basic_ios, 1025
constructor, 1026
destructor, 1026
exceptions, 1029
fill, 1027
init, 1026
move, 1027
rdbuf, 1026
set_rdbuf, 1028
swap, 1028
tie, 1026

basic_ios<char>, 1015
basic_ios<wchar_t>, 1015
basic_iostream, 1054

basic_iostream, 1055
constructor, 1055
destructor, 1055
operator=, 1055
swap, 1055

basic_istream, 1010, 1043
basic_istream, 1045
constructor, 1045
destructor, 1045, 1046
get, 1050, 1051, 1054
operator<<, 1055
operator=, 1045
seekg, 1054
swap, 1045
tellg, 1053

basic_istream<char>, 1042
basic_istream<wchar_t>, 1042
basic_istreambuf_iterator, 1010
basic_istringstream, 1010, 1074
basic_istringstream, 1075
constructor, 1075
operator=, 1075
str, 1076
swap, 1075

basic_istringstream<char>, 1069
basic_istringstream<wchar_t>, 1069
basic_ofstream, 1010, 1089
basic_ofstream, 1089
constructor, 1089, 1090
operator=, 1090
swap, 1090

basic_ofstream<char>, 1079

Cross references

1318

c(cid:13) ISO/IEC

N4296

basic_ofstream<wchar_t>, 1079
basic_ostream, 1010, 1122
basic_ostream, 1058
constructor, 1058
destructor, 1058, 1059
operator<<, 1061, 1062, 1064
operator=, 1058
seekp, 1059
swap, 1058

basic_ostream<char>, 1042
basic_ostream<wchar_t>, 1042
basic_ostreambuf_iterator, 1010
basic_ostringstream, 1010, 1076
basic_ostringstream, 1077
constructor, 1077
operator=, 1077
str, 1077
swap, 1077

basic_ostringstream<char>, 1069
basic_ostringstream<wchar_t>, 1069
basic_regex, 1098, 1112, 1139

assign, 1115, 1116
basic_regex, 1114, 1115
constants, 1113, 1114
constructor, 1114, 1115
flag_type, 1116
getloc, 1116
imbue, 1116
mark_count, 1116
operator=, 1115
swap, 1117

basic_streambuf, 1010, 1033
basic_streambuf, 1035
constructor, 1035
destructor, 1035
operator=, 1037
setbuf, 1074
swap, 1037

basic_streambuf<char>, 1032
basic_streambuf<wchar_t>, 1032
basic_string, 658, 679, 1069

constructor, 662–664
copy, 674
crbegin, 666
crend, 666
empty, 667
end, 666
erase, 672
find, 675
find_first_not_of, 677
find_first_of, 676
find_last_not_of, 678
find_last_of, 677
front, 668
get_allocator, 675
getline, 683, 684
insert, 671, 672
length, 666
max_size, 666
operator!=, 681
operator+, 679, 680
operator+=, 668
operator<, 681
operator<=, 682
operator<<, 683
operator=, 665, 666
operator==, 681
operator>, 682
operator>=, 682
operator>>, 683
operator[], 667
pop_back, 672
push_back, 669
rbegin, 666
rend, 666
replace, 673, 674
reserve, 667
resize, 666, 667
rfind, 676
shrink_to_fit, 667
size, 666
substr, 678
swap, 675, 683

basic_stringbuf, 1010, 1070
basic_stringbuf, 1071
constructor, 1071
operator=, 1071
str, 1072
swap, 1071, 1072

basic_stringbuf<char>, 1069
basic_stringbuf<wchar_t>, 1069
basic_stringstream, 1010, 1078

append, 668, 669
assign, 669, 670
at, 667
back, 668
begin, 666
capacity, 667
cbegin, 666
cend, 666
clear, 667
compare, 678, 679

Cross references

1319

c(cid:13) ISO/IEC

N4296

basic_stringstream, 1078
constructor, 1079
operator=, 1079
str, 1079
swap, 1079

before

type_info, 488

before_begin

forward_list, 787

begin, 494

array, 777
basic_string, 666
initializer_list, 494
match_results, 1126
valarray, 1001

begin(C&), 883
begin(initializer_list<E>), 495
begin(T (&)[N]), 883
bernoulli_distribution, 962

constructor, 963
p, 963

beta

gamma_distribution, 968

bidirectional_iterator_tag, 862
binary_negate, 594
binary_search, 914
bind, 595–597
binomial_distribution, 963

constructor, 963
p, 964
t, 964

bit_and, 593
bit_and<>, 593
bit_not<>, 594
bit_or, 593
bit_or<>, 593
bit_xor, 593
bit_xor<>, 593
<bitset>, 534
bitset, 534

bitset, 536, 537
flip, 538
operator[], 540
reset, 538
set, 538

boolalpha, 1029
byte_string

wstring_convert, 700

c_str

basic_string, 675

Cross references

basic_string, 667
vector, 801

cacos

cacosh

complex, 934

complex, 934
call_once, 1186
calloc, 555, 1252
capacity

casin

casinh

complex, 934

complex, 934

<cassert>, 450
catan

complex, 934

catanh

complex, 934

category

error_code, 509
error_condition, 511
locale, 693

cauchy_distribution, 972

a, 973
b, 973
constructor, 973

cbefore_begin

forward_list, 787

cbegin

basic_string, 666
cbegin(const C&), 883
cbrt, 1005
<ccomplex>, 936
cend

basic_string, 666

cend(const C&), 884
cerr, 1013
<cerrno>, 461
<cfenv>, 925
CHAR_BIT, 477
char_class_type

regex_traits, 1109

CHAR_MAX, 477
char_traits, 650–653

char_type, 650
int_type, 650
off_type, 650
pos_type, 650
state_type, 650

char_type

char_traits, 650

1320

c(cid:13) ISO/IEC

N4296

chi_squared_distribution, 972

constructor, 972
n, 972
chrono, 625
cin, 1013
<ciso646>, 1250
classic

locale, 698
classic_table

ctype<char>, 709

clear

atomic_flag, 1157
basic_ios, 1028
basic_string, 667
error_code, 508
error_condition, 510
forward_list, 789

<climits>, 1258
<clocale>, 446, 1250
clock, 495, 496
clock_t, 496
CLOCKS_PER_SEC, 496
clog, 1013
close

basic_filebuf, 1083, 1093
basic_ifstream, 1088
basic_ofstream, 1090
messages, 738

code

future_error, 1196
system_error, 513

codecvt, 709, 742

always_noconv, 711
do_always_noconv, 713
do_encoding, 713
do_in, 711
do_length, 713
do_max_length, 713
do_out, 711
do_unshift, 712
encoding, 711
in, 711
length, 711
max_length, 711
out, 711
unshift, 711

codecvt_byname, 713
collate, 724

compare, 725
do_compare, 725
do_hash, 725

do_transform, 725
hash, 725
transform, 725
collate_byname, 726
combine

locale, 697

common_type, 630, 633
compare

basic_string, 678, 679
collate, 725
sub_match, 1118

compare_exchange_strong

atomic type, 1154

compare_exchange_strong_explicit

atomic type, 1154
compare_exchange_weak
atomic type, 1154

compare_exchange_weak_explicit

atomic type, 1154

complex

literals, 936
<complex>, 926
complex, 928

complex, 930
imag, 930
operator-, 932
operator/, 932
real, 930

<condition_variable>, 1187
condition_variable
constructor, 1188
destructor, 1188
notify_all, 1189
notify_one, 1189
wait, 1189
wait_for, 1190, 1191
wait_until, 1189, 1190

condition_variable_any

constructor, 1192
destructor, 1192
notify_all, 1192
notify_one, 1192
wait, 1192, 1193
wait_for, 1193, 1194
wait_until, 1193

conj, 935

complex, 933

const_pointer

allocator_traits, 549

const_pointer_cast
shared_ptr, 575

Cross references

1321

c(cid:13) ISO/IEC

N4296

const_void_pointer

allocator_traits, 549

scoped_allocator_adaptor, 644, 645

construct

converted

copy, 902

wstring_convert, 700

basic_string, 674

copy_backward, 903
copy_n, 902
copyfmt

basic_ios, 1027

copysign, 1005
cos, 993, 1005

complex, 934

cosh, 993, 1005

complex, 934

count, 899

bitset, 539
duration, 632

count_if, 899
cout, 1013
crbegin

basic_string, 666

crbegin(const C& c), 884
cref

reference_wrapper, 588

crend

basic_string, 666
crend(const C& c), 884
<csetjmp>, 461, 495, 496
cshift

valarray, 990
<csignal>, 495, 496
<cstdalign>, 495, 496
<cstdarg>, 461, 495, 496
<cstdbool>, 495, 496
<cstddef>, 1250, 1252
<cstdint>, 478
<cstdio>, 1013, 1014, 1080, 1083, 1084, 1250
<cstdlib>, 449, 495, 496, 1250, 1253
<cstring>, 447, 1250, 1258, 1262
<ctgmath>, 1004
<ctime>, 495, 496, 691, 1250
ctype, 704

do_is, 705
do_narrow, 706
do_scan_not, 706
do_tolower, 706
do_toupper, 706
do_widen, 706

is, 705
narrow, 705
scan_is, 705
scan_not, 705
tolower, 705
toupper, 705
widen, 705

ctype<char>, 707

classic_table, 709
constructor, 708
ctype<char>, 708
destructor, 708
do_narrow, 709
do_tolower, 709
do_toupper, 709
do_widen, 709
is, 708
narrow, 709
scan_is, 708
scan_not, 709
table, 709
tolower, 709
toupper, 709
widen, 709
ctype_base, 703

do_scan_is, 705

ctype_byname, 707
<cuchar>, 461
curr_symbol

moneypunct, 736

current_exception, 492
<cwchar>, 461, 1250

data

basic_string, 675
array, 778
vector, 802

date_order

time_get, 727

DBL_DIG, 477
DBL_EPSILON, 477
DBL_MANT_DIG, 477
DBL_MAX, 477
DBL_MAX_10_EXP, 477
DBL_MAX_EXP, 477
DBL_MIN, 477
DBL_MIN_10_EXP, 477
DBL_MIN_EXP, 477
deallocate

allocator, 552
allocator_traits, 550

Cross references

1322

c(cid:13) ISO/IEC

N4296

scoped_allocator_adaptor, 644

dec, 1031, 1061
DECIMAL_DIG, 477
decimal_point

moneypunct, 736
numpunct, 723

declare_no_pointers, 546
declare_reachable, 546
declval, 518
default_delete

default_delete, 557, 558
operator(), 557, 558
default_error_condition
error_category, 506
error_code, 509

default_random_engine, 956
defaultfloat, 1031
defer_lock, 1176
defer_lock_t, 1176
delete

operator, 555
operator, 462, 482–484

denorm_absent, 475
denorm_indeterminate, 475
denorm_min

numeric_limits, 474

denorm_present, 475
densities

piecewise_constant_distribution, 978
piecewise_linear_distribution, 980

<deque>, 775
deque, 779

deque, 782
shrink_to_fit, 782
swap, 783

detach

thread, 1166
difference_type

allocator_traits, 549
pointer_traits, 546

numeric_limits, 471

digits

digits10

numeric_limits, 472

discard_block_engine, 952

constructor, 953

discrete_distribution, 975

constructor, 976
probabilities, 976

distance, 863
div, 1005

divides, 588
divides<>, 589
do_always_noconv
codecvt, 713

do_close

message, 739

do_compare

collate, 725
do_curr_symbol

moneypunct, 737

do_date_order

time_get, 728
do_decimal_point

moneypunct, 736
numpunct, 724

do_encoding

codecvt, 713

do_falsename

numpunct, 724

do_frac_digits

moneypunct, 737

do_get

messages, 739
money_get, 732
num_get, 716, 718
time_get, 729

do_get_date

time_get, 729
do_get_monthname
time_get, 729

do_get_time

time_get, 728

do_get_weekday

time_get, 729

do_get_year

time_get, 729

do_grouping

moneypunct, 737
numpunct, 724

do_hash

collate, 725

codecvt, 711

do_in

do_is

ctype, 705

do_length

codecvt, 713

do_max_length

codecvt, 713

do_narrow, 709
ctype, 706

Cross references

1323

c(cid:13) ISO/IEC

N4296

ctype<char>, 709

do_neg_format

moneypunct, 737

do_negative_sign

moneypunct, 737

do_open

do_out

messages, 738

codecvt, 711

do_pos_format

moneypunct, 737

do_positive_sign

moneypunct, 737

do_put

money_put, 734
num_put, 719, 722
time_put, 731

do_scan_is

ctype_base, 705

do_scan_not

ctype, 706

do_thousands_sep

moneypunct, 737
numpunct, 724

do_tolower

do_toupper

ctype, 706
ctype<char>, 709

ctype, 706
ctype<char>, 709

do_transform

collate, 725

do_truename

numpunct, 724

do_unshift

codecvt, 712

do_widen, 709
ctype, 706
ctype<char>, 709
domain_error, 498, 499
domain_error, 499

duration

constructor, 631, 632
count, 632
max, 633
min, 633
operator!=, 634
operator*, 634
operator*=, 633
operator+, 632, 638
operator++, 632

operator+=, 633
operator-, 632, 638
operator-=, 633
operator--, 632
operator/, 634
operator/=, 633
operator<, 635
operator<=, 635
operator==, 634
operator>=, 635
operator%, 634
operator%=, 633
zero, 633

duration_cast, 635
duration_values, 629

max, 630
min, 629
zero, 629

dynamic_pointer_cast

shared_ptr, 574

eback

egptr

basic_streambuf, 1037

basic_streambuf, 1037

element_type

pointer_traits, 545

emplace

priority_queue, 848

emplace_after

forward_list, 788

emplace_front

forward_list, 787

empty, 862

basic_string, 667
match_results, 1125

enable_shared_from_this, 578

constructor, 579
destructor, 579
operator=, 579
shared_from_this, 579

encoding

end, 494

codecvt, 711

array, 777
basic_string, 666
initializer_list, 494
match_results, 1126
valarray, 1001

end(C&), 883
end(initializer_list<E>), 495

Cross references

1324

c(cid:13) ISO/IEC

N4296

end(T (&)[N]), 883
endl, 1061, 1063
ends, 1064
entropy

random_device, 957

eof

epptr

epsilon

eq

basic_ios, 1029

basic_streambuf, 1038

numeric_limits, 472

char_traits, 675–678

istreambuf_iterator, 882

equal, 900

equal_range, 914
equal_to, 590
equal_to<>, 590
equivalent

error_category, 506, 507

erase

deque, 783
list, 795
basic_string, 672
vector, 802

erase_after

forward_list, 788

erased

forward_list, 788

erf, 1005
erfc, 1005
errc, 502
error_category, 502, 505

constructor, 506
default_error_condition, 506
destructor, 506
equivalent, 506, 507
message, 506
name, 506
operator!=, 506
operator<, 506
operator==, 506

assign, 508
category, 509
clear, 508
default_error_condition, 509
error_code, 508
message, 509
operator bool, 509
operator!=, 511

operator<, 509
operator<<, 509
operator=, 508
operator==, 511
value, 509

error_condition, 502

assign, 510
category, 511
clear, 510
constructor, 510
message, 511
operator bool, 511
operator!=, 511
operator<, 511
operator=, 510
operator==, 511
value, 511

error_type, 1107, 1108
exception

bad_function_call, 597
bad_weak_ptr, 567

<exception>, 489
exception, 490

constructor, 490
destructor, 490
exception_ptr, 492
exceptions

basic_ios, 1029

exchange

atomic type, 1154

exit, 62, 64, 143, 449, 479, 480, 487
EXIT_FAILURE, 479
EXIT_SUCCESS, 479
exp, 993, 1005

complex, 934

exp2, 1005
expired

weak_ptr, 577

expm1, 1005
exponential_distribution, 966

constructor, 967
lambda, 967

a, 970
b, 970
constructor, 969

facet

fail

locale, 694

basic_ios, 1029

error_code, 502, 507, 509

extreme_value_distribution, 969

Cross references

1325

c(cid:13) ISO/IEC

N4296

failed

failure

ostreambuf_iterator, 883

ios_base::failure, 1018

falsename

numpunct, 723

fclose, 1084
fdim, 1005
FE_ALL_EXCEPT, 925
FE_DFL_ENV, 925
FE_DIVBYZERO, 925
FE_DOWNWARD, 925
FE_INEXACT, 925
FE_INVALID, 925
FE_OVERFLOW, 925
FE_TONEAREST, 925
FE_TOWARDZERO, 925
FE_UNDERFLOW, 925
FE_UPWARD, 925
feclearexcept, 925
fegetenv, 925
fegetexceptflag, 925
fegetround, 925
feholdexcept, 925
fenv_t, 925
feraiseexcept, 925
fesetenv, 925
fesetexceptflag, 925
fesetround, 925
fetch_

atomic type, 1155

fetestexcept, 925
feupdateenv, 925
fexcept_t, 925
filebuf, 1010, 1079
fill, 905

array, 778
basic_ios, 1027
gslice_array, 998
indirect_array, 1000
mask_array, 999
slice_array, 995

fill_n, 905
find, 898

basic_string, 675

find_end, 898
find_first_not_of

basic_string, 677

find_first_of, 898

basic_string, 676

find_if, 898

find_if_not, 898
find_last_not_of

basic_string, 678

find_last_of

basic_string, 677

fisher_f_distribution, 973

constructor, 974
m, 974
n, 974
fixed, 1031
flag_type

basic_regex, 1116

flags

flip

ios_base, 703, 1020

bitset, 538
bitset, 538
vector<bool>, 805

float_denorm_style, 469, 475

numeric_limits, 473

float_round_style, 469, 475
floor, 1005
FLT_DIG, 477
FLT_EPSILON, 477
FLT_EVAL_METHOD, 477
FLT_MANT_DIG, 477
FLT_MAX, 477
FLT_MAX_10_EXP, 477
FLT_MAX_EXP, 477
FLT_MIN, 477
FLT_MIN_10_EXP, 477
FLT_MIN_EXP, 477
FLT_RADIX, 477
FLT_ROUNDS, 477
flush, 1020, 1046, 1059, 1064

basic_ostream, 1063

fma, 1005
fmax, 1005
fmin, 1005
fmtflags

fopen, 1083
for_each, 897
format

ios, 1065
ios_base, 1018, 1020

match_results, 1126, 1127

format_default, 1105
format_default, 1107
format_first_only, 1105, 1132
format_first_only, 1107
format_no_copy, 1105, 1132

Cross references

1326

c(cid:13) ISO/IEC

N4296

format_no_copy, 1107
format_sed, 1105
format_sed, 1107
forward, 517
forward_as_tuple, 530
forward_iterator_tag, 862
<forward_list>, 775
forward_list

before_begin, 787
cbefore_begin, 787
clear, 789
emplace_after, 788
emplace_front, 787
erase_after, 788
erased, 788
forward_list, 786, 787
front, 787
insert_after, 787, 788
merge, 790
pop, 787
push_front, 787
remove, 790
remove_if, 790
resize, 788
reverse, 790
sort, 790
splice_after, 789
swap, 791
unique, 790
fpclassify, 1007
fpos, 1015, 1023, 1024

state, 1023

frac_digits

moneypunct, 736

free, 555
freeze

ostrstream, 1262
strstream, 1264
strstreambuf, 1258

frexp, 1005
from_bytes

wstring_convert, 700

from_time_t, 639
front

basic_string, 668
forward_list, 787

front_insert_iterator, 870

front_insert_iterator, 870

front_inserter, 871
fseek, 1083
<fstream>, 1079

fstream, 1010
function, 597

assign, 601
bool conversion, 601
destructor, 600
function, 599
invocation, 601
operator!=, 601
operator(), 601
operator=, 600
operator==, 601
swap, 601, 602
target, 601
target_type, 601

<functional>, 582
future

constructor, 1200, 1201
get, 1201
operator=, 1201
share, 1201
valid, 1201
wait, 1202
wait_for, 1202
wait_until, 1202
future_category, 1195
future_errc

make_error_code, 1195
make_error_condition, 1196

future_error
code, 1196
what, 1196

gamma_distribution, 967

alpha, 968
beta, 968
constructor, 968

gbump

gcount

basic_streambuf, 1037

basic_istream, 1050

generate, 905

seed_seq, 958

generate_canonical, 960
generate_n, 905
generic_category, 505, 507
geometric_distribution, 964

constructor, 964
p, 964

get

array, 779
basic_istream, 1050, 1051, 1054

Cross references

1327

c(cid:13) ISO/IEC

N4296

future, 1201
messages, 738
money_get, 732
num_get, 715
pair, 522, 523
reference_wrapper, 587
shared_future, 1204
shared_ptr, 572
time_get, 728
tuple, 531, 532
unique_ptr, 562

get_allocator

basic_string, 675
match_results, 1127

get_date

time_get, 727

get_deleter

shared_ptr, 575
unique_ptr, 562

get_future

packaged_task, 1208
promise, 1198

get_id

this_thread, 1167
thread, 1166
get_money, 1066
get_monthname

time_get, 727

get_new_handler, 462
get_pointer_safety, 547
get_temporary_buffer, 553
get_terminate, 462
get_time, 1067

time_get, 727

get_unexpected, 462
get_weekday

time_get, 727

get_year

time_get, 727

getenv, 495, 496
getline

basic_istream, 1051, 1052
basic_string, 683, 684

getloc, 1111

basic_regex, 1116
basic_streambuf, 1035
ios_base, 1021

global

good

locale, 698

basic_ios, 1029

hash, 511, 581, 582, 602, 647, 686

gptr

basic_streambuf, 1037

greater, 590
greater<>, 591
greater_equal, 590
greater_equal<>, 591
grouping

moneypunct, 736
numpunct, 723

gslice, 995

constructor, 996
gslice_array, 997

hardware_concurrency

thread, 1166
has_denorm_loss

numeric_limits, 473

has_facet

locale, 698

has_infinity

numeric_limits, 473

has_quiet_NaN

numeric_limits, 473

has_signaling_NaN

numeric_limits, 473

collate, 725

hash_code, 540

type_info, 488
type_index, 647

hex, 1031
hexfloat, 1031
hypot, 1005

id

idxl

locale, 695

operator>, 635
ifstream, 1010, 1079
ignore, 530

basic_istream, 1052

ilogb, 1005
imag, 935

imbue, 1111

complex, 930, 933

basic_filebuf, 1086
basic_ios, 1027
basic_regex, 1116
basic_streambuf, 1038
ios_base, 1021

in

Cross references

1328

c(cid:13) ISO/IEC

N4296

codecvt, 711

in_avail

basic_streambuf, 1036

includes, 915
independent_bits_engine, 953
index_sequence, 516
index_sequence_for, 516
indirect_array, 999
operator[], 1000

infinity

numeric_limits, 473

ios_base::Init, 1020

Init

init

basic_ios, 1026, 1045, 1058

<initializer_list>, 494
initializer_list, 494

begin, 494
end, 494
initializer_list, 494
size, 495

inner_allocator

scoped_allocator_adaptor, 644

inner_allocator_type

scoped_allocator_adaptor, 642

inner_product, 1002
inplace_merge, 915
input_iterator_tag, 862
emplace

deque, 783

insert

deque, 783
list, 795
basic_string, 671, 672
map, 812
multimap, 816
unordered_map, 830
unordered_multimap, 834
vector, 802

push_back

deque, 783

push_front

deque, 783
insert_after

forward_list, 787, 788

insert_iterator, 871

insert_iterator, 872

insert_or_assign

map, 812
unordered_map, 830

inserter, 872

char_traits, 650
wstring_convert, 701

integer_sequence, 534
internal, 1030
intervals

piecewise_constant_distribution, 978
piecewise_linear_distribution, 980

intmax_t, 478
intptr_t, 478
invalid_argument, 498, 499, 536

invalid_argument, 499

int16_t, 478
int32_t, 478
int64_t, 478
int8_t, 478
int_fast16_t, 478
int_fast32_t, 478
int_fast64_t, 478
int_fast8_t, 478
int_least16_t, 478
int_least32_t, 478
int_least64_t, 478
int_least8_t, 478
INT_MAX, 477
INT_MIN, 477
int_type

INVOKE , 585, 586
invoke, 586
<iomanip>, 1042
<ios>, 1014
ios, 1010, 1015
ios_base, 1015

destructor, 1023
fmtflags, 1020
ios_base, 1023
iostate, 1018
precision, 1021
setf, 1021
streamsize, 1021

ios_base::failure, 1018
ios_base::Init, 1020

destructor, 1020

<iosfwd>, 1010
iostate

ios_base, 1018

<iostream>, 1012
iostream_category, 1031
iota, 1004
is

ctype, 705
ctype<char>, 708

Cross references

1329

c(cid:13) ISO/IEC

N4296

is_always_equal

allocator_traits, 550
scoped_allocator_adaptor, 643

is_bind_expression, 595
is_bounded

numeric_limits, 474
is_error_code_enum, 502
is_error_condition_enum, 502
is_exact

numeric_limits, 472

is_heap, 919
is_heap_until, 919
is_iec559

numeric_limits, 474

numeric_limits, 472

numeric_limits, 474

is_integer

is_modulo

is_open

basic_filebuf, 1083, 1092
basic_ifstream, 1088
basic_ofstream, 1090

is_partitioned, 909
is_permutation, 901
is_placeholder, 595
is_signed

numeric_limits, 472

is_sorted, 912
is_sorted_until, 912
isalnum, 698
isalpha, 698
isblank, 698
iscntrl, 698
isctype

isdigit, 698
isfinite, 1007
isgraph, 698
isgreater, 1007
isgreaterequal, 1007
isinf, 1007
isless, 1007
islessequal, 1007
islessgreater, 1007
islower, 698
isnan, 1007
isnormal, 1007
<iso646.h>, 1250
isprint, 698
ispunct, 698

isspace, 698
<istream>, 1041
istream, 1010, 1042
istream_iterator, 877

constructor, 878
destructor, 878
operator!=, 879
operator*, 878
operator++, 878
operator->, 878
operator==, 878, 879
istreambuf_iterator, 880

constructor, 881
operator++, 882

istringstream, 1010, 1069
istrstream, 1261

constructor, 1261
istrstream, 1261

isunordered, 1007
isupper, 698
isxdigit, 698
iter_swap, 904
<iterator>, 857
iword

ios_base, 1022

jmp_buf, 496
join

joinable

thread, 1166

thread, 1166

kill_dependency, 1147
knuth_b, 956

LDBL_DIG, 477
LDBL_EPSILON, 477
LDBL_MANT_DIG, 477
LDBL_MAX, 477
LDBL_MAX_10_EXP, 477
LDBL_MAX_EXP, 477
LDBL_MIN, 477
LDBL_MIN_10_EXP, 477
LDBL_MIN_EXP, 477
left, 1030
length

regex_traits, 1110
regular expression traits, 1140

lambda

exponential_distribution, 967

Cross references

1330

char_traits, 664, 666, 670, 681
basic_string, 666
codecvt, 711

c(cid:13) ISO/IEC

N4296

match_results, 1126
regex_traits, 1109
sub_match, 1117
valarray, 990

length_error, 498, 500, 658

length_error, 500

less, 590
less<>, 591
less_equal, 590
less_equal<>, 591
lexicographical_compare, 921
lgamma, 1005
<limits>, 469
linear_congruential_engine, 948

constructor, 949

<list>, 775
list, 791

list, 793, 794
splice, 796
swap, 797

literals

complex, 936

LLONG_MAX, 477
LLONG_MIN, 477
llrint, 1005
llround, 1005
load

atomic type, 1153

<locale>, 690, 691
locale, 1111, 1116, 1139

category, 693
classic, 698
combine, 697
constructor, 696
destructor, 697
facet, 694
global, 698
has_facet, 698
id, 695
name, 697
operator!=, 697
operator(), 697
operator=, 696
operators==, 697
use_facet, 698

lock, 1185

shared_lock, 1183
unique_lock, 1180
weak_ptr, 577

lock_guard

constructor, 1177

destructor, 1177

log, 993, 1005

complex, 934
log10, 993, 1005
complex, 935

log1p, 1005
log2, 1005
logb, 1005
logic_error, 498

logic_error, 499

logical_and, 592
logical_and<>, 592
logical_not, 592
logical_not<>, 592
logical_or, 592
logical_or<>, 592
lognormal_distribution, 971

constructor, 971
m, 971
s, 971

LONG_MAX, 477
longjmp, 495, 496
lookup_classname

regex_traits, 1110
regular expression traits, 1140

lookup_collatename

regex_traits, 1109
regular expression traits, 1140

lower_bound, 913
lowest

numeric_limits, 471

lrint, 1005
lround, 1005

m

fisher_f_distribution, 974
lognormal_distribution, 971

make_error_code, 502, 509, 1031

future_errc, 1195

make_error_condition, 502, 511, 1031

future_errc, 1196

make_exception_ptr, 493
make_heap, 918
make_index_sequence, 516
make_integer_sequence, 534
make_move_iterator, 876
make_pair, 522
make_ready_at_thread_exit

packaged_task, 1209

make_reverse_iterator, 869
make_shared, 573

Cross references

1331

c(cid:13) ISO/IEC

N4296

make_tuple, 529
make_unique, 565
malloc, 555, 1252
<map>, 805
map, 807

constructor, 811
insert, 812
insert_or_assign, 812
map, 811
operator<, 811
operator==, 811
swap, 812
try_emplace, 812

mark_count

basic_regex, 1116

mask_array, 998

operator[], 998

match_any, 1105
match_any, 1107
match_continuous, 1105, 1135
match_continuous, 1107
match_default, 1105
match_flag_type, 1105, 1106, 1141
match_not_bol, 1105
match_not_bol, 1106
match_not_bow, 1105
match_not_bow, 1107
match_not_eol, 1105
match_not_eol, 1106
match_not_eow, 1105
match_not_eow, 1107
match_not_null, 1105, 1135
match_not_null, 1107
match_prev_avail, 1105, 1135
match_prev_avail, 1107
match_results, 1123, 1133, 1136

begin, 1126
empty, 1125
end, 1126
format, 1126, 1127
get_allocator, 1127
length, 1126
match_results, 1124, 1125
matched, 1123
max_size, 1125
operator!=, 1128
operator=, 1125
operator==, 1128
operator[], 1126
position, 1126
prefix, 1126

size, 1125
state, 1125
str, 1126
suffix, 1126
swap, 1127

max, 920

duration, 633
duration_values, 630
numeric_limits, 471
time_point, 638
valarray, 990

max_align_t, 468, 469
max_digits10

numeric_limits, 472

max_element, 921
max_exponent

numeric_limits, 473

max_exponent10

numeric_limits, 473

max_length

codecvt, 711

max_size

allocator, 552
allocator_traits, 550
array, 777
basic_string, 666
match_results, 1125
scoped_allocator_adaptor, 644

MB_LEN_MAX, 477
mean

normal_distribution, 971
poisson_distribution, 966
student_t_distribution, 975

mem_fn, 597
memchr, 687
<memory>, 541
merge, 914

list, 796
forward_list, 790

mersenne_twister_engine, 949

constructor, 950

message

do_close, 739
error_category, 506
error_code, 509
error_condition, 511

messages, 738
close, 738
do_get, 739
do_open, 738
get, 738

Cross references

1332

c(cid:13) ISO/IEC

N4296

open, 738

messages_byname, 739
min, 919

duration, 633
duration_values, 629
numeric_limits, 471
time_point, 638
valarray, 990
min_element, 920
min_exponent

numeric_limits, 472

min_exponent10

numeric_limits, 472

minmax, 920
minmax_element, 921
minstd_rand, 955
minstd_rand0, 955
minus, 588
minus<>, 589
mismatch, 899
mod, 1005
modf, 1005
modulus, 588
modulus<>, 589
money_get, 732
do_get, 732
get, 732

money_put, 734
do_put, 734
put, 734

moneypunct, 735

curr_symbol, 736
decimal_point, 736
do_curr_symbol, 737
do_decimal_point, 736
do_frac_digits, 737
do_grouping, 737
do_neg_format, 737
do_negative_sign, 737
do_pos_format, 737
do_positive_sign, 737
do_thousands_sep, 737
frac_digits, 736
grouping, 736
negative_sign, 736
positive_sign, 736
thousands_sep, 736
moneypunct_byname, 737
move, 518

basic_ios, 1027

movemove, 903

move_backward, 903
move_if_noexcept, 518
move_iterator, 873

base, 874
constructor, 874
move_iterator, 874
operator!=, 876
operator*, 874
operator+, 875, 876
operator++, 875
operator+=, 875
operator-, 875, 876
operator-=, 875
operator->, 875
operator--, 875
operator<, 876
operator<=, 876
operator=, 874
operator==, 876
operator>, 876
operator>=, 876
operator[], 876

mt19937, 955
mt19937_64, 956
multimap, 813

insert, 816
multimap, 816
operator<, 816
operator==, 816
swap, 816

multiplies, 588
multiplies<>, 589
multiset, 820

multiset, 823
operator<, 823
operator==, 823
swap, 823
<mutex>, 1167
mutex

shared_lock, 1185
unique_lock, 1181

n

name

chi_squared_distribution, 972
fisher_f_distribution, 974

type_info, 488
error_category, 506
locale, 697
type_index, 647

nan, 1005

Cross references

1333

c(cid:13) ISO/IEC

N4296

narrow

basic_ios, 1027
ctype, 705
ctype<char>, 709

NDEBUG, 450
nearbyint, 1005
negate, 588
negate<>, 589
negative_binomial_distribution, 965

condition_variable, 1189

Cross references

1334

condition_variable_any, 1192
notify_all_at_thread_exit, 1187
notify_one

condition_variable, 1189
condition_variable_any, 1192

nounitbuf, 1030
nouppercase, 1030
nth_element, 912
NULL, 468, 469
nullptr_t, 468, 469
num_get, 714

do_get, 716, 718
get, 715
num_put, 718

do_put, 719, 722
put, 719

<numeric>, 1001
numeric_limits, 470
numeric_limits, 469
denorm_min, 474
digits, 471
digits10, 472
epsilon, 472
float_denorm_style, 473
has_denorm_loss, 473
has_infinity, 473
has_quiet_NaN, 473
has_signaling_NaN, 473
infinity, 473
is_bounded, 474
is_exact, 472
is_iec559, 474
is_integer, 472
is_modulo, 474
is_signed, 472
lowest, 471
max, 471
max_digits10, 472
max_exponent, 473
max_exponent10, 473
min, 471
min_exponent, 472
min_exponent10, 472
quiet_NaN, 474
radix, 472
round_error, 472
round_style, 475
signaling_NaN, 474
tinyness_before, 475
traps, 474

numeric_limits<bool>, 477

operator, 481, 485
operator, 461, 462, 482–485, 555

constructor, 965
p, 965
t, 965

negative_sign

moneypunct, 736

nested_exception, 493

nested_exception, 493
nested_ptr, 493
rethrow_if_nested, 494
rethrow_nested, 493
throw_with_nested, 493

nested_exception, 493

nested_ptr

<new>, 481
new

new_handler, 487
next, 864
next_permutation, 922
nextafter, 1005
nexttoward, 1005
noboolalpha, 1029
none

bitset, 539

none_of, 897
norm, 935

complex, 933

normal_distribution, 970

constructor, 970
mean, 971
stddev, 971
noshowbase, 1029
noshowpoint, 1029
noshowpos, 1030
noskipws, 1030
not1, 594
not2, 594
not_equal_to, 590
not_equal_to<>, 591
notify_all

c(cid:13) ISO/IEC

N4296

numpunct, 722

decimal_point, 723
do_decimal_point, 724
do_falsename, 724
do_grouping, 724
do_thousands_sep, 724
do_truename, 724
falsename, 723
grouping, 723
thousands_sep, 723
truename, 723

numpunct_byname, 724

oct, 1031
off_type

char_traits, 650

offsetof, 468, 469, 1252
ofstream, 1010, 1079
once_flag, 1185
open

basic_filebuf, 1083, 1092
basic_ifstream, 1088
basic_ofstream, 1090
messages, 738

openmode

ios_base, 1018

operator @=

atomic type, 1156
operator basic_string

sub_match, 1117

operator bool

basic_istream, 1046
basic_ios, 1028
basic_ostream, 1059
error_code, 509
error_condition, 511
shared_lock, 1185
shared_ptr, 573
unique_lock, 1181
unique_ptr, 562

operator C

operator T&

atomic type, 1153

reference_wrapper, 587

operator!

basic_ios, 1028
valarray, 988

operator!=, 516

pair, 521
type_info, 488
allocator, 552

basic_string, 681
bitset, 539
complex, 932
duration, 634
error_category, 506
error_code, 511
error_condition, 511
function, 601
istream_iterator, 879
istreambuf_iterator, 882
locale, 697
match_results, 1128
move_iterator, 876
queue, 845
regex_iterator, 1135
regex_token_iterator, 1139
reverse_iterator, 868
scoped_allocator_adaptor, 646
shared_ptr, 574
stack, 850
sub_match, 1118–1122
thread::id, 1164
time_point, 638
tuple, 532
type_index, 647
unique_ptr, 565, 566
valarray, 992

operator()

default_delete, 557, 558
function, 601
locale, 697
packaged_task, 1208
random_device, 957
reference_wrapper, 587

operator*

back_insert_iterator, 870
complex, 932
duration, 634
front_insert_iterator, 871
insert_iterator, 872
istream_iterator, 878
istreambuf_iterator, 881
move_iterator, 874
ostream_iterator, 880
ostreambuf_iterator, 883
raw_storage_iterator, 553
regex_iterator, 1135
regex_token_iterator, 1139
reverse_iterator, 866
shared_ptr, 572
unique_ptr, 562

Cross references

1335

c(cid:13) ISO/IEC

N4296

valarray, 991

operator*=

complex, 931
duration, 633
gslice_array, 998
indirect_array, 1000
mask_array, 999
slice_array, 995
valarray, 989

operator+

operator++

basic_string, 679, 680
complex, 932
duration, 632, 638
move_iterator, 875, 876
reverse_iterator, 867, 868
time_point, 638
valarray, 988, 991

atomic type, 1156
back_insert_iterator, 870
duration, 632
front_insert_iterator, 871
insert_iterator, 872
istream_iterator, 878
istreambuf_iterator, 882
move_iterator, 875
ostream_iterator, 880
ostreambuf_iterator, 883
raw_storage_iterator, 553
regex_iterator, 1135, 1136
regex_token_iterator, 1139
reverse_iterator, 866

operator+=

basic_string, 668
complex, 931
duration, 633
gslice_array, 998
indirect_array, 1000
mask_array, 999
move_iterator, 875
reverse_iterator, 867
slice_array, 995
time_point, 637
valarray, 989

operator-

complex, 932
duration, 632, 638
move_iterator, 875, 876
reverse_iterator, 867, 868
time_point, 638
valarray, 988, 991

operator-=

complex, 931
duration, 633
gslice_array, 998
indirect_array, 1000
mask_array, 999
move_iterator, 875
reverse_iterator, 867
slice_array, 995
time_point, 637
valarray, 989

operator->

istream_iterator, 878
move_iterator, 875
regex_iterator, 1135
regex_token_iterator, 1139
reverse_iterator, 866
shared_ptr, 572
unique_ptr, 562

operator--

atomic type, 1156
duration, 632
move_iterator, 875
reverse_iterator, 867

operator/

complex, 932
duration, 634
valarray, 991

operator/=

operator<

complex, 931
duration, 633
gslice_array, 998
indirect_array, 1000
mask_array, 999
slice_array, 995
valarray, 989

pair, 521
basic_string, 681
duration, 635
error_category, 506
error_code, 509
error_condition, 511
move_iterator, 876
queue, 845
reverse_iterator, 868
shared_ptr, 573, 574
stack, 850
sub_match, 1118–1122
thread::id, 1164
time_point, 638

Cross references

1336

c(cid:13) ISO/IEC

N4296

tuple, 532
type_index, 647
unique_ptr, 565, 566
valarray, 992

operator«

operator<<

shared_ptr, 575
sub_match, 1122

bitset, 539, 540
complex, 933

operator<<=

bitset, 537
operator<=, 516

pair, 522
basic_string, 682
duration, 635
move_iterator, 876
queue, 845
reverse_iterator, 868
shared_ptr, 566, 574
stack, 851
sub_match, 1118–1122
thread::id, 1164
time_point, 638
tuple, 533
type_index, 647
unique_ptr, 566
valarray, 992

operator<<

basic_istream, 1055
basic_ostream, 1060–1062, 1064
basic_string, 683
error_code, 509
thread::id, 1164
valarray, 991

operator<<=

gslice_array, 998
indirect_array, 1000
mask_array, 999
slice_array, 995
valarray, 989

operator=

bad_alloc, 486
bad_cast, 488
bad_exception, 491
bad_typeid, 489
reverse_iterator, 866
atomic type, 1153
back_insert_iterator, 870
basic_filebuf, 1082
basic_fstream, 1092

basic_ifstream, 1088
basic_iostream, 1055
basic_istream, 1045
basic_istringstream, 1075
basic_ofstream, 1090
basic_ostream, 1058
basic_ostringstream, 1077
basic_regex, 1115
basic_streambuf, 1037
basic_string, 665, 666
basic_stringbuf, 1071
basic_stringstream, 1079
enable_shared_from_this, 579
error_code, 508
error_condition, 510
exception, 490
front_insert_iterator, 871
function, 600
future, 1201
gslice_array, 997
indirect_array, 1000
insert_iterator, 872
locale, 696
mask_array, 999
match_results, 1125
move_iterator, 874
ostream_iterator, 880
ostreambuf_iterator, 883
packaged_task, 1208
pair, 520, 521
promise, 1198
raw_storage_iterator, 553
reference_wrapper, 587
shared_future, 1203, 1204
shared_ptr, 571, 572
slice_array, 994
thread, 1165
tuple, 528, 529
unique_lock, 1179
unique_ptr, 561, 562
valarray, 986, 991
weak_ptr, 577

operator==

pair, 521
type_info, 488
allocator, 552
basic_string, 681
bitset, 539
complex, 932
duration, 634
error_category, 506

Cross references

1337

c(cid:13) ISO/IEC

N4296

error_code, 511
error_condition, 511
function, 601
istream_iterator, 878
istreambuf_iterator, 882
match_results, 1128
move_iterator, 876
queue, 845
regex_iterator, 1135
regex_token_iterator, 1136, 1139
reverse_iterator, 867
scoped_allocator_adaptor, 646
shared_ptr, 573
stack, 850
sub_match, 1118–1122
thread::id, 1164
time_point, 638
tuple, 532
type_index, 647
unique_ptr, 565, 566
valarray, 992

operator>, 516
pair, 521
basic_string, 682
idxl, 635
move_iterator, 876
queue, 845
reverse_iterator, 868
shared_ptr, 574
stack, 851
sub_match, 1118–1122
thread::id, 1164
time_point, 639
tuple, 533
type_index, 647
unique_ptr, 566
valarray, 992

operator>=, 516

pair, 522
basic_string, 682
duration, 635
move_iterator, 876
queue, 845
reverse_iterator, 868
shared_ptr, 574
stack, 851
sub_match, 1118–1122
thread::id, 1164
time_point, 639
tuple, 533
type_index, 647

operator>>=

operator[]

basic_istream, 1048
basic_string, 683
istream, 1047–1049
valarray, 991

gslice_array, 998
indirect_array, 1000
mask_array, 999
slice_array, 995
valarray, 989

basic_string, 667
bitset, 540
indirect_array, 1000
map, 811
mask_array, 998
match_results, 1126
move_iterator, 876
reverse_iterator, 867
unique_ptr, 564
unordered_map, 829
valarray, 986–988

operator>>

unique_ptr, 566
valarray, 992

bitset, 539, 540
complex, 932

operator>>=

bitset, 537

operator>>

operator%

duration, 634
valarray, 991

operator%=

duration, 633
gslice_array, 998
indirect_array, 1000
mask_array, 999
slice_array, 995
valarray, 989

operator&

bitset, 540
valarray, 991

operator&=

bitset, 537
gslice_array, 998
indirect_array, 1000
mask_array, 999
slice_array, 995
valarray, 989

operator&&

Cross references

1338

c(cid:13) ISO/IEC

N4296

valarray, 991, 992

operatorˆ

bitset, 540
valarray, 991

operatorˆ=

bitset, 537
gslice_array, 998
indirect_array, 1000
mask_array, 999
slice_array, 995
valarray, 989

operator~

bitset, 538
valarray, 988

operators==

locale, 697

operator|

bitset, 540
valarray, 991

operator|=

bitset, 537
gslice_array, 998
indirect_array, 1000
mask_array, 999
slice_array, 995
valarray, 989

operator||

valarray, 991, 992

<ostream>, 1042
ostream, 1010, 1042
ostream_iterator, 879

constructor, 879
destructor, 879
operator*, 880
operator++, 880
operator=, 880

ostreambuf_iterator, 882

constructor, 883

ostringstream, 1010, 1069
ostrstream, 1262

constructor, 1262
ostrstream, 1262

out

codecvt, 711

out_of_range, 500

out_of_range_error, 498
outer_allocator

out_of_range, 500, 536, 538, 539, 658

scoped_allocator_adaptor, 644

output_iterator_tag, 862
overflow

overflow_error, 498, 501, 502, 536, 538, 539

basic_filebuf, 1085
basic_streambuf, 1041
basic_stringbuf, 1073
strstreambuf, 1258

overflow_error, 501

owner_before

shared_ptr, 573, 577

owns_lock

shared_lock, 1185
unique_lock, 1181

p

bernoulli_distribution, 963
binomial_distribution, 964
geometric_distribution, 964
negative_binomial_distribution, 965

packaged_task

constructor, 1207, 1208
destructor, 1208
get_future, 1208
make_ready_at_thread_exit, 1209
operator(), 1208
operator=, 1208
reset, 1209
swap, 1208, 1209
valid, 1208

pair, 519, 527, 529
get, 522, 523
operator=, 520, 521
pair, 519, 520
swap, 521

param

seed_seq, 959
partial_sort, 911
partial_sort_copy, 912
partial_sum, 1002
partition, 909
partition_copy, 909
partition_point, 910
pbackfail

basic_filebuf, 1084
basic_streambuf, 1040
basic_stringbuf, 1072
strstreambuf, 1259

basic_streambuf, 1038

basic_streambuf, 1038

ostrstream, 1262

pbase

pbump

pcount

Cross references

1339

c(cid:13) ISO/IEC

N4296

strstream, 1264
strstreambuf, 1258

peek

basic_istream, 1052

piecewise_constant_distribution, 976

constructor, 977, 978
densities, 978
intervals, 978

piecewise_construct, 523
piecewise_construct_t, 523
piecewise_linear_distribution, 978

constructor, 979, 980
densities, 980
intervals, 980
placeholders, 596
plus, 588
plus<>, 589
pointer

allocator_traits, 549

pointer_to

pointer_traits, 546

pointer_traits, 545

difference_type, 546
element_type, 545
pointer_to, 546
rebind, 546

poisson_distribution, 965

constructor, 966
mean, 966

complex, 934

polar

pop

priority_queue, 848
forward_list, 787

pop_back

basic_string, 672

pop_heap, 918
pos_type

char_traits, 650

position

match_results, 1126

positive_sign

moneypunct, 736

pow, 936, 993, 1005
complex, 935

pptr

basic_streambuf, 1038

precision

prefix

ios_base, 703, 1021

match_results, 1126

prev, 864
prev_permutation, 922
priority_queue, 845

emplace, 848
priority_queue, 846, 847
swap, 848
probabilities

discrete_distribution, 976

proj

promise

complex, 933

constructor, 1198
destructor, 1198
get_future, 1198
operator=, 1198
set_exception, 1199
set_exception_at_thread_exit, 1199
set_value, 1199
set_value_at_thread_exit, 1199
swap, 1198, 1200

propagate_on_container_copy_assignment

allocator_traits, 550
scoped_allocator_adaptor, 643

propagate_on_container_move_assignment

allocator_traits, 550
scoped_allocator_adaptor, 643

propagate_on_container_swap

allocator_traits, 550
scoped_allocator_adaptor, 643

proxy

istreambuf_iterator, 881

ptrdiff_t, 468
pubimbue

basic_streambuf, 1035

pubseekoff

pubseekpos

pubsetbuf

basic_streambuf, 1036

basic_streambuf, 1036

basic_streambuf, 1036

basic_streambuf, 1036

pubsync

push

priority_queue, 848

push_back

push_front

basic_string, 669

forward_list, 787

push_heap, 918
put

basic_ostream, 1063

Cross references

1340

c(cid:13) ISO/IEC

N4296

money_put, 734
num_put, 719
time_put, 731

put_money, 1066
put_time, 1067
putback

basic_istream, 1053

putenv, 495
pword

ios_base, 1022

<queue>, 842
queue, 843

swap, 845

quick_exit, 479, 480
quiet_NaN

numeric_limits, 474

quoted, 1068

radix

numeric_limits, 472

raise, 496
<random>, 945–947
random_access_iterator_tag, 862
random_device, 957
constructor, 957
entropy, 957
operator(), 957
range_error, 498, 501
range_error, 501

ranlux24, 956
ranlux24_base, 956
ranlux48, 956
ranlux48_base, 956
ratio, 622
ratio_equal, 624
ratio_greater, 625
ratio_greater_equal, 625
ratio_less, 625
ratio_less_equal, 625
ratio_not_equal, 624
raw_storage_iterator

constructor, 553
operator*, 553
operator++, 553
operator=, 553

rbegin

basic_string, 666

rbegin(C&), 884
rbegin(initializer_list<E>), 884
rbegin(T (&array)[N]), 884

rdbuf

basic_filebuf, 1092
basic_ifstream, 1088
basic_ios, 1026
basic_istringstream, 1076
basic_ofstream, 1090
basic_ostringstream, 1077
basic_stringstream, 1079
istrstream, 1261
ostrstream, 1262
strstream, 1264
wbuffer_convert, 702, 703

rdstate

read

readsome

real, 935

basic_ios, 1028

basic_istream, 1052

basic_istream, 1053

complex, 930, 933

realloc, 555, 1252
rebind

pointer_traits, 546

rebind_alloc

allocator_traits, 550

ref

reference_wrapper, 587

reference_wrapper, 586

cref, 588
get, 587
operator T&, 587
operator(), 587
operator=, 587
ref, 587
reference_wrapper, 587

<regex>, 1098
regex, 1098
regex_constants, 1105

error_type, 1107, 1108
match_flag_type, 1105
syntax_option_type, 1105
regex_error, 1108, 1112, 1141

constructor, 1108
regex_iterator, 1133

increment, 1135
operator!=, 1135
operator*, 1135
operator++, 1135, 1136
operator->, 1135
operator==, 1135
regex_iterator, 1134

Cross references

1341

c(cid:13) ISO/IEC

N4296

regex_match, 1128–1130
regex_replace, 1132, 1133
regex_search, 1130, 1131
regex_token_iterator, 1136

end-of-sequence, 1136
operator!=, 1139
operator*, 1139
operator++, 1139
operator->, 1139
operator==, 1136, 1139
regex_token_iterator, 1138

regex_traits, 1108

char_class_type, 1109
isctype, 1110
length, 1109
lookup_classname, 1110
lookup_collatename, 1109
transform, 1109
transform_primary, 1109
translate, 1109
translate_nocase, 1109
value, 1111

register_callback
ios_base, 1023

regular expression traits

isctype, 1140
lookup_classname, 1140
lookup_collatename, 1140
transform_primary, 1141

rel_ops, 514
release

shared_lock, 1184
unique_lock, 1181
unique_ptr, 562

remainder, 1005
remove, 906

list, 796
forward_list, 790

remove_copy, 906
remove_copy_if, 906
remove_if, 906

forward_list, 790

remquo, 1005
rend

basic_string, 666

rend(const C&), 884
rend(initializer_list<E>), 884
rend(T (&array)[N]), 884
rep

system_clock, 639

replace, 904

basic_string, 673, 674

replace_copy, 905
replace_copy_if, 905
replace_if, 904
reserve

basic_string, 667
vector, 801

reset

bitset, 538
packaged_task, 1209
shared_ptr, 572
unique_ptr, 562, 565
weak_ptr, 577

resetiosflags, 1064
resize

deque, 782
list, 794
basic_string, 666, 667
forward_list, 788
valarray, 990
vector, 801

rethrow_exception, 492
rethrow_if_nested

nested_exception, 494

rethrow_nested

nested_exception, 493

return_temporary_buffer, 553
reverse, 907
list, 797
forward_list, 790

reverse_copy, 907
reverse_iterator, 864

tion, 869

operator++, 866
operator--, 867

rfind

basic_string, 676

right, 1030
rint, 1005
rotate, 908
rotate_copy, 908
round, 1005
round_error

numeric_limits, 472
round_indeterminate, 475
round_style

numeric_limits, 475

reverse_iterator, 866
base, 866
constructor, 866
make_reverse_iterator non-member func-

Cross references

1342

c(cid:13) ISO/IEC

round_to_nearest, 475
round_toward_infinity, 475
round_toward_neg_infinity, 475
round_toward_zero, 475
runtime_error, 498, 500

runtime_error, 500, 501

s

sbumpc

lognormal_distribution, 971

basic_streambuf, 1036

scalbln, 1005
scalbn, 1005
scan_is

scan_not

ctype, 705
ctype<char>, 708

ctype, 705
ctype<char>, 709

SCHAR_MAX, 477
SCHAR_MIN, 477
scientific, 1031
<scoped_allocator>, 640
scoped_allocator_adaptor

allocate, 644
construct, 644, 645
constructor, 643
deallocate, 644
destructor, 646
inner_allocator, 644
inner_allocator_type, 642
is_always_equal, 643
max_size, 644
operator!=, 646
operator==, 646
outer_allocator, 644
propagate_on_container_copy_assignment,

propagate_on_container_move_assignment,

643

643

propagate_on_container_swap, 643
select_on_container_copy_construction,

646
search, 901
search_n, 902
seed_seq

constructor, 958
generate, 958
param, 959
size, 959

seekdir

N4296

seekg

seekoff

seekp

seekpos

ios_base, 1020

basic_istream, 1054

basic_filebuf, 1085
basic_streambuf, 1038
basic_stringbuf, 1073
strstreambuf, 1259

basic_ostream, 1059

basic_filebuf, 1086
basic_streambuf, 1038
basic_stringbuf, 1074
strstreambuf, 1260

select_on_container_copy_construction

allocator_traits, 551
scoped_allocator_adaptor, 646

sentry

basic_istream, 1045
basic_ostream, 1058
constructor, 1046, 1058

<set>, 806
set, 817

bitset, 538
operator<, 819
operator==, 819
set, 819, 820
swap, 820

set_difference, 917
set_exception

promise, 1199

set_exception_at_thread_exit

promise, 1199

set_intersection, 916
set_new_handler, 462, 487
set_rdbuf

basic_ios, 1028

set_symmetric_difference, 917
set_terminate, 462, 491
set_unexpected, 462, 1264
set_union, 916
set_value

set_value_at_thread_exit

promise, 1199

promise, 1199

setbase, 1065
setbuf

basic_filebuf, 1085
basic_streambuf, 1038, 1074
streambuf, 1261

Cross references

1343

c(cid:13) ISO/IEC

N4296

strstreambuf, 1261

setenv, 495
setf

setfill, 1065
setg

ios_base, 1020, 1021

basic_streambuf, 1037
strstreambuf, 1258

setiosflags, 1064
setjmp, 461, 496
<setjmp.h>, 495
setlocale, 446
setp

setprecision, 1065
setstate

basic_ios, 1028

setw, 1066
sgetc

basic_streambuf, 1038

basic_streambuf, 1036

basic_streambuf, 1036

sgetn

share

future, 1201
shared_from_this

shared_future

enable_shared_from_this, 579

shared_lock

constructor, 1203
destructor, 1203
get, 1204
operator=, 1203, 1204
valid, 1204
wait, 1204
wait_for, 1204
wait_until, 1205

constructor, 1182, 1183
destructor, 1183
lock, 1183
mutex, 1185
operator bool, 1185
operator=, 1183
owns_lock, 1185
release, 1184
swap, 1184, 1185
try_lock, 1184
try_lock_for, 1184
try_lock_until, 1184
unlock, 1184

<shared_mutex>, 1168
shared_ptr, 567, 579

atomic_compare_exchange_strong, 581
atomic_compare_exchange_strong_-

explicit, 581

atomic_compare_exchange_weak, 581
atomic_compare_exchange_weak_-

explicit, 581

atomic_exchange, 580
atomic_exchange_explicit, 580
atomic_is_lock_free, 580
atomic_load, 580
atomic_load_explicit, 580
atomic_store, 580
atomic_store_explicit, 580
const_pointer_cast, 575
constructor, 569–571
destructor, 571
dynamic_pointer_cast, 574
get, 572
get_deleter, 575
operator bool, 573
operator!=, 574
operator*, 572
operator->, 572
operator<, 573, 574
operator«, 575
operator<=, 566, 574
operator=, 571, 572
operator==, 573
operator>, 574
operator>=, 574
owner_before, 573, 577
reset, 572
shared_ptr, 569
static_pointer_cast, 574
swap, 572, 574
unique, 572
use_count, 572

basic_filebuf, 1084
basic_streambuf, 1039, 1084

shift

valarray, 990

showbase, 1029
showmanyc

showpoint, 1029
showpos, 1030
shrink_to_fit

basic_string, 667
deque, 782
vector, 801

SHRT_MAX, 477
SHRT_MIN, 477

Cross references

1344

c(cid:13) ISO/IEC

N4296

shuffle, 908
shuffle_order_engine, 954

constructor, 955
sig_atomic_t, 496
SIG_DFL, 496
SIG_ERR, 496
SIG_IGN, 496
SIGABRT, 496
SIGFPE, 496
SIGILL, 496
SIGINT, 496
signal, 496
<signal.h>, 495
signaling_NaN

signbit, 1007
SIGSEGV, 496
SIGTERM, 496
sin, 993, 1005

complex, 935

sinh, 993, 1005

complex, 935

size

numeric_limits, 474

array, 777, 778
basic_string, 666
bitset, 539
gslice, 997
initializer_list, 495
match_results, 1125
seed_seq, 959
slice, 994
size_t, 115, 468
size_type

allocator_traits, 549

skipws, 1030
sleep_for

sleep_until

this_thread, 1167

this_thread, 1167

slice, 993

slice, 993

slice_array, 994
snextc

basic_streambuf, 1036

sort, 911

list, 797
forward_list, 790

sort_heap, 919
splice

list, 795
list, 796

splice_after

forward_list, 789

sputbackc

basic_streambuf, 1036

sputc

sputn

basic_streambuf, 1037

basic_streambuf, 1037

sqrt, 993, 1005

complex, 935
<sstream>, 1069
<staarg.h>, 495
stable_partition, 909
stable_sort, 911
<stack>, 848
stack, 848

swap, 851

start

state

gslice, 997
slice, 994

fpos, 1023
match_results, 1125
wbuffer_convert, 702
wstring_convert, 701

char_traits, 650
wbuffer_convert, 703
wstring_convert, 701

state_type

static_pointer_cast
shared_ptr, 574

<stdalign.h>, 495
<stdarg.h>, 495
<stdbool.h>, 495
stddev

<stdexcept>, 498
<stdlib.h>, 495, 1253
stod, 685
stof, 684, 685
stoi, 684, 685
stol, 684, 685
stold, 684, 685
stoll, 684, 685
store

atomic type, 1153

stoul, 684, 685
stoull, 684, 685
str

normal_distribution, 971

basic_istringstream, 1076
basic_ostringstream, 1077

Cross references

1345

c(cid:13) ISO/IEC

N4296

strftime, 731
stride

gslice, 997
slice, 994
<string>, 654
stringbuf, 1010, 1069
stringstream, 1010
strlen, 1258, 1262
strpbrk, 686
strrchr, 687
strstr, 687
strstream, 1263

destructor, 1263
strstream, 1263

strstreambuf, 1255, 1257
strstreambuf, 1257
destructor, 1258
setg, 1258

student_t_distribution, 974

constructor, 975
mean, 975

sub_match, 1117

basic_stringbuf, 1072
basic_stringstream, 1079
istrstream, 1261
match_results, 1126
ostrstream, 1262
strstream, 1264
strstreambuf, 1258
sub_match, 1118

strchr, 686
<streambuf>, 1032
streambuf, 1010, 1032
streamoff, 1015, 1024, 1254
streamsize, 1015

ios_base, 1021

compare, 1118
constructor, 1117
length, 1117
operator basic_string, 1117
operator!=, 1118–1122
operator<, 1118–1122
operator«, 1122
operator<=, 1118–1122
operator==, 1118–1122
operator>, 1118–1122
operator>=, 1118–1122
str, 1118

substr

basic_string, 678

subtract_with_carry_engine, 951

constructor, 951, 952

match_results, 1126

valarray, 990

suffix

sum

sungetc

basic_streambuf, 1036

swap, 517, 533
pair, 522
array, 778
basic_filebuf, 1082
basic_fstream, 1092
basic_ifstream, 1088
basic_ios, 1028
basic_iostream, 1055
basic_istream, 1045
basic_istringstream, 1075
basic_ofstream, 1090
basic_ostream, 1058
basic_ostringstream, 1077
basic_regex, 1117
basic_streambuf, 1037
basic_string, 675, 683
basic_stringbuf, 1071, 1072
basic_stringstream, 1079
deque, 783
forward_list, 791
function, 601, 602
list, 797
map, 812
match_results, 1127
multimap, 816
multiset, 823
packaged_task, 1208, 1209
pair, 521
priority_queue, 848
promise, 1198, 1200
queue, 845
set, 820
shared_lock, 1184, 1185
shared_ptr, 572, 574
stack, 851
thread, 1165, 1166
tuple, 529
unique_lock, 1181
unique_ptr, 562
unordered_map, 830
unordered_multimap, 834
unordered_multiset, 842
unordered_set, 838
valarray, 989, 993

Cross references

1346

c(cid:13) ISO/IEC

N4296

vector, 801, 802
vector<bool>, 805
weak_ptr, 577, 578

swap(unique_ptr&, unique_ptr&), 565
swap_ranges, 903
sync

basic_filebuf, 1086
basic_istream, 1053
basic_streambuf, 1038

sync_with_stdio

ios_base, 1021

syntax_option_type, 1105

awk, 1105
basic, 1105
collate, 1105, 1141
ECMAScript, 1105
egrep, 1105
extended, 1105
grep, 1105
icase, 1105
nosubs, 1105
optimize, 1105
syntax_option_type

awk, 1106
basic, 1106
collate, 1106
ECMAScript, 1106
egrep, 1106
extended, 1106
grep, 1106
icase, 1106
nosubs, 1106
optimize, 1106

system, 495, 496
system_category, 505, 507
system_clock
rep, 639

system_error, 502, 512

code, 513
system_error, 512, 513
what, 513

binomial_distribution, 964
negative_binomial_distribution, 965

t

table

ctype<char>, 709

tan, 993, 1005

complex, 935

tanh, 993, 1005

complex, 935

target

function, 601

target_type

function, 601

tellg

tellp

basic_istream, 1053

basic_ostream, 1059

terminate, 480, 491, 492, 1264
terminate_handler, 462, 491
test

bitset, 539

tgamma, 1005
this_thread

get_id, 1167
sleep_for, 1167
sleep_until, 1167
yield, 1167
thousands_sep

moneypunct, 736
numpunct, 723

<thread>, 1162
thread

constructor, 1164, 1165
destructor, 1165
detach, 1166
get_id, 1166
hardware_concurrency, 1166
join, 1166
joinable, 1166
operator=, 1165
swap, 1165, 1166

thread::id

constructor, 1164
operator!=, 1164
operator<, 1164
operator<=, 1164
operator<<, 1164
operator==, 1164
operator>, 1164
operator>=, 1164

throw_with_nested

nested_exception, 493

tie, 530

basic_ios, 1026

time, 495
<time.h>, 495
time_get, 726

date_order, 727
do_date_order, 728
do_get, 729

Cross references

1347

c(cid:13) ISO/IEC

N4296

time_get_byname, 730
time_point

do_get_date, 729
do_get_monthname, 729
do_get_time, 728
do_get_weekday, 729
do_get_year, 729
get, 728
get_date, 727
get_monthname, 727
get_time, 727
get_weekday, 727
get_year, 727

constructor, 637
max, 638
min, 638
operator!=, 638
operator+, 638
operator+=, 637
operator-, 638
operator-=, 637
operator<, 638
operator<=, 638
operator==, 638
operator>, 639
operator>=, 639
time_since_epoch, 637

time_point_cast, 639
time_put, 730

do_put, 731
put, 731

time_put_byname, 731
time_since_epoch

time_point, 637

tinyness_before

numeric_limits, 475

to_bytes

wstring_convert, 701

to_string, 685
bitset, 539
to_time_t, 639
to_ullong

bitset, 538

to_ulong

bitset, 538
to_wstring, 685
tolower, 699

ctype, 705
ctype<char>, 709

toupper, 699

ctype, 705

numeric_limits, 474

treat_as_floating_point, 629
truename

ctype<char>, 709

transform, 904

collate, 725
regex_traits, 1109

transform_primary

regex_traits, 1109

translate

regex_traits, 1109

translate_nocase

regex_traits, 1109

traps

numpunct, 723

trunc, 1005
try_emplace
map, 812
unordered_map, 830

try_lock, 1185

shared_lock, 1184
unique_lock, 1180

try_lock_for

shared_lock, 1184
unique_lock, 1180

try_lock_until

shared_lock, 1184
unique_lock, 1180

try_to_lock, 1176
try_to_lock_t, 1176
<tuple>, 523
tuple, 523, 525, 779

constructor, 526, 527
forward_as_tuple, 530
get, 531, 532
make_tuple, 529
operator!=, 532
operator<, 532
operator<=, 533
operator=, 528, 529
operator==, 532
operator>, 533
operator>=, 533
swap, 529
tie, 530
tuple, 526
tuple_cat, 530
tuple_element, 522, 531, 779
tuple_size, 522, 530, 779

in general, 530

type_index

Cross references

1348

c(cid:13) ISO/IEC

N4296

constructor, 647
hash_code, 647
name, 647
operator!=, 647
operator<, 647
operator<=, 647
operator==, 647
operator>, 647
operator>=, 647
type_info, 108, 487
type_info::name

implementation-deﬁned, 488

<typeinfo>, 487, 646

UCHAR_MAX, 477
uflow

basic_filebuf, 1084
basic_streambuf, 1040

uint16_t, 478
uint32_t, 478
uint64_t, 478
uint8_t, 478
uint_fast16_t, 478
uint_fast32_t, 478
uint_fast64_t, 478
uint_fast8_t, 478
uint_least16_t, 478
uint_least32_t, 478
uint_least64_t, 478
uint_least8_t, 478
UINT_MAX, 477
uintmax_t, 478
uintptr_t, 478
ULLONG_MAX, 477
unary_negate, 594
uncaught_exception, 1264
uncaught_exceptions, 425, 492
undeclare_no_pointers, 547
undeclare_reachable, 546
underflow

basic_filebuf, 1084
basic_streambuf, 1039
basic_stringbuf, 1072
strstreambuf, 1259

underflow_error, 498

underflow_error, 502

unexpected, 1264
unexpected_handler, 462, 1264
unget

basic_istream, 1053

uniform_int_distribution, 960

uniform_real_distribution, 961

a, 961
b, 961
constructor, 961

a, 962
b, 962
constructor, 962

uninitialized_copy, 554
uninitialized_copy_n, 554
uninitialized_fill, 554
uninitialized_fill_n, 555
unique, 906

list, 796
forward_list, 790
shared_ptr, 572

unique_copy, 907
unique_lock

constructor, 1178, 1179
destructor, 1179
lock, 1180
mutex, 1181
operator bool, 1181
operator=, 1179
owns_lock, 1181
release, 1181
swap, 1181
try_lock, 1180
try_lock_for, 1180
try_lock_until, 1180
unlock, 1180
unique_ptr, 571

constructor, 560, 561, 564
destructor, 561
get, 562
get_deleter, 562
operator bool, 562
operator!=, 565, 566
operator*, 562
operator->, 562
operator<, 565, 566
operator<=, 566
operator=, 561, 562, 564
operator==, 565, 566
operator>, 566
operator>=, 566
operator[], 564
release, 562
reset, 562, 565
swap, 562
unique_ptr, 559

unitbuf, 1030

Cross references

1349

c(cid:13) ISO/IEC

N4296

unlock

shared_lock, 1184
unique_lock, 1180
<unordered_map>, 824
unordered_map, 824, 825

at, 829
insert, 830
insert_or_assign, 830
operator[], 829
swap, 830
try_emplace, 830
unordered_map, 829

unordered_multimap, 824, 831

insert, 834
swap, 834
unordered_multimap, 834

unordered_multiset, 824, 838, 839

swap, 842
unordered_multiset, 841

<unordered_set>, 824
unordered_set, 824, 835

swap, 838
unordered_set, 838

uses_allocator, 548, 1198, 1209
uses_allocator<tuple>, 533
USHRT_MAX, 477
<utility>, 514

unsetf

ios_base, 1021

unshift

codecvt, 711
upper_bound, 913
uppercase, 1030
use_count

shared_ptr, 572
weak_ptr, 577

use_facet

locale, 698

va_arg, 496
va_copy, 496
va_end, 461, 496
va_list, 461, 496
va_start, 495, 496
<valarray>, 980
valarray, 983, 997

begin, 1001
constructor, 985
destructor, 985
end, 1001
operator!=, 992

Cross references

operator*, 991
operator*=, 989
operator+, 991
operator+=, 989
operator-=, 989
operator/, 991
operator/=, 989
operator<, 992
operator<=, 992
operator<<, 991
operator<<=, 989
operator=, 986, 991
operator==, 992
operator>, 992
operator>=, 992
operator>>, 991
operator>>=, 989
operator%, 991
operator%=, 989
operator&, 991
operator&=, 989
operator&&, 992
operatorˆ, 991
operatorˆ=, 989
operator|, 991
operator|=, 989
operator||, 992
swap, 989, 993
valarray, 985

valid

value

future, 1201
packaged_task, 1208
shared_future, 1204

error_code, 509
error_condition, 511
regex_traits, 1111

<vector>, 776
vector, 797

operator<, 800
operator==, 800
vector, 800
swap, 802

vector<bool>, 803

flip, 805
swap, 805
void_pointer

allocator_traits, 549

wait

condition_variable, 1189

1350

c(cid:13) ISO/IEC

N4296

wait_for

condition_variable_any, 1192, 1193
future, 1202
shared_future, 1204

condition_variable, 1190, 1191
condition_variable_any, 1193, 1194
future, 1202
shared_future, 1204

wait_until

condition_variable, 1189, 1190
condition_variable_any, 1193
future, 1202
shared_future, 1205

weibull_distribution, 968

wbuffer_convert, 702

constructor, 703
destructor, 703
rdbuf, 702, 703
state, 702
state_type, 703

wcerr, 1014
wcin, 1014
wclog, 1014
wcout, 1014
wcschr, 687
wcspbrk, 687
wcsrchr, 687
wcsstr, 687
weak_ptr, 570, 575
constructor, 576
destructor, 577
expired, 577
lock, 577
operator=, 577
reset, 577
swap, 577, 578
use_count, 577

a, 969
b, 969
constructor, 969
wfilebuf, 1010, 1079
wfstream, 1010
what

bad_alloc, 486
bad_cast, 489
bad_exception, 491
bad_typeid, 489
exception, 490
bad_weak_ptr, 567
future_error, 1196
system_error, 513

wide_string

wstring_convert, 701

widen

width

basic_ios, 1027
ctype, 705
ctype<char>, 709

ios_base, 703, 1021

wifstream, 1010, 1079
wios, 1015
wistream, 1010, 1042
wistringstream, 1010, 1069
wmemchr, 687
wofstream, 1010, 1079
wostream, 1010, 1042
wostringstream, 1010, 1069
wregex, 1098
write

basic_ostream, 1063

ws, 1048, 1054
wstreambuf, 1010, 1032
wstring_convert, 699
byte_string, 700
constructor, 701
converted, 700
destructor, 701
from_bytes, 700
int_type, 701
state, 701
state_type, 701
to_bytes, 701
wide_string, 701
wstringbuf, 1010, 1069
wstringstream, 1010

xalloc

xsgetn

xsputn

ios_base, 1022

basic_streambuf, 1039

basic_streambuf, 1041

yield

this_thread, 1167

zero

duration, 633
duration_values, 629

Cross references

1351

c(cid:13) ISO/IEC

N4296

Index of implementation-deﬁned behavior

The entries in this section are rough descriptions; exact speciﬁcations are at the indicated page in the
general text.

#pragma, 436

additional formats for time_get::do_get_date,

729
alignment, 80
alignment additional values, 80
alignment of bit-ﬁelds within a class object, 240
allocation of bit-ﬁelds within a class object, 240
argument values to construct basic_ios::failure,

1028

assignability of placeholder objects, 597

behavior of attribute scoped token, 186
behavior of iostream classes when traits::pos_-

type is not streampos or when traits::off_-
type is not streamoff, 1010

behavior of non-standard attributes, 186
bits in a byte, 6

28

choice of larger or smaller value of ﬂoating literal,

concatenation of some types of string literals, 30
conversions between pointers and integers, 111
converting characters from source character set to

execution character set, 18

converting function pointer to object pointer and

vice versa, 111

default number of buckets in unordered_map, 829
default number of buckets in unordered_multimap,

default number of buckets in unordered_multiset,

834

841, 842

default number of buckets in unordered_set, 838
deﬁning main in freestanding environment, 62
deﬁnition and meaning of __STDC__, 436
deﬁnition and meaning of __STDC_VERSION__, 436
derived type for typeid, 108
diagnostic message, 2
dynamic initialization of static objects before main,

dynamic initialization of thread-local objects be-

64

fore entry, 64

eﬀect of calling basic_filebuf::setbuf with non-

eﬀect of calling basic_filebuf::sync when a get

zero arguments, 1085

area exists, 1086

eﬀect of calling basic_streambuf::setbuf with

non-zero arguments, 1074

eﬀect of calling ios_base::sync_with_stdio af-
ter any input or output operation on stan-
dard streams, 1021

eﬀect on C locale of calling locale::global, 698
encoding of universal character name not in exe-

error_category for errors originating outside the

cution character set, 27

operating system, 467

exception type when shared_ptr constructor fails,

570

exceptions thrown by standard library functions
that do not have an exception speciﬁca-
tion, 467

execution character-set and execution wide-character

set, 19
exit status, 480
extended signed integer types, 75

formatted character sequence generated by time_-

put::do_put in C locale, 731

headers for freestanding implementation, 449

interactive device, 8

linkage of main, 62
linkage of names from Standard C library, 450
locale names, 696

manner of search for included source ﬁle, 429
mapping from name to catalog when calling messages

::do_open, 738

ﬁle, 21

mapping header name to header or external source

mapping physical source ﬁle characters to basic

source character set, 17

mapping to message when calling messages::do_-

get, 739

Cross references

1352

c(cid:13) ISO/IEC

meaning of asm declaration, 182
meaning of attribute declaration, 148

428

104

5

negative value of character literal in preprocessor,

nesting limit for #include directives, 429
number of threads in a program under a freestand-

ing implementation, 11

numeric values of character literals in #if direc-

tives, 428

parameters to main, 62
passing argument of class type through ellipsis,

physical source ﬁle characters, 17
presence and meaning of native_handle_type and

native_handle, 1159

rank of extended signed integer type, 87
representation of char, 75
required libraries for freestanding implementation,

result of exception::what, 490
result of inexact ﬂoating-point conversion, 85
result of right shift of negative value, 126
return value of bad_alloc::what, 486
return value of bad_cast::what, 489
return value of bad_exception::what, 491
return value of bad_typeid::what, 489
return value of char_traits<char16_t>::eof, 652
return value of char_traits<char32_t>::eof, 653
return value of type_info::name(), 488

search locations for "" header, 429
search locations for <> header, 429
semantics of linkage speciﬁcation on templates,

334

semantics of linkage speciﬁers, 182
semantics of non-standard escape sequences, 27
sequence of places searched for a header, 429
signedness of char, 75
sizeof applied to fundamental types other than
char, signed char, and unsigned char,
115

stack unwinding before call to std::terminate(),

start-up and termination in freestanding environ-

string resulting from __func__, 208
string returned by what() for bad_weak_ptr, 567,

418, 425

ment, 62

597

N4296

support for extended alignment, 622
support for over-aligned types, 115, 552, 553
supported multibyte character encoding rules, 651,

654

text of __DATE__ when date of translation is not

text of __TIME__ when time of translation is not

available, 436

available, 436

type of ios_base::streamoff, 1254
type of ios_base::streampos, 1254
type of ptrdiff_t, 125, 469
type of regex_constants::error_type, 1107
type of size_t, 469
type of streamoff, 651
type of streampos, 651
type of u16streampos, 652
type of u32streampos, 653
type of wstreampos, 653
type of array::const_iterator, 777
type of array::iterator, 777

underlying type for enumeration, 168
use of non-POF function as signal handler, 496

value of ctype<char>::table_size, 708
value of bit-ﬁeld that cannot represent

assigned value, 131
incremented value, 106
initializer, 214

sponding type, 27

value of character literal outside range of corre-

value of multicharacter literal, 26
value of result of inexact integer to ﬂoating-point

value of result of unsigned to signed conversion, 85
value of wide-character literal containing multiple

conversion, 86

characters, 27

value of wide-character literal with single c-char
that is not in execution wide-character
set, 27

value representation of ﬂoating-point types, 76
value representation of pointer types, 77
values of a trivially copyable type, 73
values of various ATOMIC_..._LOCK_FREE macros,

1147

whether get_pointer_safety returns pointer_-

safety::relaxed or pointer_safety::preferred
if the implementation has relaxed pointer
safety, 547

Cross references

1353

c(cid:13) ISO/IEC

N4296

whether time_get::do_get_year accepts two-digit

whether an implementation has relaxed or strict

year numbers, 729

pointer safety, 69

whether locale object is global or per-thread, 693
whether sequence pointers are copied by basic_-

filebuf move constructor, 1082

whether sequence pointers are copied by basic_-

stringbuf move constructor, 1071

whether source of translation units must be avail-

able to locate template deﬁnitions, 18

whether stack is unwound before calling std::terminate()

when a noexcept speciﬁcation is violated,
425

whether values are rounded or truncated to the
required precision when converting be-
tween time_t values and time_point ob-
jects., 639

which functions in Standard C++ library may be

recursively reentered, 465

Cross references

1354

